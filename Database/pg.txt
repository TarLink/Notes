
        
   PG   
        


VERSION ==>                   #3.6.2

PG                            #Installation requires libpq

new PG.Client( [STR|OBJ],     #Connect to the database specified by STR|OBJ, then fire FUNC. 
FUNC( ERROR, CLIENT,          #FUNC2 must be fired when all operations are done to close connection. 
FUNC2(ERROR)))	              #STR is "[connectionname://][user[:password]@][host[:port]][/database]" 
                              #(all defaults if no first arg) or a IPC socket folder path. 
                              #Connectionname can be anything, it just differentiate sessions. OBJ has members :
                              #  - user (def: process.env.USER)
                              #  - database (def: process.env.USER)
                              #  - password (def: null)
                              #  - port (def: 5432)
                              #  - host (def: null): if not URL, use DIR/.s.PGSQL.PORT
                              #  - ssl (def: false)
                              #Defaults are in PG.defaults.VAR
                              #Other defaults:
                              #  - PG.defaults.parseInt8:
                              #     - PSQL bigint (such as result of count()) is too big for Javascript INT.
                              #     - If false (def), bigint -> STR. If true, bigint -> INT
                              #Returns CLIENT, but should only be used for events. Use CLIENT in callback for connect|end()
CLIENT.connect
([FUNC(ERROR, CLIENT)])       #
CLIENT.end()                  #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            QUERIES            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


CLIENT.query(STR[, VAL_ARR]   #Returns a QUERY from PostgreSQL command STR. 
[,FUNC(ERROR, OBJ)])          #If FUNC, also execute it and event handlers of QUERY cannot be used (so QUERY is useless then). 
                              #OBJ is same as in QUERY end event handler.
                              #If VAL_ARR, each "$1", "$2", etc. in STR will be replaced by those VAL, providing it does not 
                              #point to a TABLE, a COL or a SCHEMA. It is slower but it prevents SQL injections (VAL_ARR are 
                              #properly escaped instead of using risky STR concatenation).
CLIENT.query(OBJ[, FUNC])		  #Same but OBJ can have members :
                              #  - text: same as STR
                              #  - values: same as VAL_ARR
                              #  - name STR3: 
                              #     - make it PREP: but using PSQL Extended Protocol, so same effect (skip parsing phase when
                              #       calling came query with same name (will use same text|values)), but not actual PREP
                              #     - parsing is only done when values VAL_ARR is used, so only useful then

QUERY.on                      
("row", FUNC( OBJ ))	        #Execute QUERY and fire event handler for each row OBJ: { VAR: VAL }...
QUERY.on("end", FUNC( OBJ ) )	#Execute QUERY and fire event handler for all rows. OBJ has members :
                              #  - command STR : SQL command
                              #  - rowCount UINT
                              #  - oid DOUBLE
                              #  - rows OBJ_ARR: { VAR: VAL }...
                              #  - fields OBJ_ARR:
                              #     - name STR
                              #     - format TYPE_STR
                              #     - tableID DOUBLE
                              #     - columnID DOUBLE
                              #     - dataTypeID DOUBLE
                              #     - dataTypeSize UINT
                              #     - dataTypeModifier UINT
QUERY.on("error",FUNC(ERROR))	#

CLIENT.query
(new PG-QUERY-STREAM(STR))    #Like CLIENT.query(STR) but returns as ISTREAM.
CLIENT.query
(new PG-CURSOR(STR)[,VAL_ARR])#Like CLIENT.query(STR[, VAL_ARR]) but returns a CURSOR (version 0.2.0).
CURSOR.read
(UINT, FUNC(ERROR, OBJ_ARR))  #OBJ_ARR is { VAR: VAL }... or [] if no more rows
CLIENT.copyFrom|To( STR )		  #COPY...FROM|TO statement must use this instead of CLIENT.query(). 
                              #Returns a I|OSTREAM (must execute I|OSTREAM.end()). 
                              #Can use stdin (not stdout) in STR if writing|reading from I|OSTREAM
CLIENT.pause|resumeDrain()	  #Stops|resumes emission of drain events (useful when async operations need to complete first)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:       OTHER OPERATIONS        :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


CLIENT.on("drain", FUNC())		#Fired each time all queries have been executed
CLIENT.on("error",FUNC(ERROR))#
CLIENT.on                     #Fired with listen/notify SQL statements
("notification", FUNC(OBJ))	  #OBJ:
                              #  - name "notification"
                              #  - channel STR
                              #  - payload STR
                              #  - length NUM
                              #  - processId NUM
CLIENT.on("notice", FUNC(STR))#Fired with warning messages (otherwise printer in stdout)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            POOLING            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


PG.pools.getOrCreate([OBJ])   #Returns POOL (from GENERIC-POOL) of CLIENT that has extra method:
                              #  - connect(FUNC(ERROR, CLIENT, FUNC2(ERROR2))): acquire a CLIENT and fires FUNC()
                              #Created with params (either OBJ or PG.defaults):
                              #  - name: OBJ stringified
                              #  - max <- poolSize
                              #  - idleTimeoutMillis <- poolIdleTimeout
                              #  - reapIntervalMillis <- reapIntervalMillis
                              #  - log <- poolLog
                              #Other OBJ passed to new PG.CLIENT(OBJ)
                              #If no POOL used, would use one new connection for each query.
PG.pools.all                  #POOL_OBJ

PG.connect(OBJ, FUNC)         #Like new PG.CLIENT(OBJ, FUNC).connect() but uses PG.pools.getOrCreate(OBJ)
PG.on
("error",FUNC(ERROR, CLIENT)) #
PG.end()	                    #Close all CLIENT, even if currently querying.
