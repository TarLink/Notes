
         
   REACT  
         


REACT
REACTDOM                          #Two packages (versions 15.4.2). Must require both.
REACTDOMSERVER                    #Subpackage of REACTDOM, for using in the server

DEVELOPMENT MODE ==>              #Checks NODE_ENV !== 'production'.
                                  #React uses envify in release files, which replaces NODE_ENV by 'development|production'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            THEORY             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PRINCIPLE ==>                     #Data flow:
                                  #  - one-way direction (parent to children):
                                  #      - communicating with parent: passing a FUNC (e.g. REACTLINK) as props
                                  #  - 'state' is state owned by current RCOMP, 'props' is state owned by a parent
                                  #     - when changing 'state':
                                  #        - current RCOMP gets 'updated'
                                  #        - children get 'updated' (if same RTYPE) or 'unmounted|mounted' (if different RTYPE)
                                  #     - smart vs dumb RCOMP:
                                  #        - smart components / 'containers':
                                  #           - manipulate state:
                                  #              - have 'state', passed to children as props
                                  #              - pass Flux actions callbacks to children
                                  #           - not visual, e.g. no CSS nor DOM
                                  #           - should be as few as possible
                                  #        - dumb / 'presentational' components:
                                  #           - manipulate UI:
                                  #              - no 'state'
                                  #           - reusable, so no dependency (e.g. no Flux actions nor dispatch)
                                  #     - reduce amount of 'state':
                                  #        - not computed|duplicated from other 'state|props'
                                  #           - e.g. getInitialState() should not use props
                                  #        - not complex (e.g. not RELEM)
                                  #     - 'context':
                                  #        - like 'props' but with less typing
                                  #        - should only be used for 'props' that are used everywhere in the app, e.g. current user, design theme, etc.
                                  #        - should use explicit 'props' otherwise
                                  #  - children are owned by the RCOMP that create them:
                                  #     - i.e. in RCOMP.render() -> <RCOMP2>...</RCOMP2>, ... will be 'updated' when current RCOMP is,
                                  #       but not when RCOMP2 is, except if cloned in RCOMP2.render()
                                  #        - will still be correctly 'mounted|unmounted'
                                  #Virtual DOM:
                                  #  - provides abstraction (e.g. can be used on server without real DOM)
                                  #  - allows faster diff algorithm
                                  #  - problem: makes it harder to reach to actual DOM
                                  #JSX: mixing templates into JavaScript because they belong together

GOOD PRACTICES ==>                #  - when passing props down, should explicitely pass props that are consumed, e.g. deconstructing then spreading:
                                  #      let [ VAR, OBJ... ] = this.props;
                                  #      // Use VAR
                                  #      return <ELEM [VAR={VAR}] {...OBJ}>

BAD PRACTICES ==>                 #  - reaching to HTML elements instead of using RELEM|RCOMP abstraction:
                                  #     - e.g. using REF, REACTDOM.findDOMNode()
                                  #  - using RCOMP other than as 'this' in RCOMP methods:
                                  #     - e.g. using REACTDOM.render() return value
                                  #  - shortcircuiting data flow:
                                  #     - RCOMP.forceUpdate()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          TERMINOLOGY          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RTYPE                             #RELEM's type
                                  #By convention, custom RTYPE name should be Capitalized
REACT.Component                   #Base RTYPE
RDOM                              #Builtin RTYPE representing an HTML 'TAG'

RELEM                             #Abstracted ELEM (non-instantiated), i.e. RTYPE + props
RNODE                             #VAL[_ARR...]
                                  #  - VAL can be:
                                  #     - RELEM
                                  #     - STR|NUM: text node. Cannot use HTML entities, but can use raw|escaped Unicode.
                                  #     - null|undefined|true|false: no node (but present in props.children as null)
                                  #  - can be ARR, or ARR_ARR, etc. (will be flattened)

RCOMP                             #Instantiated RELEM. Is not an ELEM.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             RTYPE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REACT.createClass(OBJ)            #Creates and returns a RTYPE
                                  #Bind all OBJ.FUNC's this to current RCOMP
                                  #OBJ is merged into RCOMP's prototype
STATELESS COMPONENT ==>           #Can use a FUNC()->RELEM as RTYPE:
                                  #  - like specifying only OBJ.render(), with also:
                                  #     - can specify FUNC.contextTypes OBJ
                                  #  - REF is null, so:
                                  #     - cannot use findDOMNode()
                                  #     - cannot use props.ref

ES6 CLASSES ==>                   #Can create ES6 class derived from REACT.Component as an alternative to REACT.createClass()
                                  #Preferred.
                                  #Differences:
                                  #  - different syntax:
                                  #     - getInitialState() -> setting this.state in constructor
                                  #     - propTypes OBJ -> static propTypes OBJ
                                  #     - getDefaultProps()->OBJ -> static defaultProps OBJ
                                  #  - less functionalities:
                                  #     - no 'this' binding
                                  #     - cannot use mixins
                                  #     - cannot use RCOMP.replaceState|isMounted()

RCOMP.displayName                 #JSX tag name, used for debugging (should be in dev only)
                                  #Deduced from assigned variable if using Babel plugin "react-display-name"


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             RELEM             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REACT.createElement               #Creates and returns a RELEM
('TAG'|RTYPE[, OBJ][, RNODE...])  #OBJ|RNODE... are RCOMP.props|children.
                                  #'TAG':
                                  #  - use corresponding RDOM
                                  #  - RCOMP.props|children -> HTML attributes|children
REACT.createFactory('TAG'|RTYPE)  #Similar to REACT.createElement.bind(null, 'TAG'|RTYPE)
REACT.DOM.TAG(...)                #Same as REACT.createElement('TAG', ...)
REACT.cloneElement                #Creates and returns a RELEM2, cloned from RELEM.
(RELEM[, OBJ][, RNODE...])        #OBJ are shallow merged, RNODE... children are replaced.

RELEM.type                        #'TAG'|RTYPE
REACT.isValidElement(VAL)         #True if RELEM


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            RENDER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REACTDOM.render                   #ELEM's children = RELEM2's instantiation
(RELEM2, ELEM[, FUNC()])->REF     #If ELEM children already contains older RELEM:
                                  #  - RELEM === RELEM2 (i.e. same reference): nothing happens
                                  #  - RELEM == RELEM2 (i.e. same RTYPE): 'update' RELEM
                                  #  - RELEM != RELEM2 (i.e. different RTYPE): 'unmount' RELEM, 'mount' RELEM2
                                  #Calls FUNC() after all events done.
                                  #Rendering adds React-specific HTML attributes:
                                  #  - e.g. data-reactid, data-react-checksum, data-reactroot
                                  #  - if RELEM does not have them (i.e. has not been previously rendered by React), will
                                  #    'unmount|mount' instead of 'update'
REACTDOMSERVER.renderToString     #Returns RELEM as 'HTML'
(RELEM)                           #Idea is pre-render on the server:
                                  #  - why:
                                  #     - when client calls REACTDOM.render(), there is less DOM update, making initial load time faster
                                  #     - more SEO-friendly
                                  #  - requires code to be both client and server ('universal app')
                                  #  - 'HTML' includes React-specific HTML attributes
                                  #Server should be able to just render the component by reusing components client code:
                                  #  - components must use code that can be loaded on both the client and server
                                  #  - component props must be calculated server-side, so AJAX requests must work on both the client and Node
REACTDOMSERVR.renderToStaticMarkup#Same but does not include React-specific HTML attributes.
(RELEM)                           #To use if rendered 'HTML' will not be loaded in client-side React.

MOUNT ==>                         #Fired on:
                                  #  - parent rendered with different RTYPE, for new RELEM2
                                  #  - first render()
                                  #Fires RCOMP2 (in order):
                                  #  - componentWillMount()
                                  #  - render()
                                  #  - componentDidMount()
UPDATE ==>                        #Fired on:
                                  #  - parent rendered with same RTYPE but different props
                                  #  - RCOMP.setState()
                                  #  - RCOMP.forceUpdate()
                                  #Not fired if an 'update' is already ongoing
                                  #Does:
                                  #  - not create new RCOMP (only updates it)
                                  #  - replace RCOMP's props with RCOMP2's
                                  #  - fires RCOMP (in order):
                                  #     - componentWillReceiveProps(OBJ2, OBJ4):
                                  #        - not fired by RCOMP.setState() nor RCOMP.forceUpdate()
                                  #        - before assigning props (this.props is still old one)
                                  #        - OBJ2|OBJ4 is next props|context
                                  #        - often used to call setState() according to props
                                  #     - shouldComponentUpdate(OBJ2, OBJ3, OBJ4)->BOOL:
                                  #        - not fired by RCOMP.forceUpdate()
                                  #        - return false if nothing was changed, so we stop here and avoid to:
                                  #           - fire componentWillUpdate|DidUpdate(), which might do more
                                  #           - fire render():
                                  #              - since render() would render same DOM, then no DOM manipulation would done anyway.
                                  #              - however this saves the time spent by JavaScript to check it
                                  #        - is optional and for performance purpose
                                  #        - OBJ2|OBJ3|OBJ4 is next props|state|context
                                  #        - React.PureComponent is like React.Component except:
                                  #           - it defines shouldComponentUpdate() doing shallow comparison of props|state
                                  #           - to use if:
                                  #              - props|state|context can be shallow compared (i.e. contain objects)
                                  #              - render() only depends on props|state|context
                                  #     - componentWillUpdate(OBJ2, OBJ3, OBJ4)
                                  #        - cannot use setState()
                                  #        - OBJ2|OBJ3|OBJ4 is next props|state|context
                                  #     - render()
                                  #     - componentDidUpdate(OBJ2, OBJ3, OBJ4)
                                  #        - OBJ2|OBJ3|OBJ4 is prev props|state|context
UNMOUNT ==>                       #Fired on:
                                  #  - parent rendered with different RTYPE, for old RELEM
                                  #  - REACTDOM.unmountComponentAtNode()
                                  #Fires RCOMP:
                                  #  - componentWillUnmount()

RCOMP.render()                    #Does the actual DOM manipulation.
                                  #Must return RCOMP's single child, i.e. RELEM (or null|false):
                                  #  - calls REACTDOM.render() on child recursively:
                                  #     - order:
                                  #        - start with ancestor for componentWill*(), shouldComponentUpdate(), render()
                                  #        - start with descendant for componentDid*()
                                  #     - compare children old RELEM with new RELEM2 according to DOM order
                                  #        - problem:
                                  #           - in lists of similar items, modifications might recreate all items
                                  #             (e.g. prepending, since it compares by DOM order)
                                  #           - this is bad for performance, but also does not retain state in those items
                                  #        - solution:
                                  #           - can use HTML attribute 'key', which will then be used for comparison
                                  #           - should then be unique ID among siblings
                                 ##           - CREATEFRAGMENT({ VAR: RNODE ... })->RNODE_ARR:
                                 ##              - returns all RNODE concatenated
                                 ##              - assigns each RNODE.key = 'VAR/.NUM[$KEY]' where:
                                 ##                 - NUM is element index in RNODE (which can be an array)
                                 ##                 - KEY is RNODE.key
                                 ##              - package 'react-addons-create-fragment' (same version as React)
                                  #     - if children are not newly created in render() (e.g. use props.children reference),
                                  #       old RELEM === new RELEM2, so nothing will happen for that child
                                  #        - i.e. RCOMP 'owns' the children it creates in render(), but not the children passed to it
                                  #  - if RDOM, will update DOM, but in an efficient way:
                                  #     - does not update if same
                                  #     - only add|remove attributes if only attributes changed
                                  #  - should not modify state nor read global state nor be async
                                  #    (use componentDidMount|Update() for that)
                                  #Single child, i.e. must return RELEM, not RELEM_ARR
RCOMP.forceUpdate()               #Forces 'update'
                                  #Useful when render() depends on state that changed but did not trigger a new render(), e.g.:
                                  #  - RCOMP.state.OBJ.VAR changed, but no setState() was called
                                  #  - DOM element change that cannot be caught with onEvent
REACTDOM.unmountComponentAtNode   #Inverse of REACTDOM.render(): remove ELEM children (firing 'unmount') then returns true.
(ELEM)                            #If no RCOMP was mounted, does nothing and returns false.

RCOMP.isMounted()                 #To use in async operation to make sure RCOMP still exists.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       PROPS/STATE BASE        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RCOMP.props                       #Read-only state OBJ.
                                  #Readonly (non-configurable, non-writable) shallowly (but should be considered deeply readonly)
                                  #'Owned' by a parent, i.e. props change when the parent passing them re-rendered children with different props.
                                  #Rendered as HTML attributes for RDOM
RELEM.props                       #As opposed to RCOMP, props.key|ref are not on RELEM.props.* but on RELEM.*
RCOMP.getDefaultProps()->OBJ      #Called once per RTYPE (not per RCOMP),
                                  #then the result OBJ is shallowingly assigned to each new RCOMP.props


RCOMP.state                       #Read-write state OBJ
                                  #'Owned' by RCOMP
                                  #Should never be written to:
                                  #  - use setState() instead
                                  #  - to avoid it, might need to make deep copy, including using tools like immutable-js
                                  #Might be null if not getInitialState()
RCOMP.getInitialState()->OBJ      #Initial RCOMP.state
                                  #Called before componentWillMount()
RCOMP.setState(OBJ[(OBJ2, OBJ3)]  #Shallow merges into RCOMP.state
[, FUNC()])                       #OBJ2|OBJ3 is current state|props
                                  #Might be performed async or not. FUNC() performed afterwards.
                                  #Fires 'update'
RCOMP.replaceState(...)           #Same but sets instead of merging


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       PROPS/STATE EXTRA       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RCOMP.props.children              #CHILDREN
                                  #Opaque structure to be manipulated only through React.Children RCHILDREN,
                                  #where RNODE will be individual elements (not ARR)
RCHILDREN.count(CHILDREN)         #
RCHILDREN.map|forEach
(CHILDREN, FUNC(RNODE)[, THIS])   #
RCHILDREN.toArray(CHILDREN)       #Returns RNODE_ARR
RCHILDREN.only(CHILDREN)          #Returns RNODE if CHILDREN contains only one child, and it is a RELEM
                                  #Otherwise throws (if in 'development mode')


RCOMP.propTypes                   #OBJ.VAR PROP_RULE:
                                  #  - if RTYPE.props.VAR does not satisfy PROP_RULE during createElement(), it will throw error:
                                  #     - only once for a given RTYPE + VAR + PROP_RULE
                                  #     - only in 'development mode'
                                  #  - use PTYPES.oneOfType or custom PROP_RULE for multiple validations
                                  #PROP_RULE is FUNC(RTYPE.props, 'VAR', 'RTYPE')[->ERROR]
                                  #List of builtin PROP_RULE:
React.PropTypes                   #PTYPES
PTYPES.array|bool|func|symbol|
number|object|string|node|element #Checks type: 'node' is RNODE[_ARR], 'element' RELEM
PTYPES.instanceOf(TYPE)           #
PTYPES.oneOf(VAL_ARR)             #
PTYPES.oneOfType(PROP_RULE_ARR)   #
PTYPES.arrayOf(PROP_RULE)         #
PTYPES.objectOf(PROP_RULE)        #Object values
PTYPES.shape({VAR: PROP_RULE ...})#
PROP_RULE.isRequired              #E.g. PTYPES.bool.isRequired


RCOMP.mixins                      #OBJ_ARR, where OBJ gets merged into RCOMP.
                                  #If property conflict:
                                  #  - if lifecycle RCOMP.FUNC (e.g. componentWillUpdate, etc.), surcharges instead of
                                  #    overriding it (i.e. called before non-mixin one)
                                  #  - otherwise, throws error
                                  #Deprecated, prefer high-order-composition/decorators


RCOMP.statics                     #OBJ assigned to RTYPE during createClass(), i.e. static methods.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONTEXT            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RCOMP.context                     #Like RCOMP.props, but with less typing (see getChildContext())
RCOMP.getChildContext()->OBJ      #Define|merges RCOMP.context OBJ in all ancestors
RCOMP.contextTypes                #Like RCOMP.propTypes but for RCOMP.context, defined in the ancestor using it
                                  #Required.
RCOMP.childContextTypes           #Same for the parent defining getChildContext().
                                  #Required.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             REFS              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REF                               #Instantiation of a RELEM:
                                  #  - if based on RTYPE, RCOMP
                                  #  - if based on 'TAG', ELEM
                                  #  - if stateless component, null

RCOMP.props.ref                   #On createElement():
                                  #  - FUNC(REF):
                                  #     - on mounting, called once with REF
                                  #     - on updating, first called with null (to let handler clean previous
                                  #       reference), then called with new REF
                                  #     - when unmounting, called once with null
                                  #  - 'REF': same as FUNC(REF) { this.refs['REF'] = REF; }

REACTDOM.findDOMNode(RCOMP)       #Returns corresponding ELEM
                                  #If RCOMP not mounted, throws exception


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             RDOM              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RDOM ==>                          #Builtin RTYPE mimicking usual HTML.
                                  #Differences are below.

ALLOWED HTML TAGS|ATTRIBUTES ==>  #Whitelisted:
                                  #  - but should cover most standard HTML
                                  #  - custom HTML tags are allowed
                                  #  - custom HTML attributes are allowed if HTML tag name contains '-' or HTML attribute
                                  #    is="..." present

HTML ATTRIBUTES ==>               #  - camelCased, except data-*, aria-*
                                  #  - class -> className, html -> htmlFor
                                  #  - values:
                                  #     - style.CSSPROP VAL (camelCased, except vendor prefix which are titleized)
                                  #     - boolean attributes: must only use BOOL as value
                                  #     - NUM -> NUMpx, except where LENP is not expected
                                  #  - new:
                                  #     - dangerouslySetInnerHtml { __html STR }: set innerHTML
                                  #     - ref|key: see below

DOM EVENTS ==>                    #  - onEvent(REVENT), with REVENT being like EVENT but:
                                  #     - better crossbrowser behavior
                                  #     - more performant (use only one global event listener, then redistribute)
                                  #     - extra properties:
                                  #        - nativeEvent EVENT
                                  #        - isDefaultPrevented|PropagationStopped(): like jQuery
                                  #     - no stopImmediatePropagation()
                                  #     - is deleted after function ends, so async can only use it with:
                                  #        - copying to local variable
                                  #        - or calling REVENT.persist()

FORM CONTROLS ==>                 #Value:
                                  #  - <textarea> children   -> <textarea value>
                                  #  - <option selected>     -> <select value> (STR[_ARR])
                                  #  - <input value|checked> -> same
                                  #HTML attributes:
                                  #  - onChange:
                                  #     - should be used. Like onInput, but with React's behavior for 'value'
                                  #     - for checkboxes|radio buttons, do not call REVENT.preventDefault(),
                                  #       or control will be updated in model but not in UI
                                  #  - value|checked:
                                  #     - sets default value
                                  #     - makes control read-only: can only updated with new render(), usually
                                  #       with this.setState() in onChange event handler
                                  #     - not updated on UI interaction but:
                                  #        - JavaScript value|checked is
                                  #        - if it triggers a new render() with new value|checked, it gets updated like this
                                  #     - if null|undefined (as opposed to ''), does not do anything anymore
                                  #  - defaultValue|Checked: only sets default value


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              JSX              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


<...>                             #Like HTML but inside JavaScript:
                                  #  - translated as REACT.createElement(...) by transformers (e.g. Babel)
                                  #     - e.g. <VAL attr="VAL5" attr2={VAL6}> <hr/> {VAL3} VAL4 </VAL>
                                  #     -> REACT.createElement(VAL, { attr: "val5", attr2: val6 }, [ REACT.createElement("hr"), VAL3, "VAL4" ])
                                  #  - RTYPE is JavaScript expression (unless HTML tag), i.e.:
                                  #     - must be available in scope
                                  #     - can be complex, e.g. RTYPE.VAR
                                  #  - HTML attribute is stringified, unless {...}
                                  #     - boolean attributes must use {BOOL} instead of "BOOL" (def: true)
                                  #     - OBJ attributes (e.g. "style"): ATTR="{ ... }" or ATTR={OBJ}
                                  #     - can spread an OBJ for several attributes: {...OBJ}
                                  #  - children are stringified (i.e. text nodes) unless {...} or <...>
                                  #  - JavaScript comments can be used
                                  #     - however, where they might be interpreted as text node, must be wrapped in {...}
                                  #  - must close tags, including as self-closing tags

TRANSFORMERS ==>                 ##  - Babel plugins:
                                 ##     - "transform-react-jsx": main transformation
                                 ##     - "transform-react-jsx-self": add to props { __self: this }, used for debugging (should be done only in dev)
                                 ##     - "transform-react-jsx-source": add to props { __source: { fileName STR, lineNumber NUM } }, used for debugging (should be done only in dev)
                                 ##     - "transform-react-constant-elements":
                                 ##        - move REACT.createElement() that will always return value (e.g. <hr/>) outside of render()
                                 ##           - goal: they are performed only once, i.e. faster reference comparison
                                 ##        - should not be done in dev, because stack trace harder to read
                                 ##     - "transform-react-inline-elements":
                                 ##        - replace REACT.createElement() by faster alternative, but not good for debugging
                                 ##        - should not be done in dev, only production
                                 ##  - reactify (Browserify)
                                 ##  - jsx-requirejs-plugin (RequireJS)

AST TREE ==>                      #Extends ESTree
                                  #Parsers: acorn, esprima, babylon, flow, typescript

<ELEM>...</ELEM>                  #Child of EXPR, type 'JSXElement':
                                  #  - openingElement JSX_OPENING_ELEM
                                  #  - [closingElement JSX_CLOSING_ELEM] (none if selfClosing)
                                  #  - children ARR of JSX_ELEM|JSX_TEXT|JSX_EXPR_CONTAINER|JSX_SPREAD_CHILD
<ELEM>                            #Type 'JSXOpeningElement':
                                  #  - name JSX_IDENTIFIER|JSX_MEMBER_EXPR|JSX_NAMESPACED_NAME
                                  #  - selfClosing BOOL: if <ELEM/>
                                  #  - attributes ARR of JSX_ATTRIBUTE|JSX_SPREAD_ATTRIBUTE
</ELEM>                           #Type 'JSXClosingElement':
                                  #  - name JSX_IDENTIFIER|JSX_MEMBER_EXPR|JSX_NAMESPACED_NAME

ELEM|ATTR                         #Child of IDENTIFIER, type 'JSXIdentifier'
ELEM.ELEM2                        #Child of EXPR, type 'JSXMemberExpression':
                                  #  - object JSX_IDENTIFIER|JSX_MEMBER_EXPR (all parts but last)
                                  #  - property JSX_IDENTIFIER (last part)
NS:ELEM|ATTR                      #Child of EXPR, type 'JSXNamespacedName':
                                  #  - name JSX_IDENTIFIER
                                  #  - namespace JSX_IDENTIFIER

ATTR[="VAL"]                      #Type 'JSXAttribute':
                                  #  - name JSX_IDENTIFIER|JSX_NAMESPACED_NAME
                                  #  - [value LITERAL|JSX_EXPR_CONTAINER|JSX_ELEM]
{...ATTR_OBJ}                     #Child of SPREAD_ELEM, type 'JSXSpreadAttribute'

{VAL}                             #Type 'JSXExpressionContainer':
                                  #  - expression EXPR or JSX_EMPTY_EXPR (type 'JSXEmptyExpression')
{...CHILD}                        #Type 'JSXSpreadChild'

TEXT                              #Type 'JSXText':
                                  #  - value STR
                                  #  - raw STR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          ANIMATIONS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


                                 ##Package 'react-addons-css-transition-group' (same version as React)

<ReactTransitionGroup>           ##RTYPE firing children's RCOMP:
                                 ##  - componentWillAppear(FUNC()), componentDidAppear():
                                 ##     - when child is added, on first frame (using ReactTransitionGroup's componentDidMount())
                                 ##  - componentWillEnter(FUNC()), componentDidEnter():
                                 ##     - when child is added, on next frames (using ReactTransitionGroup's componentDidUpdate())
                                 ##  - componentWillLeave(FUNC()), componentDidLeave():
                                 ##     - when child is removed (using ReactTransitionGroup's componentDidUpdate|Mount())
                                 ##  - componentDid* wait for componentWill* FUNC to be fired
                                 ##Props:
                                 ##  - component RTYPE|'TAG' (def: 'span'): top-level element
                                 ##  - other props are passed to props.component
<ReactCSSTransitionGroup>        ##<ReactTransitionGroup> firing CSS transitions on children from .appear|enter|leave-CLASS to .appear|enter|leave-CLASS-active
                                 ##In details: children componentWillAppear|Enter|Leave():
                                 ##  - add CSS class 'appear|enter|leave-CLASS'
                                 ##  - at next tick, add CSS class 'appear|enter|leave-CLASS-active'
                                 ##  - after timeout, remove both CSS classes.
                                 ##    Timeout should be same as CSS transition duration.
                                 ##Props:
                                 ##  - transitionAppear|Enter|Leave BOOL (def: false, true, true): enable that feature
                                 ##  - transitionAppear|Enter|LeaveTimeout NUM (required if switch true)
                                 ##  - transitionName 'CLASS' or OBJ.appear|enter|leave[Active] 'CLASS'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:    PERFORMANCE MEASUREMENT    :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


                                 ##Package 'react-addons-perf' (same version as React)

MEASUREMENTS                     ##Opaque structure
PERF.start|stop()                ##Fills in MEASUREMENTS
PERF.isRunning()->BOOL           ##
PERF.getLastMeasurements()
 ->MEASUREMENTS                  ##

PERF.printInclusive(MEASUREMENTS)##Print time taken by each component, and number of instances.
PERF.printExclusive(MEASUREMENTS)##Same but decompose time from mounting, rendering and the rest.
PERF.printWasted(MEASUREMENTS)   ##Same but for the time spent trying to update but giving up because same DOM.
PERF.printOperations(MEASUREMNTS)##Print underlying DOM manipulations.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       IMMUTABLE UPDATE        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


                                 ##Package 'react-addons-update' (same version as React)

UPDATE(OBJ, { VARR:              ##Does immutable update (returns without modifying object) (see also immutable-js)
{ $CMD: VAL ... } ... })         ##Possible $CMD:
                                 ##  - VARR parent must exist:
                                 ##     - $set VAL:               VARR = VAL
                                 ##     - $apply FUNC(VAL2)->VAL: VARR = FUNC(VARR)
                                 ##  - VARR must exist and be an OBJ2:
                                 ##     - $merge OBJ:             VARR = _.extend(VARR, OBJ) (shallow merge)
                                 ##  - VARR must exist and be an ARR:
                                 ##     - $push|unshift ARR2:     VARR.push|unshift(VAL)
                                 ##     - $splice ARR2_ARR3:      VARR.splice(...ARR2), for each ARR2


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            TESTING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


                                 ##Package 'react-addons-test-utils' (same version as React)

TESTUTILS.isElement(RELEM)       ##Is RELEM
TESTUTILS.isElementOfType
(RELEM, RTYPE)                   ##
TESTUTILS.isDOMComponent(RELEM)  ##RELEM's RTYPE is RDOM
TESTUTILS.isCompositeComponent
(RELEM)                          ##RELEM's RTYPE is custom
TESTUTILS.
isCompositeComponentWithType
(RELEM, RTYPE)                   ##

TESTUTILS.renderIntoDocument     ##Like REACTDOM.render(RELEM, ELEM) where ELEM is a detached node.
(RELEM)                          ##A DOM must still be available (e.g. window.document.createElement())
TESTUTILS.createRenderer()       ##Returns RENDERER
RENDERER.render(RELEM[, OBJ])    ##Like REACTDOM.render(RELEM) but:
                                 ##  - does not require|use a DOM
                                 ##  - RELEM's children's children are not rendered.
                                 ##  - REF not supported
                                 ##OBJ is context
RENDERED.unmount()               ##
RENDERED.getRenderedOutput()     ##Returns RCOMP

TESTUTILS.mockComponent
(RTYPE[, 'TAG'])                 ##Make RCOMP.render() -> <TAG>...</TAG> (def: 'div')

TESTUTILS.findAllInRenderedTree
(RELEM, FUNC(RCOMP)->BOOL)       ##Returns RCOMP_ARR
TESTUTILS.scryRenderedDOM
ComponentsWithClass(RCMP,'CLASS')##Same with test for a specific 'CLASS'
TESTUTILS.scryRenderedDOM
ComponentsWithTag(RCOMP, 'TAG')  ##
TESTUTILS.scryRenderedDOM
ComponentsWithType(RCOMP, RTYPE) ##
TESTUTILS.find*()                ##Like TESTUTILS.scry*(), but returns the first result only, or throw exception if nothing found.

TESTUTILS.Simulate.EVENT         ##Trigger EVENT, but still work with virtual DOM and REVENT
(RCOMP|ELEM[, OBJ])              ##OBJ are assigned to EVENT
