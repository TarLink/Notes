
           
   REACT   
           


REACT
REACTDOM                          #Two packages (versions 15.2.1). Must require both.
REACTDOMSERVER                    #Subpackage of REACTDOM, for using in the server

DEVELOPMENT MODE ==>              #Checks NODE_ENV !== 'production'.
                                  #React uses envify in release files, which replaces NODE_ENV by 'development|production'


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            THEORY             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


PRINCIPLE ==>                     #Data flow:
                                  #  - one-way direction (parent to children):
                                  #      - communicating with parent: passing a FUNC (e.g. REACTLINK) as props
                                  #  - 'state' is state owned by current RCOMP, 'props' is state owned by a parent
                                  #     - when changing 'state':
                                  #        - current RCOMP gets 'updated'
                                  #        - children get 'updated' (if same RTYPE) or 'unmounted|mounted' (if different RTYPE)
                                  #     - smart vs dumb RCOMP:
                                  #        - smart components / 'containers':
                                  #           - manipulate state:
                                  #              - have 'state', passed to children as props
                                  #              - pass Flux actions callbacks to children
                                  #           - not visual, e.g. no CSS nor DOM
                                  #           - should be as few as possible
                                  #        - dumb / 'presentational' components:
                                  #           - manipulate UI:
                                  #              - no 'state'
                                  #           - reusable, so no dependency (e.g. no Flux actions nor dispatch)
                                  #     - reduce amount of 'state': 
                                  #        - not computed|duplicated from other 'state|props'
                                  #           - e.g. getInitialState() should not use props
                                  #        - not complex (e.g. not RELEM)
                                  #     - 'context':
                                  #        - like 'props' but with less typing
                                  #        - should only be used for 'props' that are used everywhere in the app, e.g. current user, design theme, etc.
                                  #        - should use explicit 'props' otherwise
                                  #  - children are owned by the RCOMP that create them:
                                  #     - i.e. in RCOMP.render() -> <RCOMP2>...</RCOMP2>, ... will be 'updated' when current RCOMP is, 
                                  #       but not when RCOMP2 is, except if cloned in RCOMP2.render()
                                  #        - will still be correctly 'mounted|unmounted'
                                  #Virtual DOM:
                                  #  - provides abstraction (e.g. can be used on server without real DOM)
                                  #  - allows faster diff algorithm
                                  #  - problem: makes it harder to reach to actual DOM
                                  #JSX: mixing templates into JavaScript because they belong together

GOOD PRACTICES ==>                #  - when passing props down, should explicitely pass props that are consumed, e.g. deconstructing then spreading:
                                  #      let [ VAR, OBJ... ] = this.props;
                                  #      // Use VAR
                                  #      return <ELEM [VAR={VAR}] {...OBJ}>

BAD PRACTICES ==>                 #  - reaching to HTML elements instead of using RELEM|RCOMP abstraction:
                                  #     - e.g. using REF, REACTDOM.findDOMNode()
                                  #  - using RCOMP other than as 'this' in RCOMP methods:
                                  #     - e.g. using REACTDOM.render() return value
                                  #  - shortcircuiting data flow:
                                  #     - RCOMP.forceUpdate()


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          TERMINOLOGY          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


RTYPE                             #RELEM's type
                                  #By convention, custom RTYPE name should be Capitalized
REACT.Component                   #Base RTYPE
RDOM                              #Builtin RTYPE representing an HTML 'TAG'

RELEM                             #Abstracted ELEM (non-instantiated), i.e. RTYPE + props
RNODE                             #VAL[_ARR...]
                                  #  - VAL can be:
                                  #     - RELEM
                                  #     - STR|NUM: text node. Cannot use HTML entities, but can use raw|escaped Unicode.
                                  #     - null|undefined|true|false: no node (but present in props.children as null)
                                  #  - can be ARR, or ARR_ARR, etc. (will be flattened)

RCOMP                             #Instantiated RELEM. Is not an ELEM.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             RTYPE             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


REACT.createClass(OBJ)            #Creates and returns a RTYPE
                                  #Bind all OBJ.FUNC's this to current RCOMP
                                  #OBJ is merged into RCOMP's prototype
STATELESS COMPONENT ==>           #Can use a FUNC()->RELEM as RTYPE:
                                  #  - like specifying only OBJ.render(), with also:
                                  #     - can specify FUNC.contextTypes OBJ
                                  #  - REF is null, so:
                                  #     - cannot use findDOMNode()
                                  #     - cannot use props.ref

ES6 CLASSES ==>                   #Can create ES6 class derived from REACT.Component as an alternative to REACT.createClass()
                                  #Differences:
                                  #  - different syntax:
                                  #     - getInitialState() -> setting this.state in constructor
                                  #     - propTypes|defaultProps OBJ -> static properties
                                  #  - less functionalities:
                                  #     - no 'this' binding
                                  #     - cannot use mixins
                                  #     - cannot use RCOMP.replaceState|isMounted()

RCOMP.displayName                 #JSX tag name, used for debugging.
                                  #Deduced from assigned variable if using JSX transformer.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             RELEM             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


REACT.createElement               #Creates and returns a RELEM
('TAG'|RTYPE[, OBJ][, RNODE...])  #OBJ|RNODE... are RCOMP.props|children.
                                  #'TAG':
                                  #  - use corresponding RDOM
                                  #  - RCOMP.props|children -> HTML attributes|children
REACT.createFactory('TAG'|RTYPE)  #Similar to REACT.createElement.bind(null, 'TAG'|RTYPE)
REACT.DOM.TAG(...)                #Same as REACT.createElement('TAG', ...)
REACT.cloneElement                #Creates and returns a RELEM2, cloned from RELEM.
(RELEM[, OBJ][, RNODE...])        #OBJ are shallow merged, RNODE... children are replaced.

RELEM.type                        #'TAG'|RTYPE
REACT.isValidElement(VAL)         #True if RELEM


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            RENDER             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


REACTDOM.render                   #ELEM's children = RELEM2's instantiation
(RELEM2, ELEM[, FUNC()])->REF     #If ELEM children already contains older RELEM:
                                  #  - RELEM === RELEM2 (i.e. same reference): nothing happens
                                  #  - RELEM == RELEM2 (i.e. same RTYPE): 'update' RELEM
                                  #  - RELEM != RELEM2 (i.e. different RTYPE): 'unmount' RELEM, 'mount' RELEM2
                                  #Calls FUNC() after all events done.
                                  #Rendering adds React-specific HTML attributes:
                                  #  - e.g. data-reactid, data-react-checksum, data-reactroot
                                  #  - if RELEM does not have them (i.e. has not been previously rendered by React), will
                                  #    'unmount|mount' instead of 'update'
REACTDOMSERVER.renderToString     #Returns RELEM as 'HTML'
(RELEM)                           #Idea is pre-render on the server:
                                  #  - why:
                                  #     - when client calls REACTDOM.render(), there is less DOM update, making initial load time faster
                                  #     - more SEO-friendly
                                  #  - requires code to be both client and server ('universal app')
                                  #  - 'HTML' includes React-specific HTML attributes
                                  #Server should be able to just render the component by reusing components client code:
                                  #  - components must use code that can be loaded on both the client and server
                                  #  - component props must be calculated server-side, so AJAX requests must work on both the client and Node
REACTDOMSERVR.renderToStaticMarkup#Same but does not include React-specific HTML attributes.
(RELEM)                           #To use if rendered 'HTML' will not be loaded in client-side React.

MOUNT ==>                         #Fired on:
                                  #  - parent rendered with different RTYPE, for new RELEM2
                                  #  - first render()
                                  #Fires RCOMP2 (in order):
                                  #  - componentWillMount()
                                  #  - render()
                                  #  - componentDidMount()
UPDATE ==>                        #Fired on:
                                  #  - parent rendered with same RTYPE but different props
                                  #  - RCOMP.setState()
                                  #  - RCOMP.forceUpdate()
                                  #Not fired if an 'update' is already ongoing
                                  #Does:
                                  #  - not create new RCOMP (only updates it)
                                  #  - replace RCOMP's props with RCOMP2's
                                  #  - fires RCOMP (in order):
                                  #     - componentWillReceiveProps(OBJ2, OBJ4): 
                                  #        - not fired by RCOMP.setState() nor RCOMP.forceUpdate()
                                  #        - before assigning props (this.props is still old one)
                                  #        - OBJ2|OBJ4 is next props|context
                                  #        - often used to call setState() according to props
                                  #     - shouldComponentUpdate(OBJ2, OBJ3, OBJ4)->BOOL: 
                                  #        - not fired by RCOMP.forceUpdate()
                                  #        - return false if nothing was changed, so we stop here and avoid to:
                                  #           - fire componentWillUpdate|DidUpdate(), which might do more
                                  #           - fire render():
                                  #              - since render() would render same DOM, then no DOM manipulation would done anyway.
                                  #              - however this saves the time spent by JavaScript to check it
                                  #        - is optional and for performance purpose
                                  #        - OBJ2|OBJ3|OBJ4 is next props|state|context
                                 ##        - package 'react-addons-pure-render-mixin' (same version as React):
                                 ##           - mixin PURERENDERMIXIN, which adds shouldComponentUpdate() that does shallow comparison of props|state
                                 ##           - to use if:
                                 ##              - props|state|context can be shallow compared (i.e. contain objects)
                                 ##              - render() only depends on props|state|context
                                  #     - componentWillUpdate(OBJ2, OBJ3, OBJ4)
                                  #        - cannot use setState()
                                  #        - OBJ2|OBJ3|OBJ4 is next props|state|context
                                  #     - render()
                                  #     - componentDidUpdate(OBJ2, OBJ3, OBJ4)
                                  #        - OBJ2|OBJ3|OBJ4 is prev props|state|context
UNMOUNT ==>                       #Fired on:
                                  #  - parent rendered with different RTYPE, for old RELEM
                                  #  - REACTDOM.unmountComponentAtNode()
                                  #Fires RCOMP:
                                  #  - componentWillUnmount()

RCOMP.render()                    #Does the actual DOM manipulation.
                                  #Must return RCOMP's single child, i.e. RELEM (or null|false):
                                  #  - calls REACTDOM.render() on child recursively:
                                  #     - order:
                                  #        - start with ancestor for componentWill*(), shouldComponentUpdate(), render()
                                  #        - start with descendant for componentDid*()
                                  #     - compare children old RELEM with new RELEM2 according to DOM order
                                  #        - problem:
                                  #           - in lists of similar items, modifications might recreate all items
                                  #             (e.g. prepending, since it compares by DOM order)
                                  #           - this is bad for performance, but also does not retain state in those items
                                  #        - solution: 
                                  #           - can use HTML attribute 'key', which will then be used for comparison
                                  #           - should then be unique ID among siblings
                                 ##           - can automatically create 'key' based on RELEM index order and 'VAR' namespace 
                                 ##             with CREATEFRAGMENT({ VAR: RNODE ...}):
                                 ##              - considering RNODE can either be a single RNOD or several RNOD, 
                                 ##                returns all as flattened RNOD_ARR, after assigning RNOD.key 'VAR/.NUM[$KEY]' where:
                                 ##                 - NUM is RNOD index in RNODE (which can be an array)
                                 ##                 - KEY is RNOD.key
                                 ##              - Package 'react-addons-create-fragment' (same version as React)
                                  #     - if children are not newly created in render() (e.g. use props.children reference),
                                  #       old RELEM === new RELEM2, so nothing will happen for that child
                                  #        - i.e. RCOMP 'owns' the children it creates in render(), but not the children passed to it
                                  #  - if RDOM, will update DOM, but in an efficient way:
                                  #     - does not update if same
                                  #     - only add|remove attributes if only attributes changed
                                  #  - should not modify state nor read global state nor be async
                                  #    (use componentDidMount|Update() for that)
                                  #Single child, i.e. must return RELEM, not RELEM_ARR
RCOMP.forceUpdate()               #Forces 'update'
                                  #Useful when render() depends on state that changed but did not trigger a new render(), e.g.:
                                  #  - RCOMP.state.OBJ.VAR changed, but no setState() was called
                                  #  - DOM element change that cannot be caught with onEvent
REACTDOM.unmountComponentAtNode   #Inverse of REACTDOM.render(): remove ELEM children (firing 'unmount') then returns true.
(ELEM)                            #If no RCOMP was mounted, does nothing and returns false.

RCOMP.isMounted()                 #To use in async operation to make sure RCOMP still exists.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:       PROPS/STATE BASE        :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


RCOMP.props                       #Read-only state OBJ.
                                  #Readonly (non-configurable, non-writable) shallowly (but should be considered deeply readonly)
                                  #'Owned' by a parent, i.e. props change when the parent passing them re-rendered children with different props.
                                  #Rendered as HTML attributes for RDOM
RELEM.props                       #As opposed to RCOMP, props.key|ref are not on RELEM.props.* but on RELEM.*
RCOMP.getDefaultProps()->OBJ      #Called once per RTYPE (not per RCOMP), 
                                  #then the result OBJ is shallowingly assigned to each new RCOMP.props


RCOMP.state                       #Read-write state OBJ
                                  #'Owned' by RCOMP
                                  #Should never be written to:
                                  #  - use setState() instead
                                  #  - to avoid it, might need to make deep copy, including using tools like immutable-js
                                  #Might be null if not getInitialState()
RCOMP.getInitialState()->OBJ      #Initial RCOMP.state
                                  #Called before componentWillMount()
RCOMP.setState(OBJ[(OBJ2, OBJ3)]  #Shallow merges into RCOMP.state
[, FUNC()])                       #OBJ2|OBJ3 is current state|props
                                  #Might be performed async or not. FUNC() performed afterwards.
                                  #Fires 'update'
RCOMP.replaceState(...)           #Same but sets instead of merging


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:       PROPS/STATE EXTRA       :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


RCOMP.props.children              #CHILDREN
                                  #Opaque structure to be manipulated only through React.Children RCHILDREN, 
                                  #where RNODE will be individual elements (not ARR)
RCHILDREN.count(CHILDREN)         #
RCHILDREN.map|forEach
(CHILDREN, FUNC(RNODE)[, THIS])   #
RCHILDREN.toArray(CHILDREN)       #Returns RNODE_ARR
RCHILDREN.only(CHILDREN)          #Returns RNODE if CHILDREN contains only one child, and it is a RELEM
                                  #Otherwise throws (if in 'development mode')


RCOMP.propTypes                   #OBJ.VAR PROP_RULE:
                                  #  - if RTYPE.props.VAR does not satisfy PROP_RULE during createElement(), it will throw error:
                                  #     - only once for a given RTYPE + VAR + PROP_RULE
                                  #     - only in 'development mode'
                                  #  - use PTYPES.oneOfType or custom PROP_RULE for multiple validations
                                  #PROP_RULE is FUNC(RTYPE.props, 'VAR', 'RTYPE')[->ERROR]
                                  #List of builtin PROP_RULE:
React.PropTypes                   #PTYPES
PTYPES.array|bool|func|symbol|
number|object|string|node|element #Checks type: 'node' is RNODE[_ARR], 'element' RELEM
PTYPES.instanceOf(TYPE)           #
PTYPES.oneOf(VAL_ARR)             #
PTYPES.oneOfType(PROP_RULE_ARR)   #
PTYPES.arrayOf(PROP_RULE)         #
PTYPES.objectOf(PROP_RULE)        #Object values
PTYPES.shape({VAR: PROP_RULE ...})#
PROP_RULE.isRequired              #E.g. PTYPES.bool.isRequired


RCOMP.mixins                      #OBJ_ARR, where OBJ gets merged into RCOMP.
                                  #If property conflict:
                                  #  - if lifecycle RCOMP.FUNC (e.g. componentWillUpdate, etc.), surcharges instead of
                                  #    overriding it (i.e. called before non-mixin one)
                                  #  - otherwise, throws error


RCOMP.statics                     #OBJ assigned to RTYPE during createClass(), i.e. static methods.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            CONTEXT            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


RCOMP.context                     #Like RCOMP.props, but with less typing (see getChildContext())
RCOMP.getChildContext()->OBJ      #Define|merges RCOMP.context OBJ in all ancestors
RCOMP.contextTypes                #Like RCOMP.propTypes but for RCOMP.context, defined in the ancestor using it
                                  #Required.
RCOMP.childContextTypes           #Same for the parent defining getChildContext().
                                  #Required.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             REFS              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


REF                               #Instantiation of a RELEM:
                                  #  - if based on RTYPE, RCOMP
                                  #  - if based on 'TAG', ELEM
                                  #  - if stateless component, null

RCOMP.props.ref                   #On createElement():
                                  #  - FUNC(REF): 
                                  #     - on mounting, called once with REF
                                  #     - on updating, first called with null (to let handler clean previous
                                  #       reference), then called with new REF
                                  #     - when unmounting, called once with null
                                  #  - 'REF': same as FUNC(REF) { this.refs['REF'] = REF; }

REACTDOM.findDOMNode(RCOMP)       #Returns corresponding ELEM
                                  #If RCOMP not mounted, throws exception


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             RDOM              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


RDOM ==>                          #Builtin RTYPE mimicking usual HTML.
                                  #Differences are below.

ALLOWED HTML TAGS|ATTRIBUTES ==>  #Whitelisted:
                                  #  - but should cover most standard HTML
                                  #  - custom HTML tags are allowed
                                  #  - custom HTML attributes are allowed if HTML tag name contains '-' or HTML attribute
                                  #    is="..." present

HTML ATTRIBUTES ==>               #  - camelCased, except data-*, aria-*
                                  #  - class -> className, html -> htmlFor
                                  #  - values:
                                  #     - style.CSSPROP VAL (camelCased, except vendor prefix which are titleized)
                                  #     - boolean attributes: must only use BOOL as value
                                  #     - NUM -> NUMpx, except where LENP is not expected
                                  #  - new:
                                  #     - dangerouslySetInnerHtml { __html STR }: set innerHTML
                                  #     - ref|key: see below

DOM EVENTS ==>                    #  - onEvent(REVENT), with REVENT being like EVENT but:
                                  #     - better crossbrowser behavior
                                  #     - more performant (use only one global event listener, then redistribute)
                                  #     - extra properties:
                                  #        - nativeEvent EVENT
                                  #        - isDefaultPrevented|PropagationStopped(): like jQuery
                                  #     - no stopImmediatePropagation()
                                  #     - is deleted after function ends, so async can only use it with:
                                  #        - copying to local variable
                                  #        - or calling REVENT.persist()

FORM CONTROLS ==>                 #Value:
                                  #  - <textarea> children   -> <textarea value>
                                  #  - <option selected>     -> <select value> (STR[_ARR])
                                  #  - <input value|checked> -> same
                                  #HTML attributes:
                                  #  - onChange: 
                                  #     - should be used. Like onInput, but with React's behavior for 'value'
                                  #     - for checkboxes|radio buttons, do not call REVENT.preventDefault(),
                                  #       or control will be updated in model but not in UI
                                  #  - value|checked: 
                                  #     - sets default value
                                  #     - makes control read-only: can only updated with new render(), usually
                                  #       with this.setState() in onChange event handler
                                  #     - not updated on UI interaction but:
                                  #        - JavaScript value|checked is
                                  #        - if it triggers a new render() with new value|checked, it gets updated like this
                                  #     - if null|undefined (as opposed to ''), does not do anything anymore
                                  #  - defaultValue|Checked: only sets default value


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:              JSX              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


<...>                             #Like HTML but inside JavaScript:
                                  #  - translated as REACT.createElement(...) by transformers (e.g. Babel)
                                  #  - <RTYPE...>: RTYPE is JavaScript expression, i.e.:
                                  #     - must be available in scope
                                  #     - can be complex, e.g. RTYPE.VAR
                                  #  - can use {...}:
                                  #     - instead of a node, e.g. <TAG>{RNODE}</TAG>
                                  #        - replaced by createElement() RNODE
                                  #     - HTML attribute VAR={VAL}:
                                  #        - replaced by createElement() OBJ { VAR: VAL }
                                  #        - can spread an OBJ: {...OBJ}
                                  #  - boolean attributes:
                                  #     - must use {BOOL} instead of "BOOL"
                                  #     - nothing -> true
                                  #  - OBJ attributes (e.g. "style"): ATTR="{ ... }"
                                  #  - JavaScript comments can be used
                                  #     - however, where they might be interpreted as text node, must be wrapped in {...}
                                  #  - must close tags, including as self-closing tags

TRANSFORMERS ==>                 ##  - Babel (CLI)
                                 ##  - reactify (Browserify)
                                 ##  - jsx-requirejs-plugin (RequireJS)

REACT TRANSFORMS ==>             ##Plugins that transform each new RTYPE (2.0.0)
                                 ##Configured in .babelrc as CONF.env.development.plugins[*] [ 'react-transform', { transforms OBJ_ARR } ]
                                 ##with OBJ:
                                 ##  - transform "MODULE"
                                 ##  - imports "MODULE"_ARR: dependencies
                                 ##  - locals STR_ARR: local variables to define
                                 ##Defined as:
                                 ##  FUNC(OBJ)->FUNC(RTYPE, COMPONENT_ID)->RTYPE
                                 ##with OBJ:
                                 ##  - filename "FILE"
                                 ##  - imports|locals VAR_ARR
                                 ##  - components:
                                 ##     - COMPONENT_ID:
                                 ##        - displayName STR: must use babel-plugin-transform-react-display-name
                                 ##        - isInFunction BOOL: defined in another function


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          ANIMATIONS           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


                                 ##Package 'react-addons-css-transition-group' (same version as React)

<ReactTransitionGroup>           ##RTYPE firing children's RCOMP:
                                 ##  - componentWillEnter(FUNC()), componentDidEnter(): 
                                 ##     - each time that child is added. 
                                 ##     - done in ReactTransitionGroup's componentDidUpdate()
                                 ##     - componentDidEnter() wait for componentWillEnter FUNC() to be called
                                 ##  - componentWillAppear(FUNC()), componentDidAppear(): 
                                 ##     - same but fired instead when ReactTransitionGroup is mounting 
                                 ##     - done in ReactTransitionGroup's componentDidMount()
                                 ##  - componentWillLeave(FUNC()), componentDidLeave(): 
                                 ##     - each time that child is removed
                                 ##     - done in ReactTransitionGroup componentDidMount() or componentDidUpdate()
                                 ##Props:
                                 ##  - component RTYPE|'TAG' (def: 'span'): top-level element
                                 ##  - other props are passed to props.component
<ReactCSSTransitionGroup>        ##Renders as <ReactTransitionGroup> firing CSS transitions on children from 
                                 ##  .appear|enter|leave-CLASS to .appear|enter|leave-CLASS-active
                                 ##In details: children componentWillAppear|Enter|Leave():
                                 ##  - add CSS class 'appear|enter|leave-CLASS'
                                 ##  - at next tick, add CSS class 'appear|enter|leave-CLASS-active'
                                 ##  - after timeout, remove both CSS classes.
                                 ##    Timeout should be same as CSS transition duration.
                                 ##Props:
                                 ##  - appear|enter|leave BOOL (def: false, true, true): switches
                                 ##  - appear|enter|leaveTimeout NUM (required if switch true)
                                 ##  - transitionName 'CLASS'|{appear|enter|leave[Active] 'CLASS'}


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:    PERFORMANCE MEASUREMENT    :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


                                 ##Package 'react-addons-perf' (same version as React)

PERF.start|stop()                ##Fills in MEASUREMENT
PERF.isRunning()->BOOL           ##
PERF.getLastMeasurements()       ##Returns MEASUREMENT_ARR

PERF.printInclusive(MEASUREMENT) ##Print time taken by each component, and number of instances.
PERF.printExclusive(MEASUREMENT) ##Same but decompose time from mounting, rendering and the rest.
PERF.wastedTime(MEASUREMENT)     ##Same but for the time spent trying to update but giving up because same DOM.

PERF.printOperations(MEASUREMENT)##Print underlying DOM manipulations.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:       IMMUTABLE UPDATE        :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


                                 ##Package 'react-addons-update' (same version as React)

UPDATE(OBJ, { VARR:              ##Does immutable update (returns without modifying object) (see also immutable-js)
{ $CMD: VAL ... } ... })         ##Possible $CMD:
                                 ##  - VARR parent must exist:
                                 ##     - $set VAL:               VARR = VAL
                                 ##     - $apply FUNC(VAL2)->VAL: VARR = FUNC(VARR)
                                 ##  - VARR must exist and be an OBJ2:
                                 ##     - $merge OBJ:             VARR = _.extend(VARR, OBJ) (shallow merge)
                                 ##  - VARR must exist and be an ARR:
                                 ##     - $push|unshift ARR2:     VARR.push|unshift(VAL)
                                 ##     - $splice ARR2_ARR3:      VARR.splice(...ARR2), for each ARR2


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            TESTING            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


                                 ##Package 'react-addons-test-utils' (same version as React)

TESTUTILS.isElement(RELEM)       ##Is RELEM
TESTUTILS.isElementOfType
(RELEM, RTYPE)                   ##
TESTUTILS.isDOMComponent(RELEM)  ##RELEM's RTYPE is RDOM
TESTUTILS.isCompositeComponent
(RELEM)                          ##RELEM's RTYPE is custom
TESTUTILS.
isCompositeComponentWithType
(RELEM, RTYPE)                   ##

TESTUTILS.renderIntoDocument     ##Like REACTDOM.render(RELEM, ELEM) where ELEM is a detached node.
(RELEM)                          ##A DOM must still be available (e.g. window.document.createElement())
TESTUTILS.createRenderer()       ##Returns RENDERER
RENDERER.render(RELEM[, OBJ])    ##Like REACTDOM.render(RELEM) but:
                                 ##  - does not require|use a DOM
                                 ##  - RELEM's children's children are not rendered.
                                 ##  - REF not supported
                                 ##OBJ is context
RENDERED.unmount()               ##
RENDERED.getRenderedOutput()     ##Returns RCOMP

TESTUTILS.findAllInRenderedTree
(RELEM, FUNC(RCOMP)->BOOL)       ##Returns RCOMP_ARR
TESTUTILS.scryRenderedDOM
ComponentsWithClass(RCMP,'CLASS')##Same with test for a specific 'CLASS'
TESTUTILS.scryRenderedDOM
ComponentsWithTag(RCOMP, 'TAG')  ##
TESTUTILS.scryRenderedDOM
ComponentsWithType(RCOMP, RTYPE) ##
TESTUTILS.find*()                ##Like TESTUTILS.scry*(), but returns the first result only, or throw exception if nothing found.

TESTUTILS.Simulate.EVENT         ##Trigger EVENT, but still work with virtual DOM and REVENT
(RCOMP|ELEM[, OBJ])              ##OBJ are assigned to EVENT
