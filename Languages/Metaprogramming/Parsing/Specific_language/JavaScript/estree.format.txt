
          
   ESTREE  
          



TODO:
  - go through ESTree spec
  - try with online parser everything documented here, to see if there is more in output
  - go through JavaScript doc to see if something is missing


VERSION ==>                       #Last commit 19/03/2017
                                  #JavaScript AST standard

OPTIONAL VALUES ==>               #Are either defined or null

any                               #NODE:
                                  #  - type STR
                                  #  - [loc] (position in source code):
                                  #     - [source STR]
                                  #     - start|end:
                                  #        - line NUM (1-indexed)
                                  #        - column NUM (0-indexed)
                                  #It is root type, abstract:
                                  #  - all other types inherit from it
                                  #  - all redefine type STR, except if abstract types themselves

FILE                              #Type 'Program':
                                  #  - sourceType 'script|module'
                                  #  - body STATEMENT|MODULE_DECLARATION_ARR
STATEMENT                         #

EXPR_STATEMENT                    #Statement with single EXPR.
                                  #Child of STATEMENT, type 'ExpressionStatement':
                                  #  - expression EXPR
;                                 #Empty statement, with only semicolon
                                  #Child of STATEMENT, type 'EmptyStatement'
{...}                             #Child of STATEMENT, type 'BlockStatement':
                                  #  - body STATEMENT_ARR

if (...) {...} [else {...}]       #Child of STATEMENT, type 'IfStatement':
                                  #  - test EXPR
                                  #  - consequent STATEMENT
                                  #  - [alternate STATEMENT]
switch (...) {...}                #Child of STATEMENT, type 'SwitchStatement':
                                  #  - discriminant EXPR
                                  #  - cases SWITCH_CASE_ARR (type 'SwitchCase'):
                                  #     - [test EXPR] (case's VAL) (null if default case)
                                  #     - consequent STATEMENT_ARR (if two following cases, the first one has no consequent)

while (...) {...}                 #Child of STATEMENT, type 'WhileStatement':
                                  #  - test EXPR
                                  #  - body STATEMENT
do {...} while (...)              #Child of STATEMENT, type 'DoWhileStatement':
                                  #  - test EXPR
                                  #  - body STATEMENT
for (...;...;...) {...}           #Child of STATEMENT, type 'ForStatement':
                                  #  - [init VARIABLE_DECLARATION|EXPR]
                                  #  - [test EXPR]
                                  #  - [update EXPR]
                                  #  - body STATEMENT
for (VAR in|of VAL) {...}         #Child of STATEMENT, type 'ForInStatement|ForOfStatement':
                                  #  - left VARIABLE_DECLARATION|PATTERN
                                  #  - right EXPR
                                  #  - body STATEMENT
break [LABEL]                     #Child of STATEMENT, type 'BreakStatement':
                                  #  - [label IDENFIFIER]
continue [LABEL]                  #Child of STATEMENT, type 'ContinueStatement':
                                  #  - [label IDENFIFIER]

with (...) {...}                  #Child of STATEMENT, type 'WithStatement':
                                  #  - object EXPR
                                  #  - body STATEMENT
LABEL: ...                        #Child of STATEMENT, type 'LabeledStatement':
                                  #  - label IDENTIFIER
                                  #  - body STATEMENT

try { ... }                       #Child of STATEMENT, type 'TryStatement':
[catch (...) {...}]               #  - block BLOCK_STATEMENT
[finally {...}]                   #  - [handler CATCH_CLAUSE] (type 'CatchClause'):
                                  #     - param PATTERN
                                  #     - body BLOCK_STATEMENT
                                  #  - [finalizer BLOCK_STATEMENT]
throw VAL                         #Child of STATEMENT, type 'ThrowStatement':
                                  #  - argument EXPR

debugger                          #Child of STATEMENT, type 'DebuggerStatement'

DECLARATION                       #Child of STATEMENT. Parent of VARIABLE_DECLARATION, FUNCTION_DECLARATION, CLASS_DECLARATION
QUAL VAR = VAL, ...               #Child of DECLARATION, type 'VariableDeclaration':
                                  #  - declarations VARIABLE_DECLARATOR_ARR (type 'VariableDeclarator'):
                                  #     - id PATTERN
                                  #     - [init EXPR]
                                  #  - kind 'var|let|const'

EXPR                              #EXPR

super                             #Type 'Super'
this                              #Child of EXPR, type 'ThisExpression'

[VAL...]                          #Child of EXPR, type 'ArrayExpression':
                                  #  - elements EXPR2|SPREAD_ELEMENT_ARR (null for sparse ARR elements)
...ARR                            #Type 'SpreadElement':
                                  #  - argument EXPR

{VAR[: VAL], ...}                 #Child of EXPR, type 'ObjectExpression':
{[VAL]: VAL}                      #  - properties PROPERTY_ARR (type 'Property'):
{FUNC(...){...}}                  #     - key EXPR (LITERAL if {[VAR]: VAL} or {NUM: VAL})
                                  #     - value EXPR
                                  #     - kind 'init|get|set' (get|set are for getters|setters)
                                  #     - method BOOL (if FUNC)
                                  #     - shorthand BOOL (if { VAR })
                                  #     - computed BOOL

VAR or related                    #PATTERN
VAR                               #Child of EXPR+PATTERN, type 'Identifier':
                                  #  - name STR
OBJ.VAR                           #Child of EXPR+PATTERN, type 'MemberExpression':
OBJ[VAL]                          #  - object EXPR|SUPER (OBJ)
                                  #  - property EXPR (VAL) or IDENTIFIER (VAR)
                                  #  - computed true (VAL) or false (VAR)
[VAR,...]                         #Child of PATTERN, type 'ArrayPattern' (deconstruction):
                                  #  - elements PATTERN_ARR (null for parse array element)
{VAR,...}                         #Child of PATTERN, type 'ObjectPattern' (deconstruction):
                                  #  - properties ASSIGNMENT_PROPERTY_ARR, child of PROPERTY with differences:
                                  #     - value PATTERN
                                  #     - kind always 'init'
                                  #     - method always false
...VARIADIC_ARG                   #Child of PATTERN, type 'RestElement':
                                  #  - argument PATTERN

FUNC                              #FUNCTION:
                                  #  - [id IDENTIFIER] (null if anonymous)
                                  #  - params PATTERN_ARR
                                  #  - body BLOCK_STATEMENT
                                  #  - generator BOOL
function [*]FUNC(...){...}        #Child of FUNCTION+DECLARATION, type 'FunctionDeclaration'
function [*][FUNC](...){...}      #Child of FUNCTION+EXPR, type 'FunctionExpression'
[FUNC]() => {...}                 #Child of FUNCTION+EXPR, type 'ArrowFunctionExpression':
                                  #  - no id
                                  #  - params PATTERN_ARR
                                  #  - body BLOCK_STATEMENT or (if () => VAL) EXPR
                                  #  - no generator
                                  #  - expression BOOL (if () => VAL)
VAR = VAL                         #Child of PATTERN, type 'AssignmentPattern' (default values):
                                  #  - left PATTERN
                                  #  - right EXPR
return [VAL]                      #Child of STATEMENT, type 'ReturnStatement':
                                  #  - [argument EXPR]
yield [*] [VAL]                   #Child of EXPR, type 'YieldExpression':
                                  #  - [argument EXPR]
                                  #  - delegate BOOL (if *)
FUNC(...)                         #Child of EXPR, type 'CallExpression':
                                  #  - callee EXPR|SUPER (FUNC)
                                  #  - arguments EXPR|SPREAD_ELEMENT_ARR
new FUNC(...)                     #Child of EXPR, type 'NewExpression':
                                  #  - callee EXPR (FUNC)
                                  #  - arguments EXPR|SPREAD_ELEMENT_ARR

-VAL
+VAL
!VAL
~VAL                              #Child of EXPR, type 'UnaryExpression':
typeof VAL                        #  - operator '-|+|!|~|typeof|void|delete'
void VAL                          #  - prefix BOOL (whether before VAL, i.e. always true)
delete VAL                        #  - argument EXPR

++VAR                             #Child of EXPR, type 'UpdateExpression':
VAR++                             #  - operator '--|++'
--VAR                             #  - prefix BOOL
VAR--                             #  - argument EXPR

VAL == != === !== < <= > >= <<    #Child of EXPR, type 'BinaryExpression':
>> >>> + - * / % | ^ & in         #  - operator '==|!=|===|!==|<|<=|>|>=|<<|>>|>>>|+|-|*|/|%|||^|&|in|instanceof'
instanceof VAL2                   #  - left EXPR
                                  #  - right EXPR
VAR = += -= *= /= %= <<= >>=      #Child of EXPR, type 'AssignmentExpression':
>>>= |= ^= &= VAL                 #  - operator '=|+=|-=|*=|/=|%=|<<=|>>=|>>>=||=|^=|&='
                                  #  - left PATTERN or (only on older JavaScript engines) EXPR
                                  #  - right EXPR
VAL || && VAL2                    #Child of EXPR, type 'LogicialExpression':
                                  #  - operator '|||&&'
                                  #  - left EXPR
                                  #  - right EXPR

VAL ? VAL2 : VAL3                 #Child of EXPR, type 'ConditionalExpression':
                                  #  - test EXPR
                                  #  - alternate EXPR
                                  #  - consequent EXPR
VAL,...                           #Child of EXPR, type 'SequenceExpression':
                                  #  - expressions EXPR_ARR

STR|BOOL|NUM|null|REGEXP          #Child of EXPR, type 'Literal':
                                  #  - value STR|BOOL|NUM|null|REGEXP
                                  #  (REGEXP only)
                                  #  - regex:
                                  #     - pattern STR
                                  #     - flags STR
TAG`...`                          #Child of EXPR, type 'TaggedTemplateExpression':
                                  #  - tag EXPR
                                  #  - quasi TEMPLATE_LITERAL
`...`                             #Child of EXPR, type 'TemplateLiteral':
                                  #  - quasis TEMPLATE_ELEMENT_ARR (non-${} parts), type 'TemplateElement':
                                  #     - tail BOOL (if last one, including empty "" if ends with ${})
                                  #     - value: cooked|raw STR
                                  #  - expressions EXPR_ARR (${} parts)

class [CLASS] [extends PARENT] {  #Type 'Class':
  [static] FUNC(...) {...}        #  - [id IDENTIFIER]
}                                 #  - [superclass EXPR]
                                  #  - body CLASS_BODY, type 'ClassBody':
                                  #     - body METHOD_DEFINITION_ARR, type 'MethodDefinition':
                                  #        - key EXPR
                                  #        - value FUNCTION_EXPR
                                  #        - kind 'constructor|method|get|set'
                                  #        - static BOOL
                                  #        - computed BOOL
class CLASS ... {}                #Child of CLASS+DECLARATION, type 'ClassDeclaration'
class [CLASS] ... {}              #Child of CLASS+EXPR, type 'ClassExpression'
new.target                        #Child of EXPR, type 'MetaProperty':
                                  #  - meta IDENTIFIER (new)
                                  #  - property IDENTIFIER (target)

import|export ...                 #MODULE_DECLARATION
???                               #MODULE_SPECIFIER:
                                  #  - local IDENTIFIER

                                  #Child of MODULE_DECLARATION, type 'ImportDeclaration':
                                  #  - source LITERAL
                                  #  - specifiers MODULE_SPECIFIER_ARR, among:
                                  #      IMPORT_SPECIFIER, type 'ImportSpecifier':
                                  #        - imported IDENTIFIER
                                  #      IMPORT_DEFAULT_SPECIFIER, type 'ImportDefaultSpecifier'
                                  #      IMPORT_NAMESPACE_SPECIFIER, type 'ImportNamespaceSpecifier'

                                  #Child of MODULE_DECLARATION, type 'ExportNamedDeclaration':
                                  #  - [declaration DECLARATION]
                                  #  - [source LITERAL]
                                  #  - specifiers EXPORT_SPECIFIER_ARR
