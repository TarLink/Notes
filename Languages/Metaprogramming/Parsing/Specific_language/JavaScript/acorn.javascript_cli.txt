
         
   ACORN  
         



ALTERNATIVES ==>                  #  - esprima: maintained by jQuery, historic main parser.
                                  #    Least support for new ES syntax, uses ESTree, most stable, least active
                                  #  - acorn:
                                  #    Uses ESTree, most utilities functions, good plugin system
                                  #  - babylon: fork of acorn, used by Babel
                                  #    Supports Flow, most support for new ES syntax, uses slightly different ESTree,
                                  #    least utilities functions, least stable, most active, twice slower
                                  #Prefer acorn

VERSION ==>                       #5.0.3
                                  #Browser, Node.js or CLI

ACORN.parse('JS'[, OPTS])         #JavaScript parser, using ESTree as AST format (see its doc)
->PROGRAM_NODE                    #Errors raise SyntaxError, with ERROR.pos NUM (offset) and loc.line|column NUM
                                  #OPTS:
                                  #  - ecmaVersion 3|5|6|7|8 (def: 7)
                                  #  - sourceType 'script|module' (def: 'script')
                                  #  - preserveParens BOOL: parse parenthesis as EXPR_NODE, type 'ParenthesizedExpression'
                                  #    with property expression EXPR2_NODE, instead of ignoring them
                                  #  - onComment(OBJ): called on comments with: BOOL (// vs /* */), STR (text),
                                  #    START_OFFSET, END_OFFSET
                                  #  - onToken(TOKEN): called by tokenizer
                                  #  - allowReturnOutsideFunction BOOL (def: false): fail on top-level return
                                  #  - allowImportExportEverywhere BOOL (def: false): fail on non-top-level import|export
                                  #  - allowReserved BOOL|'never' (def: false): fail on VAR that is a reserved keywords
                                  #    (true|false) or a OBJ.VAR ('never')
                                  #  - allowHashBang BOOL (def: false): ignore hashbangs
                                  #  - onInsertedSemicolon(NUM, POSITION): called when found a line with missing semicolon
                                  #  - onTrailingComma(NUM, POSITION): called on trailing commas
                                  #  - program PROGRAM2_NODE: prepend PROGRAM2.body to PROGRAM.body
                                  #Positions:
                                  #  - line-wise (if OPTS.locations true, def false):
                                  #     - POSITION is OBJ.line|column
                                  #     - NODE|TOKEN.loc:
                                  #        - start|end POSITION
                                  #        - sourceFile VAL, using OPTS.sourceFile VAL
                                  #          Can also be added to NODE.sourceFile, with OPTS.directSourceFile VAL
                                  #     - can use ACORN.getLineInfo('JS', START_OFFSET)->POSITION
                                  #  - non-line-wise:
                                  #     - NODE|TOKEN.start|end START|END_OFFSET, always defined
                                  #     - NODE|TOKEN.range [START_OFFSET, END_OFFSET], defined if OPTS.ranges true (def: false)
ACORN.parseExpressionAt('JS',
OFFSET_NUM[, OPTS])->EXPR_NODE    #Same but for an expression, not a full file. Ignores next expressions|statements

ACORN.tokenizer('JS'[, OPTS])
question ?
arrow =>
template template
ellipsis ...
backQuote `
dollarBraceL ${
eq =
assign _=
incDec ++/--
prefix prefix
logicalOR ||
logicalAND &&
bitwiseOR |
bitwiseXOR ^
bitwiseAND &
equality ==/!=
relational </>
bitShift <</>>
plusMin +/-
modulo %
star *
slash /
starstar **
_break break
_case case
_catch catch
_continue continue
_debugger debugger
_default default
_do do
_else else
_finally finally
_for for
_function function
_if if
_return return
_switch switch
_throw throw
_try try
_var var
_const const
_while while
_with with
_new new
_this this
_super super
_class class
_extends extends
_export export
_import import
_null null
_true true
_false false
_in in
_instanceof instanceof
_typeof typeof
_void void
_delete delete

TOK.keyword: if _*, same as *, otherwise undefined
