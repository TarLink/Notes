
             
   ONEFLOW   
             


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            BASICS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


  - module                                        var MDL = Flow.module("MDL")
  - routing         modules/MDL/MDL.js            MDL.Router|router + comm (out, exp)
  - controller      modules/MDL/controller.js     MDL.Controller|controller, defining MDL_FUNC
                                                  MDL_FUNC often fires either:
                                                    - REGION.show(new MDL.*View(...))
                                                    - this.ensureView(REGION, VIEW_CTOR)
                                                  Using new Flow.Entities.MODEL(OBJ)
  - models          entities/MODEL/MODEL.js       Flow.Entities.MODEL = RelationalModel|SimpleModel.extend(OBJ)
  - views           modules/MDL/views/VIEW.js     MDL.VIEWView = Flow.Views.BASEVIEW.extend(OBJ), with OBJ.template requireJS of "tpl!PATH_TO_TEMPLATE"
  - templates       modules/MDL/templates/*.html                            

  - comm (out, exp)                               Flow|Agreement.execute|request("EVENT", ...)[->VAL]
                                                  "EVENT" is "MDL:SUBMDL:ACTION"
  - comm (in, exp)                                Flow|Agreement.commands|reqres.setHandler("EVENT", FUNC(...)[->VAL]):
                                                  Usually calls MDL_FUNC(), and (if ACTION "show") Flow.RouteTo.location()
  - comm (out, imp)                               Flow.on("EVENT", FUNC(...))
  - comm (in, imp)                                Flow.trigger("EVENT", ...)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            ROUTING            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/

SUMMARY ==> 
  - appRoutes: user-change, URL+MDL_FUNC
  - MDL.router.execute(): programatic, MDL_FUNC
  - Flow.RouteTo.location(): programatic, URL
  - <a href="">: do nothing, but should setup VIEW.triggers eventually calling programatic change

Flow.router                                           // Root MDL.router, with no appRoutes nor MDL_FUNC

MDL.Router = Flow.Routers.AppRouter.extend
({ appRoutes: { "PATH[:VAR|*VAR]": "MDL_FUNC" } });   // When URL user-change: fires MDL_FUNC([VAR...])

routes = Flow.RouteTo.compileRoutables(MDL.Router);   // routes is { MDL_FUNC: PATH }
MDL.RouteTo = { "ROUTE": FUNC(...)->PATH };           // using routes.MDL_FUNC
Flow.RouteTo.addRouteDefinitions(MDL.RouteTo);        // Adds Flow.RouteTo.ROUTE(...)->PATH, used by Flow.RouteTo.location|navigate()

MDL.Controller = Flow.Controllers.Controller.extend({ "MDL_FUNC"(...) });
                                                      // Can add access: MDL_FUNC"_ARR, to allow public access
Flow.addInitializer(function () {
  MDL.controller = new MDL.Controller();
  MDL.router = new MDL.Router({ controller: MDL.controller });
});

MDL.router.execute("MDL_FUNC"[, ...]): calls MDL_FUNC(...)
Flow.RouteTo.location|navigate("ROUTE"[, ...]): 
  - changes URL path to Flow.RouteTo.ROUTE(...)->PATH (navigates also fires URL user-change)
  - camelcase -> dasherized

<a href="URL">:
  - URL should use routeTo.ROUTE([...])->PATH (template helper)
  - if external website: use data-bypass
  - otherwise, will not do anything by itself, but should set up VIEW.triggers["click a.SELECTOR"] "MDL:SUBMDL:ACTION"
    with then VIEW.on("MDL:SUBMDL:ACTION", Flow.execute("MDL:SUBMDL:ACTION"))

Flow.redirect([PATH[, BOOL]]): user change URL to "[/app]PATH" (/app if true)
Flow.reload(): user reload URL


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             VIEWS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


MVIEW OBJ:
  - template requireJS("tpl!PATH")
  - className STR
  - ui OBJ
  - events|triggers."EVENT SELECTOR" "MDL_FUNC|MDL:SUBMDL:ACTION":
     - events usually handled as view functions, doing DOM manipulation
     - triggers usually handled in controller, as VIEW.on("MDL:SUBMDL:ACTION"), doing logic, e.g. calling MDL_EVENT
     - VIEW->CONTROLLER: this.trigger("EVENT") -> VIEW.on("EVENT")
  - modelEvents|collectionEvents
  - bindings.SELECTOR "VARR": Stickit maintaining MODEL.VARR <-> SELECTOR
     - must use this.stickit() at end of onRender()
     - if populated MODEL with bindings, must use MODELbindings instead of bindings then this.stickit(MODEL, MODELbindings)
  - behaviors.BEHAVIOR OBJ: merge with Flow.addBehavior("BEHAVIOR", MBEHAVIOR)

new MVIEW() OBJ.model|collection (unless simple one)

MBEHAVIOR:
  - "DisableInputZoom": all inputs on focus, disable zoom
  - "FeedbackButton": button that shows feedback while loading, after calling VIEW.triggerMethod("feedback:button:request", XHR)
  - "ActionButton": similar but legacy

BASEVIEW:
  - Flow.Views.ItemView|CollectionView|CompositeView: same as Marionette, with template helpers
  - Flow.Views.EmptyView: 
     - can use <%=text%> (from ..emptyViewText)
     - template is ..emptyViewTemplate (def: "<%=text%>")
     - adds ..emptyViewTagName|ClassName

MCOLLVIEW:
  - MCOLLVIEW..displayLimit NUM: max children rendered
  - ..childViewOptions -> ..extraChildViewOptions (gets OBJ.index NUM)
  - respect COLL order

																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         DO NOT FORGET         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


_FUNC                             #Private func

assetRoot()                       #Template helpers, link to /dist/

_t("STR"[, OBJ])                  
_tp("STR", "PLUR_STR", NUM[, OBJ])#Can contain {VAR}. Programatically, for several languages: use i18n.setLanguage() then restores

dataLabel|radio|input|select(): template helpers to do

Flow.isPrintMode()                #Should not use popup|popover|modal in print mode

Flow.$                            #Link to $
Flow.ajax.ajax                    #Link to $.ajax, but:
                                  #  - XHR.fail() calls module "error-handler", which shows flash notifications and redirects
                                  #     - except 404 when not logged in: shows full page error. 
                                  #       IS module "public:info" 404|410 (according to RESPONSE.revoked)
                                  #     - unless OBJ.ignoredStatusCodes NUM_ARR
                                  #     - OBJ.messageContainer JQ: where notification appears
                                  #  - extra HTTP headers flow-client-version: BUILD_NO
Flow.ajax.get|post|put[JSON]      #Same with OBJ.method|contentType set

REQUIREJS ==>                     #  - libs: defined in main.js, used anywhere
                                  #  - base_classes.js, main objects: see loading
                                  #  - modules:
                                  #     - PARENT_MDL.js <- MDL.js <- controller.js <- views  <- templates
                                  #                                                <- models
                                  #  - otherwise just what is being used


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          EXCEPTIONS           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


ExceptionReporting.reportException
(ERROR)                           #Forwards to Rollbar and show UI error
tryFunc(FUNC(...))                #Calls ExceptionReporting.reportException(ERROR) if exception
Flow.delay|defer(...)             #Calls tryFunc()
console.debug|etc.                #console.debug() + Rollbar
console._debug|etc.               #console.debug() only


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            LOADING            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


main.js: all libs (except need i18n)
flow.js: tools (error handling, browser, data_tools) + config + Flow
startup.js: libs (need i18n) + tools (others) + everything else (load only public modules if in public path)
module "index":
  - route "" -> "index:show"
  - MDL_EVENT:
     - "index:show"(OBJ) -> "agreements:dashboard:show"(Flow.settings.direction(), OBJ) 

LIBS: do validation, then stickit, then module "auth", then module "dashboard"


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            LAYOUT             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Flow: MAPPLICATION but acting as a MLAYOUTVIEW too (on "document"):
  - main "#main" (public): Flow.Layouts.Public, big box (e.g. login page), module "public"
     R- content "#content-area"
  - main "#main" (app): Flow.Layouts.ApplicationBase, main page:
     - flash "#flash-notification": module "flash_nofication"
     U- header "#header": use Flow MDL_EVENT "flow:header:show|hide"
       - top "#top-navigation": module "top" (top bar)
          - navigation "#main-navigation"
          - messages "#top-messages"
          - notifications "#top-notifications"
          - userMenu "#top-user-menu": top-right menu
     - loader "#app-loader": module "loaders"
     - app "#app-body": Flow.Layouts.Application:
        - body "#content-body"
        - sidebar "#sidebar" (using CONTROLLER._sidebarLayout()): Flow.Layouts.Sidebar
           - boxNUM
  - footer "#footer": bottom bar on agreement, for guests


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             TOOLS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


  - browser.*: check browser type, disable zoom (when focusing on input, for mobile), disable scroll (on popover|modals, for mobile)
  - dateTools.timeago|dateTime|customDate(): creates|update <abbr> with time info
  - Flow.storage: link to localStorage


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          VALIDATION           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Setting up:
  - MODEL:
     - validation.VARR RULE, with extra validators:
        - beLessThan|beGreaterThan "VARR2"
        - acceptance: can also use 1|"1"
        - pattern "recoveryHash|dateConfig|fullname"
        - email|fullname: true (same as pattern "email|fullname")
     - labels.VARR STR (def: VLD.labels): for {0} in MODEL.validation.VARR
     - serverValidation.VARR { url URL[(VAL, "VARR", MVIEW)], msg STR }
        - validates with URL with payload { VARR: VAL }
        - used for validating email so far
  - this.model.addValidation(Flow.Entities.Validation.Mixins.VARR RULE, this):
     - predefined validation { VARR RULE } and labels (added to MODEL.validation|labels)
     - called in MVIEW.initialize(), before bindValidation()
  - this.bindValidation([false]), in MITEMVIEW.initialize()). Like VLD.bind(this) but:
     - setup "destroy" handler (MITEMVIEW.unbindValidation())
     - on "render", unless false, for each VARR.required true: adds .required | * to .control-group > label.js-VARR-label

Calling:
  - when view updates model through Stickit (using MITEMVIEW.preValidate())
  - MITEMVIEW.validateAndSave([MODEL[, OBJ[, ATTR_OBJ]]]), calling in order:
     - preValidateModel([MODEL])->PROMISE (def: MITEMVIEW.model)
        - does MODEL.preValidate() (providing there are Stickit bindings) + pending serverValidation
     - MODEL.save(ATTR_OBJ, OBJ)
     - handleXHRResponse(XHR)->PROMISE: 
        - if success, resolve with MODEL, XHR_RESP
        - otherwise, rejected with XHR_RESP and calls MODEL.displayFieldsErrors(XHR_RESP)
     - displayFieldsErrors(XHR_RESP): calls VLD.invalid|valid() according to XHR_RESP:
        - fields_errors.VARR "|missing"
        - conflict "VARR[|...]", using MODEL.serverValidation.VARR.msg

Effect:
  - Backbone.validation invalid|valid():
     .control-group -> .error
       .controls
         any(name="VARR", data-error-style="tooltip", data-tooltip-position="left|...|right(def)") // Shows as tooltip
         any(name="VARR", data-error-style="inline") // Create|find sibling .help-inline.error-message | ERROR
         any(name="VARR")                            //Same with .help-block.error-message.hide, and fades in



																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          MODELS BASE          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/



Setting up MODELs:
  - MDL "Entities"
  - events -> [attributes]events[Once]."[ATTR] EVENT ..." "FUNC" (for COLL too)
  - handlers.js: 
     - view->model interaction beyond normal REST routes, using same as MDL_EVENT (Flow.reqres). 
     - Usually a PROMISE returned by doRequest(XHR, FUNC(RESP, STATUS, XHR_RESP)->VAL, FUNC2(RESP, STATUS, ERROR)->VAL2)->PROMISE, wrap PROMISE so it resolves
       with VAL, XHR_RESP, and rejected with XHR_RESP, VAL2
  - extends from:
     - Entities.SimpleModel or Entities.RelationalModel (if needs relations)
     - Entities.Collection
  - Entities.SUBMDL.CONSTANT

Backbone.relational:
  - ID:
     - MODEL._id is client-side only, until real MODEL.id is set
     - getIdObj()->ID
  - new MODEL_CTOR(...) -> MODEL_CTOR.findOrCreate(...)
  - relations.includeInJSON false|"id" for back references to parent (otherwise too big)

Server interaction:
  - URL:
     - MODEL.urlRoot + COLL.url Flow.config.api.* (COLL URL)
     - All can use "<VAR>" then must use STR.replace("<VAR>", MODEL.get(...)->"ID")
  - mostly fetch() at init the root model (server returns populated), then only use save()
  - fetch|patch|save(): proxied through Flow.ajax.ajax(), so can OBJ.messageContainer|ignoredStatusCodes
  - patch(LFUNC[, OBJ]): like save(OBJ) with OBJ.patch true, using LFUNC

Timestamps:
  - MODEL.lastChanged(): MODEL.get("updated|created")
  - MODEL.updated|created|removed[_ts]: set by server

Helpers:
  - MODEL.empty("VAR"): like has("VAR") but also trims
  - createRestorePoint|restore(): MODEL.set()|COLL.reset() with MODEL|COLL.toJSON() (for cancel buttons)
  - debounceFetch(NUM[, OBJ]): like fetch(OBJ) but with debounce
  - EntityHandlers.getModel(MODEL, OBJ): like fetch(OBJ), but returns as PROMISE resolved with MODEL, RESP or rejected with RESP

Stickit:
  - bindings selectors:
     - any(data-editable="true"): updates with html() on change|input|cut|paste
     - redactor-editor: updates with html()
     - input(type="number"): NUM in model
     - input(type="checkbox|radio", [data-off-]value="YES|NO")
     - abbr(data-type="timeago-date|textdays-date|moment-date"): with a DATE in model
     - a(data-type="href"): updates href
     - special handling for Select2, Typeahead
  - CONF.getFormat[(VAL, CONF)] (MODEL->VIEW): 
     - "ssn|orgnr": "-"
     - "days|months": "NUM days|months"
     - "country": country code -> name
  - CONF.setFormat "float|int|string"


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            MODELS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


  - attribute
  | method
 || collection method
  x handler
  + comment
  _ set by server

NAV_ITEM (COLL: NAVIGATION) (only local):
  - label STR
  - path STR
  - event OBJ
  - visible BOOL
  - disabled BOOL

SETTINGS:
  - Flow.settings
  + must initiate with Settings.create(PARENT[, ATTR_OBJ]) (ATTR_OBJ.type automatically set)
  - type account|position|guest
  | isAccount|Position()
  - parent ACCOUNT|POSITION

PERMISSIONSET (only local):
  + in initialize(), this.permissions = new PERMISSIONSET({}, OBJ), with OBJ:
     - parent: current MODEL. Sets same attributes as MODEL.getPermissions([POSITION])->OBJ
     - resetEvents "EVENT ...": reinit on MODEL EVENT
     - resetTriggerMap { events: "EVENT ....", attr "VAR" }
  | allow("ACTION")->PERMISSIONSET.allow-ACTION
  | onlyVisible("ACTION")->PERMISSIONSET.visible-ACTION
  | visible("ACTION")->PERMISSIONSET.visible|allow-ACTION

CHART (/graph/POSITION/CHART_TYPE, but only local):
  + fetch() gets stub data
  - position_id
  - chart "won_account|won_compare|published_compare|hit_ratio|hit_ratio_compare|sales_cycle|sales_cycle_compare|sales_pipe|top_sellers|churn"
  - series NUM_ARR_ARR
  | getSeries(NUM)
  - categories STR_ARR
  | getCategories[Months](): with "Months", sets as "MMM [-YY]"
  - labels STR_ARR
  | getLabels(NUM)

USER: /users
  + Flow.user
  | isGhost(): Flow.user.ghost
  - positions POSITION_ARR
  | hasPosition(POSITION)
  - current_position POSITION_ID
  | getCurrentPosition()->POSITION
  | getCurrentAccount()->ACCOUNT
  | isMe(POSITION|PARTICIPANT)
  - isGuest|User(), isGuest(VAL): getter/setter
  - getAccessToken(), setAccessToken(VAL)
  - settings SETTINGS_POSITION /positions/POSITION/settings
     + Flow.settings
     + If type guest:
        + must initialize with OBJ.participant if type guest
        + /agreements/AGREEMENT/participants/PARTICIPANT/settings
     - user USER
     - position-agreement-direction "outbound|inbound|both"
     | direction()->STR: "both" is returned as "outbound"
     | directionOutbound|InBound(BOOL): if true, rejects "both"
     | directionBoth()
     + when changed, fires "settings-change:agreements:direction
  - fullname STR [V]
  + sets Flow.position.fullname on save|patch()
  - email STR [V]: also serverValidation /users/validate_invite_email
  - state new|invited|guest|registered
  | isStateNew|Invited|Guest|Registered()
  x "user:signup"(OBJ): /users/signup, with OBJ: company_*, private_token STR, fullname, password, language, persistent, mixpanel_id

COMPANY: /directory/companies/
  - name [V]
  - orgnr [V]
  - country [V]

ACCOUNT: /accounts
  - Flow.account
  - structure ACCOUNT_STRUCTURE_ARR: /accounts/ACCOUNT/structure/ (POSITION groups)
     - parent ACCOUNT_STRUCTURE
     - name STR
     | isRoot()
     - positions POSITION_ARR
     x "account:structure:get"(ACCOUNT): /accounts/ACCOUNT/structure/, then sets ACCOUNT
  | getManager|EmployeeGroup()->ACCOUNT_STRUCTURE_ARR: according to isRoot()
  - owner POSITION: see promote|demote()
  - positions POSITION_ARR /positions/
     + Flow.position
     | isMe()
     - account ACCOUNT
     - group ACCOUNT_STRUCTURE
     - shareAccountWith(POSITION)->BOOL
     - fullname STR [V]: used as comparator
     + When save|fetch(), updates Flow.user.fullname
     - email STR [V]
     - phone_number STR
     - title STR
     - is_manager BOOL
     | isAccountManager()
     | canViewColleagueContracts(): isAccountManager() or Flow.settings "account-permissions-employee-colleague-contracts"
     | canEditTemplates(): isAccountManager() or Flow.settings "account-permissions-employee-edit-templates"
     - claimed BOOL: create account and filled a password
     | isClaimed()
     - active BOOL
     | isActive()
     - promote|demote()->POSITION (as PROMISE): if isAccountManager(), change owner with /accounts/ACCOUNT/positions/POSITION/promote|demote
  - template_id ID
  - agreement_templates TEMPLATE_ARR: /accounts/ACCOUNT/templates/
     + COLL constructor must use OBJ.account_id
     - account ACCOUNT
     - agreement AGREEMENT
    || getByAgreement(AGREEMENT): non-subcollection COLL
     - owner POSITION
     - name STR [V]: uses as comparator
     - visible 1|0
     | isVisible()
    || visible(): subcollection, using default as comparator
     - default 1|0
     | isDefault()
     | makeDefault(): set default 1, set other TEMPLATE as 0
     - is_new BOOL
     | isNewTemplate()
     + when save|patch() fails, fetch() the whole COLL
  - company_name [V]
  - company_orgnr [V]
  - company_country [V]
  - brand_log[_dimensions] STR
  | getLogoURL([true])->/ID/logo.png (if true, adds cache busting query variable)
  x "account:get:one"(ID)->ACCOUNT (as PROMISE): fetch() if not available yet
  x "account:position:create"(ACCOUNT, USER): 
     - creates and returns a POSITION after inviting a USER
     - adds to ACCOUNT_STRUCTURE.positions
     - /accounts/ACCOUNT/invites/ with USER as data
  x "account:invitation:resend"(ACCOUNT, POSITION): /accounts/ACCOUNT/invites/POSITION/resend, then returns POSITION
  x "account:invitation:revoke"(ACCOUNT, POSITION): DESTROY /accounts/ACCOUNT/invites/

SETTINGS_ACCOUNT (SETTINGS child): /accounts/ACCOUNT/settings
  + does fetch() when Flow.settings.fetch()
  - account-agreement-expire_date NUM
  - account-brand-logo[-dimensions] STR
  + sets ACCOUNT.brand-logo[-dimensions] when changed, and inverse
  + others shown below

AGREEMENT: /agreements/AGREEMENT
  - state: draft|pending|signinprogress|signed|declined|expired|template
  | isDraft|Pending|SigninInProgress(true)|Signed|Declined|Expired|Template()
  | isSigninInProgress(): signinprogress|signed
  | isClosed|Open(): [not] signed|declined
  _ state_timestamp[_ts] "ISO"|TIMESTAMP
  - lifecycle awaiting|active|ended
  | isAwaiting|Active|Ended()
  _ lifecycle_timestamp
  - agreement_type b2b(def)|b2c|b2a
  | isB2B|B2C()
  - type one_time|one_time_w_duration|recurring|recurring_w_initial|not_set:
     + one_time: nothing
     + one_time_w_duration: duration
     + recurring[_w_initial]: duration + notice_period. notice_period (max 3) < duration. Can be canceled during notice_period. Use period_*
     + all: optional start_date
     + all but one_time: optional end_date
  | isOneOff[Duration]|Recurring[WithInitial]|NotSet()
  | setType(VAL): if type recurring
  - duration NUM [V]: in months
  - notice_period NUM [V]: in months
  - start_date|end_date "ISO"
  - start_timestamp "ISO"
  | toggleStartDate(): from null to now
  | toggleEndDate(): from null to now + duration
  - expire_date "YYYY-MM-DD"
  | getExpireTime()
  | hasExpireDatePassed(): now one day after expire_date
  - period_start|end_timestamp "ISO"
  _ period_count NUM
  | inNoticePeriod(): state signed, type recurring[_w_initial], now is after ( period_end_timestamp - notice_period )
  - _is_international BOOL: true when different (B2B) AGREEMENT_COMPANY.company_country or (B2C) PARTICIPANT.consumer_country (among sellers with state enabled)
  | isInternational() 
  - cancel_timestamp "ISO"
  | isCanceled()
  _ terminate_timestamp "ISO"
  | isTerminated(): canceled or lifecycle ended
  _ publish_timestamp[_ts] "ISO"|TIMESTAMP
  | publish(STR, STR2): calls /agreements/AGREEMENT/publish with data { subject STR, message STR2 }, which changes state draft->pending and sends emails
    Triggers "publish"
  | cancel(): calls /agreements/AGREEMENT/cancel_recurring which sets state expired if type recurring and in notice_period
    Triggers "cancel"
  - parent AGREEMENT: only the id because no relation setup
  | isCopy()
  - checksum STR
  - language "LANG"
  + triggers "counterparts:change" on many changes on AGREEMENT_COMPANY|PARTICIPANT: added|removed, enabled|disabled, sign|decline, change type|orgnr
  x "agreements:request"(OBJ): /agreements/request with data OBJ: subject, message, email, save (buyer request of an agreement)
  x "agreements:position:get:email"(AGREEMENT, EMAIL, 1|0): /agreements/AGREEMENT/participants/lookup_emails with data { email EMAIL, consumer 1|0 }
    Returns matching POSITION_COLL
  - companies AGREEMENT_COMPANY_ARR /agreements/AGREEMENT/companies/
     - agreement AGREEMENT
     | getEnabledDecisionMakers|Influencers(): AGREEMENT.participants subcollection with state enabled and type decisionmaker|influencer
     - owner POSITION
     | isOwner(POSITION[, BOOL]): if true, also if same AGREEMENT_COMPANY as owner
     | isUs(): current PARTICIPANT belongs to AGREEMENT_COMPANY
     - state enabled|disabled
     | isEnabled|Disabled()
     | enable|disable(): does patch()
     - company_name [V]
     - company_orgnr [V]
     - company_country [V]
     + updates Flow.company.company_* on save|patch()
     - consumer 0|1: seller|buyer
     | isConsumer()
     | hasInfoMatching(COMPANY|ACCOUNT): same company_*
  - owner POSITION
  | isOwner([POSITION[, BOOL]]): same POSITION or (if true) same AGREEMENT_COMPANY
  - requester POSITION
  | isRequester(POSITION)
  - participants PARTICIPANT_ARR /agreements/AGREEMENT/participants/
     - id: sort subcollections
     - agreement AGREEMENT
    || enabledNoneOwners(): subcollection on AGREEMENT.owner === PARTICIPANT.position
     - state enabled|signed|declined|disabled[_by_company]
     | isPending|Signed|Declined|hasDecided|Disabled|Enabled()
     | enable|disable([OBJ]): does a patch([OBJ])
     | sign|decline([OBJ]): does with /agreements/AGREEMENT/participants/PARTICIPANT/sign|decline with data { checksum AGREEMENT.checksum }
     | Then updates prev_visit[_ts]
    || enabled|getEnabled|disabled(): subcollection
    || enabledArray(): same as non-subcollection COLL
     + When state becomes enabled, triggers "sign:reset" on PARTICIPANT and AGREEMENT, providing PARTICIPANT isMe()
       and there has been an EVENT with reset true and created_ts < PARTICIPANT.last_visit_ts
     - visibility hidden[_with_notifications]|visible
     | hasVisibility(VAL): always true if state disabled*
     | setVisibility(VAL): does a patch()
     + "change:visibility" forwarded to AGREEMENT
     - type influencer|decisionmaker(def) [V]
     | isDecisionMaker|Influencer()
     | delegate BOOL: if true, type decisionmaker
     + triggers "participant:change:type" on AGREEMENT and "agreement:participant:change:type" on Flow
    || [get]enabledDecisionMakers|Influencers(AGREEMENT_COMPANY): subcollection on same AGREEMENT_COMPANY, state enabled and given type
     - email_status failure|bounce|suppressed|success|ooto|complaint(spam)
     _ email_timestamp "ISO"
     | hasEmailFail|Bounce|Success(): failure, bounce|suppressed, success|ooto|complaint
     - position POSITION
     | isMe()
     | sharesAccountWith(POSITION): same ACCOUNT
    || [get]enabledOthers(): subcollection on state enabled, and isMe()
    || getPublishEmailRecipients(): same but also excludes PARTICIPANT from hardcoded CONFIG.agreements.delegate_accounts
     - owner POSITION
     | isOwner([POSITION[, BOOL]]): same POSITION or (if true) same AGREEMENT_COMPANY
     - agreement_company AGREEMENT_COMPANY
     | sharesCompanyWith(POSITION)
    || getByCompany(AGREEMENT_COMPANY): subcollection on same AGREEMENT_COMPANY
    || enabledByCompanyArray(AGREEMENT_COMPANY): non-subcollection COLL on same AGREEMENT_COMPANY, and state enabled
     | isConsumer(): AGREEMENT_COMPANY.isConsumer()
    || disabledConsumers(): subcollection on buyers with state disabled
     - visits NUM: to this agreement
     - first|prev|last_visit[_ts] "ISO"|TIMESTAMP: to this agreement
     - fullname [V]
     + Updates Flow.user.fullname when save|patch(), unless isGuest() or !.isMe()
     - email [V]
     - phone_number STR
     - title STR
     - consumer_country STR
     | hasInfoMatching(USER|POSITION): same fullname and title
     + Sets POSITION.phone_number|title when save|patch(), unless isGuest() or !.isMe()
     - prev_visit[_ts] "ISO"|TIMESTAMP
     - last_visit_ts TIMESTAMP
     | getInviteDate(): returns min of created or AGREEMENT.publish_timestamp
     | contactMeOneflow(): calls /agreements/AGREEMENT/participants/PARTICIPANT/contact_me
     | getSignupToken(): calls /agreements/AGREEMENT/participants/PARTICIPANT/contact_me
     + permissions:
        + reset on change:state|type, sign|decline, AGREEMENT.permissions:reset, AGREEMENT.participant:sign
        + only for AGREEMENT|AGREEMENT_COMPANY|POSITION.owner and for AGREEMENT PARTICIPANT (or same COMPANY)
        + allow-edit true
        (not AGREEMENT.owner, or same AGREEMENT_COMPANY)
        + allow-remove|restore: state [not] disabled*
  | get[My]Participant([POSITION[, BOOL]])->PARTICIPANT: with same position (def: Flow.position)
    If false (def), must be state enabled.
  | isParticipant([POSITION])
  | hasSigned|Declined|isConcluded(): Flow.position.state signed|declined (or both)
  | hasVisibility(VAL): current PARTICIPANT has state disabled* or visiblity VAL
  | isVisible|Hidden(): same for visibility visible
  | hide|unhide(): sets current PARTICIPANT visibility hidden_with_notifications|visible
  - discard(): calls destroy()
  | hideOrDiscard(): if state:
     - template|draft|pending|expired: calls destroy(), if isOwner() and is seller
     - signinprogress|signed|expired: calls hide(), unless isGuest()
  | hasCounterparts(): min 2 PARTICIPANT with state enabled and type decisionmaker
  | hasEnabledDecisionMakers([POSITION]): at least one PARTICIPANT with type decisionmaker, state enabled and same AGREEMENT_COMPANY
  | hasEveryoneSigned(): all PARTICIPANT with type decisionmaker have state signed|disabled
  | getCounterpartAccounts()->{ ACCOUNT_ID: { account ACCOUNT, participant PARTICIPANT_ARR } }, except Flow.position ACCOUNT
  - box_order BOX_ID_ARR: used as BOX_COLL comparator
  | enable|disableComments(): change state of BOX of type comments
  + trigger "boxes:change" when add|remove boxes, or change BOX.state
  - boxes BOX_ARR: /agreements/AGREEMENT/boxes/
     - agreement AGREEMENT
     - state: enabled|draft(def)|disabled
     | isEnabled|Draft|Disabled()
     | enable|draft|disable(): does patch().
     + on change, fires "comments:enable|disable" (if isComments()) and "box:enable|disable"
     + save() can use OBJ.enableIfApplicable true, which sets state enabled (unless draft|template or isEmpty())
    || enabled(BOOL): subcollection on state enabled (or draft if true) and not type comments|history
    || disabled|removedBoxes(BOOL): subcollection on state disabled [and not type comments|history]
    || hasAny(BOX_STATE)
    || hasDraft()
     - type comments|duration|document|attachments|history|text|form|products: used for subModelTypes
     | isComments|Duration|Document|Attachments|History|Text|Form|Products()
    || has[Enabled](BOX_TYPE): returns non-subcollection COLL, or false
     - isManagerLocked(), toggleManagerLock(): is set on Flow.config (so global lock)
     - getContent(KEY)->VALUE:
        - according to contentRelations OBJ3_ARR:
           - key KEY
           - VALUE is either:
              - OBJ3.relationCallback(OBJ3)->VALUE
              - OBJ3.collectionType "COLL":
                  - if new: new COLL(), with COLL.box BOX. Also:
                     - OBJ3.comparator used as comparator
                     - OBJ3.initCollection(COLL) called when done
                  - otherwise retrieve current value (BOX.content)
        - stored locally in BOX._content VALUE, on the server as BOX.content.KEY VALUE.toJSON() (or OBJ3.toJSON)
     + permissions:
        (if:
          1) is PARTICIPANT and not AGREEMENT type declined|signed|signinprogress
          2) not AGREEMENT type template (except allow-disable)
          3) if AGREEMENT type pending|expired, AGREEMENT_COMPANY enabled and with a company_orgnr
          4) not isManagerLocked() (unless PARTICIPANT.is_manager))
          5) is AGREEMENT.owner
        + allow-update[-shared]: -shared only needs condition 1)
        + allow-set-read-only: PARTICIPANT.is_manager
        + allow-disable: type draft or state enable
        (if type draft and not AGREEMENT type draft|template)
        + visible-publish
        + allow-publish: unless isEmpty()
     (overriden by boxes)
     - isEmpty()->BOOL: to show as draft, and not allow saving
     - viewHandler "MDL_EVENT": see below
     - contentRelations OBJ3_ARR
     (duration box)
     + KEY is "agreement", VALUE is AGREEMENT, VALUE.toJSON() only keep AGREEMENT.type|duration|notice_period|start_date|end_date
     - isEmpty(): AGREEMENT type notset
     (comment box): not used
     (document box):
     + KEY is "documents", VALUE is AGREEMENT_DOCUMENT_CONTENT_COLL
     - isEmpty(): AGREEMENT_DOCUMENT_ARR not empty or containing only _removed
     + on save(), changes state draft -> enabled, or enabled -> disabled
     (attachments box)
     + KEY is "documents", VALUE is AGREEMENT_DOCUMENT_CONTENT_COLL
     - config:
        - order AGREEMENT_DOCUMENT_ID_ARR: used as comparator. BOX.toJSON() fills default (only not _removed ones)
        - counterpart_edit true: never isEmpty()
     | moveFile(AGREEMENT_DOCUMENT, AGREEMENT_DOCUMENT2): to change config.order
     | toggleCounterpartEdit()
     - isEmpty(): like document box
     + save(): changes state draft -> enabled
     + permission allow-add-attachment: same as permission "allow-update" or (if config.counterpart_edit true) "allow-update-shared"
     (text box)
     + KEY is "data", VALUE is DATA_COLL, but use only DATA_COLL[0] (with subtype "text"), initially setup with value ""
     - isEmpty(): DATA_COLL[0].value not empty
     (products box)
     + KEY is "data", VALUE is DATA_CONTENT_COLL (with subtype "product"), DATA is { price_1|2 NUM, count NUM}
     - config:
        - order BOX_ID_ARR: like attachments box
        - hide_sum BOOL (def: false)
        - columns OBJ_ARR: enabled BOOL, key STR
     | isSumHidden()
     | hideSum|showSum(): also triggers "sum:show|hide"
     | moveProduct(...): like moveFile(...) for attachments box
     | isColHidden(STR)->BOOL: config.columns with key STR is enabled
     - isEmpty(): like attachments box
     - addEmptyProduct(): append empty DATA and returns it
     - getTotalPrice1|2()->NUM: sum all price_1|2 x count
     (form box)
     + KEY is "data", VALUE DATA_CONTENT_COLL (with subtype "form_input")
     - config:
        - colCount NUM (def: 2)
        - order DATA_ID|null_ARR_ARR (def: each DATA.id)
     + MATRIX.toJSON() returns config OBJ
     - isEmpty(): VALUE.length > 0
     + validateAndSave() also validates individual DATA
     - getFieldMatrix()->MATRIX: create singleton:
        - form FORM_BOX
        | getFormId()
        - colCount NUM: from FORM_BOX.config.colCount
        | setColCount(NUM): if more, will add new default CELL.
        - rows ROW_ARR:
           - matrix MATRIX
           - r NUM: VERT_NUM, used as comparator between rows (def: index)
           - cells CELL_ARR:
              - row ROW
              - item DATA: instantiated from FORM_BOX.config.order
                 - value:
                    - colspan NUM: when changed|set, changes CELL.colspan too
              - pos [ HORZ_NUM, VERT_NUM ] (def: indexes): VERT_NUM is same as ROW.r
              | isSpace()
              - hidden BOOL: when colspan > 1, first is not hidden, next are
              | isHidden()
              - colspan NUM
              | setColSpan(NUM)
              | getAllowedColspacing()->BOOL_ARR: true,... until one cell not isSpace(), then false,...
        | getCell(DATA)->CELL_ARR
        | addEmptyRow()
        | removeRow(ROW)
        | moveRow(ROW, VERT_NUM)
        | addField([ HORZ_NUM, VERT_NUM ])
        | removeField(CELL)
        | moveField(2 [ HORZ_NUM, VERT_NUM ])
        | moveAllowed(2 [ HORZ_NUM, VERT_NUM ])->BOOL
        + "change:matrix" triggered when anything changes
  - documents AGREEMENT_DOCUMENT_ARR: /agreements/AGREEMENT/documents/
     - agreement AGREEMENT
     - owner POSITION
     | isOwner(POSITION[, BOOL]): if true, also if same AGREEMENT_COMPANY as owner
     - state disabled|draft|enabled|receipt
     _ state_timestamp[_ts] "ISO"|TIMESTAMP
     _ success BOOL
     | isDisabled|Draft|Enabled|Receipt()
    || receipt(): non-subcollection COLL
    || [get]enabled(): subcollection on state enabled or (if isOwner()) draft
     | enable|disable()
     - name STR [V]
     - pages NUM
     - page_dimensions "ARR_ARR": WIDTH|HEIGHT for each page
     _ mimetype STR
     - file_extension STR
     | isPDF()
     - has_file BOOL
     | generateDownloadURL()->"/agreements/AGREEMENT/documents/DOCUMENT/download[?at=TOKEN]"
     - setPages()->AGREEMENT_DOCUMENT_PAGE_COLL (according to pages|page_dimensions, redone when changed):
        - agreement AGREEMENT
        - document AGREEMENTDOCUMENT
        - page NUM
        - width|height NUM
        - failed BOOL: if page_dimensions missing
        - generatePageURL(): "/agreements/AGREEMENT/documents/DOCUMENT/pages/PAGE.jpg[?at=TOKEN]"
     + There are two COLL AgreementDocumentCollection and AgreementDocumentContentCollection like DATA with _removed, remove(), active()
     + AgreementDocument.createFromJSON(AGREEMENT_DOCUMENT): to use instead of new(AGREEMENT_DOCUMENT)
     + permissions:
        (state template|declined|signed|signinprogress and (unless state template) AGREEMENT_DOCUMENT.owner === AGREEMENT.owner === current POSITION)
        + allow-replace
        (state enabled|draft)
        + allow-update
        + allow-disable
        (state disabled)
        + allow-enable
  - data DATA_ARR (no URL):
     - agreement AGREEMENT
     - key "form_input|product|text" (subtypes) [V]
     - value DATA_VALUE_FORM_INPUT|PRODUCT|STR
        - _id: removed from toJSON()
        - _data DATA
        (form_input)
        - type "field|text" or "" (same as "field")
        | isField|isText()
        - size 0-5
        | getSize()->OBJ: className "input-20-100", label: "20-100%"
        - label STR [V]
        - value STR [V]
        - required 0|1: only if !AGREEMENT.isOwner()
        - placeholder STR [V]
        - description STR [V]
        (product)
        - count NUM
        - count_type single|multiple (def: multiple) [V]
        - name STR
        - description STR
        - price_1|2 NUM
     + validateAndSave() also validates value
     (product)
     + all EVENT from value are forwarded as "related:value:EVENT" to DATA
     - count_type single|multiple
     | isTypeSingle|Multiple()
     + There are two COLL AgreementDataCollection and AgreementDataContentCollection with the following:
     - _removed 0|1
    || remove() overwritten so it doesn't really remove but sets _removed, unless OBJ.modelRemove true or MODEL._id not set
    || active(): subcollection on _removed
  - messages MESSAGE_ARR (email message): /agreements/AGREEMENT/messages
     - id: comparator (id null is min)
     - agreement AGREEMENT
     - owner POSITION
     | isOwner([POSITION]) (def: Flow.position)
     - type message|invite|reminder|contactme|request
     | isMessage|Invite|Reminder|ContactMe()
     - body STR [V]
     - justPosted BOOL
     | wasAddedSincePrevVisit([PARTICIPANT]): PARTICIPANT.prev_visit (or first visit) < created, and not justPosted + isOwner()
       If no PARTICIPANT, gets prev_visit from localStorage
    || visible|hidden([PARTICIPANT]): returns non-subcollection COLL2 with first|last NUM items, where NUM is min between 3 and number of wasAddedSincePrevVisit(PARTICIPANT)
       COLL2 is in sync with parent COLL add|remove|reset events
  + reset on AGREEMENT.fetch()
  - texts TEXT_ARR (only local, not used anymore)
  - events EVENT_ARR: /agreements/AGREEMENT/events/
     - agreement AGREEMENT
     - type "many_possibilities"
     - state invisible|public|private
     | isPublic|Private()
     - publisher POSITION
     - parent EVENT
     | isParent|Child()
     | getParents(): subcollection on isParent()
     | getChildEvents(EVENT): non-subcollection COLL
     - reset BOOL
     | isParticipantReset()
     - created_ts TIMESTAMP: used as sort comparator for the SUBCOLLs
     - isNewUpdate()->BOOL: compare "created" with last visit time (current PARTICIPANT.prev_visit, or if not PARTICIPANT localStorage item)
     | updates(): subcollection on isNewUpdate()+isParent()
     _ refs OBJ: event data
  - setFilter(FILTER): make fetch() use OBJ.data FILTER.fetchQueryArray(), which returns FILTER, without [_]name|_cols or null|"" values
    FILTER[_DRAFT|OPEN|CLOSED] (only local) are search criteria:
      - name|_name "all|draft|open|closed"
      | asRoutePart()->"/f/_NAME"
      + Single instances at AgreementFilter.PRESET_FILTERS.all|draft|open|closed
      - direction Flow.OUTBOUND(def)|INBOUND|BOTH: translated as outbound 0|1 by fetchQueryArray()
      - page NUM (def: 1)
      - offset NUM (def: 0)
      - limit NUM (def: 10, saved on localStorage)
      - sort "VAR asc|desc"
      - state VAL[_ARR]: null (FILTER), draft (DRAFT), pending,expired (OPEN), signed|declined (CLOSED)
      - _cols STR_ARR: among:
         - state
         - created: not DRAFT
         - magicDate: only OPEN|CLOSED
         - stateDate: for no default FILTER
         - ourSide
         - counterparts
         - documents: not if INBOUND. For no default FILTER
         - insight: not if INBOUND. Only OPEN
         - lc: for no default FILTER
         - ending: only CLOSED
      + AgreementsFilter.COLUMNS.STR: name of _cols (e.g. COLUMNS.magicDate)
  + permissions:
     (all must be AGREEMENT PARTICIPANT, except state template)
       + visible-post-message
     (draft)
       + visible-publish: is AGREEMENT.owner
     (draft|pending|expired)
       + visible-delegate: decisionmaker and not signed|declined, seller
     (template|draft|pending|expired)
       + visible-sign: (unless template) decisionmaker and not signed|declined
       + allow-edit-layout, allow-update[-shared]: isOwner()
       + allow-discard: isOwner(), seller
     (pending|expired)
       + allow-publish: is AGREEMENT.owner, there are enabled decisionmakers with same AGREEMENT_COMPANY, not beyond expire_date, there is company_orgnr, no box with type draft, 
         not guest (unless no company_name or PARTICIPANT fullname)
     (pending|expired|signinprogress|signed|expired)
       + allow-post-message
       + allow-add-participants: seller
     (signinprogress|signed|expired)
       + allow-sign: decisionmaker, not beyond expire_date, there are enabled decisionmakers with same AGREEMENT_COMPANY, one AGREEMENT_COMPANY with state enabled and company_orgnr, 
         min 2 PARTICIPANT with state enabled and type decisionmaker, if isOwner() no box with type draft, POSITION not already signed|declined
       + allow-decline: same except: seller, isOwner(), ok if draft box
       + allow-delegate: same except: seller, POSITION not signed|declined
       + allow-cancel: decisionmaker and not lifecycle ended, type recurring
       + allow-hide: not guest
 

																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            MODULES            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/

Module "dashboard":
  - MDL_EVENT:
     - "dashboard:performance:show"(REGION, DIRECTION)
     - "dashboard:agreements:show"(REGION, DIRECTION)
        - REGION: 
           - widget1|2|3|41|2: the 8 charts (shows first four), each being a REGION:
              - content ".js-widget-content-container"
                 - CompositeView
              - footer ".js-widget-footer-container"

Search: (searching through agreements, right panel)
  - routes: "contracts/[seller|buyer/]FILTER._name" and MDL_EVENT "agreements:search:show"(OBJ):
  - SearchView (composite):
     - collection AGREEMENT_COLL with setFilter(FILTER), so fetch() with FILTER_OBJ at init and when FILTER changes
       Uses SearchAgreementView:
        - <tr><td> with content depending on FILTER._name|_cols. Columns:
           - state: AGREEMENT.state. if draft, "Request|Draft" according to isRequester()
           - created (not draft): AGREEMENT.created
           - magicDate (open|closed): AGREEMENT.expire_date (if pending|expired) or AGREEMENT.state_timestamp
           - ourSide|counterparts: AGREEMENT.participants|companies|agreement_type
           - lc: AGREEMENT.lifecycle|cancel_timestamp
           - insight (open, seller): AGREEMENT.participants|companies, PARTICIPANT.*visit*|email_status
           - documents (seller): AGREEMENT.documents
           - ending (closed): AGREEMENT.state|lifecycle|cancel_timestamp|type|start_timestamp|period_end_timestamp|terminate_timestamp
        - on click -> "agreements:agreement:show:ID" (unless draft and is the requester)
        ! re-render on AGREEMENT[.visibility] change
        - hidden according to AGREEMENT.visibility (changed with UI)
     - model FILTER:
        - Programatically: OBJ.filter|direction
        - user-changed URL: cached one according to FILTER._name (or new empty one)
        - 6 inputs on top are bound to FILTER.state|from_date|to_date|company_name|participant_name|limit
        - FILTER.page|offset|limit according to pagination (using jQuery Bootstrap pagination)

Dashboard:
  - routes + MDL_EVENT:
     - "contracts[/seller|buyer]", "agreements:dashboard:show"(DIRECTION, OBJ), which does:
        - "agreements:list-view:current:set"("Highlights")
        - "dashboard:agreements:show"(main.app.body, DIRECTION)
        - "agreements:navigation:show"(sidebar.box1, DIRECTION)
        - "navigation:active:set"("dashboard")
     - "contracts/performance": to do??? (forwards to module "dashboard")

Auth:
  - MDL_EVENT:
     - "auth:login"(OBJ): 
        - on login screen
        - sends REST API /api/users/login with:
           - data.email|password|persistent (form)
           - messageContainer|error() + ignoredStatusCodes 401: to show error in UI
       Cookie flow-user-hash STR, and redirects to "/app" (triggering "auth:autologin" then)
     - "auth:autologin"(OBJ): 
        - at startup.
        - uses Flow.startupData, filled from a <script> served by server based on flow-user-hash cookie. OBJ:
           - auth_user_id STR, users OBJ_ARR, positions OBJ_ARR
        - sets Flow.user|account|position|settings
        - pings to /api/ping every minute, which returns 401 if not logged in, and redirects to login page
        - if isGhost(), i.e. when USER.ghost true (setup by backend according to HTTP headers Ghost*):
           - append "GHOSTING" view to <body>
           - no pings
           - cannot subscribe to Pusher private-*|presence-* channels
     - "auth:logout"(OBJ): 
        - when clicking logout button
        - calls /api/users/logout, which unsets cookie flow-user-hash, then redirects to "/"
     - "auth:token-user:init"(VAL)
        - on /contracts/ID/at/VAL or MDL_EVENT "agreements:agreement:show:token"(ID, VAL)
        - sets Flow-Access-Token: VAL [C], and put in guest mode
     - "auth:token-user:set"(USER, POSITION, BOOL)

Public:
  - login:
     - route "login": MDL_EVENT "login:show"
     - MDL_EVENT: "login:show"
  - recover-account:
     - routes:
        - "recover-account"
        - "recover-account/HASH"
     - MDL_EVENT: "recovery:enter-email:show"
  - signup:
      - routes:
         - "signup/HASH"
      - MDL_EVENT: 
         - "signup:success"
         - "signup:invalid-hash"

Learn (videos):
  - route "learn/videos" or MDL_EVENT "learn:videos:show"()

Loaders:
  - no MDL_EVENT
  - loading spinner (covers whole screen) at Flow.main.currentView.loader:
     - fades at app:started
     - appears at requests:start|finished (i.e. on AJAX requests), with DELAY 1sec, MIN_SHOW 0.8sec, MAX_SHOW 20s

Help (popovers):
  - MDL_EVENT:
     - "help:popover|inline:show"("NAME", "HTML_TPL", PARENT_VIEW, JQ, OBJ)
         - OBJ:
            - dismissForever: if true, will not show anymore (localStorage)
            - buttonText STR
            (inline)
            - append BOOL (def: false): append|prepend
            - viewOptions OBJ
            (popover)
            - placement (def: "top")
            - container
            - show BOOL: show now
     - "help:popover|inline:dismiss"("NAME", JQ)

flash_nofication (notification on top, small):
  - MDL_EVENT:
     - "flash:show[:next]"(OBJ) with OBJ: messageContainer JQ, header|text STR, type "error|warning|info|success", timeout NUM
     - "flash:hide"(OBJ)

app-alert (notification on top, large):
  - MDL_EVENT "app-alert:show"(STR[, BOOL])
     - If true, close button
  - shown with:
     - browser check
     - on Pusher system:app-alert

Pusher (server push):
  - MDL_EVENT 
     - "push:[un]subscribe"("CHANNEL")
     - "push:[un]bind"("EVENT")

Zopim:
  - MDL_EVENT: 
     - "zopim:offset:set"(NUM): vertical offset
     - "zopim:hide"()

Upsales:
  - route "integrations/upsales/ID"
  - MDL_EVENT "integrations:upsales:show"(ID)

modal:
  - MDL_EVENT:
     - "modal:show"(MVIEW)
        - triggers MVIEW.on("modal:show[n]|hide", FUNC())
        - MVIEW extends from:
           - ModalView, with OBJ..size "small|large" (adds CSS classes)
           - ModalLayout, with region container "#modal-layout-container"
     - "modal:confirm:show"(OBJ):
        - same but create a default MVIEW, with OBJ: header|content STR, cancel|confirm.color|text STR, theme STR (CSS class STR-theme)
        - triggers MVIEW.on("confirm:true|false",FUNC())
     - "modal:close"(BOOL)

app_reload (modal asking to reload):
  - MDL_EVENT "app-reload:show"()
     - called by Pusher system:app-reload

media_query:
  - MDL_EVENT:
     - "media-query:check"("mobile|tablet[-small]|desktop")
         - can add new with "media-query:add"({ name "...", query "(CSS_MEDIA_QUERY)" })
     - "media-query:check:touch"()->BOOL

editable:
  - MDL_EVENT "editable:mixin"(MVIEW), which adds MVIEW:
     - popoverText|Number|Date(JQ, OBJ)->OBJ2: 
        - creates a popover on JQ, which asks for input
        - OBJ:
           - model MODEL
           - autoSave BOOL: when submits, MODEL.patch()
           - autoSet BOOL: when submits, MODEL.set({ OBJ.attr: VAL }) then closes
           - title STR (def exists according to OBJ.attrDisplayName)
           (Text)
           - inputClass STR: CSS
           (Datapicker)
           - datepicker OBJ
        - OBJ2:
           - show|hide(): show() is called on click
           - disable()
           - getView()->MVIEW2, depending on type
        - triggers MEVENT "editable:close"(), "editable:OTHERS"()
        - does JQ.popover(OBJ) (def: animation true, html true, content $el, trigger "manual", no delay) then shows
     - popoverView(JQ, MVIEW2, OBJ3, OBJ): same with a custom new MVIEW2(OBJ3), where OBJ3:
        - OBJ.getTempModel()->MODEL
        - OBJ.targetModel MODEL
     - inlineSimple|RTF(JQ, OBJ): similar but with inline editing:
        - OBJ:
           - autoSave|autoSet|attr: like above
           - placeholder STR
           (Simple: contenteditable)
           - size STR (Bootstrap size)
           (RTF)
           - imageUploadURL URL
        - triggers MEVENT:
           - "editable:close"(JQ, OBJ)
           - "editable:cancel|error|open|save"(JQ, "simple|rtf", OBJ)

Agreement:
  - layoutmode:
     - get: inLayout|ViewMode()
     - set: setViewMode(Agreement.LAYOUT|VIEW_MODE)
     - when changes, rerenders

Agreement Toolbar:
  - MDL_EVENT "toolbar-view"(AGREEMENT)->MVIEW
  - according to isGuest(): small|full

Agreement LayoutSidebar:
  - MDL_EVENT "layout-sidebar:view(AGREEMENT)->MVIEW
     - according to AGREEMENT.boxes.type

BoxMenu:
  - MBEHAVIOR added to boxes, as a REGION to ".js-box-menu-container", with OBJ:
     - renderTrigger(FUNC()): re-render menu when FUNC() called. Should this.listenTo(..., FUNC)
  - Must use MVIEW:
     - _buildBoxMenu()->OBJ[()]:
        - actions OBJ_ARR: <button> list
           - title "HTML", className STR
           - event "EVENT", eventData VAL: when clicking on button, MDL_EVENT "box:menu:EVENT"(VAL)
           - confirm OBJ: passed to "modal:confirm:show", filtering event trigger
           - doConfirm()->BOOL: false if must not do confirm OBJ
        - dropdown OBJ_ARR: same but as dropdown. Can also OBJ:
           - url URL, bypass BOOL
  - adds:
     - OBJ.dropdown OBJ for removing box ("box-disable")
     - boxActions, i.e. publish|disable buttons with MDL_EVENT "box:publish|disable"(BOX), which changes BOX.state

Language:
  - Use MBEHAVIOR "TemplateLanguage": 
      - during rendering (between before:render and render), changes i18n.setLanguage()
      - according to new MVIEW() OBJ2.lang "LANG" (set by all boxes)

BoxManager (BaseBoxes container):
  - MDL_EVENT "box-manager:view"(AGREEMENT)->MCOLLVIEW:
     - according to:
        - AGREEMENT.inLayoutMode()
        - AGREEMENT.boxes (filtered by BOX.state enabled)
        - AGREEMENT.box_order changes with drag&drop

BaseBox (Box container):
  - MDL_EVENT:
     - "base-box:build:box"(BOX)->MLAYOUTVIEW: 
        - according to AGREEMENT.inLayoutMode():
           - view mode: 
           - layout mode: according to BOX.agreement.state, BOX.type
        - all: 
           - sets HTML attribute data-id="BOX.id"
           - MLAYOUTVIEW.inner contains BOX view, through BOX.viewHandler

Boxes:
  - all (by inheriting BoxController):
     - getView(BOX):
        - if LayoutMode: simple view with only content:
           - or boxTypeString()->"HTML" (layout mode description), using MDL_EVENT "boxes:TYPE:tostring" (must be same as BOX.toStringHandler)
           - or toString(BOX)->"HTML" (view mode content after edit)
             With MDL_EVENT "boxes:TYPE:tostring"(BOX)
           - or _getLayoutView(BOX)->VIEW, for less simple view
        - if ViewMode: _getView(BOX)
          With MDL_EVENT "boxes:TYPE:view"(BOX) (must be same as BOX.viewHandler)
  - duration:
     - MDL_EVENT:
        - "boxes:duration:disable:text"()->"HTML": text when about to remove from layout mode
     - according to AGREEMENT:
        - type (5 duration types)
        - start_date|end_date|duration|notice_period
  - text:
     - according to BOX_CONTENT.data[0].value
  - comments:
     - according to:
        - BOX.agreement.messages
        - BOX.config.enable_in_receipt BOOL
  - document|attachments:
     - according to BOX_CONTENT.documents OBJ: name STR
  - forms:
     - BOX_CONTENT.data

