
         
   AJV   
         


TO FINISH:
NOT DONE: from addSchema() to VALIDATE.schema, from AOPTS.loadSchema() to extendRefs, custom keywords|formats, async errors
Go through main doc again, to see if missing interesting options
https://github.com/epoberezkin/ajv-keywords
https://github.com/epoberezkin/ajv-merge-patch
https://github.com/epoberezkin/ajv-pack
https://github.com/jessedc/ajv-cli

ALTERNATIVES ==>                  #JSON schema validators:
                                  #  - tdegrunt jsonschema, z-schema: too slow
                                  #  - jsen, is-my-json-valid: quite ok
                                  #  - ajv: best speed, and most features. Only one supporting some of v5

VERSION ==>                       #4.11.4
                                  #Validates JSON schema v4
                                  #Also some of v5, providing AOPTS.v5 true (see JSON schema to see list supported by ajv)
                                  #Browser or Node.js

PHASES ==>                        #Schema validation: SCHEMA validated against its meta-schema
                                  #Compilation: SCHEMA transformed in a fast function (VALIDATE)
                                  #Data validation: data validated against VALIDATE


NOTATION ==>                      #The following notation takes as example:
                                  #  - schema: { properties: { world: { properties: { hello: { minimum: 1 } } } } }
                                  #  - data: { world: { hello: 2 } }
SCHEMA_ID                         #SCHEMA.id
                                  #Only available if direct call to AJV.add[Meta]Schema()
SCHEMA_VAL                        #1
PARENT_SCHEMA                     #{ minimum: 1 }
DATA_VAL                          #2
DATA_PATH                         #'.world.hello'
DATA_VAR                          #'hello'
SCHEMA_PATH                       #'#/properties/world/properties/hello/minimum'


new Ajv([AOPTS])                  #

AJV.add[Meta]Schema               #Validate a schema, but does not compile it
(SCHEMA[_ARR][,'SCHEMA_ID'])      #Can overwrite SCHEMA.id with SCHEMA_ID
AOPTS.schemas SCHEMA[_ARR]        #Difference with "Meta": 
                                  #  - mostly semantics, but there are few differences of behavior
                                  #  - metaschemas are global, so should do AJV.validateSchema(OBJ) instead of 
                                  #    AJV.validate(SCHEMA, OBJ)
AOPTS.validateSchema              #Validate schema against its meta-schema
                                  #Throws exception if invalid if true (def), logs only if "log", do nothing if false.
                                  #Meta-schema is defined by either:
                                  #  - SCHEMA.schema
                                  #  - KOPTS.metaSchema SCHEMA (not for validate())
AJV.getSchema('SCHEMA_ID')
 ->VALIDATE                       #
AJX.removeSchema
 (SCHEMA|'SCHEMA_ID'|REGEXP)      #REGEXP matches schema.id or SCHEMA_ID

AJV.compile(SCHEMA)->VALIDATE     #Validate a schema + compile
AJV.compileAsync                  #Same but async, waiting for remote references to be resolved.
 (SCHEMA, FUNC(ERROR, VALIDATE))  #AOPTS.missingRefs must be true
                                  #Possible ERRORs: loadSchema() ERROR, AOPTS.missingRegs true, invalid schema
 
VALIDATE(OBJ)->BOOL               #
AJV.validate                      #Same as AJV.compile(SCHEMA)(OBJ)->BOOL
 (SCHEMA|'SCHEMA_ID', OBJ)->BOOL  #Will use AJV.errors instead of VALIDATE.errors
VALIDATE.schema                   #SCHEMA


VALIDATE.errors                   #Of the last VALIDATE()
                                  #ERROR_OBJ_ARR:
                                  #  - null if no errors
                                  #  - only the first error, unless AOPTS.allErrors true
                                  #Validation functions (in AJV.addKeyword()) can assign this.errors ERROR_OBJ_ARR 
                                  #(def: standard errors):
                                  #  - if not, should use KOPTS.errors false for better efficiency
                                  #  - must at least define ERROR_OBJ.message|keyword|params
                                  #Async:
                                  #  - in ERROR.errors instead
                                  #  - custom 'RULE' should reject with new Ajv.ValidationError(ERROR_OBJ_ARR) instead
AJV.errorsText(ERR_OBJ_ARR[,OPTS])#Returns "data.DATA_PATH MESSAGE,...", e.g. "data.examplevar should be >= 10"
                                  #OPTS: separator (def: ","), dataVar (def: "data")
                                  #Can be used as human-friendly error message
ERROR_OBJ.message                 #'ERROR': if AOPTS.messages true (def)
                                  #Does not include paths, e.g. 'should be >= 10'
ERROR_OBJ.keyword                 #'RULE'
ERROR_OBJ.dataPath                #DATA_PATH, as 'VARR' or (if AOPTS.jsonPointers true) JSON_POINTER (e.g. '/VAR/...')
                                  #For rules that are one level upper than the object validated (e.g. required, additionalProperties, dependencies),
                                  #is the object validated if AOPTS.errorDataPath 'object' (def), or upper level if 'property'
ERROR_OBJ.schemaPath              #SCHEMA_PATH, as JSON_POINTER (e.g. '#/VAR/...')
ERROR_OBJ.params                  #Schema information. OBJ:
                                  #  (type)
                                  #  - type 'TYPE[,...]'
                                  #  (format)
                                  #  - format 'FORMAT' 
                                  #  (enum)
                                  #  - allowedValues VAL_ARR 
                                  #  (multipleOf)
                                  #  - multipleOf 
                                  #  ([exclusive]maximum|minimum)
                                  #  - limit NUM, exclusive BOOL, comparison '<|<=|>|>=' 
                                  #  (max|minLength)
                                  #  - limit NUM 
                                  #  (pattern)
                                  #  - pattern 
                                  #  (additionalItems|maxItems|minItems)
                                  #  - limit NUM 
                                  #  (uniqueItems)
                                  #  - i|j NUM 
                                  #  (max|minProperties)
                                  #  - limit NUM 
                                  #  (required)
                                  #  - missingProperty 
                                  #  (additionalProperties)
                                  #  - additionalProperties 'VAR'
                                  #  (patternRequired)
                                  #  - missingPattern 
                                  #  (patternGroups)
                                  #  - pattern REGEXP, reason 'minimum|maximum', limit NUM 
                                  #  (dependencies)
                                  #  - property 'VAR', missingProperty 'VAR', deps 'STR,...', depsCount NUM 
                                  #  ($ref)
                                  #  - ref STR 
                                  #  (custom keyword)
                                  #  - keyword 'RULE' 
(if AOPTS.verbose true)
ERROR_OBJ.schema                  #SCHEMA_VAL
ERROR_OBJ.parentSchema            #PARENT_SCHEMA
ERROR_OBJ.data                    #DATA_VAL

If JSON references with URI (not just #HASH):
  - must use compileAsync() and defined loadSchema()
JSON pointer difference from spec:
  - ignores trailing slash
Relative JSON pointer:
  - only in {$data}


AOPTS.loadSchema                  #JSON references are automatically resolved
('URI', FUNC(ERROR, SCHEMA))      #Function to fetch JSON references
AOPTS.missingRefs VAL             #What to do with JSON references that are not resolved or cannot be:
                                  #  - true (def): throw exception with ERROR: missingRef 'URI#HASH', missingSchema 'URI'
                                  #  - 'ignore|fail': log error, then create rule that always succeeds|fails
AOPTS.extendRefs                  #What to do when JSON references has other members than just "$ref":
                                  #  - true (def): merge those members as additional rules, with log message
                                  #  - "ignore": ignore members (as per JSON reference standard), with log message
                                  #  - "fail": throw exception


MODIFICATION ==>                  #The following directly modify data OBJ

AOPTS.removeAdditional            #Remove extra properties (e.g. the ones specified by SCHEMA.additionalProperties)
                                  #Can be:
                                  #  - false (def)
                                  #  - "all": whatever SCHEMA.additionalProperties is
                                  #  - true: only if SCHEMA.additionalProperties false
                                  #  - "failing": only if SCHEMA.additionalProperties false, or if SCHEMA.additionalProperties and properties do not validate to it
AOPTS.useDefaults                 #Apply SCHEMA.default. Can be:
                                  #  - false (def)
                                  #  - true: by deep copy
                                  #  - "shared": by reference
                                  #Cannot be used inside switch|anyOf|oneOf|not
AOPTS.coerceTypes                 #Try to transtype to SCHEMA.type. Can be:
                                  #  - false (def)
                                  #  - true: only for scalar types
                                  #  - "array": for array type too, i.e. VAL <-> [VAL]
                                  #Some difference from JavaScript:
                                  #  - String(null) -> ""
                                  #  - Boolean("true|false")->true|false, others errors
                                  #  - Boolean(NUM): if NUM not 1|0, errors
                                  #  - null(""|0|false), others errors


AOPTS.multipleOfPrecision         #Max number of decimals for multipleOf RULE argument


AOPTS.cache                       #Object used for caching. By def, done in memory
                                  #Is done as memoization, performed by add[Meta]Schema() and compile(), i.e. caches any [meta-]SCHEMA (not validation itself)
                                  #Should have methods: put('KEY', 'VAL'), get('KEY')->'VAL', del('KEY'), clear()


AJV.addFormat('FORMAT', VVAL)     #Add custom SCHEMA.format according to VVAL:
AOPTS.formats.FORMAT VVAL         #  - OBJ:
                                  #     - validate, async: see AJV.addKeyword()
                                  #     - compare(STR, STR2)->-1|0|1: to make SCHEMA.format[Exlusive]Maximum|Minimum work
                                  #  - VAL: shortcut for OBJ.validate VAL
AOPTS.full                        #Make format validation slower, must more correct, e.g. validates dates against Date() not just REGEXP (e.g. 25:00 is wrong)
AOPTS.unknownFormats              #If unknown format, throws exception: true (future def) or "ignore" (def, as per spec)



AJV.addKeyword('RULE', KOPTS)     #Add custom SCHEMA.RULE
                                  #'RULE' must be [:alnum:]-_$ and should be namespaced
                                  #Can be performed in four different ways according to KOPTS:
                                  #  - validate REGEXP|'REGEXP' or FUNC(SCHEMA_VAL, DATA_VAL, PARENT_SCHEMA, DATA_PATH, PARENT_VAL, DATA_VAR, ROOT_VAL)->[PROMISE_]BOOL
                                  #     - fired during VALIDATE()
                                  #     - is the most flexible, but slowest
                                  #  - compile(SCHEMA_VAL, PARENT_SCHEMA, CONTEXT)->(DATA_VAL, DATA_PATH, PARENT_VAL, DATA_VAR, ROOT_VAL)->[PROMISE_]BOOL
                                  #     - first function is fired during AJV.compile(), second during VALIDATE()
                                  #  - macro(SCHEMA_VAL, PARENT_SCHEMA, CONTEXT)->EXTRA_SCHEMA
                                  #     - fired during AJV.compile()
                                  #     - can be the most efficient
                                  #  - inline(CONTEXT, 'RULE', SCHEMA_VAL, PARENT_SCHEMA)->STR
                                  #     - fired during AJV.compile()
                                  #     - the fastest, but way too complicated to use
                                  #KOPTS:
                                  #  - type 'TYPE'[_ARR] (def: all): only trigger on those types
                                  #  - valid true: if FUNC is performed but its result can be ignored, i.e. only used for side-effects
                                  #  - modifying true: so FUNC can modify object (through PARENT|ROOT_VAL)
                                  #  (validate() only)
                                  #  - schema false: [PARENT|ROOT_]VAL are not passed as argument
                                  #  - async VAL: 
                                  #     - if returning PROMISE
                                  #     - RSCHEMA.$async true should be true as well
                                  #     - will use, according to VAL: "*"|"co*" (generator), "es7" (async function), true (either is installed)
                                  #     - will transpile using KOPTS.transpile "nodent|regenerator" (must be installed separately)
                                  #  - $data true: allow using $data
                                  #AOPTS:
                                  #  - passContext BOOL: if false (def), bind validate function context with AJV
                                  #CONTEXT:
                                  #  - level NUM: depth level of SCHEMA_VAL
                                  #  - dataLevel NUM: depth level of DATA_VAL
                                  #  - schema SCHEMA
                                  #  - schemaPath SCHEMA_PATH
                                  #  - self AJV
                                  #  - opts AOPTS
                                  #  - async BOOL
                                  #  - formats 'FORMAT'_ARR: all available in AJV
                                  #  - baseId: base URI for $ref resolving
                                  #  - compositeRule BOOL: is inside anyOf|oneOf|not|if|switch
AJV.getKeyword('RULE')->VAL       #Returns KOPTS, true (if builtin) or false (undefined)
AJV.removeKeyword('RULE')         #
