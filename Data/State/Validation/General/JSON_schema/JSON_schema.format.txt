
                 
   JSON_SCHEMA   
                 



STANDARD ==>                      #Draft RFCs:
                                  #  - "draft-wright-json-schema-[validation-]00" (is "v4"), with also some v5 proposals (was WIP)
                                  #Validates an instance (JSON) against a schema (set of validation rules, also JSON)


application/schema+json           #MIME
Link: <URI>; rel="describedby" [S]#Tells client that HTTP response payload is validate by JSON schema available at URI
Content-Type: application/json
 ;profile="URI ..." [C|S]         #Same for client|server


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          METASCHEMA           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


RSCHEMA.$schema 'META_SCHEMA_URI' #Metaschema:
                                  #  - schema validating another schema
                                  #  - default: "http://json-schema.org/schema#" (latest) or "http://json-schema.org/draft-04/schema#" (v4)

CUSTOM ==>                        #Can add:
                                  #  - new possible schema rules
                                  #  - new possible SCHEMA.format
                                  #Then:
                                  #  - should write own meta-schema
                                  #  - consumers should extend $schema (using allOf) with it


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          SUBSCHEMAS           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


RSCHEMA                           #Root level of schema

SCHEMA.id 'URI'                   #Schema identifier, used e.g. by SREF
                                  #  - can be in sub-schemas
                                  #  - can be:
                                  #     - 'ABS_URI[#HASH]': required for RSCHEMA (with no HASH)
                                  #     - 'REL_URI[#HASH]': relative to RSCHEMA URI
                                  #     - '#HASH': relative to closest parent schema with an URI
                                  #  - can be any URI scheme

SREF                              #JSON reference to SCHEMA (targetting SCHEMA.id), including sub-schema
                                  #Can replace any sub-SCHEMA
                                  #HASH can be SCHEMA.id #HASH, or JSON_POINTER
SCHEMA.definitions.DEF SCHEMA2    #Does not add any semantics, but used to be pointed by SREF, and put all pointed values together.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          VALIDATION           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


STR|NUM|BOOL|OBJ|ARR_SCHEMA       #SCHEMA targetting a STR|NUM|BOOL|OBJ|ARR


EQUALITY ==>                      #Is always deep
DEFINED ==>                       #Means object key is present, whatever the value is

REGEXP                            #Is JavaScript REGEXP but recommends avoiding (due to implementations differences)
                                  #\b \B \w \W \s \S \d \D (?:) (?=) (?!)
                                  #Matches against part of STR, i.e. must manually add ^ or $ to anchor


SCHEMA.title STR
SCHEMA.description STR            #Metadata


SCHEMA.type 'TYPE'[_ARR]          #VAL of 'TYPE' among 'string', 'number', 'integer', 'object', 'array', 'boolean', 'null'
                                  #If ARR, several possible choices
                                  #Can be not defined, whatever the TYPE. However can only be null if TYPE 'null'
SCHEMA.format 'FORMAT'            #VAL matches FORMAT among:
                                  #  (string)
                                  #  - "date-time": RFC 3339, i.e. YYYY-MM-DDTHH:MM:SS[.SSSS...]Z|TIMEZONE
                                  #  - "email"
                                  #  - "hostname"
                                  #  - "ipv4|ipv6"
                                  #  - "uri": absolute
                                  #  - "uriref": absolute|relative
                                  #  (any type)
                                  #  - any custom
SCHEMA.enum VAL_ARR               #Only possible values
SCHEMA.default VAL                #Default value


NUM_SCHEMA.multipleOf NUM2        #NUM % NUM2 === 0
NUM_SCHEMA.maximum|minimum NUM2           
NUM_SCHEMA.
 exclusiveMaximum|Minimum BOOL    #NUM <= >= NUM2 or (if exclusiveMaximum|Minimum true, def: false) NUM < > NUM2


STR_SCHEMA.min|maxLength UINT     #STR.length <= >= UINT (in Unicode chars)
STR_SCHEMA.pattern REGEXP         #STR matches REGEXP


ARR_SCHEMA.items SCHEMA           #SCHEMA is applied against each ARR element

ARR_SCHEMA.items SCHEMA_ARR       #Each SCHEMA is applied against each ARR element with same index
ARR_SCHEMA.                       #Missing ARR items are allowed (i.e. SCHEMA_ARR.length can be >= ARR.length)
 additionalItems BOOL|SCHEMA2     #Additional ARR items (i.e. when SCHEMA_ARR.length < ARR.length):
                                  #  - are all matched against SCHEMA2
                                  #  - are not allowed if BOOL false

ARR_SCHEMA.max|minItems NUM       #ARR.length <= >= NUM
ARR_SCHEMA.uniqueItems BOOL       #If true, no duplicate ARR elements


OBJ_SCHEMA.max|minProperties NUM  #OBJ.length <= >= NUM
OBJ_SCHEMA.required 'VAR'_ARR     #Each OBJ.VAR is defined

OBJ_SCHEMA.properties.VAR SCHEMA  #SCHEMA is applied against OBJ.VAR
OBJ_SCHEMA.                       #Missing OBJ.VAR are allowed (i.e. present in schema but not in OBJ)
 additionalProperties BOOL|SCHEMA2#Additional OBJ.VAR (i.e. present in OBJ but not in schema):
                                  #  - are all matched against SCHEMA2
                                  #  - are not allowed if BOOL false
OBJ_SCHEMA.                       #Like OBJ_SCHEMA.properties but matches against any OBJ.VAR whose VAR matches REGEXP
 patternProperties.REGEXP SCHEMA  #If both OBJ_SCHEMA.properties and one or several patternProperties match, all apply
                                  #Has same behavior when it comes to missing|additional properties

OBJ_SCHEMA.dependencies.VAR       #Applies OBJ_SCHEMA2 to OBJ, providing OBJ.VAR is defined
 OBJ_SCHEMA2|'VAR'_ARR            #'VAR'_ARR is like { required: 'VAR'_ARR }


SCHEMA.not SCHEMA2                #! combination
SCHEMA.allOf SCHEMA2_ARR          #&& combination
SCHEMA.anyOf SCHEMA2_ARR          #|| combination
SCHEMA.oneOf SCHEMA2_ARR          #|| combination, but must match only one
