
                 
   JSON_SCHEMA   
                 


Is standard:
  - implemented by ajv-keywords:
     - if|then|else
     - propertyNames
     - deepProperties, deepRequired
  - probably implemented by ajv:
     - format[Exclusive]Maximum|Minimum
     - additionalProperties|Items: no BOOL


STANDARD ==>                      #Draft RFCs:
                                  #  - "draft-wright-json-schema-[validation-]00" (is "v4")
                                 -#  - v5 and v6 are WIP. but ajv library supports some of it. It is then documented here
                                 -#    The following are not standardized or not implemented, and not documented by me so far:
                                !!#     - SCHEMA.messages
                                !!#     - contentLang
                                !!#     - $comment
                                 -#     - SCHEMA.format "uritemplate"
                                 -#     - any SCHEMA can be true|false
                                 -#     - exclusiveMinimum|Maximum BOOL -> NUM
                                 -#     - renaming:
                                 -#        - id -> $id
                                 -#        - SCHEMA.format "json-pointer" -> "jsonpointer"
                                 -#        - SCHEMA.constant -> SCHEMA.const
                                  #Validates an instance (JSON) against a schema (set of validation rules, also JSON)
                                  #How to check for updates:
                                  #  - https://github.com/json-schema-org/json-schema-spec/issues (issues + pull requests)
                                  #     - contains the spec discussion
                                  #     - last time I checked everything was 24/03/2017
                                  #  - ajv contains versions of WIP next versions in /lib/refs
                                  #  - implementations: ajv, ajv-keywords, others

NOTATION ==>                     !#v5 or v6, supported by a library (ajv or ajv-keywords unless specified otherwise)
                                 -#v5 or v6, but not not supported by any library
                                !!#Might become v5 or v6, but not completely sure
                                 ##Non-standard


application/schema+json           #MIME
Link: <URI>; rel="describedby" [S]#Tells client that HTTP response payload is validate by JSON schema available at URI
Content-Type: application/json
 ;profile="URI ..." [C|S]         #Same for client|server


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          METASCHEMA           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


RSCHEMA.$schema 'META_SCHEMA_URI' #Metaschema:
                                  #  - schema validating another schema
                                  #  - default: "http://json-schema.org/schema#" (latest) or "http://json-schema.org/draft-04/schema#" (v4)

CUSTOM ==>                        #Can add:
                                  #  - new possible schema rules
                                  #  - new possible SCHEMA.format
                                  #Then:
                                  #  - should write own meta-schema
                                  #  - consumers should extend $schema (using allOf) with it


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          SUBSCHEMAS           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


SCHEMA                            #Is an OBJ
RSCHEMA                           #Root level of schema

SCHEMA.id 'URI'                   #Schema identifier, used e.g. by SREF
                                  #  - can be in sub-schemas
                                  #  - can be:
                                  #     - 'ABS_URI[#HASH]': required for RSCHEMA (with no HASH)
                                  #     - 'REL_URI[#HASH]': relative to RSCHEMA URI
                                  #     - '#HASH': relative to closest parent schema with an URI
                                  #  - can be any URI scheme

SREF                              #JSON reference to SCHEMA (targetting SCHEMA.id), including sub-schema
                                  #Can replace any sub-SCHEMA
                                  #HASH can be SCHEMA.id #HASH, or JSON_POINTER
SCHEMA.definitions.DEF SCHEMA2    #Does not add any semantics, but used to be pointed by SREF, and put all pointed values together.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:        REFERENCED DATA        :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


{ "$data": "[REL_]JSON_POINTER" }!#Can be used instead of any VAL
                                 !#Replaced by a value coming from the instance being validated, according to JSON pointer
                                 !#JSON pointer can be absolute (root of the instance) or relative (to current { "$data" }) 
                                 !#(see its doc)
                                 !#If pointed value does not exist, no error nor validation
                                 !#Not supported by ajv for:
                                 !#  - any rule where VAL can be SCHEMA
                                 !#  - title, description, type, default


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          VALIDATION           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


STR|NUM|BOOL|OBJ|ARR_SCHEMA       #SCHEMA targetting a STR|NUM|BOOL|OBJ|ARR


EQUALITY ==>                      #Is always deep
DEFINED ==>                       #Means object key is present, i.e. not undefined, but null is fine

REGEXP                            #Is JavaScript REGEXP but recommends avoiding (due to implementations differences)
                                  #\b \B \w \W \s \S \d \D (?:) (?=) (?!)
                                  #Matches against part of STR, i.e. must manually add ^ or $ to anchor


SCHEMA.title STR                  #Metadata
SCHEMA.description STR            #Metadata
SCHEMA.examples VAL_ARR          !#Metadata


SCHEMA.type 'TYPE'[_ARR]          #VAL of 'TYPE' among 'string', 'number', 'integer', 'object', 'array', 'boolean', 'null'
                                  #If ARR, several possible choices
                                  #Can be not defined, whatever the TYPE. However can only be null if TYPE 'null'
SCHEMA.format 'FORMAT'            #VAL matches FORMAT among:
                                  #  (string)
                                 !#  - "regex": JavaScript REGEX
                                  #  - "date-time": RFC 3339, i.e. YYYY-MM-DDTHH:MM:SS[.SSSS...]Z|TIMEZONE
                                 !#  - "date": RFC 3339 YYYY-MM-DD
                                 !#  - "time": RFC 3339 HH:MM:SS
                                  #  - "email"
                                  #  - "hostname"
                                  #  - "ipv4|ipv6"
                                  #  - "uri": absolute
                                 -#  - "uriref": absolute|relative
                                 !#  - "json-pointer": absolute
                                 !#  - "relative-json-pointer": relative
                                  #  (any type)
                                  #  - any custom
SCHEMA.enum VAL_ARR               #Only possible values
SCHEMA.constant VAL              !#Only one possible value
SCHEMA.default VAL                #Default value, if not defined


NUM_SCHEMA.multipleOf NUM2        #NUM % NUM2 === 0
NUM_SCHEMA.maximum|minimum NUM2           
NUM_SCHEMA.
 exclusiveMaximum|Minimum BOOL    #NUM <= >= NUM2 or (if exclusiveMaximum|Minimum true, def: false) NUM < > NUM2

VAL_SCHEMA.maximum|minimum NUM2           
VAL_SCHEMA.                      !#Like NUM_SCHEMA, but for any VAL according to its SCHEMA.format, if the format has implicit ordering
 exclusiveMaximum|Minimum BOOL   !#E.g. defined for: "date", "time", "date-time"


STR_SCHEMA.min|maxLength UINT     #STR.length <= >= UINT (in Unicode chars)
STR_SCHEMA.pattern REGEXP         #STR matches REGEXP


ARR_SCHEMA.items SCHEMA           #SCHEMA is applied against each ARR element

ARR_SCHEMA.items SCHEMA_ARR       #Each SCHEMA is applied against each ARR element with same index
ARR_SCHEMA.                       #Missing ARR items are allowed (i.e. SCHEMA_ARR.length can be >= ARR.length)
 additionalItems BOOL|SCHEMA2     #Additional ARR items (i.e. when SCHEMA_ARR.length < ARR.length):
                                  #  - are all matched against SCHEMA2
                                  #  - are not allowed if BOOL false
ARR_SCHEMA.contains SCHEMA[_ARR] !#Each SCHEMA must be match by at least one ARR element

ARR_SCHEMA.max|minItems NUM       #ARR.length <= >= NUM
ARR_SCHEMA.uniqueItems BOOL       #If true, no duplicate ARR elements


OBJ_SCHEMA.max|minProperties NUM  #OBJ.length <= >= NUM
OBJ_SCHEMA.required 'VAR'_ARR     #Each OBJ.VAR is defined

OBJ_SCHEMA.properties.VAR SCHEMA  #SCHEMA is applied against OBJ.VAR
OBJ_SCHEMA.                       #Missing OBJ.VAR are allowed (i.e. present in schema but not in OBJ)
 additionalProperties BOOL|SCHEMA2#Additional OBJ.VAR (i.e. present in OBJ but not in schema):
                                  #  - are all matched against SCHEMA2
                                  #  - are not allowed if BOOL false
OBJ_SCHEMA.                       #Like OBJ_SCHEMA.properties but matches against any OBJ.VAR whose VAR matches REGEXP
 patternProperties.REGEXP SCHEMA  #If both OBJ_SCHEMA.properties and one or several patternProperties match, all apply
                                  #Has same behavior when it comes to missing|additional properties
OBJ_SCHEMA.
 patternRequired.REGEXP SCHEMA   !#Same as patternProperties, except at least one property must match each REGEXP
OBJ_SCHEMA.                      !#Same as patternProperties, using OBJ.schema, 
 patternGroups.REGEXP OBJ        !#except at least|most OBJ.minimum|maximum properties must match each REGEXP

OBJ_SCHEMA.dependencies.VAR       #Applies OBJ_SCHEMA2 to OBJ, providing OBJ.VAR is defined
 OBJ_SCHEMA2|'VAR'_ARR            #'VAR'_ARR is like { required: 'VAR'_ARR }


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          COMBINATION          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


SCHEMA.not SCHEMA2                #! combination
SCHEMA.allOf SCHEMA2_ARR          #&& combination
SCHEMA.anyOf SCHEMA2_ARR          #|| combination
SCHEMA.oneOf SCHEMA2_ARR          #|| combination, but must match only one

SCHEMA.switch OBJ_ARR            ##Logic combination of schemas, with OBJ_ARR:
                                 ##  - then SCHEMA|BOOL: 
                                 ##     - main validation to apply
                                 ##     - BOOL means automatic success|failure
                                 ##  - if SCHEMA2 (optional): only apply SCHEMA if SCHEMA2 applies
                                 ##After each OBJ, goes to next OBJ providing either:
                                 ##  - SCHEMA2 fails
                                 ##  - SCHEMA2 succeeds, and OBJ.continue true
                                 ##Otherwise, stops switch with success
                                 ##Implemented by "ajv"

SCHEMA.$merge OBJ                ##Merge OBJ.with OBJ2 (JSON merge patch, RFC 7386) with OBJ.source SCHEMA2
SCHEMA.$patch OBJ                ##Merge OBJ.with OBJ2_ARR (JSON patch, RFC 6902) with OBJ.source SCHEMA2
                                 ##Both use package "ajv-merge-patch" (2.1.0)
