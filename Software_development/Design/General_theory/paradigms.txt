
               
   PARADIGMS   
               


Interaction:
  - single execution:
     - e.g. Unix command
  - event-driven: 
     - instead of only one execution, event loop (i.e. new function executed according to events)
     - events might be other than user interaction, e.g.:
        - hardware events, e.g. Bash serie of pipes (wait for file events)
     - advantages:
        - can react to interaction
     - problems:
        - event handlers should not check current state (creates big conditional logic if many state variables)
           - instead, state should modify/enable/disable event handlers
           - e.g.:
              - web app route
  - menu-driven:
     - like event loop except user manually picks event among the list of all events
        - might be done using menus/submenus
     - e.g.:
        - CLI command asking for action among several choices
        - GUI app where actions can only be done through top bar
     - easier to reason with this kind of interaction, but less flexible

Imperative vs Declarative :
  - Imperative :
    - statements changeant le state
      - assignations à des variables
      - utilisation de looping statements possible 
      - branchements :
        - conditionnels : if, etc.
        - inconditionnels : jumps, goto, switch, call
    - sous-type :
      - declarative :
        - organisation du projet en subroutines
      - structured vs non-structured :
        - structured :
          - utilisation de boucles for, etc. 
          - modularité (libraries)
          - POO :
            - chaque ensemble de fonction est lié à un ensemble de data (objets)
            - un objet est :
              - un ensemble de data (object state)
              - un ensemble de méthodes (behavior)
              - une identity (existence propre d'une instantiation par rapport à une autre instantiation)
            - class-based vs prototype-based :
              - class-based : le type (structure) des objets est défini compile-time dans des classes
              - prototype-based : le type des objets est défini runtime dans des prototypes, qui sont ensuite clonés pour l'instantiation.
        - non-structured :
          - utilisation de branchements inconditionnels
    - ex : x86, C, BASIC
  - Declarative :
    - pas de statements, ni de side effects, juste un logic flow
    - ne modifie pas le global state, ni n'utilise un global state mutable
    - programme == théorie logique avec des assomptions, et computation == déduction en fonction de cette théorie et d'un input
    - sous-types :
      - functional : accent sur l'absence de side effects
        - purely functional : absence totale de side effects
      - logic : accent sur la représentation logique et mathématique
  - On peut établir des liens entre l'abstraction et modularité tirées des subroutines, de la POO et du functional programming.
