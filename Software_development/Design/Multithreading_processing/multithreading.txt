                    
   MULTITHREADING   
                    

                    /=+===============================+=\ 
                   /  :                               :  \  
                   )==:            GENERAL            :==(   
                   \  :_______________________________:  /    
                    \=+===============================+=/

Multiprocessing : utilisation de plusieurs CPU sur un même PC
Multitasking : utilisation de plusieurs tasks sur un même OS
Multiprogramming : utilisation de plusieurs processes sur un même OS
Multithreading : utilisation de plusieurs threads dans un même process
Hyperthreading : terme Intel pour désigner le fait de faire tourner plusieurs threads de manière réellement simultanée (et non avec un switch rapide) en utilisant plusieurs CPU

Thread == 1 task + 1 état (en cours d'exécution ; en attente d'exécution, mais non-bloqués ; bloqué (par un mutex par ex) ; à supprimer)
Processus == 1 ou plusieurs thread + 1 adress space partagé par ces threads (=> synchronization nécessaire).
Chaque thread a cependant un stack alloué à seulement lui : les TLS (thread-local storage)
Créer un nouveau thread pour un même processus, plutôt qu'un nouveau processus, est plus léger, car pas de création de nouveau memory space. Les différents threads d'un processus partagent donc ce memory space.

Intérêt du multi-threading :
  - parallélisme (lancer plusieurs tâches pour un même processus)
  - gain en rapidité si plusieurs CPU

Un thread noyau est un thread dont le privilège est superuser ; par opposition aux threads users.
Il peut changer d'adress space explicitement, car il en a les privilèges, contrairement aux threads users.

Les threads ont souvent toujours les mêmes adresses virtuelles sur un OS donné, mais différentes adresses physique grâce au changement de l'adress space.

                    /=+===============================+=\ 
                   /  :                               :  \  
                   )==:        ORDONNANCEMENT         :==(   
                   \  :_______________________________:  /    
                    \=+===============================+=/

Un changement de task implique donc un changement de process :
  - à plus haut niveau, l'OS sauvegarde donc, en plus de l'état de la task courante, celui du process courant (pour Linux dans un "PCB", "Process Control Block", ou switchframe)

Ordonnancement : gère le changement de threads (en cours d'exécution vs en attente d'exécution). Un task switch a lieu à chaque "cancellation point". Cancellation point possibles :
  - Task witch volontaire :
    - synchrone :
      - décision de faire un sleep pendant une durée donnée 
      - décision de passer la main (yield)
      - libération ou bloquage d'une ressource partagée par un procédé de synchronization
  - Task switch involontaire :
    - asynchrone :
      - retour d'une IRQ (dont le timer de l'horloge, IRQ0) (seulement pour un OS "préemptible" (par opposition à "collaboratif"/"coopératif"))
    - synchrone :
      - exception processeur lancée

Collaboratif vs Préemptif :
  - Dans un OS collaboratif, chaque processus doit "collaborer" pour laisser la main via un sleep ou yield.
  - Dans un OS preemptif (ex : Linux), cela n'est pas nécessaire.
    - le temps maximum alloué entre deux points de préemptions est alors une "time slice".

Busy-waiting vs event-driven :
  - spinning / busy waiting / software-driven / synchronous : 
    - une boucle effectue :
      - un spinlock : 
        - test de manière infinie et active 
        - test et lock de la ressource doit être opération atomique, sinon possibilité de collusion
        - polling / sleeplock :
          - quand il y a un sleep fixe (donnant lieu à un yield) entre deux tests (pour éviter gâcher du CPU)
          - est donc asynchronous
      - un grand nombre donné d'itération 
    - raisons possibles :
      - un thread effectuant un test pour accéder à une ressource
      - effectuer un sleep() (mais à éviter car impossible de déterminer le temps de sleep exact, et des syscalls fondés sur du polling (IRQ timer) existent)
    - à éviter, car gâche de la ressource : préférer event-driven
    - cependant spinlock low-level peut être plus rapide qu'autre processus de synchronization :
      - si pas de context switch entre acquisition et release de la ressource (donc critical section très courte)
      - souvent dans les kernels
  - event-driven / interrupt-driven / asynchronous :
    - le thread attend l'irruption d'une IRQ signalant réussite du test :
      - très peu de CPU consommé (sleeping proccess)
      - pas de collusion possible, comme l'IRQ ne réveille qu'un seul process parmi ceux attendant cette IRQ
    - exemple d'IRQ courante : tapes claviers, mouvement souris
    - on peut aussi utiliser à l'user level :
      - définir des signal handlers, et sleep un temps infini
      - des condition variables

Select loop :
  - event-driven wait, attendant une IRQ parmi en général :
    - accès d'un des file descriptors
    - fin d'un processus enfant
    - timeout IRQ
  - peut aussi être implémenté en polling (mais plus rare)

Sync I/O vs async I/O :
  - sync/blocking I/O :
    - un thread utilisant un périphérique attend que le périphérique ait terminé avant de yield
    - problème : le CPU reste idle longtemps car opérations I/O sont très lentes par rapport à vitesse d'un CPU
  - async/non-blocking I/O :
    - un thread utilisant un périphérique yield immédiatement, et attend l'irruption d'une IRQ indiquant la fin d'utilisation du périphérique pour reprendre la main
    - peut aussi être implémenté via un polling
    - problème : il faut utiliser des processus de synchronization pour s'assurer qu'un périphérique n'est pas partagé par plusieurs threads de sorte qu'une collusion puisse survenir

Priority inversion :
  - arrive quand task A attend que task C lâche une ressource, et task B survient, où A > B > C en terme de priorité. B ne demande pas la ressource, mais ayant une priorité supérieure à C, empêche (ou ralentit) C de continuer, et donc A.
  - solution possible :
    - priority inheritance : quand une task acquiert une ressource, sa priorité devient celle de la task maximale demandant la ressource, +1 (C devient A+), temporairement (le temps de relâcher la ressource)

                    /=+===============================+=\ 
                   /  :                               :  \  
                   )==:          RESSOURCES           :==(   
                   \  :_______________________________:  /    
                    \=+===============================+=/

Ressource : ressource demandée par un thread. Ex :
  - CPU :
    - timesharing, géré par l'ordonnanceur de l'OS
  - mémoire :
    - fichier / file descriptor :
      - régulier :
        - cas fréquent : création de fichier temporaire
      - socket :
        - 2 channels IRC avec le même nom, créés en même temps
    - variable globale

Plusieurs threads partageant la même ressource, avec l'un d'eux modifiant celle-ci (si ressource mémoire), provoque une collusion. Il peut s'agir :
  - de plusieurs threads d'un même processus
  - de plusieurs threads de processus différents
  - d'un thread interrompu par un interrupt handler
Race condition : quand il y a collusion.
Fonction thread-safe : ne peut pas poser de problème de collusion.
Les procédés de synchronization doivent songer à l'éventualité d'une exception, et donc être exception-safe.
Section exception-safe :
  - bout de code utilisant une ressource ne générant pas de collusion, ni de memory leak en cas d'exception processeur (et donc logicielle C++) lancée.
  - RAII : procédé pour unlocker et désallouer automatiquement une ressource si une exception est lancée.

                    /=+===============================+=\ 
                   /  :                               :  \  
                   )==:        SYNCHRONIZATION        :==(   
                   \  :_______________________________:  /    
                    \=+===============================+=/

Synchronization / serialization : procédés utilisés pour éviter collusion.
  - process synchronization :
    - s'assurer que les critical sections d'un process multi-threaded ne soit exécutés que par un seul thread à la fois.
    - par exemple en interdisant les context switchs involontaires pendant la critical section : IRQ (instruction cli/sti), et exception-safety.
  - data synchronization :
    - s'assurer qu'une ressource n'est pas écrite par un thread et accédée par un autre.
    - par exemple :
      - en utilisant atomic operation + pas de buffer.
      - en utilisant des procédés de synchronization
Atomic operation :
  - opération n'exigeant qu'une seule instruction du CPU et ne pouvant donc pas être interrompue par une interruption ou un context switch.
  - pas besoin de procédé de synchronization donc.
  - "read-modify-write" operations :
    - effectue plusieurs opérations de manière atomique (par opposition à une opération atomique simple, comme mov eax, VAL)
    - souvent implémentées au niveau du CPU
    - exemples :
      - compare-and-swap : si ( X == Y ), alors X = Z (cmpxchg, cmpxchg8b)
      - test-and-set : X = Y, renvoie ancien X
      - fetch-and-add : X += Y (xadd)
Critical section : partie d'un code utilisant une ressource exigeant une data synchronization.

Problème de la synchronization :
  - diminue réactivité
  - diminue optimisation du parallélisme possible sur un système multi-CPU.
Solutions : éviter tant que possible la synchronization, tout en restant thread-safe :
  - non-blocking algorithmes
  - ex : try_lock ou (dans une moindre mesure) timed_lock

                    /=+===============================+=\ 
                   /  :                               :  \  
                   )==:  PROCEDES DE SYNCHRONIZATION  :==(   
                   \  :_______________________________:  /    
                    \=+===============================+=/

Procédé de synchronization :
  - ils doivent tous être eux-mêmes des ressources partagées par les différents threads les utilisant (ce qui implique par exemple de les passer par référence en C++).
  - mutex :
    - objet permettant à un thread de locker l'accès sur une ressource pour tous les autres threads.
    - il s'agit d'un indicateur à checker. Il n'est pas lié physiquement à la ressource : il faut donc que chaque thread pouvant modifier la ressource le checke.
    - possibilité sans collision :
      - unique mutex : un seul thread locke écriture + lecture, écrivant lui-même
        - recursive mutex : possibilité de faire une suite de locks. Pour véritablement unlocker après une suite de n locks, il faudra faire une suite de n unlocks.
      - shared mutex : plusieurs threads locke l'écriture, tous lisant, aucun n'écrivant
    - timed mutex : mutex ne durant qu'un temps limité.
    - contrairement à un sémaphore binaire, seul le thread ayant fait lock, peut faire unlock (notion de propriété)
  - semaphore :
    - associé à un nombre.
    - Chaque lock fait baisser ce nombre de 1 (peut devenir négatif)
    - l'action véritable de lock n'a lieu que quand le nombre devient 0
    - ressource unlockée seulement quand le nombre redevient positif
    - permet aussi d'être utilisée comme une barrier
  - rendezvous / barrier :
    - plusieurs threads s'arrêtent à un point (barrier) tant que les autres threads n'ont pas atteint eux aussi la barrier.
    - s'il y a trois threads X, Y et Z, et que deux threads X pourraient être lancés en même temps, mettre un mutex prévenant l'atteinte de la barrier par les deux threads X en même temps.
  - conditions variables :
    - principe :
      - un thread se lit à une ConditionVar et sleep
      - un autre thread le wake up. Peut wake up tous les threads attendant ConditionVar ou seulement l'un d'entre eux.
    - souvent se lier à ConditionVar unlock un Mutex qui est relock lors du wake up, dans l'idée que les actions qui suivent doivent être thread-exclusives.
    - intérêt : évite spinlocks while ( ! condition )
  - spinlock

Monitor :
  - classe dont toutes les méthodes sont gérées via des mutexs, thread-safe donc

Lock/own une ressource :
  - fait qu'un thread bloque l'utilisation d'une ressource par les autres threads.
  - on peut demander non pas une ressource, mais l'une de plusieurs ressources. Si aucune disponible, attendra que l'une de ces ressources se libère.
Thread bloqué : thread mis en attente le temps qu'une ressource soit libérer.
[Wait]queue :
  - liste d'attente des threads bloqués en attente de la libération d'une ressource.
  - un même thread peut être sur plusieurs queues si plusieurs ressources ont été demandées en même temps.
Une mauvaise gestion des procédés de synchronization peut provoquer :
  - Starvation : quand un thread cherche à accéder à une ressource perpétuellement sans succès
    - Deadlock : deux threads ont un besoin mutuel d'une ressource de l'autre pour continuer. Cela peut être plus que deux avec une référence circulaire (qui peut alors aussi être considérée comme un livelock).
  - Livelock : si le programme génère une fonction en cas de deadlock pour sortir du deadlock, mais que cette fonction est activée par les deux parties bloquantes du deadlock en même temps, ce qui conduit à un nouveau deadlock, et ainsi de suite.
  - Ressource leak : oublie d'unlock la resource, qui ne peut plus être libérée. Ex : 
    - memory leak
    - handle leak

Moyen de gérer les deadlocks et livelocks :
  - créer une classe centrale manageuse de la synchronization (à éviter)
  - faire un algorithme sans autorité centrale.

                    /=+===============================+=\ 
                   /  :                               :  \  
                   )==:          REENTRANCY           :==(   
                   \  :_______________________________:  /    
                    \=+===============================+=/

Possibilité pour un programme d'être interrompu (IRQ, interruption, task/thread switching), puis de reprendre sans que cela pose problème.
Les codes récursifs doivent être reentrants.
Les interrupt handlers ne peuvent utiliser que des fonctions reentrants (au cas où elles aient interrompue la même fonction que celle qu'elles appellent).

Différent de thread-safety :
  - si reentrant, alors thread-safe ; mais pas inverse.
  - par exemple, un code simple lockant une ressource globale avec des mutexs est thread-safe, mais pas reentrant, car accède une variable globale (le mutex). Une interruption interromptant ce code, puis l'invoquant dans son interrupt handler, provoquerait un deadlock.
  - un thread n'ayant pas besoin d'accéder à une ressource globale n'a pas besoin de procédé de synchronization, mais seulement d'être reentrant pour être thread-safe.

Pour être reentrant :
  - ne pas accéder de variables global non-const
  - ne pas appeler soi-même de fonctions non-reentrantes.
  - ne pas modifier son propre code (self-modifying code)

                    /=+===============================+=\ 
                   /  :                               :  \  
                   )==:             AUTRE             :==(   
                   \  :_______________________________:  /    
                    \=+===============================+=/

Volatile variables : cf c_synthese et c++_synthese pour l'utilisation de volatile sur les variables partagées par plusieurs threads

Puisque bloquer et libérer une ressource provoque un changement de contexte (avec une prise en charge particulière de l'OS pour cet événement), cela peut être utilisé pour les signaux :
  - le thread 1 bloque SIGFOOBAR_Mutex, partagé avec le thread 2
  - quand le thread 2 veut envoyer le signal SIGFOOBAR au thread 1, il débloque SIGFOOBAR_Mutex
  - l'OS prend en charge le signal

resource tracking : recherche par un OS ou une VM, d'un resource leak. Exemple : garbage collection

Join : fait qu'un thread attend qu'un autre arrive à un certain endroit pour continuer sa propre exécution.

                    /=+===============================+=\ 
                   /  :                               :  \  
                   )==:      CANCELLATION POINTS      :==(   
                   \  :_______________________________:  /    
                    \=+===============================+=/

Une cancellation ne peut avoir lieu que lors d'un cancellation point.
Cancellation handler : handler utilisé si la ressource cesse d'être utilisée par le thread actuel (par exemple, libérer la mémoire) Utile pour les asynchronously et synchronously cancelable threads.
Cancellation status d'un thread :
  - asynchronously cancelable : peut être cancelled à tout moment (défaut).
  - synchronously cancelable : ne peut être cancelled que lors d'un cancellation point.
  - uncancelable : ne peut pas être cancelled (une des manière d'implémenter une critical section).

Cancellation points :
accept              access              aio_suspend         asctime             
asctime_r           catclose            catgets             catopen             
clock_nanosleep     close               closedir            closelog            
connect             creat               ctermid             ctime               
ctime_r             dbm_close           dbm_delete          dbm_fetch           
dbm_nextkey         dbm_open            dbm_store           dlclose             
dlopen              endgrent            endhostent          endnetent           
endprotoent         endpwent            endservent          endutxent           
fclose              fcntl2              fcntl3              fdatasync           
fflush              fgetc               fgetpos             fgets               
fgetwc              fgetws              fmtmsg              fopen               
fpathconf           fprintf             fputc               fputs               
fputwc              fputws              fread               freopen             
fscanf              fseek               fseeko              fsetpos             
fstat               fsync               ftell               ftello              
ftw                 fwprintf            fwrite              fwscanf             
getaddrinfo         getc                getchar             getchar_unlocked    
getc_unlocked       getcwd              getdate             getgrent            
getgrgid            getgrgid_r          getgrnam            getgrnam_r          
gethostbyaddr       gethostbyname       gethostent          gethostid           
gethostname         getlogin            getlogin_r          getmsg              
getnameinfo         getnetbyaddr        getnetbyname        getnetent           
getopt4             getpmsg             getprotobyname      getprotobynumber    
getprotoent         getpwent            getpwnam            getpwnam_r          
getpwuid            getpwuid_r          gets                getservbyname       getservbyport       getservent          getutxent           getutxid            
getutxline          getwc               getwchar            getwd               
glob                iconv_close         iconv_open          ioctl               
link                localtime           localtime_r         lockf               
lseek               lstat               mkstemp             mktime              
mq_receive          mq_send             mq_timedreceive     mq_timedsend        
msgrcv              msgsnd              msync               nanosleep           
nftw                open                opendir             openlog             
pathconf            pause               pclose              perror              
poll                popen               pread               printf              
posix_fadvise                           posix_fallocate                         
posix_madvise                           posix_openpt                            
posix_spawn                             posix_spawnp                            
posix_trace_clear                       posix_trace_close                       
posix_trace_create                      posix_trace_create_withlog              
posix_trace_eventtypelist_getne         posix_trace_eventtypelist_rewin         
posix_trace_flush                       posix_trace_get_attr                    
posix_trace_get_filter                  posix_trace_getnext_event               
posix_trace_get_status                  posix_trace_open                        
posix_trace_rewind                      posix_trace_set_filter                  
posix_trace_shutdown                    posix_trace_timedgetnext_event          
posix_typed_mem_open                    pthread_cond_timedwait                  
pthread_cond_wait                       pthread_join                            
pthread_rwlock_rdlock                   pthread_rwlock_timedrdlock              
pthread_rwlock_timedwrlock              pthread_rwlock_wrlock                   
pthread_testcancel                
pselect             putc                putchar             putchar_unlocked    
putc_unlocked       putmsg              putpmsg             puts                
pututxline          putwc               putwchar            pwrite              
read                readdir             readdir_r           readv               
recv                recvfrom            recvmsg             remove              
rename              rewind              rewinddir           scanf               
seekdir             select              semop               sem_timedwait       
sem_wait            send                sendmsg             sendto              
setgrent            sethostent          setnetent           setprotoent         
setpwent            setservent          setutxent           sigpause            
sigsuspend          sigtimedwait        sigwait             sigwaitinfo         
sleep               stat                strerror            strerror_r          
strftime            symlink             sync                syslog              
system              tmpfile             tmpnam              ttyname             
ttyname_r           tzset               ungetc              ungetwc             
unlink              vfprintf            vfwprintf           vprintf             
vwprintf            wcsftime            wordexp             wprintf             
wscanf           
