
                    
   BEST_PRACTICES   
                    

ENSEMBLE DES AVANTAGES  #Developer-side :
D'UN LOGICIEL ==>       #  - maintainable (temps requis pour mettre à jour/
                        #    extend) :
                        #      - interopérable (rapidité pour porter)
                        #      - scalable (par exemple avec programmation
                        #        générique)
                        #      - simplicité du système pour le développeur
                        #  - portabilité
                        #User-side :
                        #  - efficience / utilisation des ressources
                        #  - confort (de l'interface pour l'utilisateur) :
                        #    - visuel (esthétique)
                        #    - simplicité
                        #  - qualité de la fonction fournie (ex : qualité 
                        #    cryptographique d'un logiciel crypto)
                        #    - comprend la facilité de debuggage d'une
                        #      bibliothèque
                        #  - nombre de fonctionnalités fournies (à 
                        #    l'utilisateur)
                        #  - reliability (contre accident involontaire) :
                        #      - problème de réseau
                        #      - d'une bibliothèque, pour un développeur 
                        #        codant mal (le protéger de ses propres
                        #        erreurs avec des compile-time tests)
                        #      - interface-stability / backward-compatibility
                        #  - security (contre accident volontaire)

GUIDES  ==>             #  - minimalisme / simplicité : "do one thing and do it 
                        #    well" et non ( Simplicity > Nombre de 
                        #    fonctionnalités ) :
                        #     - "creeping featurism" 
                        #     - problème : moins de "diversité d'utilisation /
                        #       nombre de features".
                        #         - solution possibles : plugins
                        #  - modularité / extensible :
                        #     - utilisation d'interfaces / polymorphisme
                        #     - "loose coupling" / law of Demeter : chaque 
                        #       partie du système a peu de connaissance et 
                        #       d'interaction des autres parties. Modifier
                        #       les autres parties (réagencement, suppression,
                        #       addition, modification) ne modifie pas le
                        #       comportement de cette partie.
                        #       Notamment éviter d'invoquer une méthode sur
                        #       un objet retourné par une méthode, et étranger 
                        #       à la classe courante
                        #  - backward compatibility
                        #  - interopérabilité

SOLID Principles        #Principes pour la scability et la granularity :
Single responsibility   #Une classe ne doit avoir qu'une responsibility. Si ce
                        #n'est pas le cas : la diviser.
                        #Définitions de responsibility : 
                        #  - role jouée par une classe
                        #  - "reason to change"
Open/Close Principle    #Le code existant (interface) doit être fermée à la
                        #modification, mais ouvert à nouvel ajout par 
                        #inhéritance. Recommande en fait l'utilisation de
                        #l'inhéritance pour extend un système, et non 
                        #modification du code existant.
Liskov substitution /   #Une subclasse peut toujours remplacer sa parente sans
LSP / substitutability  #faire que le programme se comporte de manière
                        #indésirée (cf Design by contract) (mais pas forcément 
                        #l'inverse)
                        #Implique, dans la subclasse :
                        #  - pas de nouvelles exceptions lancées, sauf si 
                        #    celles-ci sont elles-mêmes enfants des exceptions 
                        #    du parent
                        #  - pas plus de préconditions (mais moins possible)
                        #  - au moins les mêmes postconditions (mais plus 
                        #    possible)
                        #  - mêmes invariants
                        #De plus, si A, B, C, D, etc. est une hierarchie de
                        #classes, avec A comme base classe et Z comme dernière
                        #classe, et que Superclasse prend M* comme argument,
                        #alors Subclasse doit :
                        #  - prendre un argument de type entre A et M (argument
                        #    contravariant), sinon Subclasse ne peut pas se
                        #    substituer à Superclasse, car pouvant accepter un
                        #    range d'inputs plus petits
                        #  - retourner une valeur de type entre M et Z (return
                        #    type covariante), sinon pas de substitution, car
                        #    Subclasse peut renvoyer des outputs au-delà du 
                        #    range attendu d'un Superclasse
                        #  - donc par rapport à son parent, être libéral à
                        #    l'input et strict à l'output
                        #Ex de violation : une classe Carré, enfant de 
                        #Rectangle, car ajoute la Précondition "tous côtés 
                        #égaux" absent de Rectangle, qui pourrait par exemple
                        #avoir un SetHorizontalEdges() + SetVerticalEdges()
                        #séparés.
Interface-segregation   #Une interface ne doit pas devenir une God Class, sinon
                        #il faut la diviser en plusieurs interfaces.
Dependancy Inversion    #Normalement, les dépendances se font par le haut :
                        #  - les détails de l'implémentation peuvent changer,
                        #    mais doivent rentrer dans l'interface des modules
                        #    supérieurs (ces premiers dépendent de cette 
                        #    dernière)
                        #  - si les modules supérieurs changent, ceux inférieurs
                        #    doivent être changés
                        #Pour éviter cela, on peut ajouter un layer entre les
                        #deux. Le layer spécifie une norme que l'implémentation
                        #doit donner, et l'interface recevoir. Exemple : 
                        #couche TCP/IP.
                        #Il faut donc rajouter une interface entre chaque couche
                        #supérieurs/inférieurs, afin de pouvoir modifier aussi
                        #librement les modules supérieurs.

ORTHOGONALITY ==>       #Fait que la modification d'un module d'un programme ne
                        #modifie pas les autres modules (side effects). Impliqué
                        #par le "Single responsibility" principle.

GRANULARITY ==>         #Fait de décomposer un système en un maximum de petites
                        #classes/objets.

SCALABILITY ==>         #Fait de pouvoir extend un system facilement.

12 FACTOR ==>           #Create isolated apps that scale up, behave as expected and easy to config.
                        #Isolated apps:
                        #  - one repo === one app
                        #  - dependency -> dependency manager:
                        #     - no system-wide dependency
                        #     - run in isolated environment (e.g. nvm|pyenv) to make sure
                        #  - local/remote backing services (databases, etc.) -> URL only
                        #     - if should communicate, export itself by listening to localhost:PORT
                        #That scale up:
                        #  - stateless/share-nothing processes
                        #  - automated:
                        #     - start on boot
                        #     - fast startup, graceful shutdown (SIGTERM or sudden death)
                        #     - timestamp releases
                        #Behaves as expected, i.e. branches are as close as possible, and easy tp config:
                        #  - same people (devOps), same tools (OS, backing services), continuous deployment
                        #     - use container (Vagrant, etc.)
                        #  - logs to stdout (branch-specific config redirects it)
                        #  - admin scripts run in same environment as the app itself (e.g. REPL)
                        #  - steps:
                        #     - build, not branch-specific: most should happen here
                        #     - release, branch-specific: only adds config (ENVVAR-only, not in code)
                        #     - run: should be minimalistic
