
                 
   REUSABILITY   
                 



REUSING ==>                       #Difference between reusing:
                                  #  - when adding new features, i.e. easier
                                  #  - after features were added, i.e. goal is to increase modularity
                                  #Reusability:
                                  #  - encouraging the first one (although it might help second one too)
                                  #  - i.e. increases extensibility
                                  #Also called "standing on the shoulders of giants"

OPEN/CLOSE PRINCIPLE ==>          #Interfaces should encourage being extended, as opposed to being modified.
                                  #I.e. limit|simplify the parts that need modification|addition in order to extend
                                  #"O" of SOLID principles

POLYMORPHISM ==>                  #See polymorphism doc

CUT-AND-PASTE PROGRAMMING ==>     #Antipattern also called "clipboard coding" or "software cloning|propagation"
                                  #Code reuse that:
                                  #  - does not understand the initial code well enough
                                  #  - i.e. does not adapt it to current case perfectly

REINVENTED THE WHEEL ==>          #Re-implementing instead of reusing existing tools/libraries
                                  #Might be due to:
                                  #  - not knowing those tools exist
                                  #  - "design around": avoidin patents conflicts
                                  #  - "not invented here": 
                                  #     - conscious choice.
                                  #     - possible reasons:
                                  #        - desire for flexibility: which can be avoided by using customizable tools
                                  #        - desire for security: which relies on the fallacy that in-house will be more secure
                                  #        - avoiding vendor lock-in: which can be avoided by using tools with high interchangeabibility,
                                  #          e.g. open-source software and open standards-based tools
                                  #     - opposite is "PFE" (Proudly Found Elsewhere) or "Invented elsewhere"
