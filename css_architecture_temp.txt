
                           
   CSS_ARCHITECTURE_TEMP   
                           


BEM or RSCSS:
  - parts are dasherized, or camelcased
  - only use .CLASS selectors:
     - with possibly :PSEUDO
     - but not tag selectors, attribute selectors, combinations nor *
  - no !important
  - use namespaced js-CLASS for JavaScript selection
  - indent according to the depth level

BEM:
  - selector is .BLOCK[__ELEMENT][--MODIFIER[--MODIFIERVALUE]][.is|has-STATE]:
     - BLOCK: [sub]component (unique across app)
        - often at least two words
        - sometimes namespaced: c- (component), o- (object), u- (utility)
     - ELEMENT: [sub]component's part (unique across BLOCK)
        - only one level of depth, no BLOCK__ELEMENT__SUBELEMENT
        - when too many subelements, should be extracted as a BLOCK instead
     - MODIFIER: styling state
        - always local to a specific BLOCK[__ELEMENT] (no global MODIFIER)
        - HTML need to have both selectors: with and without MODIFIER
        - responsive suffix:
           - @MODIFIER instead of --MODIFIER
           - used for media queries breakpoints, browser or theming
     - STATE: interaction state
        - :PSEUDO can be used instead or in addition to STATE
        - always local to a specific BLOCK[__ELEMENT] (no global STATE)
        - dynamically changed by JavaScript (as opposed to BLOCK, ELEMENT and MODIFIER)
  - can sometimes use _ or - instead of __ or --
  - a given DOM element can be several BLOCK|ELEMENT ('BEM' mixin)
  - file organization: BLOCK/[__ELEMENT/][--MODIFIER/][.is-STATE/]FULL_SELECTOR.css|js|png|etc.


bem-constructor:
  - Sass mixin (1.0.0) to write BEM notation
  - Each mixin can take extra argument, which is same as making several calls

@include object('BLOCK'[, 'object|component|utility']) {      .o|c|u-BLOCK
  @include element('ELEMENT') {...}                           .o-BLOCK__ELEMENT {...}
  @include modifies-element('ELEMENT') {...}                  > .o-BLOCK__ELEMENT {...}
  @include modifier('MODIFIER') {...}                         .o-BLOCK[__ELEMENT]--MODIFIER{...}
  @include state('STATE') {...}                               .o-BLOCK[__ELEMENT].is-MODIFIER{...}
  @include suffix('MODIFIER') {...}                           .o-BLOCK[__ELEMENT]@MODIFIER{...}
  @include theme('THEME') {...}                               .t-THEME .o-BLOCK {...}
}  

Variables:
  - $bem-block-namespaces.TYPE STR (def: 'object|component|utility' 'o|c|u') 
  - $bem-use-namespaces BOOL (def: true): for .o|c|u-
  - $bem-element-separator (def: '__')
  - $bem-modifier-separator (def: '--')
  - $bem-state-namespace (def: 'is')
  - $bem-suffix-namespace (def: '@')
  - $bem-theme-namespace (def: 't')

@bem-debug(): show some color borders to distinguish components, elements, modifiers, etc.



RSCSS:
  - selector is .BLOCK[.-MODIFIER] [>] .ELEMENT[-MODIFIER]
     - BLOCK (called "component"): like BEM, but must be at least two different words
     - ELEMENT: like BEM
     - MODIFIER (called "variant")
     - >: otherwise might target .BLOCK .ANOTHERBLOCK .ELEMENT
  - file organization: BLOCK.css
  - focus on using UI component:
     - 1 UI component === 1 BLOCK
     - BLOCK declaration should not use positioning (so can be reused in different contexts)
        - but BLOCK2 using BLOCK might position BLOCK, and BLOCK might position ELEMENT, as long as it does not assume things
          about how that other element work internally
     - single responsibility: should break down big UI components



Trello CSS style guide:
  - reuse most of BEM ideas but use .BLOCK-ELEMENT[-...][.mod|is-MODIFIER]
  - reuse RSCSS focus on UI components
  - files order:
     - main file: CSS reset, variables, mixins/functions, components
     - component: .BLOCK, .BLOCK-ELEMENT, .BLOCK[-ELEMENT].mod-MODIFIER, .BLOCK[-ELEMENT].is-MODIFIER, @media queries
  - avoid .CLASS .CLASS2:
     - only: 
        - when a UI component override another component:
           - override can be e.g. positioning
           - but must not overriding the inside of that other component. The other component should define MODIFIER instead.
        - .BLOCK--MODIFIER .BLOCK__ELEMENT (because .BLOCK--MODIFIER__ELEMENT is not correct syntax)
     - not:
        - specify a subelement: use naming syntax instead
     - as such, rarely need to use Less/Sass nesting
        - should still use it for &:PSEUDO
  - Less/Sass:
     - only use very simple mixins/functions/inheritance:
        - prefix with m|u-
     - use variables, including for media queries


grvcoelho CSS style guide:
  - reuse BEM: .BLOCK[__ELEMENT][--MODIFIER][.is-MODIFIER]
  - CSS formatting:
     - newline after selector-, or ;
     - two newlines after }
     - space after : (not before)
  - reuse "avoid .CLASS .CLASS2" from Trello CSS style guide


MCSS:
  - divide into layers, in order:
     - CSS reset
     - context: media queries breakpoints, browser or theming
     - cosmetic styling: common generic styling (e.g. clearfix, padding, etc.)
     - base components: as abtract as possible
     - project components: specific to a given page/region/use-case
  - each layer:
     - can only use same or upper layer CSS classes/variables:
        - exception: cosmetic styling can be used but not overriden
     - can be defined as:
        - CSS classes: components, cosmetic styling, context (e.g. on body)
        - variable or simple mixins/functions/inheritance: cosmetic styling, context
     - has its own file or directory
  - can use abbreviation list to keep CSS classnames short
  - use composition over inheritance for components


SMACSS:
  - divide into layers:
     - base: CSS reset + common generic styling
     - theme
     - layout: layout-related UI components BLOCK
     - module: other UI components BLOCK
     - state: UI components MODIFIER/STATE
  - each layer:
     - has its own file or directory
     - has its own prefix
  - reuse RSCSS focus on UI components
  - reuse OOCSS naming scheme


OOCSS:
  - separate:
     - structure: UI component, with only invariant structure, behavior and styling
     - skin: 
        - variant styling: 1 UI component can have many skins (similar to BEM MODIFIER|STATE)
        - cross-UI-component: 1 skin can be applied to many UI components (similar to global BEM MODIFIER|STATE)
  - reuse RSCSS focus on UI components
  - naming scheme: add extra CSS class to define skin or extend component


Atomic CSS:
  - use CSS classes that reflect CSS props/vals, instead of being an abtraction layer between HTML and CSS:
     - use syntax [ANCESTORCLASS[:PSEUDO]_]FUNC[(VAL|VAR...)][!][:[:]PSEUDO][--MEDIA_QUERY]
        - ! is !important
        - FUNC: CSS props being styled, based on Emmet abbreviation, with some extensions
     - a tool (atomizer) exists to create CSS stylesheets based on atomic class name that are used


CSS in JavaScript:
  - component-scoped, so does not need naming scheme
  - can use JavaScript logic
  - see "CSS alternatives"


cssguidelin.es:
  - CSS formatting:
     - 4 spaces indent
     - 80 chars columns
     - newline after selector-, if unrelated selector
     - newline after ;
     - space before {
     - space after : (not before)
     - indent according to depth level
     - indent to vertically align related rules values (e.g. top:   0; bottom: 0;)
     - one newline after related rulesets, two after unrelated inside same section, five between sections
  - comment:
     - use comment header before each section
     - when selector from another file is being overriden
  - HTML formatting:
     - classes: one space between related classes, two spaces otherwise
     - one newline between interdependant <TAG>, two between closely related <TAG>, fiven between less related <TAG>
  - reuse "avoid .CLASS .CLASS2" from Trello CSS style guide
  - reuse BEM
  - reuse RSCSS focus on UI components:
     - make components as abstract as possible, including in classnames chosen
  - reuse OOCSS separation of structure and skin
  - reuse MCSS "composition over inheritance"


mdo code guide:
  - CSS formatting:
     - 2 spaces indent
     - "", not ''
     - newline after selector-, ;
     - space after VAL-, except if inside FUNC()
     - space before {
     - no newline around { } if only one prop/val
     - space after : (not before)
     - .5 (not 0.5)
     - unitless 0
     - lowercase hex value
     - props order: positioning, box model, typography, visual, misc
     - put @media-queries close to related code without the @media-queries
     - indent to vertically align related rules values (e.g. top:   0; bottom: 0;)
     - no shorthand properties
  - HTML formatting:
     - <TAG>, not <TAG/>
     - use <!DOCTYPE html>
     - <html lang="en-us">
     - <meta charset="UTF-8">
     - <link rel="stylesheet" href="URL">
     - <script src="URL">
     - attributes order: class, id|name, data-*, src|for|type|href|value, title|alt, role|aria-*
     - boolean attribute: checked, not checked="checked"
     - avoid HTML in JavaScript
