ANIMATION VS KEYFRAME ==>         #Keyframes are a specific type (and the only one so far) of animation where properties are interpolated.

AnimationEffectReadonly           #Animation type
ANIMATIONEFFECTREADONLY.timing    #TIMING
TIMING.delay                      #NUM (def: 0). Like CSS
TIMING.endDelay                   #NUM (def: 0). Like delay, but at the end (e.g. delay finish event)
TIMING.duration                   #NUM (def: 0). Like CSS
TIMING.direction                  #STR (def: 'normal'). Like CSS
TIMING.easing                     #STR (def: 'linear'). Like CSS
TIMING.iterationStart             #NUM (def: 0)
TIMING.iterations                 #NUM (def: 1, can be Infinity)
TIMING.fill                       #STR: 'none' (def), 'forwards', 'backwards', 'both', 'auto'
ANIMATIONEFFECTREADONLY
.getComputedTiming()->CTIMING     #
CTIMING.delay|...|iterations      #Like TIMING
CTIMING.localTime                 #NUM|null
CTIMING.endTime                   #NUM
CTIMING.activeDuration            #NUM
CTIMING.progress                  #null|NUM (0-1)
CTIMING.currentIteration          #null|NUM (starts at 0)

KEYFRAMES                         #Keyframes transformations. Can be:
                                  #  - OBJ_ARR:
                                  #     - PROP: VAL
                                  #     - offset NUM (0-1): percentage of where it happens (def: interpolate)
                                  #     - easing, composite: see below
                                  #  - OBJ: PROP: VAL_ARR
                                  #  - new SharedKeyframeList(KEYFRAMES)
                                  #     - is like KEYFRAMES, except KEYFRAMES will only be parsed the first ANIMATION that uses it

KEYFRAMEEFFECT[READONLY]: 
  - inherits from ANIMATIONEFFECT[READONLY]
  - new KeyframeEffect[ReadOnly]([ELEM[, KEYFRAMES[, KEYFRAMEEFFECTOPTIONS]]])
     - KEYFRAMEEFFECTOPTIONS: same as ANIMATIONEFFECT[READONLY].timing with also:
        - composite STR: if an animated PROP is animated by another ANIMATION, how do they mix:
           - 'replace' (def): overrides, e.g. 'translateX(VAL)' + 'translateX(VAL2)' -> 'translateX(VAL)'
           - 'add': concanates, e.g. 'translateX(VAL)' + 'translateX(VAL2)' -> 'translateX(VAL) translateX(VAL2)'
           - 'accumulate': add values, e.g. 'translateX(VAL)' + 'translateX(VAL2)' -> 'translateX(VAL+VAL2)'
        - iterationComposite STR: 'replace' (def), 'accumulate'
        - spacing STR: 'distribute' (def), 'paced'
  - target ELEM|null
  - composite, iterationComposite, spacing: see KEYFRAMEEFFECTOPTIONS
  - getKeyframes()->KEYFRAMES
     - using OBJ_ARR syntax
     - also add:
        - computedOffset NUM
  - setKeyframes(KEYFRAMES): not if readonly

ELEM|CSSPSEUDOELEM.animate(...)   #Same as: 
->ANIMATION                       #  let effect = new KeyframeEffectReadOnly(ELEM, ...);
                                  #  let animation = new Animation(effect, ELEM.ownerDocument.timeline);
                                  #  animation.play();
                                  #Except can specify KEYFRAMEEFFECTOPTIONS.id for the ANIMATION.id

ANIMATION:
  - new Animation([ANIMATIONEFFECTREADONLY[, ANIMATIONTIMELINE]])
     - def ANIMATIONTIMELINE: DOCUMENT.timeline
  - currentTime NUM|null
  - startTime NUM
  - effect ANIMATIONEFFECTREADONLY
  - finished PROMISE(ANIMATION)
  - ready PROMISE(ANIMATION)
  - id STR
  - playState STR: 'idle', 'pending', 'running', 'paused', 'finished'
  - playbackRate NUM (def: 1)
  - timeline ANIMATIONTIMELINE
  - oncancel|onfinish = FUNC(ANIMATIONPLAYBACKEVENT)
     - ANIMATIONPLAYBACKEVENT:
        - inherits from EVENT
        - currentTime NUM|null
        - timelineTime NUM|null
  - cancel()
  - finish()
  - pause()
  - play()
  - reverse()

ELEM|CSSPSEUDOELEM|DOCUMENT
.getAnimations()->ANIMATION_ARR   #

DOCUMENT:
  - timeline DOCUMENTTIMELINE
ANIMATIONTIMELINE
  - currentTime NUM|null
DOCUMENTTIMELINE:
  - inherits from ANIMATIONTIMELINE
  - new DocumentTimeline(NUM)
