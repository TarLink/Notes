ANIMATION VS KEYFRAME ==>         #Keyframes are a specific type (and the only one so far) of animation where properties are interpolated.

ELEM|CSSPSEUDOELEM.animate(...)   #Same as: 
->ANIMATION                       #  let effect = new KeyframeEffectReadOnly(ELEM, ...);
                                  #  let animation = new Animation(effect, ELEM.ownerDocument.timeline);
                                  #  animation.play();
                                  #Except can specify KEYFRAMEEFFECTOPTIONS.id for the ANIMATION.id
ELEM|CSSPSEUDOELEM|DOCUMENT
.getAnimations()->ANIMATION_ARR   #Includes animations created using CSS

new Animation([ANIMEFFECTREADONLY #Animation instance
[, ANIMATIONTIMELINE]])           #def ANIMATIONTIMELINE: DOCUMENT.timeline
ANIMATION.effect                  #ANIMATIONEFFECTREADONLY
ANIMATION.timeline                #ANIMATIONTIMELINE
ANIMATION.id                      #STR (def: null)
ANIMATION.currentTime             #See TIMELINE.currentTime
ANIMATION.startTime               #ANIMATION.currentTime at animation start:
                                  #  - when started playing (past) 
                                  #  - or when will be played (future)
ANIMATION.playbackRate            #How fast TIMELINE.currentTime progress. 
                                  #NUM (def: 1) (can be negative, or 0)
ANIMATION.reverse()               #Changes direction
ANIMATION.playState               #Similar to CSS animation-play-state but more values: 
                                  #  - 'pending': before start, if startTime is specified
                                  #  - 'idle': before start, if startTime is unspecified
                                  #  - 'running': between start and end
                                  #  - 'paused': after ANIMATION.pause()
                                  #  - 'finished': after end
ANIMATION.play()                  #[Re]starts from beginning, playState -> 'running'
ANIMATION.pause()                 #Stops, playState -> 'paused'
ANIMATION.finish()                #Goes to end|beginning (depending on direction), playState -> 'finished'
ANIMATION.cancel()                #Removes any animation, playState -> 'idle'
ANIMATION.ready                   #PROMISE, resolved with ANIMATION when playState !== 'pending|idle'
ANIMATION.finished                #PROMISE, resolved with ANIMATION when playState === 'finished'
ANIMATION.oncancel|finish =       #ANIMATIONPLAYBACKEVENT:
FUNC(ANIMATIONPLAYBACKEVENT)      #  - currentTime NUM|null
                                  #  - timelineTime NUM|null
ANIMATION.onfinish =
FUNC(ANIMATIONPLAYBACKEVENT)      #

AnimationEffectReadonly           #Animation type
ANIMATIONEFFECTREADONLY.timing    #TIMING
ANIMATIONEFFECTREADONLY.
getComputedTiming()->CTIMING      #

new KeyframeEffect[ReadOnly]
([ELEM[, KEYFRAMES                #Keyframe type
[, KEYFRAMEEFFECTOPTIONS]]])      #Inherits from AnimationEffect[Readonly]
KEYFRAMEEFFECT[READONLY].target   #ELEM|null
KEYFRAMEEFFECT[READONLY].         #KEYFRAMES:
getKeyframes()->KEYFRAMES         #  - uses OBJ_ARR syntax
                                  #  - also add computedOffset: like offset but with computed default values when unspecified
KEYFRAMEEFFECT[READONLY].
setKeyframes(KEYFRAMES|null)      #Not if readonly
KEYFRAMEEFFECT[READONLY].delay|...#Same properties as KEYFRAMEEFFECTOPTIONS

KEYFRAMES                         #Keyframes transformations. Can be:
                                  #  - OBJ_ARR:
                                  #     - PROP: VAL
                                  #     - offset NUM (0-1): percentage of where it happens (def: see KEYFRAMEEFFECTOPTIONS.spacing)
                                  #     - easing, composite: see below
                                  #  - OBJ: PROP: VAL_ARR
                                  #  - new SharedKeyframeList(KEYFRAMES)
                                  #     - is like KEYFRAMES, except KEYFRAMES will only be parsed the first ANIMATION that uses it

AnimationEffectTiming             #TIMING: animation options
ComputedTiming                    #CTIMING: computed animation options
KeyframeEffectOptions             #Keyframes options. Inherits from TIMING

TIMING.delay|duration|direction|  #Like CSS animation-delay|duration|direction|timing-function|iteration-count|fill-mode
easing|iterations|fill            #(including default values). Note:
                                  #  - iterations can use Infinity
                                  #  - fill|duration can use 'auto' (same as 'none'|0, and converted to it in CTIMING)
TIMING.endDelay                   #NUM (def: 0). Like delay, but at the end (i.e. delay finishing)
TIMING.iterationStart             #NUM (def: 0). Where to start (can use float number)
CTIMING.delay|...|iterationStart  #Like TIMING
CTIMING.localTime                 #TIMELINE.currentTime now
CTIMING.endTime                   #TIMELINE.currentTime when animation will be over
CTIMING.activeDuration            #duration * iterations
CTIMING.currentIteration          #NUM|null (starts at 0): current iteration index
CTIMING.progress                  #NUM|null (0-1): current iteration progress
KEYFRAMEEFFECTOPTIONS.composite   #If an animated PROP is animated by another ANIMATION, how do they mix:
                                  #  - 'replace' (def): overrides,  e.g. 'translateX(VAL)' + 'translateX(VAL2)' -> 'translateX(VAL)'
                                  #  - 'add':           concanates, e.g. 'translateX(VAL)' + 'translateX(VAL2)' -> 'translateX(VAL) translateX(VAL2)'
                                  #  - 'accumulate':    add values, e.g. 'translateX(VAL)' + 'translateX(VAL2)' -> 'translateX(VAL+VAL2)'
KEYFRAMEEFFECTOPTIONS.            #How animated PROP mix when an interation last keyframe and next iteration's first keyframe coincide:
iterationComposite                #  - 'replace' (def): see KEYFRAMEEFFECTOPTIONS.composite
                                  #  - 'accumulate': see KEYFRAMEEFFECTOPTIONS.composite
KEYFRAMEEFFECTOPTIONS.spacing     #Def offset for keyframes with none specified:
                                  #  - 'distribute' (def): interpolate time-wise
                                  #  - 'paced': interpolate value-wise
                                  #Ex: 
                                  #  - [ { offset: 0, PROP: 0 }, { PROP: 0.2 }, { offset: 1, PROP: 1 } 
                                  #  - missing offset will be: 0.5 (distribute) or 0.2 (paced)

AnimationTimeline                 #Contains:
                                  #  - start time: 
                                  #     - when animations will start (future) or started (past)
                                  #     - Unix time (in ms).
                                  #  - current time: 
                                  #     - current animations offset
                                  #     - offset from start time (in ms) 
                                  #     - null if negative
                                  #     - multiplied by playbackRate
                                  #     - null if not started yet
ANIMATIONTIMELINE.currentTime     #NUM|null
new DocumentTimeline(NUM)         #Inherits from ANIMATIONTIMELINE. 
                                  #Start time === navigationStart Unix time + NUM
DOCUMENT.timeline                 #Is new DocumentTimeline(0)
