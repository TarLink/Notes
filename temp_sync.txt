<img|video|audio|object|iframe|svg>: 
  - does not block (because might take long)
  - can listen to load event

<style>, inline <style>: 
  - block parsing (because is directly parsed)
  - consider using external files instead if requires async (e.g. big)

Dynamically added <script src> or CSS <link>:
  - does not block parsing nor rendering

<script src>:
  - if async|defer: does not block parsing
  - otherwise: block parsing

CSS <link>:
  - Parsing:
     - blocked at next <script> (because <script> might use CSSOM)
  - Rendering:
     - in <head>: blocked (upfront dependency)
     - in <body>: block after (not before) (component dependency)
  - Exceptions:
     - Safari: block parsing and rendering under any condition, including dynamically adding
     - Firefox, in <body>: 
        - does not block rendering after nor before
        - can fix it by adding empty <script> just after <link> to block parsing (hence blocking rendering)

Performance problem:
  - should try parallel/async when possible, but sometimes serial/sync is needed:
     - CSS -> HTML: 
        - showing unstyled HTML is ugly and leads to FOUC (Flash of unstyled content), i.e. DOM jumping around
        - possible fixes:
           - block rendering by using <style> (if added dynamically) or <link> (in <body>, followed by empty <script>) before HTML
           - async load CSS, temporarily putting display: none on related HTML
              - possible async CSS load: 
                 - dynamically adding it
                 - <link rel="preload" url="URL.css" as="style" onload="this.rel = 'stylesheet';">
     - HTML -> JavaScript:
        - when script uses DOM
        - possible fixes: 
           - "defer" 
           - DOMContentLoaded
           - (older trick) <script> at end of <body>
     - CSS -> JavaScript:
        - when script uses CSSOM
        - fixes: CSS always blocks JavaScript. 
  - if no dependency should asynchronously load CSS or JavaScript
  - should group into components so that CSS/HTML only delay the HTML/JavaScript it depends on
     - above the fold / critical path CSS:
        - make first displayed DOM's CSS sync (e.g. using <link> in <head>), other CSS async
        - rougher approach to components-approach when not possible



Prefetching / Resource hints:
  - any <link>:
     - ATTR:
        - crossorigin: for CORS request (browser support???) (attribute value???)
        - media MEDIAQUERYLIST
     - fire load|error event
  - general:
     - can use either:
         <link href="URL" rel="REL" ATTR="VAL" ...>...
         Link: <URL>; rel=REL[; ATTR=VAL]... [, <URL>...] [S]
     - ATTR.pr 'FLOAT' (0-1): 
        - probability the link will be followed 
        - used for prioritization or reducing optimization/fetching
     - does not delay document.onload
     - could previously use noop XHR to achieve something similar
     - can be:
        - speculative: before user interaction that might trigger HTTP request
        - reactive: after user interaction that will certainly trigger HTTP request, after some delay
     - cannot see in devtools network tab, but can see "prerender" using chrome://net-internals/#prerender
     - possible problems:
        - when HTTP GET request has side effects (which is improper)
        - increase bandwith usage
        - overestimate tracking (ads, analytics):
           - can use document.visibilityState 'prerender' to handle it
        - security: website make decision (not user) to trust content by browsing it
  - REL types:
     - use cases:
        - resources for current navigation action: preload
        - resources for next navigation action:
           - path is known:
              - very likely
           - path is unknown:

           - very likely: prerender
           - potential:
              - path is known: prefetch
              - path is unknown: preconnect, dns-prefetch
     - preload:
        - effect: does HTTP request async right away but does not parse/execute resource (only used for caching)
        - ATTR:
           - as TYPE: 
              - WINDOW.fetch() destination type, 
                i.e. script|style|image|font|media|object|embed|document|xslt|manifest|report|service|shared]worker
              - used for CSP and Accept [C]
           - nopush: if a HTTP2 server push has been received for that resource, do not use it
        - can use load event listener with "preload" to emulate (for any resource type):
           - <script> async: by adding to the DOM the resource
           - <script> defer: by also waiting for some order logic
        - browser support: only Chrome/Opera
     - prefetch:
        - does HTTP request after document.onload but does not parse/execute resource (only used for caching)
        - should use "preload" if needed for current navigation action, "prefetch" for potential next action
        - browser support: not [mobile] Safari nor Opera mini
        - ATTR.as: like preload
     - dns-prefetch:
        - same as prefetch, but for DNS request
        - browser support: not Opera mini
     - prerender:
        - does HTTP request after document.onload, and parse/execute resource:
           - in the background, i.e. not visible but will provide fast caching
           - only kept for short while, so should be next navigation
           - resource intensive: should only be used when confident about next navigation action
        - only HTML resources
        - browser support: only Chrome/Opera/IE
     - preconnect:
        - does DNS+TLS+TCP request right away
        - use case: like prefetch but when only domain is known, not URL path
        - browser support: only Chrome/Opera/Firefox
   



Check if concatenation really does not make sense anymore with HTTP2

Check https://www.keycdn.com/blog/resource-hints/
