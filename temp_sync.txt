<img|video|audio|object|iframe|svg>: 
  - does not block (because might take long)
  - can listen to load event

<style>, inline <style>: 
  - block parsing (because is directly parsed)
  - consider using external files instead if requires async (e.g. big)

Dynamically added <script src> or CSS <link>:
  - does not block parsing nor rendering

<script src>:
  - if async|defer: does not block parsing
  - otherwise: block parsing

CSS <link>:
  - Parsing:
     - blocked at next <script> (because <script> might use CSSOM)
  - Rendering:
     - in <head>: blocked (upfront dependency)
     - in <body>: block after (not before) (component dependency)
  - Exceptions:
     - Safari: block parsing and rendering under any condition, including dynamically adding
     - Firefox, in <body>: 
        - does not block rendering after nor before
        - can fix it by adding empty <script> just after <link> to block parsing (hence blocking rendering)

Performance problem:
  - should try parallel/async when possible, but sometimes serial/sync is needed:
     - CSS -> HTML: 
        - showing unstyled HTML is ugly and leads to FOUC (Flash of unstyled content), i.e. DOM jumping around
        - possible fixes:
           - block rendering by using <style> (if added dynamically) or <link> (in <body>, followed by empty <script>) before HTML
           - async load CSS, temporarily putting display: none on related HTML
              - possible async CSS load: 
                 - dynamically adding it
                 - <link rel="preload" url="URL.css" as="style" onload="this.rel = 'stylesheet';">
     - HTML -> JavaScript:
        - when script uses DOM
        - possible fixes: 
           - "defer" 
           - DOMContentLoaded
           - (older trick) <script> at end of <body>
     - CSS -> JavaScript:
        - when script uses CSSOM
        - fixes: CSS always blocks JavaScript. 
  - if no dependency should asynchronously load CSS or JavaScript
  - should group into components so that CSS/HTML only delay the HTML/JavaScript it depends on
     - above the fold / critical path CSS:
        - make first displayed DOM's CSS sync (e.g. using <link> in <head>), other CSS async
        - rougher approach to components-approach when not possible


Prefetching / resource hints:
  - can use either:
      Link: <URL>; rel=REL[; ATTR=VAL]... [, <URL>...] [S]
      <link href="URL" rel="REL" ATTR="VAL" ...>...
  - REL types:
+--------------+-------------------------------------------------+------------------------------------------------+------------------------------------+
| Type         | Use case                                        | Effects                                        | Browser support                    |
|              +--------------------+---------------+------------+-----------------------+----------+-------------+------------------------------------+
|              | Resource for which | Resource path | Likelihood | When is request done  | Parse/   | Protocols   |                                    |
|              | navigation action  | is known      |            |                       | execute  |             |                                    |
+--------------+--------------------+---------------+------------+-----------------------+----------+-------------+------------------------------------+
| preload      | Current            | Yes           | Certain    | async right away      | No       | HTTP        | Chrome/Opera                       |
+--------------+--------------------+---------------+------------+-----------------------+----------+-------------+------------------------------------+
| prerender    | Next               | Yes           | High       | after document.onload | Yes      | HTTP        | Chrome/Opera/IE                    |
+--------------+--------------------+---------------+------------+-----------------------+----------+-------------+------------------------------------+
| prefetch     | Next               | Yes           | Middle-low | after document.onload | No       | HTTP        | not [mobile] Safari nor Opera mini |
+--------------+--------------------+---------------+------------+-----------------------+----------+-------------+------------------------------------+
| preconnect   | Next               | No            | High       | after document.onload | No       | DNS         | Chrome/Opera/Firefox               |
+--------------+--------------------+---------------+------------+-----------------------+----------+-------------+------------------------------------+
| dns-prefetch | Next               | No            | Middle-low | after document.onload | No       | DNS+TCP/TLS | not Opera mini                     |
+--------------+--------------------+---------------+------------+-----------------------+----------+-------------+------------------------------------+
  - ATTR:
     - pr 'FLOAT' (0-1) (all)
        - probability the link will be followed 
        - used for prioritization or reducing optimization/fetching
     - as TYPE (preload|prefetch): 
        - WINDOW.fetch() destination type, 
          i.e. script|style|image|font|media|object|embed|document|xslt|manifest|report|service|shared]worker
        - used for CSP and Accept [C]
     - nopush (preload): if a HTTP2 server push has been received for that resource, do not use it
  - prerender parsing/execution:
     - in the background, i.e. not visible but will provide very fast cache
     - only kept for short while, so should be next navigation
     - resource intensive: should only be used when confident about next navigation action
     - only HTML resources
  - does not delay document.onload
  - could previously use noop XHR to achieve something similar
  - cannot see in devtools network tab, but can see "prerender" using chrome://net-internals/#prerender
  - can be:
     - speculative: before user interaction that might trigger HTTP request
     - reactive: after user interaction that will certainly trigger HTTP request, after some delay
  - possible problems:
     - when HTTP GET request has side effects (which is improper)
     - increase bandwith usage
     - overestimate tracking (ads, analytics):
        - can use document.visibilityState 'prerender' to handle it
     - security: website make decision (not user) to trust content by browsing it
   


Rework HTTP documentation

Check HTTP2 features

Check if concatenation really does not make sense anymore with HTTP2
