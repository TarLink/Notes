<img|video|audio|object|iframe|svg>: 
  - does not block (because might take long)
  - can listen to load event

<style>, inline <style>: 
  - block parsing (because is directly parsed)
  - consider using external files instead if requires async (e.g. big)

Dynamically added <script src> or CSS <link>:
  - does not block parsing nor rendering

<script src>:
  - if async|defer: does not block parsing
  - otherwise: block parsing

CSS <link>:
  - Parsing:
     - blocked at next <script> (because <script> might use CSSOM)
  - Rendering:
     - in <head>: blocked (upfront dependency)
     - in <body>: block after (not before) (component dependency)
  - Exceptions:
     - Safari: block parsing and rendering under any condition, including dynamically adding
     - Firefox, in <body>: 
        - does not block rendering after nor before
        - can fix it by adding empty <script> just after <link> to block parsing (hence blocking rendering)

Performance problem:
  - should try parallel/async when possible, but sometimes serial/sync is needed:
     - CSS -> HTML: 
        - showing unstyled HTML is ugly and leads to FOUC (Flash of unstyled content), i.e. DOM jumping around
        - possible fixes:
           - block rendering by using <style> (if added dynamically) or <link> (in <body>, followed by empty <script>) before HTML
           - async load CSS, temporarily putting display: none on related HTML
              - possible async CSS load: 
                 - dynamically adding it
                 - <link rel="preload" url="URL.css" as="style" onload="this.rel = 'stylesheet';">
     - HTML -> JavaScript:
        - when script uses DOM
        - possible fixes: 
           - "defer" 
           - DOMContentLoaded
           - (older trick) <script> at end of <body>
     - CSS -> JavaScript:
        - when script uses CSSOM
        - fixes: CSS always blocks JavaScript. 
  - if no dependency should asynchronously load CSS or JavaScript
  - should group into components so that CSS/HTML only delay the HTML/JavaScript it depends on
     - above the fold / critical path CSS:
        - make first displayed DOM's CSS sync (e.g. using <link> in <head>), other CSS async
        - rougher approach to components-approach when not possible


Prefetching / Resource hints:
  - any <link>:
     - ATTR:
        - crossorigin: for CORS request (browser support???) (attribute value???)
        - media MEDIAQUERYLIST
     - fire load|error event
  - general:
     - can use either:
         <link href="URL" rel="REL" ATTR="VAL" ...>...
         Link: <URL>; rel=REL[; ATTR=VAL]... [, <URL>...] [S]
     - ATTR.pr 'FLOAT' (0-1): 
        - probability the link will be followed 
        - used for prioritization or reducing optimization/fetching
     - does not delay document.onload
     - could previously use noop XHR to achieve something similar
     - can be:
        - speculative: before user interaction that might trigger HTTP request
        - reactive: after user interaction that will certainly trigger HTTP request, after some delay
     - cannot see in devtools network tab, but can see "prerender" using chrome://net-internals/#prerender
     - possible problems:
        - when HTTP GET request has side effects (which is improper)
        - increase bandwith usage
        - overestimate tracking (ads, analytics):
           - can use document.visibilityState 'prerender' to handle it
        - security: website make decision (not user) to trust content by browsing it
  - REL types:
     - use cases:
        - resources for current navigation action: preload
        - resources for next navigation action:
           - path is known:
              - very likely: prerender
              - potential: prefetch
           - path is unknown:
              - likely: preconnect
              - probable: dns-prefetch
     - effects:
        - request async right away:
           - does not parse/execute resource:
              - HTTP: preload
              - DNS: preconnect
        - request after document.onload
           - does not parse/execute resource:
              - HTTP: prefetch
              - DNS+TLS+TCP: preconnect
           - parse/execute resource in background: 
              - HTTP: prerender
     - browser support:
        - not Opera mini: dns-prefetch
        - not [mobile] Safari nor Opera mini: prefetch
        - only Chrome/Opera/Firefox: preconnect
        - only Chrome/Opera/IE: prerender
        - only Chrome/Opera: preload
     - ATTR:
        - as TYPE (preload|prefetch): 
           - WINDOW.fetch() destination type, 
             i.e. script|style|image|font|media|object|embed|document|xslt|manifest|report|service|shared]worker
           - used for CSP and Accept [C]
        - nopush (preload): if a HTTP2 server push has been received for that resource, do not use it
     - prerender:
        - in the background, i.e. not visible but will provide fast caching
        - only kept for short while, so should be next navigation
        - resource intensive: should only be used when confident about next navigation action
        - only HTML resources
   


Check HTTP2 features

Check if concatenation really does not make sense anymore with HTTP2
