
          
   HTTP   
          


To finish:
  - write RFCs number here
  - HTTP-related RFCs
  - w3c standards, WHATWG standards
  - format this doc
  - write summary on top
  - finish temp_sync doc
  - go back to CSS architecture to_learn list

HTTP-related RFCs:
  - MIME: 
     - General: 2017, 2045, 2046, 2047, 2049, 2936, 6839
     - S-MIME: 2311, 2312, 7114
     - MIME text/plain: 3676, 5147
     - MIME charset: 2231, 5987, 6657
  - Language tag: 4645, 4647, 5645, 5646
  - HTTP/1.*: 1945, 7231
  - Compression, chunked encoding: 7230
  - Proxies: 3143, 3205, 7239
  - Accept-Datetime [C]: 7089
  - Diff: 3229, 3284
  - Alt-* [S]: 7838

Architecture:
  - mostly maintained by IETF RTCs
  - version 2. To guess support, can use:
     - ALPN, TLS extension (see SSL/TLS doc)
     - Upgrade: h2[c] [C|S] (see below)
        - h2 is HTTS, h2c HTTPS
        - must include SETTINGS frame as HTTP2-Settings [C] (base64-encoded)
        - not supported by most browsers
        - can Upgrade to but not from HTTP/2
     - prior knowledge: client already knows server supports HTTP/2
  - layers:
     - application layer
     - usually on top of TCP/IP
        - TCP ports: 80 (HTTP), 443 (HTTPS)
     - TLS:
        - HTTP/2: 
           - not required by specs, but browser implementation does
           - when used:
              - must use TLS 1.2+ with SNI extension
              - if using TLS 1.2, must disable compression, renegotiation
        - HTTP/1.*: not required
  - URI scheme: http[s]://
  - client-server:
     - client: "user agents", e.g. web browser, web crawler, app, etc.
     - order is always: client request -> server response (can include several streams)
     - resource can be dynamic (server modifies content) or static
  - state:
     - streams independant from each other
     - but headers/payload can keep state (e.g. cookies)
     - a stream need to keep its own state though
  - session:
     - set of TCP sockets:
        - HTTP/2: 
           - one per host (not hostname) + port
        - HTTP/1.*: 
           - 6 (depends on client) per hostname + port
           - hostname sharding: using different domains on a server to overcome limit
     - parallel requests per TCP socket: 
        - HTTP/2: multiplexing: SETTINGS_MAX_CONCURRENT_STREAMS (def: unlim) with no order (unless client suggest specific order)
        - HTTP/1.1: pipelining: 4-8 (depends on client) with head-of-line blocking (answers in same order as requests)
        - HTTP/1.0: serial: one
     - how long:
        - HTTP/2: 
           - until GOAWAY frame
           - timeout not mandatory nor forbidden
        - HTTP/1.*: 
           - until Connection: close [C|S]
           - timeout 10-15 secs (depends on server). Can be set by Keep-Alive: timeout=NUM [S]
           - NUM requests using Keep-Alive: max=NUM [S]
        - HTTP/1.0: requires Connection: Keep-Alive [C|S] to remain open

Format (HTTP/2):
  - stream: one request+response, or server push:
     - several ordered frames connected by stream ID
     - is what makes multiplexing possible
     - steam ID:
        - 0: hypothetical main stream
        - odd is started by client, even by server
        - incremental ID
  - frames:
     - headers: length [0-2], type [3], flags [4], reserved [5.0], stream ID [5.1-8], payload [*]
     - payload:
        - DATA (0x0): [padding length [0], ]data [*][, padding [*]]
        - HEADERS (0x1): [padding length [0], ][exclusive [1.0], stream parent ID [1.1-4], weight [5]], headers [*][, padding [*]]
        - PRIORITY (0x2): exclusive [0.0], stream parent ID [0.1-3], weight [4]
        - RST_STREAM (0x3): error code [0-3]
        - SETTINGS (0x4): several times: VAR [0-1], VAL [2-5]
        - PUSH_PROMISE (0x5): [padding length [0], ]reserved [1.0], promise stream ID [1.1-4], headers [*][, padding [*]]
        - PING (0x6): data [0-7]
        - GOAWAY (0x7): reserved [0.0], last stream ID [0.1-3], error code [4-7], debug data [*]
        - WINDOW_UPDATE (0x8): reserved [0.0], increment [0.1-3]
        - CONTINUATION (0x9): headers [*]
     - flags:
        - END_STREAM (0x1) (DATA, HEADERS)
        - ACK (0x1) (SETTINGS, PING)
        - END_HEADERS (0x4) (HEADERS, PUSH_PROMISE, CONTINUATION)
        - PADDED (0x8) (DATA, HEADERS, PUSH_PROMISE)
        - PRIORITY (0x20) (HEADERS)
  - init (for each endpoint):
     - start:
         PRI * HTTP/2.0

         SM

     - SETTINGS frame:
        - options, noted SETTINGS_*
        - receiver must respond with empty SETTINGS frame with ACK flag
        - can be sent again later to change settings
  - normal (request/response) stream:
     - request:
        - 1 HEADERS, 0-n DATA (payload), 0-1 trailing HEADERS
        - HEADERS:
           - must contain pseudo-headers: 
               :method METHOD [C] 
               :authority URL [C] 
               :path PATH [C] : can be *
               :scheme PROTOCOL [C]
           - if 1 frame not enough, send extra CONTINUATION frames with extra headers
           - last frame should have flag END_HEADERS
     - response:
        - same but HEADERS must contain instead pseudo-header :status UINT [S]
  - server push stream:
     - enabled by SETTINGS_ENABLE_PUSH (0x2) (def: true)
     - initiated by server, in reaction to client request
     - server: PUSH_PROMISE frame:
        - contains HEADERS frame information that client would send if it was to request this stream
        - the original request cannot contain payload
        - the pushed request must be cacheable, e.g. use safe method
     - client:
        - RST_STREAM frame to cancel request, e.g. if cached
        - server reacts to RST_STREAM but does not wait for client to send next frames
     - server: 
        - HEADERS, DATA: like normal response
  - end:
     - END_STREAM flag:
        - normal stream end
        - on last DATA frame (or last HEADERS if none) for each endpoint
        - might be followed by CONTINUATION frames
     - RST_STREAM frame: 
        - cancels current stream
     - GOAWAY frame: 
        - end of session , i.e. stops any new stream
        - keep processing existing streams
        - contains last stream ID that will be processed
        - can contain arbitrary debug info
        - should respond with another GOAWAY

Error codes (HTTP/2):
  - types:
     - NO_ERROR (0x0)
     - PROTOCOL_ERROR (0x1): e.g. wrong frame order or content
     - INTERNAL_ERROR (0x2)
     - FLOW_CONTROL_ERROR (0x3): too much buffered DATA because of flow control
     - SETTINGS_TIMEOUT (0x4): SETTINGS response timeout
     - STREAM_CLOSED (0x5)
     - FRAME_SIZE_ERROR (0x6): frame too small|big
     - REFUSED_STREAM (0x7): sender notifies receiver that reqyest has not been processed, allowing safe retry. E.g. too many concurrent streams or refused server push
     - CANCEL (0x8): stream no longer needed or server push refused
     - COMPRESSION_ERROR (0x9)
     - CONNECT_ERROR (0xa): when using CONNECT method
     - ENHANCE_YOUR_CALM (0xb): throttling, e.g. too many server pushes
     - INADEQUATE_SECURITY (0xc): does not use TLS or wrong TLS setup
     - HTTP_1_1_ERROR (0xd): should downgrade to HTTP/1.1
  - contained in GOAWAY|RST_FRAME frame

Limits (HTTP/2):
  - SETTINGS_MAX_CONCURRENT_STREAMS (0x3) (def: unlim)
  - SETTINGS_MAX_FRAME_SIZE (0x5) (def/min: 16KB, max: 16MB)
  - HEADERS frames:
     - SETINGS_MAX_HEADER_LIST_SIZE (0x6) (def: unlim):
        - max HEADERS frame size, uncompressed, with extra 32 bytes per header. 
        - not mandatory to respect it.
     - SETTINGS_HEADER_TABLE_SIZE (0x1) (def: 4KB): headers dynamic table size
     - implementation additional limits, e.g. Apache limits 8MB/header and 1000 headers, Node.js 80KB/header
  - DATA frames: max receiver buffer (flow control):
     - counter SETTINGS_INITIAL_WINDOW_SIZE (0x4) bytes (def: 64KB, max: 2GB):
        - decreased when sender sends
        - increased when receiver sends WINDOW_UPDATE frame:
           - includes how much to increase
           - e.g. when receiver consumed (i.e. received and do not buffer anymore)
        - if exhausted, each endpoint should terminate stream
        - should amount to how much receiver can buffer
     - can be for a stream, or whole connection (if stream ID is 0)

PING frame (HTTP/2):
  - used to calculate round-trip time
  - contains 8 bytes of arbitrary data
  - have priority over other frame types
  - must respond with another PING frame with flag ACK

Stream prioritization (HTTP/2):
  - receiver is not constrained to respect it
  - fields/flags on HEADERS|PRIORITY frame. Must set PRIORITY flag
  - priority: Weight field 1-256 (def: 16): how much resources server should allocate
  - dependency:
     - Parent stream ID field (def: 0, i.e. none): current stream must only start once stream ID is done
     - Exclusive field: make siblings become children of current stream

Format (HTTP/1.*):
  - newline is \n\r
  - request:
      METHOD URL HTTP/1.*
      HEADER: VAL
      ...

      [BODY]
  - response:
      HTTP/1.1 UINT STR
      [HEADER: VAL
      ...]

      [BODY]
  - Host [C] is mandatory

Format extensions:
  - new headers
  - HTTP/2:
     - new frame type
     - new SETTINGS_*
     - new *_ERROR
  - should prefix with x-*

Switching protocols:
  - starting a session in HTTP then continuing in another protocol
  - how:
     - client: 
        - Upgrade: PROTOCOL/VERSION [C]
     - server:
        - 101 (Switching Protocols) + Upgrade: PROTOCOL/VERSION [S]: success
        - 426 (Upgrade Required): failure

Method:
  - concepts:
     - safety:
        - unsafe means side-effects on the resource
        - can be thought as safe (read) and unsafe (write)
        - safe implies idempotent
        - Safe [C]: 
           - declares method safe
           - useless for methods safe by default
           - other methods should remain unsafe. However ther are cases where a safe POST is needed, e.g. when need to submit
             x-www-urlencoded safe request without using XHR
           - goal is to imply idempotency, i.e. client can retry without prompting user
           - not implemented by clients
     - idempotency:
        - resource returned is always same if called again (with same parameters)
        - mean client can repeat request without risk
  - types:
     - safe:
        - GET: retrieve resource
        - HEAD: retrieve resource (header only)
        - OPTIONS:
           - retrieve metadata (e.g. functionalities of web server).
           - usually use * as URL
           - can use Allow [S] (see below)
        - TRACE: 
           - echoes request
           - to see changes introduced by servers|proxies
        - CONNECT: HTTP Tunneling
     - unsafe:
        - idempotent:
           - PUT: replace/create (completely) resource with specific ID
           - DELETE: erase resource
           - [UN]LINK: add|change|remove Link [C] (see below)
        - not idempotent:
           - POST: create resource without specific ID
           - PATCH: 
              - modify (partially) resource
              - while PUT|POST sends resource itself, PATCH sends resource diff (which might be different format)
              - can create, or not (preferred)
              - should require If-* [C], unless it just appends
              - consider 409 for conflicts
              - JSON merge patch:
                 - application/merge-patch+json 
                 - rules:
                    - set if specified
                    - leave as is if unspecified
                    - remove if null
                    - if VAL not OBJ, should set whole resource to VAL
                 - simple but not suitable if:
                    - should be able to set values to null
                    - need to be able to transform values instead or replacing, e.g. NUM++, ARR.push(), STR.concat()
  - whitelisting:
     - Allow: HTTP_METHOD,... [S]:
        - in response to OPTIONS request
     - Accept-Patch: MIME[;charset=CHARSET],... [S]
        - in response to OPTIONS request, meaning MIME types accepted by PATCH
     - 405 (Method not allowed)
  - X-HTTP-Method-Override: METHOD [C]:
     - request should be interpreted as if HTTP METHOD had been used
     - goal is to overcome proxies HTTP methods restrictions

Headers:
  - case insensitive
  - written [S|C] for server|client in my doc
  - binary compressed (HTTP/2)
     - algo is 'HPACK'
     - common HEADER or HEADER: VAL have predefined numbers
     - each endpoint caches HEADER: VAL in a dynamic table
  - :HEADER are called pseudo-headers: same as headers but with extra restrictions on when can be used (HTTP/2)

Status codes:
  - WebDAV-only: 102, 207, 208, 422, 423, 424, 507, 508
  - 1**: information
     - 100 (Continue)                         client sent only headers and can proceed to send body (see Expect: 100-continue [C])
     - 101 (Switching Protocols)              switch protocol success, e.g. from HTTP to HTTPS (see Upgrade [C])
  - 2**: success
     - 200 (OK)                               simple
     - 201 (Created)                          new resource (e.g. POST). Use Location: URL [S] for new resource URL.
     - 202 (Accepted)                         response is ongoing and will take some time to process
     - 203 (Non-Authoritative Information)    proxy transformed server response, which was originally 200
     - 204 (No Content)                       OK, but nothing is to be returned. Client should stay on same resource/document. E.g. successful DELETE, If-Modified-Since header.
     - 205 (Reset content)                    like 204 but client should reset/refresh current resource/document.
     - 206 (Partial content)                  response is only a subset of the full resource, (see Range [C])
     - 214 (Transformation applied)           proxy transformed server response, which was originally not 200
     - 226 (IM used)                          returns diff not full resource. Uses HTTP delta compression, an RFC which seems old.
  - 3**: redirection to be performed by client
     - 300 (Multiple choices)                 redirection need client input
     - 301 (Moved Permanently)                permanent, GET (even if different method, but should ask first). Cacheable.
     - 302 (Found)                            temp, GET (even if different method, but should ask first)
     - 303 (See other)                        different resource (not only different URL) than requested
     - 304 (Not Modified)                     resource did not change (see caching)
     - 305 (Use proxy)                        redirect to a proxy
     - 307 (Temporary Redirect)               temp, same HTTP method
     - 308 (Permanent Redirect)               permanent, same HTTP method
  - 4**: client-side failure
     - 400 (Bad request)                      syntax error
     - 401 (Unauthorized)                     authentication problem
     - 402 (Payment required)                 e.g. should pay to increase request rate
     - 403 (Forbidden)                        authorization problem. Prefer 404 when location itself is secret.
     - 404 (Not Found)                        wrong URL, but correct domain.
     - 405 (Method not allowed)               HTTP method not implemented or not allowed
     - 406 (Not Acceptable)                   wrong requested media type (see Accept [C])
     - 407 (Proxy authentication required)    like 401 but for application proxy
     - 408 (Request Timeout)                  as opposed to response timeout
     - 409 (Conflict)                         multi-client conflict
     - 410 (Gone)                             like 404, but indicates URL was present before
     - 411 (Length Required)                  missing request body length (see Content-Length [C])
     - 412 (Precondition Failed)              resource changed even though client assumed it did not, e.g. with If-Unmodified-Since [C] (see caching)
     - 413 (Payload too large)
     - 414 (URI too long) 
     - 415 (Unsupported Media Type)           server does not support payload media type (inverse of 406)
     - 416 (Range Not Satisfiable)            wrong Range [C]
     - 417 (Expectation failed)               wrong Expect [C]
     - 421 (Misredirected request)            request picked wrong server
     - 422 (Unprocessable Entity)             request payload has correct syntax and media type, but wrong instructions that cannot be applied
     - 426 (Upgrade Required)                 switch protocol denied, e.g. from HTTP to HTTPS
     - 428 (Precondition required)            must use If-* [C]
     - 429 (Too many requests)                throttle. May include Retry-After [S]
     - 431 (Request header fields too large)
     - 451 (Unavailable for Legal Reasons)    e.g. censorship, copyright, privacy. Can include Link [S] with rel="blocked-by"
  - 5**: server-side failure
     - 500 (Internal server error)            bug in server, e.g. syntax error
     - 501 (Not implemented)                  feature not available yet
     - 502 (Bad gateway)                      sent by proxy when it received error from server
     - 503 (Service unavailable)              server is down (cannot connect)
     - 504 (Gateway timeout)                  sent by proxy on server timeout
     - 505 (HTTP version not supported)
     - 506 (Variant also negotiates)          negotiation circular loop (see Negotiate [C])
     - 510 (Not extended)                     HTTP extension not implemented
     - 511 (Network authentication required)  like 401 but for network proxy, containing link where to authenticate.

<meta http-equiv="HEADER" content="VAL">:
  - add HTTP header client-side
  - only ones that are crossbrowser: refresh, Content-Security-Policy

Redirections:
  - use 3** status code and:
     - client should request again:
        - Location: URL [S]: right away
        - Retry-After: NUM|DATE [S]: in future, same URL
        - Refresh: NUM[, url=URL] [S]: in future, same URL or not. Can be used as <meta http-equiv>
     - server fetched it without additional request:
        - Content-Location: URL [S]
  - 5+ redirections is considered infinite loop.
  - open redirect: see webs security doc

Time:
  - Date: DATE [C]: when request was sent 
  - X-Response-Time: NUM [S]: time taken by server to process answer
  - Accept-Datetime [C]: ask for past|present versions

Browser HTTP requests:
  - by changing current URL:
     - UI: 
        - browser chrome: back|forward|home button, URL bar, searchbar, bookmarks, etc.
        - <a|area> click event 
        - <form> submit event
     - programatically:
        - WINDOW.location|history
  - XHR.send(), FETCH

Query strings:
  - use URL?VAR=VAL&...: 
     - instead of request body 
     - like 'application/x-www-form-urlencoded' but:
        - %20 instead of +
        - nesting support: Express REQ.query
  - advantages:
     - recommended way to send request body with GET|HEAD
     - easier to set non-programatically (e.g. by typing URL)
     - stateful URL, e.g. for bookmarks
  - disadvantages:
     - non-separation of concern between resource location and request body
     - longer URL
     - SEO

Software identity:
  - User-agent: STR [C]: client technology
  - X-Requested-With: STR [C]:
     - how request was performed
     - often used: XMLHttpRequest
  - Server: STR [S]: server name
  - X-Powered-By: STR [S]: server technology
  - Pragma: VAL [C|S]: headers specific to a given client|server technology
  - X-UA-Compatible: CLIENT=VERSION;... [S]: 
     - client, if CLIENT, should render as it was VERSION
     - used with IE, e.g. IE=NUM|edge

Client identity:
  - From: EMAIL_ADDRESS [C]: often used with bots for support email
Destination:
  - Host: HOST[:PORT] [C] (HTTP/1.1) or :authority HOST[:PORT] [C] (HTTP/2) 
     - HOST case sensitivity depends on server

Content:
  - vocabulary:
     - resource: highest-level
     - variant: a resource with a specific representation (e.g. language, Content-Type, etc.)
     - instance: a variant inside a request/response payload, without transfer-related encoding (e.g. compression, Range [C])
     - entity: same as instance, but with transfer-related encoding (i.e. what is actually sent)
  - content negotiation: see below
  - request payload:
     - 415 (Unsupported Media Type): wrong request payload MIME_TYPE
     - Prefer: handling=strict|lenient [C]: should validate [not] strictly request payload
  - response payload:
     - Content-Disposition: DISPOSITION[; ATTR="VAL"] [S]:
        - how to process, among:
           - attachment: prompts for download
           - inline: render
        - ATTR:
           - filename 'FILE':
              - def: use content-type
              - even for inline, might be used later when Saving through browser UI
              - must be validated (otherwise client could overwrite anywhere on the server)
        - def:
           - depends on Content-Type [S], i.e. if rendering is supported by client
           - Content-Type "multipart/form-data; boundary=STR" [S]: attachment
  - Prefer: Safe [C]:
     - should not respond with "objectionable" content, e.g. for parental control
     - Firefox, IE10 use OS/browser UI to set it

Content negotiation:
  - client:
     - only GET|HEAD
     - Accept* [C]:
        - accepted variants:
           - Accept:         MIME_TYPE[; q=NUM],... [C]
           - Accept-Charset:   CHARSET[; q=NUM],... [C]
           - Accept-language: LANGUAGE[; q=NUM],... [C] 
           - Accept-features:  FEATURE[; q=NUM],... [C]
              - FEATURE: FEAT, FEAT=|!=VAL, FEAT=[NUM-NUM2], !FEAT, *
              - anything not covered by MIME_TYPE, CHARSET or LANGUAGE: MEDIAQUERYLIST, web API support, speed vs graphics, etc.
              - should be x-FEATURE if not standard
        - NUM is preference (see below)
        - Accept* [C]: allows fingerprinting user agent (privacy concern)
        - if ommitted: should not use 'choice'
     - Negotiate: VAL [C]:
        - VAL:
           - trans: supports list|choice
           - VERSION,...: supports list|choice with those variant selection algorithm versions. Can be '*'
           - guest-small: supports and ask for list|choice providing list is small enough
           - vlist: supports and ask for list|choice
           - (default): ask for ad-hoc
        - TCN: list, re-choose [S]: 
           - server forced TCN: list, although not asked by Negotiate [C]
  - server: 
     - list|choice is called 'transparent content negotiation', ad-hoc 'server-side negotiation'
     - TCN: VAL [S]: 
        - 2xx or 3xx, except 304
        - ad-hoc[, keep]: 
           - picks one variant, provides no choice to client
           - should use:
              - Content-Location: URI [S]
              - Content-Type: MIME_TYPE[; charset=CHARSET] [S]
              - Content-language: LANGUAGE [S]
           - 406 (Not Acceptable): wrong Accept-* [C]
        - list[, re-choose]: 
           - provides client only with possible variants:
              - should be kept short, e.g. 2 to 10
              - variant URI: 
                 - should not have variant itself. Otherwise should return 506 (Variant also negotiates)
                 - are best as relative "FILENAME"
              - requires extra HTTP request
           - 300 status code
           - Alternates: CHOICE,... [S] (variants):
              - {"URI" NUM {ATTR VAL} ...}
                 - ATTR: 
                    - type|charset|language VAL
                    - features FEATURE ...:
                       - can also use FEATURESET;[+NUM][-NUM2], where FEATURESET is FEATURE or [FEATURE ...]
                       - NUM is max quality improvement (def: 1), NUM2 max degradation (def: 0)
                    - length NUM
                    - description "STR". Use %xXX for Unicode encoding.
                    - any other x-ATTR
                 - NUM (0-1):
                    - quality
                    - calculated by remote variant selection algorithm:
                       - it also selects whether to use list or choice
                       - e.g. RVSA 1.0:
                          - NUM = product of all matching Accept*;q preferences (def: 1 for each)
                          - should use list if no NUM > 0, or only used wildcards (e.g. Accept-Features: * or Accept: */*)
              - <URI>: fallback
              - proxy-rvsa="VERSION,...": remote variant selection algorithm versions
        - choice: 
           - ad-hoc + list
           - "URI" must be relative "FILENAME" for security reasons
           - reverse proxy can choose to only respond with ad-hoc answer by:
              - Variant-Vary [S] -> Vary [S]
              - remove Content-Location [S], Alternates [S]
              - remove ';LIST_ETAG'
     - caching:
        - Vary: Negotiate, Accept*... [S]: list itself (list|choice)
        - Variant-Vary [S]: ad-hoc answer (choice)
        - must append ";LIST_ETAG" to each variant ETAG
  - client:
     - accepts chosen variant (ad-hoc, choice) or ask for a specific one (choice, list)
     - when using TCN: ad-hoc, keep, force accepting chosen variant

Links:
  - Link: <URL>[; ATTR="VAL"];... [, <URL>...] [S]
     - goal:
        - semantic relationship
           - i.e. independant of representation (including MIME type)
        - between:
           - RESOURCE: the one returned 
           - RESOURCE2: at URL
        - any cardinality, including n-n relationship
     - ATTR:
        (for RESOURCE, authoritary)
        - rel "REL ..." (mandatory): relation type from RESOURCE to RESOURCE2
           - REL can be URI describing a REL type (instead of a 'REL' name)
        - anchor "URI|#HASH": for RESOURCE
        (for RESOURCE2, hints only)
        - type "MIME"
        - hreflang "LANG"
        - media "MEDIAQUERYLIST"
        - title "STR": for accessibility
        - title* "CHARSET...": like title "STR" but with a specific CHARSET
        - VAR "VAL"
  - <link ATTR="VAL">:
     - same as Link [S]
     - only works with <link> syntax: 'stylesheet', icon-related
  - [UN]LINK:
     - HTTP method unsafe, idempotent
     - asks to add (or change) or remove links to a resource
        - only one LINK between RESOURCE and RESOURCE2 for a given REL (so it can be changed)
     - accompanied with Link [C] (same as Link [S])
     - no request body
  - REL:
     (general)
     - 'type': information about the semantic type (not MIME) of resource
     - 'profile': similar to 'type'
     (versions of same resource)
     - 'alternate': alternative versions
     - 'canonical': 
        - preferred version among alternatives
        - search engines will use this link instead
     - 'latest-version'
     - 'working-copy[-of]'
     - 'predecessor|successor-version'
     - 'version-history'
     (collection type)
     - 'first|last' 
     - 'next|prev'
     - 'index|up'
     - 'collection', 'item'
     (information type)
     - 'bookmark'
     - 'preview'
     - 'tag'
     - 'create|edit-form': create or edit a FORM
     (meta-information)
     - 'about': resource meta-information
     - 'author'
     (section type)
     - 'contents': table of contents
     - 'chapter|[sub]section': full chapter or [sub]section
     - 'search'
     - 'sidebar'
     - 'appendix'
     - 'archives'
     - 'help': e.g. FaQ, documentation
     - 'glossary'
     - 'copyright'
     - 'license'
     - 'disclosure': patent disclosures
     - 'privacy-policy'
     - 'terms-of-service'
     (external references)
     - 'external': not endorsed (e.g. ads)
     - 'nofollow': crawlers
     - 'noreferrer': do not set Referrer [C]
     - 'pingback': should get a notification at this URL when used as reference
     (prefetching)
     - 'preload', 'prerender', 'preconnect', 'dns-prefetch'
     (not semantic)
     - 'stylesheet': e.g. CSS (or CSS preprocessor) stylesheet
     - icon-related: 'icon', 'shortcut', 'apple-touch-icon-precomposed'

Cache:
  - vocabulary:
     - cache hits ratio: % of requests that used cache instead
     - stale resource (as opposed to fresh): cached but not valid anymore
     - cache invalidation: removing caching on stale resources
  - types:
     - client caching: 
        - best performance but for single client
        - e.g. browser caching
     - server caching:
        - shared by many clients but less performant
        - types:
           - reverse proxy (between client and server)
              - ISP
              - web accelerator: 
                 - reverse proxy dedicated to caching
                 - can also do prefetching, compression/minification
              - CDN: 
                 - network across several geographical regions to be closer to clients
                 - optimized for high availability
           - between server and database: 
              - e.g. Memcached/Redis
  - what is cached:
     - key:
        - HTTP method
        - URI, excluding #HASH. 
        - does not include HTTP headers, unless Vary: HEADER [S]:
           - when headers have impact on content, i.e. usually on Accept* [C]
           - usually towards proxies, since browsers usually use only one set of headers
           - whitespaces, orders, case, identical values will be normalized before comparison
        - does not include request body
     - value: full response (URL, headers, body)
  - HTTP methods allowed:
     - GET
     - HEAD: theoritically. But web browsers do not seem to allow it. 
     - others: 
        - only with conditional caching (except If-Modified-Since), when manually added using XHR
  - status codes:
     - specified as:
        - should be cached: 200, 203, 204, 206, 226, 300, 3001, 308, 404, 405, 410, 414, 421, 451, 501
        - should not cached: 302-307, 428, 429, 431, 511
        - rest is unspecified
     - browser default unconditional caching:
        - Chrome/Opera: 300, 301, 308, 410
        - Firefox: 410
     - browser allowed unconditional caching:
        - Chrome/Opera: all but 205, 401, 416
        - Firefox: only 200, 203, 206, 410
  - default:
     - depends on browser, heuristics to guess which type of caching should be used and how long
     - to avoid
     - see above for which status code use unconditional cache by default or not
  - types:
     - history backward/forward caching: no control over it
     - unconditional caching:
        - client uses cache for a given time period, without server interaction
           - does not apply on page refresh
           - has priority over conditional caching
        - features:
           - fastest cache method
           - highest probability of stale resources, except when using timestamping or invalidation push
           - best for asset files
        - Cache-Control: STR,... [S|C]:
           - client override server
           - STR (client or server):
              - no-cache[="HEADER,..."]: 
                 - no unconditional caching [of a specific header]
                 - HEADER: only for server
              - no-store: no any form of caching, including unconditional or conditional
              - max-age=NUM: 
                 - how long to cache (in secs), i.e. how long stale resources are ok
                 - max: 1 year
                 - if fingerstamped, can be max value
                 - initial age is max between:
                    - 0
                    - response_received - Date [S]
                    - response_received - request_sent[ + Age: NUM [S]]
                       - Age: in secs, should be incremented by reverse proxies
              - Expires: DATE [S]:
                 - same as max-age but using a given DATE
                 - older header
              - no-transform: 
                 - don't allow reverse proxy to compress|minify resources (e.g. images/videos) or inject JavaScript code
              - stale-if-error=NUM: 
                 - on 500-504, use unconditional cache, if stale for <NUM seconds
                 - def: unless must-revalidate
           - STR (server only):
              - must-revalidate: 
                 - when expires, use conditional caching (if setup)
                 - default of most clients
              - public or private[="HEADER,..,"]:
                 - allow or prohibit (def) reverse proxy caching
                 - private: good for sensitive data, e.g. cookies
              - state-while-revalidate=NUM:
                 - if stale for <NUM seconds, proxy will:
                    - serve stale resource
                    - while retrieving fresh resource in the background for the next request
              - s-max-age=NUM: same as max-age but for reverse proxies
              - proxy-revalidate: same as must-revalidate but for reverse proxies
           - STR (client only):
              - max-stale=NUM: extend max-age|Expires with NUM seconds
              - min-fresh=NUM: must be cacheable for at least NUM seconds, otherwise ignore
              - only-if-cached: 504 if no unconditional cache available
        - Surrogate-Control: STR[;TARGET],... [S]:
           - similar to Cache-Control but from server to reverse proxy (has priority)
           - supported by many reverse proxies
           - STR:
              - no-store: like above
              - no-store-remote: like no-store but only for reverse proxy's reverse proxies
              - max-age=NUM[+NUM]: like max-age + stale-while-revalidate above
              - content="TRANSFORM ...": which transformation can be performed
           - TARGET: 
              - identify reverse proxy, when there are several along the chain
              - no TARGET: "all other TARGET"
           - reverse proxy use Surrogate-Capabilities: TARGET="VAL ..." to inform:
              - which Surrogate-Control values are supported 
                 - Surrogate/1.0 for the ones above
              - supported TRANSFORM
        - timestamping:
           - using an ID in the URL that changes when resource changes
              - e.g. version number, modification date or content checksum
           - used to invalidate cache on modified resources
           - top-level resources (i.e. that require timestamped resources) (e.g. main HTML file) cannot be timestamped itself
        - invalidation push:
           - using push technologies to invalidate resources
           - allow using unconditional caching with top-level resources
           - but:
              - more complex to implement
              - higher risk of unwanted unconditional caching if something goes wrong
     - conditional caching:
        - client sends request with information about latest representation, and server does not send body if resource has not changed
        - features:
           - slower method but no possibility of stale resources
           - does not require timestamping
           - best for top-level resources, e.g. main HTML file or AJAX calls
        - how:
           - server:
              - Last-Modified: DATE [S] 
              - ETag: "ETAG" [S]
                 - usually content hash or version number
                 - [:graph:]
                 - ETAG:
                    - "...": 
                       - strong, same instance, i.e. same byte-wise
                       - usually not shared by different representations
                       - preferred
                    - W/"...": 
                       - weak, same resource, i.e. same semantically but not necessarily byte-wise
                       - usually shared by different representations
                       - cannot be used with If-Range [C], If-Match [C] or If-Unmodified-Since [C]
                       - "..." == W/"..."
           - client include latest representation:
              - If-[Un]Modified-Since: DATE [C]
              - If-[None-]Match: "ETAG"|* [C] (if specified, If-[Un]Modified-Since is ignored)
           - server:
              - if condition does not match:
                 - 304 (Not modified) with no body: 
                    - If-Modified-Since or If-None-Match, and safe HTTP method
                 - 412 (Precondition failed):
                    - otherwise
                    - not used for caching, but e.g. do not DELETE if resource has changed
              - can use 428 (Precondition required) to force conditional caching
     - no caching:
        - features:
           - slowest method, but:
              - best if resource never same, e.g. anything that contains time-dependent/always-unique server-side content
              - prevent caching credentials
        - how:
           - server:
               Cache-Control: no-cache[="HEADER"], no-store, private, must-revalidate
           - client (works also for HTTP/1.0 servers):
               Cache-Control: no-cache, no-store, private, must-revalidate
               Pragma: no-cache
               Expires: 0
  - debugging:
     - high-level: about:cache (Chrome, Firefox)
     - low-level: about:net-internals#httpCache (Chrome)

Prefetching (resource hints, server push):
  - types, from most performant to least:
+--------------+----------------------------------------------+---------------------------------------------------------------------+------------------------------------+
| Type/REL     | Use case                                     | Effects                                                             | Browser support                    |
|              +--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+                                    |
|              | Resource for which | Known path | Likelihood | Initiated | When is resource        | Loads | Parse + | Protocols   |                                    |
|              | navigation action  |            |            | by        | fetched                 |       | render  |             |                                    |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| server push  | Current            | Yes        | Certain    | server    | right away (no request) | Yes   | Yes     | HTTP        | All                                |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| preload      | Current            | Yes        | Certain    | client    | async right away        | No    | No      | HTTP        | Chrome/Opera                       |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| preconnect   | Current            | No         | Certain    | client    | async right away        | No    | No      | DNS         | Chrome/Opera/Firefox               |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| prerender    | Next               | Yes        | High       | client    | after document.onload   | No    | Yes     | HTTP        | Chrome/Opera/IE                    |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| prefetch     | Next               | Yes        | Middle/low | client    | after document.onload   | No    | No      | HTTP        | not [mobile] Safari nor Opera mini |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| dns-prefetch | Next               | No         | Middle/low | client    | after document.onload   | No    | No      | DNS+TCP/TLS | not Opera mini                     |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
  - server push:
     - send additional resources in a single response
     - performance:
        - less roundtrips than resource hints
        - but should push only resources that would have been requested
     - caching:
        - uses pseudo-client request for caching, so works the same as normal request
        - client request must be cacheable, i.e. GET with cache headers
     - not actual prefetching (it loads resource)
     - need to be initiated by a request (so not realtime)
     - as opposed to resource hints, initiated by server so cannot be used if:
        - client needs knowledge about fetching: resource path, load|error event
        - fetching needs knowledge about client: state (cookies, localStorage), user agent info (Accept [C], etc.)
  - resource hints:
     - use Link [S] (or <link>) REL
     - ATTR:
        - pr 'FLOAT' (0-1) (all)
           - probability the link will be followed 
           - used for prioritization or reducing optimization/fetching
        - as TYPE (preload|prefetch): 
           - WINDOW.fetch() destination type, 
             i.e. script|style|image|font|media|object|embed|document|xslt|manifest|report|service|shared]worker
           - used for CSP and Accept [C]
        - nopush (preload): if a HTTP2 server push has been received for that resource, do not use it
     - prerender parsing/execution:
        - in the background, i.e. not visible but will provide very fast cache
        - only kept for short while, so should be next navigation
        - resource intensive: should only be used when confident about next navigation action
        - only HTML resources
        - can debug with about:net-internals#prerender (Chrome)
     - does not delay document.onload
     - could previously use noop XHR to achieve something similar
     - cannot see in devtools network tab, but can see "prerender" using chrome://net-internals/#prerender
     - can be:
        - speculative: before user interaction that might trigger HTTP request
        - reactive: after user interaction that will certainly trigger HTTP request, after some delay
     - possible problems:
        - when HTTP GET request has side effects (which is improper)
        - increase bandwith usage
        - overestimate tracking (ads, analytics):
           - can use document.visibilityState 'prerender' to handle it
        - security: website make decision (not user) to trust content by browsing it

Long request:
  - header first, then body:
     - client: Expect: "100-continue" [C], no request body
     - server:
        - 100 (Continue) if success
        - 417 (Expectation Failed) if failure
     - client: request body body
  - Content-Length [C|S]:
     - request body length
     - can use 411 (Length Required)
  - request too large:
     - 414 (Request URI too long)
     - 431 (Request header fields too large)
     - 413 (Request Entity too large)

Long response (size):
  - request specific ranges (byte serving):
     - init: 
        - server:
            200 (OK)
            Accept-Ranges: VAL [S]:
              - bytes
              - none (def)
              - any other UNIT: will require different Range [C] and Content-Range [S] values
            Empty response body
     - each range:
        - client:
           - only GET
           - Range: bytes=RANGE,... [C]
              - RANGE: NUM-[NUM2] or -NUM (last bytes)
           - If-Range: ETAG|MDATE [C] (optional)
              - like If-Match|If-Unmodified-Since, except if fails, should ignore Range [C]
        - server:
           - success:
              - 206 (Partial content)
              - caching:
                 - ETAG|MDATE:
                    - designates the whole resource, not the RANGE
                    - must be same as first 200 (OK) response
                 - ETAG must be strong
              - Accept-Ranges: VAL [S]
              - only one RANGE was requested:
                  Content-Range: bytes NUM-NUM2/TOTAL [S] 
                    - TOTAL can be * if unknown
              - several RANGEs were requested:
                  Content-Type: "multipart/byteranges; boundary=STR" [S], with payload:
                    STR	
                    [Content-Type: TYPE]
                    Content-Range: bytes NUM-NUM2/TOTAL
                    content as is
                    STR
                    ...
                    STR--
           - failure:
               416 (Requested Range Not Satisfiable)
               Content-Range: bytes */TOTAL [S] 
  - Prefer: return=minimal [C]:
     - should not return response body, only headers
     - as opposed to HEAD, can be done on other HTTP methods, and can include request body
  - Prefer: return=representation [C]:
     - should return only what has been changed by request, not full resource
     - should also include Content-Location [S] to full resource
  (HTTP/1.* only)
  - send response body in several times:
     - how:
        - client: TE: chunked [C]
        - server:
           - Trailer: HEADER [S] (optional) to indicate trailer headers
           - Transfer-Encoding: chunked [S], sendind each chunk
           - trailing headers
           - empty chunk
     - should use compression

Long response (time)
  - 202 (Accepted): 
     - async processing
     - client can timeout
     - should include link to monitor processing status, e.g. using Content-Location [S]
  - Prefer: respond-async [C]:
     - should process async (if takes too long) and return 202
  - Prefer: wait=NUM [C]
     - should not wait more than NUM seconds to process async
     - can be combined with Prefer: respond-async [C]

Response processing:
  - Prefer [C]:
     - client:
        - Prefer: VAR[="VAL"][;ATTR="VAL"...] ,... [C]:
        - ask server to handle request payload in a specific way
           - should not be used for content negotiation
        - can be present several times per request (with different VARs)
        - def VAL: ""
        - VAR: 
           - respond-async, time=NUM, return=minimal, return=representation, handling=strict|lenient, safe: see this doc
           - x-VAR
     - server:
        - Preference-Applied: VAR[="VAL"] ,... [S]: which Prefer [C] were honored

Proxies:
  - X-Forwarded-Host|For|Proto|Port: HOST|IP|PROTOCOL|PORT,... [C]: 
     - forwarded server info
     - when several, the leftmost is the closest to origin
  - Via: HTTP_VERSION URL SERVER ... [C|S]: proxy info
  - Max-Forwards: NUM [C]: max number of proxies
  - Warning: NUM - "DESCRIPTION" "DATE" [S]
     - 1**: caching-related, should be updated by 403:
        - 110 "Response is Stale": proxy served stale resource instead of retrieving fresh one from server
        - 111 "Revalidation Failed": same as 110, but reason is because server unavailable
        - 112 "Disconnected Operation": same as 110, but reason is proxy not connected to network
        - 113 "Heuristic Expiration"
        - 199 "Miscellaneous Warning"
     - 2**: other 
        - 214 "Transformation applied": e.g. ones prevented by "no-transform"
        - 299 "Miscellaneous Persistent Warning"
  - transformations:
     - see above for: Cache-Control: no-transform [S|C], Surrogate-Capabilities [C], Surrogate-Control: content [S]

Security: See Websites_security doc

Authentication: see authentication doc

Instance integrity:
  - digest:
     - how:
        - Want-Digest: ALGO[;q=NUM],... [C]
           - ALGO: 
              - MD5|SHA[-256|512]|UNIXsum|UNIXcksum
              - MD5|SHA[-256|512] requires base64, other ASCII
           - NUM: like for Accept* [C]
        - Digest: ALGO=CHECKSUM[,...] [S]
     - check integrity for "instance", i.e.:
        - body not headers
        - not "entity", i.e. without taking compression, Range [C], etc. into account
     - not implemented by most clients
  - Content-MD5 [C]: deprecated

Tracking:
  - Private browsing:
     - a private session erases at the end all the traces (history, cookies, cache) it created.
     - called Incognito in Chrome
  - Referer: URL [C]:
     - current URL
     - Link: noreferrer [S]: ask client not to send it
  - Do not track:
     - client:
        - DNT: VAL [C]
           - VAL is preference about tracking:
              - 1: disallow
              - 0: allow
              - (default) no preference
           - must be explicitely enabled inside browser settings
           - can check WINDOW|NAVIGATOR.doNotTrack (see DOM doc)
           - NAVIGATOR.store|remove|confirmSiteSpecific|WebSideTrackingException():
              - change site-specific or all-sites privacy settings (not implemented yet)
     - server:
        - Tk: VAL [S]:
           - VAL:
              - N: no tracking
              - T: tracking, normal
              - C: tracking, consent through a different way than DNT [C]
              - P: tracking, consent will come later. If constent rejected, previous data will be deleted|anonymized.
              - D: tracking, ignore DNT (e.g. for technical|legal reasons)
              - G: tracking, is only gateway
              - U: switched tracking, because of a different way than DNT [C]
              - ?: different VAL per request. VAL must be VAL;ID
              - !: currently implementing DNT
           - is per resource
        - 409 if refuse to deliver resource because of DNT: 1 [C]
     - GET /.well-known/dnt/[ID]:
        - must contain Content-Type "application/trackings-status+json":
           - tracking VAL (mandatory): current Tk [S]
           - compliance URL_ARR: privacy law/regulation
           - qualifiers STR: options opted in for the specific privacy law/regulation, as list of chars
           - controller URL_ARR: responsible for holding data
           - same-party URL_ARR: websites that have different domains but actually are first-party
           - audit URL_ARR: external audits of DNTs
           - policy URL: privacy policy
           - config URL:
              - where user can configure privacy
              - mandatory if Tk: C|P
        - ID is used with Tk: ? [S]
        - this GET request should never be tracked itself
     - what "tracking disallow" means with DNS: 1 [C]:
        - depends on compliance URL
        - W3C "Tracking Compliance and Scope" (http://www.w3.org/TR/2016/CR-tracking-compliance-20160426), tracking must:
           - anonymize data:
              - cannot link data to specific user
                 - user-agent, device, geolocation: allowed if general enough, e.g.:
                    - no IP address 
                    - no fingerprinting 
                    - no very specific geolocation
                 - that implies no cross-site tracking
              - cannot link patterns (i.e. several datapoints) to specific user|device, even anonymous
           - receive consent, except for (letters are "qualifiers", see above):
              - c: frequency capping (e.g. only showing something once)
              - s: security
              - f: financial/billing
              - d: debugging
           - sharing with service providers (e.g. AWS) require:
              - consent
              - qualifier "t"
           - not collect more nor longer than needed
              - retention period must be public
           - use sound security practices
     - should also have privacy policy
        - should also be at /.well-known/dnt-policy.txt

Cookies:
  - goal:
     - store state for a specific client+server pair
     - can be ignored by some clients
     - clients will remove them due to memory constraints or end-user demand
  - how:
     - server:
         Set-Cookie: VAR=VAL[;OPTIONS] [S]: one header per cookie
         OPTIONS is SVAR=VAL;...
     - client, next request on same domain+path:
         Cookie: VAR=VAL[;...] [C]: one header for all cookies
     - VAL are percent-encoded
     - SVAR:
        - domain STR:
           - must be same as server, or superdomain
           - subdomains will match
        - path '/PATH'
           - recursive
        - expires|max-age: 
           - DATE|NUM seconds before expiration 
           - max-age has priority
           - def: end of session
           - 0 deletes cookie
        - secure: can only get|set via HTTPS
        - HttpOnly: can't be used via JavaScript (document.cookies), for security reasons
  - limits:
     - 4KB/cookie (most browsers)
     - 50/domain (IE11)
     - 10KB/domain (IE11)
  - types:
     - first-party cookie:
        - cookie path/domain (i.e. HTTP request) is same as top-level page path/domain
     - third-party cookie:
        - inverse
        - can be blocked in browser settings
        - only disabled by default in Safari
     - Zombie cookie:
        - use cookies but also other storage at once, e.g. localStorage, ETag [C], Flash cookies, etc.
        - removing from one place -> others recreate it
  - security: see web security doc

Compression:
  - how:
     - client: Accept-Encoding: PROGRAM,... [C]:
        (standard)
        - "identity" (none)
        - "compress":
           - worst compression, older
           - older: not supported anymore
        - "deflate":
           - DEFLATE/INFLATE algorithm
           - inconsistent support: either without a wrapper format (IE) or with zlib wrapper format (other browsers)
        - "gzip":
           - DEFLATE/INFLATE algorithm, with gzip wrapper format
        - "exi":
           - better compression than DEFLATE, for XML files
           - w3c standard but no browser support
        (not standard)
        - "bzip2" 
           - better compression than DEFLATE but slower
           - browser support: Firefox only with specific build flag
        - "lzma":
           - better compression than DEFLATE but slower
           - better compression than bzip2, but slower, faster at decompressing but slower at compressing 
           - browser support: Opera
        - "xz":
           - LZMA2
           - browser support: Firefox only with specific build flag
        - "sdch": 
           - based on VCDIFF
           - does not seem really maintained anymore
           - browser support: Opera, Chrome
        - "br"
           - best compression. Same decompression speed as DEFLATE but slower at compressing.
           - browser support: Firefox, Chrome
     - server: 
        - Content-encoding: PROGRAM [S]: which one picked
        - Accept-Encoding: PROGRAM,... [S]: which one could have been possible
        - 415 (Unsupported media type): none could be picked
  - summary: server should offer in order: br, [sdch,] lzma, gzip, identity
  - server should cache compression

Push technologies:
  - allow server to initiate message to client
  - types:
     - XHR short polling: 
        - problems: 
           - minimum delay to receive message
           - waste resources when no message
     - HTTP server push / HTTP streaming / Comet / AJAX push / Reverse AJAX:
        - leaves XHR always open, using:
           - HTTP/1.*: Transfer-encoding: chunked [S]
           - HTTP/2: no END_STREAM flag
        - pushlet: 
           - variation where XHR is initial HTML page request
           - server sends new DOM without closing request
        - problems:
           - proxies might buffer XHR, making message not come
           - XHR might be closed by browser, forcing another request
        - problems (also shared with long polling)
           - collides with max number of TCP sockets in client, and pipelining of HTTP/1.*
           - collides with max number of TCP sockets in reverse proxies
     - Long polling: 
        - leaves XHR open, but close it (then start new one) with:
           - server response
           - timeout:
              - should be high enough for performance
              - but low enough so proxies/network do not time it out
              - usually 30 seconds is good
        - problems:
           - minimum delay to receive message after a message has just been received (because client need to start new request)
           - waste resources when timeout
     - TCP socket used by plugins like Flash or Java:
        - problems: 
           - rely on browser plugins
     - Websockets
        - problems:
           - no HTTP semantics
           - no multiplexing (as opposed to HTTP/2)
  - implementations:
     - Bayeux protocol: long polling or HTTP streaming
     - BOSH: long polling with a specific POST request with standardized parameters
     - Server-send events (SSE): HTTP steaming, using Content-Type "text/event-stream", triggering DOM events
  - best: Websockets or SSE

HTTP Tunneling:
  - wrapping another protocol packets in a HTTP payload
  - proxy and endpoints wraps|unwraps request|response
  - CONNECT method:
     - wraps TCP protocol
     - use only first HTTP handshake with proxy, then use TCP connection
     - can be used to access HTTPS using a HTTP proxy (TCP between client-proxy, SSL between proxy-server)

Practices becoming bad with HTTP/2:
  - concatenation:
     - performance impact:
        - lower number of requests
        - but invalidates cache more often
     - HTTP/2:
        - does not have limit on number of parallel requests
        - keep TCP socket always alive
        - so roundtrip performance impact is less important
     - types of concatenation:
        - file plain concatenation
        - sprites
        - inlining, e.g. <link> -> <style>
        - data URIs
  - domain sharding

HTTP URLs:
  - http:
  - //HOST/PATH
  - #HASH not send to server
  - interpretation depends on document format:
     - HTML: ID|NAME
  - relative //PATH will search for both HTTP and HTTPS
  - max length:
     - standard recommends (but does not mandate) 8KB
     - in practice with web browsers: 2KB

MIME TYPES ==>                                  #For { VAR: VAL, ... }:
                                                #  - "text/plain": 
																								#     - VAR=VAL, newline-separated
																								#  - "application/x-www-form-urlencoded" (def): 
																								#     - VAR=VAL, &-separated, percent-encoded, but space converted to + instead of %20
                                                #     - for nesting, can use VAR[VAR2]=VAL, but must be supported by server (e.g. Express BODY-PARSER)
																								#  - "multipart/form-data; boundary=STR": 
																								#         STR	
																								#         Content-Disposition: form-data; name="VAR"[; filename="FILE"]
																								#         [Content-Type: TYPE]
																								#         content as is
																								#         STR
																								#         ...
																								#         STR--
																								#     - more efficient than percent-encoding for binary/big payload, e.g. file upload.
																								#     - STR should be long enough and random. Can include a graphical line with "------" for humans reading the request.

Debugging:
  - HTTP: about:networking#http (Firefox)
  - HTTP/2: about:net-internals#http2 (Chrome)
