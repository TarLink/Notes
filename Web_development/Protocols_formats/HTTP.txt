
          
   HTTP   
          


To finish:
  - write RFCs number here
  - HTTP-related RFCs
  - w3c standards, WHATWG standards
  - format this doc
  - write summary on top
  - finish temp_sync doc
  - go back to CSS architecture to_learn list

HTTP-related RFCs:
  - MIME: 
     - General: 2017, 2045, 2046, 2047, 2049, 2936, 7231#appendix-A
     - S-MIME: 2311, 2312, 7114
     - MIME text/plain: 3676, 5147
     - MIME charset: 2231, 5987, 6657
  - URI: https://daniel.haxx.se/blog/2016/05/11/my-url-isnt-your-url/?utm_source=webopsweekly&utm_medium=email, WHATWG URL spec
  - HTTP/1.1: 7231
  - Accept-Datetime [C]: 7089, http://timetravel.mementoweb.org/

Architecture:
  - mostly maintained by IETF RTCs
  - version:
     - current: 2. 
     - to guess support, can use:
        - ALPN, TLS extension (see SSL/TLS doc)
        - Upgrade: h2[c] [C|S] (see below)
           - h2 is HTTS, h2c HTTPS
           - must include SETTINGS frame as HTTP2-Settings [C] (base64-encoded)
           - not supported by most browsers
           - can Upgrade to but not from HTTP/2
        - prior knowledge: client already knows server supports HTTP/2
     - can refuse request with 505 (HTTP version not supported)
  - URI scheme: 
     - http[s]:
        - relative URI can only be absolute path reference (/PATH/...)
        - HOSTNAME[:PORT]:
            - required
            - if relative URI, uses:
               - (HTTP/2) :authority HOSTNAME[:PORT] [C]
               - (HTTP/1.1) Host: HOSTNAME[:PORT] [C]
            - IP address or DNS name
            - case sensitivity depends on server
        - PATH: def is "/"
     - http:
        - over TCP
        - default port: 80
     - https:
        - over SSL
        - default port: 443
  - layers:
     - application layer
     - usually on top of TCP/IP
        - TCP ports: 80 (HTTP), 443 (HTTPS)
     - TLS:
        - HTTP/2: 
           - not required by specs, but browser implementation does
           - when used:
              - must use TLS 1.2+ with SNI extension
              - if using TLS 1.2, must disable compression, renegotiation
        - HTTP/1.*: not required
  - client-server:
     - client: "user agents", e.g. web browser, web crawler, app, etc.
     - order is always: client request -> server response (can include several streams)
     - resource can be dynamic (server modifies content) or static
  - state:
     - stateless: streams independant from each other
     - but headers|body can keep state (e.g. cookies)
     - a stream need to keep its own state though
  - session:
     - set of TCP sockets:
        - HTTP/2: 
           - one per host (not hostname) + port
        - HTTP/1.*: 
           - 6 (depends on client) per hostname + port
           - hostname sharding: using different domains on a server to overcome limit
     - parallel requests per TCP socket: 
        - HTTP/2: 
           - multiplexing: 
              - SETTINGS_MAX_CONCURRENT_STREAMS (def: unlim)
              - no order (unless client suggest specific order)
              - because there is a stream ID
        - HTTP/1.1: 
           - (idempotent methods) pipelining: 
              - 4-8 (depends on client)
              - head-of-line blocking (answers in same order as requests)
              - because there is no request ID to match request with response
           - (non-idempotent methods) serial: 1
        - HTTP/1.0: 
           - serial: 1
     - how long:
        - HTTP/2: 
           - until GOAWAY frame
           - timeout not mandatory nor forbidden
           - can check if connection not broken with PING frames
        - HTTP/1.*: 
           - until Connection: close [C|S]
           - until timeout:
              - 10-15 secs (depends on server)
              - Can be set by Keep-Alive: timeout=NUM [S]
           - until NUM requests: Keep-Alive: max=NUM [S]
        - HTTP/1.0: requires Connection: Keep-Alive [C|S] to remain open

Format (HTTP/2):
  - stream: one request+response, or server push:
     - several ordered frames connected by stream ID
     - is what makes multiplexing possible
     - stream ID:
        - 0: hypothetical main stream
        - odd is started by client, even by server
        - incremental ID
  - frames:
     - headers: length [0-2], type [3], flags [4], reserved [5.0], stream ID [5.1-8], payload [*]
     - payload:
        - DATA (0x0): [padding length [0], ]data [*][, padding [*]]
        - HEADERS (0x1): [padding length [0], ][exclusive [1.0], stream parent ID [1.1-4], weight [5]], headers [*][, padding [*]]
        - PRIORITY (0x2): exclusive [0.0], stream parent ID [0.1-3], weight [4]
        - RST_STREAM (0x3): error code [0-3]
        - SETTINGS (0x4): several times: VAR [0-1], VAL [2-5]
        - PUSH_PROMISE (0x5): [padding length [0], ]reserved [1.0], promise stream ID [1.1-4], headers [*][, padding [*]]
        - PING (0x6): data [0-7]
        - GOAWAY (0x7): reserved [0.0], last stream ID [0.1-3], error code [4-7], debug data [*]
        - WINDOW_UPDATE (0x8): reserved [0.0], increment [0.1-3]
        - CONTINUATION (0x9): headers [*]
     - flags:
        - END_STREAM (0x1) (DATA, HEADERS)
        - ACK (0x1) (SETTINGS, PING)
        - END_HEADERS (0x4) (HEADERS, PUSH_PROMISE, CONTINUATION)
        - PADDED (0x8) (DATA, HEADERS, PUSH_PROMISE)
        - PRIORITY (0x20) (HEADERS)
  - init (for each endpoint):
     - start:
         PRI * HTTP/2.0

         SM

     - SETTINGS frame:
        - options, noted SETTINGS_*
        - receiver must respond with empty SETTINGS frame with ACK flag
        - can be sent again later to change settings
  - normal (request/response) stream:
     - request:
        - 1 HEADERS, 0-n DATA (body), 0-1 trailing HEADERS
        - HEADERS:
           - must contain pseudo-headers: 
               :method METHOD [C] 
               :authority URL [C] 
               :path PATH [C] : can be *
               :scheme PROTOCOL [C]
           - if 1 frame not enough, send extra CONTINUATION frames with extra headers
           - last frame should have flag END_HEADERS
     - response:
        - same but HEADERS must contain instead pseudo-header :status UINT [S]
  - server push stream:
     - enabled by SETTINGS_ENABLE_PUSH (0x2) (def: true)
     - initiated by server, in reaction to client request
     - server: PUSH_PROMISE frame:
        - contains HEADERS frame information that client would send if it was to request this stream
        - the original request cannot contain request body
        - the pushed request must be cacheable, e.g. use safe method
     - client:
        - RST_STREAM frame to cancel request, e.g. if cached
        - server reacts to RST_STREAM but does not wait for client to send next frames
     - server: 
        - HEADERS, DATA: like normal response
  - end:
     - END_STREAM flag:
        - normal stream end
        - on last DATA frame (or last HEADERS if none) for each endpoint
        - might be followed by CONTINUATION frames
     - RST_STREAM frame: 
        - cancels current stream
     - GOAWAY frame: 
        - end of session , i.e. stops any new stream
        - keep processing existing streams
        - contains last stream ID that will be processed
        - can contain arbitrary debug info
        - should respond with another GOAWAY

Error codes (HTTP/2):
  - types:
     - NO_ERROR (0x0)
     - PROTOCOL_ERROR (0x1): e.g. wrong frame order or content
     - INTERNAL_ERROR (0x2)
     - FLOW_CONTROL_ERROR (0x3): too much buffered DATA because of flow control
     - SETTINGS_TIMEOUT (0x4): SETTINGS response timeout
     - STREAM_CLOSED (0x5)
     - FRAME_SIZE_ERROR (0x6): frame too small|big
     - REFUSED_STREAM (0x7): sender notifies receiver that reqyest has not been processed, allowing safe retry. E.g. too many concurrent streams or refused server push
     - CANCEL (0x8): stream no longer needed or server push refused
     - COMPRESSION_ERROR (0x9)
     - CONNECT_ERROR (0xa): when using CONNECT method
     - ENHANCE_YOUR_CALM (0xb): throttling, e.g. too many server pushes
     - INADEQUATE_SECURITY (0xc): does not use TLS or wrong TLS setup
     - HTTP_1_1_ERROR (0xd): should downgrade to HTTP/1.1
  - contained in GOAWAY|RST_FRAME frame

Limits (HTTP/2):
  - SETTINGS_MAX_CONCURRENT_STREAMS (0x3) (def: unlim)
  - SETTINGS_MAX_FRAME_SIZE (0x5) (def/min: 16KB, max: 16MB)
  - HEADERS frames:
     - SETINGS_MAX_HEADER_LIST_SIZE (0x6) (def: unlim):
        - max HEADERS frame size, uncompressed, with extra 32 bytes per header. 
        - not mandatory to respect it.
     - SETTINGS_HEADER_TABLE_SIZE (0x1) (def: 4KB): headers dynamic table size
     - implementation additional limits, e.g. Apache limits 8MB/header and 1000 headers, Node.js 80KB/header
  - DATA frames: max receiver buffer (flow control):
     - counter SETTINGS_INITIAL_WINDOW_SIZE (0x4) bytes (def: 64KB, max: 2GB):
        - decreased when sender sends
        - increased when receiver sends WINDOW_UPDATE frame:
           - includes how much to increase
           - e.g. when receiver consumed (i.e. received and do not buffer anymore)
        - if exhausted, each endpoint should terminate stream
        - should amount to how much receiver can buffer
     - can be for a stream, or whole connection (if stream ID is 0)

PING frame (HTTP/2):
  - use cases:
     - calculating round-trip time
     - check connection to endpoint is not broken
  - contains 8 bytes of arbitrary data
  - have priority over other frame types
  - must respond with another PING frame with flag ACK

Stream prioritization (HTTP/2):
  - receiver is not constrained to respect it
  - fields/flags on HEADERS|PRIORITY frame. Must set PRIORITY flag
  - priority: Weight field 1-256 (def: 16): how much resources server should allocate
  - dependency:
     - Parent stream ID field (def: 0, i.e. none): current stream must only start once stream ID is done
     - Exclusive field: make siblings become children of current stream

Format (HTTP/1.*):
  - newline is CRLF
  - request:
      METHOD URL HTTP/1.*
      HEADER: VAL
      ...

      [BODY]
  - response:
      HTTP/1.1 STATUS_NUM STATUS_STR
      [HEADER: VAL
      ...]

      [BODY]
  - Host [C] is mandatory

Charset: 
  - ASCII
  - headers:
     - unescaped:
        - [:alnum:] ! # $ % & ' * + - . ^ _ ` | ~
     - escaped with "..." or (...):
        - [:print:] TAB
        - in values only
        - \" or \( or \) to escape delimiters inside
  - escaping of body depends on MIME type

Format extensions:
  - new headers
  - HTTP/2:
     - new frame type
     - new SETTINGS_*
     - new *_ERROR
  - should prefix with x-*
  - if unavailable:
     - HTTP extensions: 510 (Not extended)
     - feature: 501 (Not implemented)

Switching protocols:
  - starting a session in HTTP then continuing in another protocol
  - allowed in HTTP/1.1 (e.g. to upgrade to HTTP/2), but not in HTTP/2
  - how:
     - client: 
        - Upgrade: PROTOCOL[/VERSION],... [C]: requested ones
        - Connection: Upgrade [C]
     - server:
        - 101 (Switching Protocols)
        - Upgrade: PROTOCOL[/VERSION],... [S]: picked ones
        - Connection: Upgrade [S]
        - 426 (Upgrade Required) if missing Upgrade [C]

Method:
  - specifies request goal
  - concepts:
     - safety:
        - unsafe means side-effects on the resource
        - can be thought as safe (read) and unsafe (write)
        - safe implies idempotent
        - Safe [C]: 
           - declares method safe
           - useless for methods safe by default
           - other methods should remain unsafe. 
              - however ther are cases where a safe POST is needed
              - e.g. when need to submit x-www-urlencoded safe request without using XHR
           - goal is to imply idempotency, i.e. client can retry without prompting user
           - not implemented by clients
     - idempotency:
        - resource returned is always same if called again (with same parameters)
        - mean client can repeat|retry request without risk
  - uppercase
  - types:
     - safe:
        - GET: retrieve resource
        - HEAD: retrieve resource (header only)
        - OPTIONS:
           - retrieve communication options (e.g. functionalities of web server).
           - can use * as URL
           - can use Allow [S] (see below)
        - TRACE: 
           - echoes request
           - to see changes introduced by servers|proxies
        - CONNECT: HTTP Tunneling (see below)
     - unsafe:
        - idempotent:
           - PUT: 
              - replace|create (completely) resource, with specific ID
              - use 201 (Created) with Location: URL [S] if created
           - DELETE: 
              - erase resource
              - use 204 (No content)
           - [UN]LINK: add|change|remove Link [C] (see below)
        - not idempotent:
           - POST:
              - non-idempotent modification
              - including creatimg resource, without specific ID
                 - use 201 (Created) with Location: URL [S]
           - PATCH: 
              - modify (partially) resource
              - while PUT|POST sends resource itself, PATCH sends resource diff (which might be different format)
              - can create, or not (preferred)
              - should require If-* [C], unless it just appends
              - consider 409 for conflicts
              - JSON merge patch:
                 - application/merge-patch+json 
                 - rules:
                    - set if specified
                    - leave as is if unspecified
                    - remove if null
                    - if VAL not OBJ, should set whole resource to VAL
                 - simple but not suitable if:
                    - should be able to set values to null
                    - need to be able to transform values instead or replacing, e.g. NUM++, ARR.push(), STR.concat()
  - whitelisting:
     - Allow: HTTP_METHOD,... [S]:
        - in response to OPTIONS request
     - Accept-Patch: MIME[;charset=CHARSET],... [S]
        - in response to OPTIONS request, meaning MIME types accepted by PATCH
     - 405 (Method not allowed)
  - X-HTTP-Method-Override: METHOD [C]:
     - request should be interpreted as if HTTP METHOD had been used
     - goal is to overcome proxies HTTP methods restrictions

Headers:
  - case:
     - name: case insensitive. Capitalized often used
     - value: depends on header, but many define it as case insensitive when value is token
  - order is not significant
  - no duplicates, except Set-Cookie [S]. Should use commas for multiple header values
  - should use (...) for comments inside values
  - written [S|C] for server|client in my doc
  - binary compressed (HTTP/2)
     - algo is 'HPACK'
     - common HEADER or HEADER: VAL have predefined numbers
     - each endpoint caches HEADER: VAL in a dynamic table
  - :HEADER are called pseudo-headers: same as headers but with extra restrictions on when can be used (HTTP/2)

Status codes:
  - WebDAV-only: 102, 207, 208, 422, 423, 424, 507, 508
  - 1**: information
     - 100 (Continue)                         client sent only headers and can proceed to send body                   See Expect: 100-continue [C]
     - 101 (Switching Protocols)              switch protocol success, e.g. from HTTP to HTTPS                        See Upgrade [C]
  - 2**: success
     - 200 (OK)                               simple
     - 201 (Created)                          new resource                                                            See POST
     - 202 (Accepted)                         response is ongoing and will take some time to process                  See Long response (time)
     - 203 (Non-Authoritative Information)    proxy transformed server's 200                                          See Proxies
     - 204 (No Content)                       OK, but nothing is to be returned and client should not refresh         See request|response length
     - 205 (Reset content)                    like 204 but client should refresh                                      See request|response length
     - 206 (Partial content)                  response is only a subset of the full resource                          See Range [C]
     - 226 (IM used)                          returns diff not full resource                                          See Delta encoding
  - 3**: redirects to be performed by client
     - 300 (Multiple choices)                 redirect need client input                                              See content negotiation
     - 301 (Moved Permanently)                permanent, GET (even if different method, but should ask first)         See redirects
     - 302 (Found)                            temp, GET (even if different method, but should ask first)              See redirects
     - 303 (See other)                        different resource (not only different URL) than requested              See redirects
     - 304 (Not Modified)                     resource did not change                                                 See unconditional caching
     - 305 (Use proxy)                        redirect to a proxy                                                     See redirects
     - 307 (Temporary Redirect)               temp, same HTTP method                                                  See redirects
     - 308 (Permanent Redirect)               permanent, same HTTP method                                             See redirects
  - 4**: client-side failure
     - 400 (Bad request)                      syntax error                                                            See wrong request|response
     - 401 (Unauthorized)                     authentication problem                                                  See web authentication
     - 402 (Payment required)                 e.g. should pay to increase request rate                                See wrong request|response
     - 403 (Forbidden)                        authorization problem (and location not secret)                         See web authentication
     - 404 (Not Found)                        wrong URL, but correct domain (or auth problem with secret location)    See wrong request|response
     - 405 (Method not allowed)               HTTP method not implemented or not allowed                              See HTTP methods
     - 406 (Not Acceptable)                   wrong requested media type or encoding (compression, delta encoding)    See Accept-* [C], delta encoding, compression
     - 407 (Proxy authentication required)    like 401 but for application proxy                                      See web authentication
     - 408 (Request Timeout)                  as opposed to response timeout                                          See request|response speed
     - 409 (Conflict)                         multi-client conflict                                                   See PATCH
     - 410 (Gone)                             like 404, but indicates URL was present before                          See wrong request|response
     - 411 (Length Required)                  missing request body length                                             See Content-Length [C]
     - 412 (Precondition Failed)              resource changed even though client assumed it did not                  See conditional caching
     - 413 (Payload too large)                                                                                        See request|response length
     - 414 (URI too long)                                                                                             See request|response length
     - 415 (Unsupported Media Type)           server does not support request body media type (inverse of 406)        See wrong request|response
     - 416 (Range Not Satisfiable)            wrong Range [C]                                                         See Range [C]
     - 417 (Expectation failed)               wrong Expect [C]                                                        See Expect [C]
     - 419 (Authentication timeout)           like 401 but for authentication timeout                                 See web authentication
     - 421 (Misredirected request)            request picked wrong server                                             See alternative services
     - 426 (Upgrade Required)                 switch protocol denied                                                  See Upgrade [C]
     - 428 (Precondition required)            must use If-* [C]                                                       See conditional caching
     - 429 (Too many requests)                throttle. May include Retry-After [S]                                   See load
     - 431 (Request header fields too large)                                                                          See request|response length
     - 451 (Unavailable for Legal Reasons)                                                                            See wrong request|response
  - 5**: server-side failure
     - 500 (Internal server error)            bug in server, e.g. syntax error                                        See wrong request|response
     - 501 (Not implemented)                  feature not available yet                                               See extensions
     - 502 (Bad gateway)                      sent by proxy when it received error from server                        See proxies
     - 503 (Service unavailable)              server is down (cannot connect)                                         See load
     - 504 (Gateway timeout)                  sent by proxy on server timeout                                         See proxies
     - 505 (HTTP version not supported)                                                                               See architecture (versions)
     - 506 (Variant also negotiates)          negotiation circular loop                                               See content negotation
     - 510 (Not extended)                     HTTP extension not implemented                                          See extensions
     - 511 (Network authentication required)  like 401 but for network proxy, containing link where to authenticate   See web authentication

<meta http-equiv="HEADER" content="VAL">:
  - add HTTP header client-side
  - only ones that are crossbrowser: refresh, Content-Security-Policy

Redirects:
  - common redirect:
     - status code is 3**:
        - general cases:
           - GET (even if different method, but should ask first):
              - permanent: 301 (Moved Permanently)
              - temp: 302 (Found)
           - same HTTP method
              - permanent: 308 (Permanent Redirect)
              - temp: 307 (Temporary Redirect)
        - specific cases:
           - different resource (not only different URL): 303 (See other)
           - server ask client to use proxy instead: 305 (Use proxy)
           - need client input: 300 (Multiple choices)
           - caching: 304 (Not modified)
     - client should request again:
        - Location: URL [S]: right away
        - Retry-After: NUM|DATE [S]: in future, same URL
        - Refresh: NUM[, url=URL] [S]: in future, same URL or not. Can be used as <meta http-equiv>
     - 5+ redirects is considered infinite loop
     - keep #HASH
  - alternative service:
     - like redirects but:
        - for an ORIGIN not URL
        - routing is performed server-side, so URL remains the same client-side
        - inform client to optionally request it, instead of requiring client
     - use cases:
        - load balancing, CDN, protocol changes (HTTP->HTTPS, HTTP/1.1->HTTP/2)
        - similar to how CNAME or load balancing works
     - support: Chrome, Firefox
     - request alternative ORIGIN using header:
        - but use same URL
        - alternative ORIGIN has same privilege and behaves the same as if it was main ORIGIN
        - should be done by hop-to-hop, i.e. (if proxy) last proxy to server not client to server
     - how:
        - server:
           - Alt-Svc: ORIGIN[;VAR=VAL],... [S]
              - ORIGIN is ALPN_SCHEME="[HOST]:PORT"
              - order indicates preference
           - frame ALTSVC (0xa): 
              - Same as Alt-Svc [S] but for HTTP/2. Can be used together with Alt-Svc [S]
              - contains:
                 - Origin length [0-1], Origin [*]: 
                    - main ORIGIN
                    - only used when stream has no :scheme nor :authority, i.e. on stream ID 0
                 - Alt-Svc-Field-Value [*]: same as Alt-Svc [S]
        - client:
           - Alt-Used: HOST[:PORT] [C]
        - server:
           - 421 (Misredirected Request): if wrong Alt-Used [C]
     - caching:
        - ORIGIN clear: invalidates all cached SERVICE
        - VAR:
           - ma=NUM
              - how long to cache, in seconds (def: 1 day)
              - same calculation as Cache-Control max-age
              - checked when creating new connections, i.e. does not terminate current ones
           - persist=1:
              - if not present, should invalidate cache on server network configuration change
  - server-side redirects:
     - Content-Location: URL [S]:
        - notifies client of URL, so it can be used for caching, or future requests
        - status code is not 3**
        - similar to alternative services, but for single URL and less features
  - open redirect: see webs security doc

Time:
  - Date: DATE [C]: when request was sent 
  - X-Response-Time: NUM [S]: time taken by server to process answer
  - Accept-Datetime [C]: ask for past|present versions

Browser HTTP requests:
  - by changing current URL:
     - UI: 
        - browser chrome: back|forward|home button, URL bar, searchbar, bookmarks, etc.
        - <a|area> click event 
        - <form> submit event
     - programatically:
        - WINDOW.location|history
  - XHR.send(), FETCH

Query strings:
  - use URL?VAR=VAL&...: 
     - instead of request body 
     - like 'application/x-www-form-urlencoded' but:
        - %20 instead of +
        - nesting support: Express REQ.query
  - advantages:
     - recommended way to send request body with GET|HEAD
     - easier to set non-programatically (e.g. by typing URL)
     - stateful URL, e.g. for bookmarks
  - disadvantages:
     - non-separation of concern between resource location and request body
     - longer URL
     - SEO

Software identity:
  - User-agent: STR [C]: client technology
  - X-Requested-With: STR [C]:
     - how request was performed
     - often used: XMLHttpRequest
  - Server: STR [S]: server name
  - X-Powered-By: STR [S]: server technology
  - Pragma: VAL [C|S]: headers specific to a given client|server technology
  - X-UA-Compatible: CLIENT=VERSION;... [S]: 
     - client, if CLIENT, should render as it was VERSION
     - used with IE, e.g. IE=NUM|edge

Client identity:
  - From: EMAIL_ADDRESS [C]: often used with bots for support email

Content transformation:
  - possible transformations:
     - variants: 
        - specific to the entity, changes final representation
        - e.g. language, charset, Content-Type, features
     - content-encoding: 
        - specific to the entity, does not change final representation
        - e.g. compression, ranges, delta encoding
        - order is unspecified, except by A-IM [C] and IM [S]
     - transfer-encoding:
        - specific to the request/response
        - e.g. Transfer-Encoding [S]
        - forbidden in HTTP/2
  - content can be:
     - resource: highest-level
     - variant
     - instance: a variant inside a request/response body
     - entity/representation: an instance after content-encoding, then transfer-encoding

Content syntax/semantics:
  - request body:
     - 415 (Unsupported Media Type): wrong request body MIME_TYPE
     - Prefer: handling=strict|lenient [C]: should validate [not] strictly request body
  - response body:
     - semantics depends on status code:
        - no body if CONNECT, 1**, 204 or 304
     - Content-Disposition: DISPOSITION[; ATTR="VAL"] [S]:
        - how to process, among:
           - attachment: prompts for download
           - inline: render
        - ATTR:
           - filename 'FILE':
              - def: use content-type
              - even for inline, might be used later when Saving through browser UI
              - must be validated (otherwise client could overwrite anywhere on the server)
        - def:
           - depends on Content-Type [S], i.e. if rendering is supported by client
           - Content-Type "multipart/form-data; boundary=STR" [S]: attachment
  - Prefer: Safe [C]:
     - should not respond with "objectionable" content, e.g. for parental control
     - Firefox, IE10 use OS/browser UI to set it

Content negotiation:
  - how:
     - client:
        - only GET|HEAD
        - Accept* [C]:
           - accepted variants:
              - Accept:         MIME_TYPE[;q=NUM],... [C]
              - Accept-Charset:   CHARSET[;q=NUM],... [C]
              - Accept-language: LANGUAGE[;q=NUM],... [C] 
              - Accept-features:  FEATURE[;q=NUM],... [C]
                 - FEATURE: FEAT, FEAT=|!=VAL, FEAT=[NUM-NUM2], !FEAT, *
                 - anything not covered by MIME_TYPE, CHARSET or LANGUAGE: MEDIAQUERYLIST, web API support, speed vs graphics, etc.
                 - should be x-FEATURE if not standard
           - NUM is preference (see below)
           - if ommitted: should not use 'choice'
        - Negotiate: VAL [C]:
           - VAL:
              - trans: supports list|choice
              - VERSION,...: supports list|choice with those variant selection algorithm versions. Can be '*'
              - guest-small: supports and ask for list|choice providing list is small enough
              - vlist: supports and ask for list|choice
              - (default): ask for ad-hoc
           - TCN: list, re-choose [S]: 
              - server forced TCN: list, although not asked by Negotiate [C]
     - server: 
        - list|choice is called 'transparent content negotiation', ad-hoc 'server-side negotiation'
        - TCN: VAL [S]: 
           - 2xx or 3xx, except 304
           - ad-hoc[, keep]: 
              - picks one variant, provides no choice to client
              - should use:
                 - Content-Location: URI [S]
                 - Content-Type: MIME_TYPE[; charset=CHARSET] [S]
                    - def: either application/octet-stream of content sniffing
                 - Content-Language: LANGUAGE,... [S]
              - 406 (Not Acceptable): wrong Accept-* [C]
           - list[, re-choose]: 
              - provides client only with possible variants:
                 - should be kept short, e.g. 2 to 10
                 - variant URI: 
                    - should not have variant itself. Otherwise should return 506 (Variant also negotiates)
                    - are best as relative "FILENAME"
                 - requires extra HTTP request
              - 300 status code
              - Alternates: CHOICE,... [S] (variants):
                 - {"URI" NUM {ATTR VAL} ...}
                    - ATTR: 
                       - type|charset|language VAL
                       - features FEATURE ...:
                          - can also use FEATURESET;[+NUM][-NUM2], where FEATURESET is FEATURE or [FEATURE ...]
                          - NUM is max quality improvement (def: 1), NUM2 max degradation (def: 0)
                       - length NUM
                       - description "STR". Use %xXX for Unicode encoding.
                       - any other x-ATTR
                    - NUM (0-1):
                       - quality
                       - calculated by remote variant selection algorithm:
                          - it also selects whether to use list or choice
                          - e.g. RVSA 1.0:
                             - NUM = product of all matching Accept*;q preferences (def: 1 for each)
                             - should use list if no NUM > 0, or only used wildcards (e.g. Accept-Features: * or Accept: */*)
                 - <URI>: fallback
                 - proxy-rvsa="VERSION,...": remote variant selection algorithm versions
           - choice: 
              - ad-hoc + list
              - "URI" must be relative "FILENAME" for security reasons
              - proxy can choose to only respond with ad-hoc answer by:
                 - Variant-Vary [S] -> Vary [S]
                 - remove Content-Location [S], Alternates [S]
                 - remove ';LIST_ETAG'
        - caching:
           - Vary: Negotiate, Accept*... [S]: list itself (list|choice)
           - Variant-Vary [S]: ad-hoc answer (choice)
           - must append ";LIST_ETAG" to each variant ETAG
     - client:
        - accepts chosen variant (ad-hoc, choice) or ask for a specific one (choice, list)
        - when using TCN: ad-hoc, keep, force accepting chosen variant
  - proactive (ad-hoc) vs reactive (list):
     - proactive:
        - puts work on the server
        - Accept* [C] allows fingerprinting user agent (privacy concern)
        - requires Vary [S] (see Vary for problems associated with it)
     - reactive:
        - puts work on the client
        - might yield better guess
        - one more request
  - might also be used with content negotiation: 
     - compression: Accept-Encoding [C], Content-Encoding [S]
     - delta encoding: A-IM [C], IM [S]

Links:
  - Location: URI [S]
     - like Link [S] but semantics is defined by status code
     - ex:
        - 201: created resource
        - 3**: redirect to
  - Link: <URL>[; ATTR="VAL"];... [, <URL>...] [S]
     - goal:
        - semantic relationship
           - i.e. independant of representation (including MIME type)
        - between:
           - RESOURCE: the one returned 
           - RESOURCE2: at URL
        - any cardinality, including n-n relationship
     - ATTR:
        (for RESOURCE, authoritary)
        - rel "REL ..." (mandatory): relation type from RESOURCE to RESOURCE2
           - REL can be URI describing a REL type (instead of a 'REL' name)
        - anchor "URI|#HASH": for RESOURCE
        (for RESOURCE2, hints only)
        - type "MIME"
        - hreflang "LANG"
        - media "MEDIAQUERYLIST"
        - title "STR": for accessibility
        - title* "CHARSET...": like title "STR" but with a specific CHARSET
        - VAR "VAL"
  - <link ATTR="VAL">:
     - same as Link [S]
     - only works with <link> syntax: 'stylesheet', icon-related
  - [UN]LINK:
     - HTTP method unsafe, idempotent
     - asks to add (or change) or remove links to a resource
        - only one LINK between RESOURCE and RESOURCE2 for a given REL (so it can be changed)
     - accompanied with Link [C] (same as Link [S])
     - no request body
  - REL:
     (general)
     - 'type': information about the semantic type (not MIME) of resource
     - 'profile': similar to 'type'
     (versions of same resource)
     - 'alternate': alternative versions
     - 'canonical': 
        - preferred version among alternatives
        - search engines will use this link instead
     - 'latest-version'
     - 'working-copy[-of]'
     - 'predecessor|successor-version'
     - 'version-history'
     (collection type)
     - 'first|last' 
     - 'next|prev'
     - 'index|up'
     - 'collection', 'item'
     (information type)
     - 'bookmark'
     - 'preview'
     - 'tag'
     - 'create|edit-form': create or edit a FORM
     (meta-information)
     - 'about': resource meta-information
     - 'author'
     (section type)
     - 'contents': table of contents
     - 'chapter|[sub]section': full chapter or [sub]section
     - 'search'
     - 'sidebar'
     - 'appendix'
     - 'archives'
     - 'help': e.g. FaQ, documentation
     - 'glossary'
     - 'copyright'
     - 'license'
     - 'disclosure': patent disclosures
     - 'privacy-policy'
     - 'terms-of-service'
     (external references)
     - 'external': not endorsed (e.g. ads)
     - 'nofollow': crawlers
     - 'noreferrer': do not set Referrer [C]
     - 'pingback': should get a notification at this URL when used as reference
     (prefetching)
     - 'preload', 'prerender', 'preconnect', 'dns-prefetch'
     (not semantic)
     - 'stylesheet': e.g. CSS (or CSS preprocessor) stylesheet
     - icon-related: 'icon', 'shortcut', 'apple-touch-icon-precomposed'

Caching:
  - vocabulary:
     - cache hits ratio: % of requests that used cache instead
     - stale resource (as opposed to fresh): cached but not valid anymore
     - cache invalidation: removing caching on stale resources
  - types:
     - client caching: 
        - best performance but for single client
        - e.g. browser caching
     - server caching:
        - shared by many clients but less performant
        - types:
           - reverse proxy (between client and server)
           - between server and database (e.g. Memcached/Redis)
  - what is cached:
     - key:
        - HTTP method
        - URI, excluding #HASH
        - HTTP headers, if Vary: HEADER [S]:
           - whitespaces, orders, case, identical values will be normalized before comparison
           - if unconditional caching failed because of different HTTP headers: 
              - client should try conditional caching
              - but if client does not implement this HEADER, it might not send it, e.g.:
                 - CLIENT_1 -> HEADER    -> PROXY -> HEADER                          -> SERVER -> 2** Vary: HEADER
                 - CLIENT_2 -> no HEADER -> PROXY -> no HEADER (conditional caching) -> SERVER -> 304
                    - here CLIENT_2 gets same response as CLIENT_1 even though HEADER varied
              - solutions:
                 - use new status code understood (thus cached) only by clients/proxies that implement HEADER
                    - ex: 226 for delta encoding
                    - problem: some clients/proxies cache any unknown status codes
                 - solutions like Cache-Control: im (delta encoding)
           - can significantly increase reverse proxy cache size
           - use case:
              - when headers have impact on content, i.e. usually on Accept* [C]
              - usually towards proxies, since browsers usually use only one set of headers
        - does not include request body
     - value: full response (URL, headers, body)
  - HTTP methods allowed:
     - GET
     - HEAD: theoritically. But web browsers do not seem to allow it. 
     - others: 
        - only with conditional caching (except If-Modified-Since), when manually added using XHR
  - status codes:
     - specified as:
        - should be cached: 200, 203, 204, 206, 226, 300, 3001, 308, 404, 405, 410, 414, 421, 451, 501
        - should not cached: 302-307, 428, 429, 431, 511
        - rest is unspecified
     - browser default unconditional caching:
        - Chrome/Opera: 300, 301, 308, 410
        - Firefox: 410
     - browser allowed unconditional caching:
        - Chrome/Opera: all but 205, 401, 416
        - Firefox: only 200, 203, 206, 410
  - default:
     - depends on browser, heuristics to guess which type of caching should be used and how long
     - to avoid
     - see above for which status code use unconditional cache by default or not
  - types:
     - history backward/forward caching: no control over it
     - unconditional caching:
        - client uses cache for a given time period, without server interaction
           - does not apply on page refresh
           - has priority over conditional caching
        - features:
           - fastest cache method
           - highest probability of stale resources, except when using timestamping or invalidation push
           - best for asset files
        - Cache-Control: STR,... [S|C]:
           - client override server
           - STR (client or server):
              - no-cache[="HEADER,..."]: 
                 - no unconditional caching [of a specific header]
                 - HEADER: only for server
              - no-store: no any form of caching, including unconditional or conditional
              - max-age=NUM: 
                 - how long to cache (in secs), i.e. how long stale resources are ok
                 - max: 1 year
                 - if fingerstamped, can be max value
                 - initial age is max between:
                    - 0
                    - response_received - Date [S]
                    - response_received - request_sent[ + Age: NUM [S]]
                       - Age: in secs, should be incremented by proxies
              - Expires: DATE [S]:
                 - same as max-age but using a given DATE
                 - older header
              - no-transform: 
                 - don't allow proxy to compress|minify resources (e.g. images/videos) or inject JavaScript code
              - stale-if-error=NUM: 
                 - on 500-504, use unconditional cache, if stale for <NUM seconds
                 - def: unless must-revalidate
           - STR (server only):
              - must-revalidate: 
                 - when expires, use conditional caching (if setup)
                 - default of most clients
              - public or private[="HEADER,..,"]:
                 - allow or prohibit (def) proxy caching
                 - private: good for sensitive data, e.g. cookies
              - state-while-revalidate=NUM:
                 - if stale for <NUM seconds, proxy will:
                    - serve stale resource
                    - while retrieving fresh resource in the background for the next request
              - s-maxage=NUM: same as max-age but for proxies
              - proxy-revalidate: same as must-revalidate but for proxies
              - retain[=NUM]: see delta encoding
              - im: see delta encoding
           - STR (client only):
              - max-stale=NUM: extend max-age|Expires with NUM seconds
              - min-fresh=NUM: must be cacheable for at least NUM seconds, otherwise ignore
              - only-if-cached: 504 if no unconditional cache available
        - Surrogate-Control: STR[;TARGET],... [S]:
           - similar to Cache-Control but from server to proxy (has priority)
           - supported by many reverse proxies
           - STR:
              - no-store: like above
              - no-store-remote: like no-store but non-last proxies
              - max-age=NUM[+NUM]: like max-age + stale-while-revalidate above
              - content="TRANSFORM ...": which transformation can be performed
           - TARGET: 
              - identify proxy, when there are several along the chain
              - no TARGET: "all other TARGET"
           - proxy use Surrogate-Capabilities: TARGET="VAL ..." to inform:
              - which Surrogate-Control values are supported 
                 - Surrogate/1.0 for the ones above
              - supported TRANSFORM
        - timestamping:
           - using an ID in the URL that changes when resource changes
              - e.g. version number, modification date or content checksum
           - used to invalidate cache on modified resources
           - top-level resources (i.e. that require timestamped resources) (e.g. main HTML file) cannot be timestamped itself
        - invalidation push:
           - using push technologies to invalidate resources
           - allow using unconditional caching with top-level resources
           - but:
              - more complex to implement
              - higher risk of unwanted unconditional caching if something goes wrong
     - conditional caching:
        - client sends request with information about latest representation, and server does not send body if resource has not changed
        - features:
           - slower method but no possibility of stale resources
           - does not require timestamping
           - best for top-level resources, e.g. main HTML file or AJAX calls
        - how:
           - server:
              - Last-Modified: DATE [S] 
                 - of the "instance" (not "entity")
              - ETag: "ETAG" [S]
                 - usually content hash or version number
                 - [:graph:]
                 - ETAG:
                    - "...": 
                       - strong, same "instance" (not "entity"), i.e. same byte-wise
                       - usually not shared by different representations
                       - preferred
                    - W/"...": 
                       - weak, same "resource", i.e. same semantically but not necessarily byte-wise
                       - usually shared by different representations
                       - cannot be used with:
                          - If-Range [C] 
                          - If-Match [C] or If-Unmodified-Since [C]
                          - delta encoding
                       - "..." == W/"..."
           - client include latest representation:
              - If-[Un]Modified-Since: DATE [C]
              - If-[None-]Match: "ETAG"|*,... [C]
                 - if specified, If-[Un]Modified-Since is ignored
                 - can use several if client cached several
           - server:
              - if condition does not match:
                 - 304 (Not modified) with no body: 
                    - If-Modified-Since or If-None-Match, and safe HTTP method
                 - 412 (Precondition failed):
                    - otherwise
                    - not used for caching, but e.g. do not DELETE if resource has changed
              - can use 428 (Precondition required) to force conditional caching
     - no caching:
        - features:
           - slowest method, but:
              - best if resource never same, e.g. anything that contains time-dependent/always-unique server-side content
              - prevent caching credentials
        - how:
           - server:
               Cache-Control: no-cache[="HEADER"], no-store, private, must-revalidate
           - client (works also for HTTP/1.0 servers):
               Cache-Control: no-cache, no-store, private, must-revalidate
               Pragma: no-cache
               Expires: 0
  - debugging:
     - high-level: about:cache (Chrome, Firefox)
     - low-level: about:net-internals#httpCache (Chrome)

Delta encoding:
  - very poor support both client-side and server-side
  - goal is to reduce response body size:
     - client:
        - use conditional caching request
        - but has cache of older version
     - server:
        - cannot respond with 304 (since older version)
        - responds with diff instead of full new entity
     - client applies diff to older cached version
  - means both server and client need to keep older versions
  - must be done together with conditional caching:
     - If-None-Match: "ETAG",... [C] (strong)
     - ETag: "ETAG" [S]
  - how:
     - client:
        - A-IM: ALGO[;VAR=VAL][;q=NUM],... [C]
           - ALGO:
              - specifies:
                 - order in which content-encoding transformation should be applied
                 - which DIFF_ALGO are supported
              - can be:
                 - DIFF_ALGO:
                    - vcdiff
                    - gdiff
                    - diffe: diff -e
                 - COMPRESSION_ALGO
                 - range
           - VAR: ALGO params
           - q=NUM: like content negotation
     - server:
        - 226 (IM Used)
        - IM: ALGO[;VAR=VAL],... [S]
        - Delta-base: "ETAG" [S]
           - source of the diff
           - mandatory when several "ETAG" specified in If-None-Match [C], recommended otherwise
        - 406 (Not acceptable): ALGO not supported
  - caching:
     - can cache 226 responses either as full entity (200 or 206) or as diff (226)
     - Vary: A-IM [S]:
        - client cache should implicitely use Vary: A-IM [S]
        - but needs to be explicit for proxies that do not understand delta encoding
        - should also use Cache-Control: no-store, im [S]:
           - see Vary [S] above for the problem associated with it
           - proxies that understand delta encoding should ignore no-store if "im" is present
           - proxies that do not understand delta encoding will use no-store
     - Cache-Control: retain[=NUM] [S]
        - hint that client should keep response cached because it might be used later as diff source
        - for NUM seconds (same calculation as Cache-Control max-age)

Prefetching (resource hints, server push):
  - types, from most performant to least:
+--------------+----------------------------------------------+---------------------------------------------------------------------+------------------------------------+
| Type/REL     | Use case                                     | Effects                                                             | Browser support                    |
|              +--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+                                    |
|              | Resource for which | Known path | Likelihood | Initiated | When is resource        | Loads | Parse + | Protocols   |                                    |
|              | navigation action  |            |            | by        | fetched                 |       | render  |             |                                    |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| server push  | Current            | Yes        | Certain    | server    | right away (no request) | Yes   | Yes     | HTTP        | All                                |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| preload      | Current            | Yes        | Certain    | client    | async right away        | No    | No      | HTTP        | Chrome/Opera                       |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| preconnect   | Current            | No         | Certain    | client    | async right away        | No    | No      | DNS         | Chrome/Opera/Firefox               |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| prerender    | Next               | Yes        | High       | client    | after document.onload   | No    | Yes     | HTTP        | Chrome/Opera/IE                    |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| prefetch     | Next               | Yes        | Middle/low | client    | after document.onload   | No    | No      | HTTP        | not [mobile] Safari nor Opera mini |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| dns-prefetch | Next               | No         | Middle/low | client    | after document.onload   | No    | No      | DNS+TCP/TLS | not Opera mini                     |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
  - server push:
     - send additional resources in a single response
     - performance:
        - less roundtrips than resource hints
        - but should push only resources that would have been requested
     - caching:
        - uses pseudo-client request for caching, so works the same as normal request
        - client request must be cacheable, i.e. GET with cache headers
     - not actual prefetching (it loads resource)
     - need to be initiated by a request (so not realtime)
     - as opposed to resource hints, initiated by server so cannot be used if:
        - client needs knowledge about fetching: resource path, load|error event
        - fetching needs knowledge about client: state (cookies, localStorage), user agent info (Accept [C], etc.)
  - resource hints:
     - use Link [S] (or <link>) REL
     - ATTR:
        - pr 'FLOAT' (0-1) (all)
           - probability the link will be followed 
           - used for prioritization or reducing optimization/fetching
        - as TYPE (preload|prefetch): 
           - WINDOW.fetch() destination type, 
             i.e. script|style|image|font|media|object|embed|document|xslt|manifest|report|service|shared]worker
           - used for CSP and Accept [C]
        - nopush (preload): if a HTTP2 server push has been received for that resource, do not use it
     - prerender parsing/execution:
        - in the background, i.e. not visible but will provide very fast cache
        - only kept for short while, so should be next navigation
        - resource intensive: should only be used when confident about next navigation action
        - only HTML resources
        - can debug with about:net-internals#prerender (Chrome)
     - does not delay document.onload
     - could previously use noop XHR to achieve something similar
     - cannot see in devtools network tab, but can see "prerender" using chrome://net-internals/#prerender
     - can be:
        - speculative: before user interaction that might trigger HTTP request
        - reactive: after user interaction that will certainly trigger HTTP request, after some delay
     - possible problems:
        - when HTTP GET request has side effects (which is improper)
        - increase bandwith usage
        - overestimate tracking (ads, analytics):
           - can use document.visibilityState 'prerender' to handle it
        - security: website make decision (not user) to trust content by browsing it

Request|response length:
  - hint (request|response):
     - Content-Length: NUM [C|S]:
        - request|response body length ('entity', not 'instance')
        - presence:
           - mandatory if body present
           - forbidden with chunked transfer encoding
           - can use 411 (Length Required)
        - only hint to help allocating resources or download progress:
           - not substitute for reading actual body length
  - unkwnown length (request|response):
     (HTTP/2)
     - not sending END_STREAM flag
     - use trailer HEADER frame for headers that are based on body, when body is not known in advance
        - TE: trailers [C] can be used (see below)
     (HTTP/1.1)
     - Chunked transfer encoding:
        - send request|response body in several times
        - how:
           - TE: WORD[;q=NUM],... [C]:
              - optional
              - indicates preference for WORD:
                 - trailers: Trailer [S]
                 - other WORD: Transfer-Encoding: WORD [S]
              - q=NUM: like content negotiation
           - Transfer-Encoding: chunked [S|C]:
              - sent with each chunk:
                 - first line is SIZE_HEX_NUM[;VAR=VAL;...]
                 - rest is data
              - empty chunk indicates end
           - Trailer: HEADER [S]
              - optional
              - unless HEADER is not important (client can use body without it), only if TE: trailers [C]
              - HEADER is limited, e.g. cannot be related to:
                 - message processing: Transfer-Encoding, Content-Length
                 - content processing: Content-Encoding, Content-Type, Content-Range, Trailer
                 - routing: Host, :authority
                 - authentication
                 - response control: Cache-Control, Expires, Date, Location, Retry-After, Vary, Warning
                 - request modifiers: Range, Max-Forwards
        - applied after any transformation (compression, range, delta encoding)
           - should use compression
  - big length:
     - request:
        - Chunked transfer encoding, not sending END_STREAM flag (see above)
        - sending header before sending body:
           - client: Expect: "100-continue" [C], no request body
           - server:
              - 100 (Continue) if success
              - 417 (Expectation Failed) if failure
           - client: request body
        - request too large:
           - 414 (Request URI too long)
           - 431 (Request header fields too large)
           - 413 (Request Entity too large)
     - response:
        - Chunked transfer encoding, not sending END_STREAM flag (see above)
        - request specific ranges (byte serving):
           - init: 
              - server:
                  200 (OK)
                  Accept-Ranges: VAL [S]:
                    - bytes
                    - none (def)
                    - any other UNIT: will require different Range [C] and Content-Range [S] values
                  Empty response body
           - each range:
              - client:
                 - only GET
                 - Range: bytes=RANGE,... [C]
                    - RANGE: NUM-[NUM2] or -NUM (last bytes)
                 - If-Range: ETAG|MDATE [C] (optional)
                    - like If-Match|If-Unmodified-Since, except if fails, should ignore Range [C]
                    - goal: only retrieve each range if "instance" remains the same (otherwise would be corrupted)
              - server:
                 - success:
                    - 206 (Partial content)
                    - caching:
                       - ETAG|MDATE:
                          - designates the "instance", not "entity", i.e.:
                             - whole resource not RANGE
                             - must be same as first 200 (OK) response
                       - ETAG must be strong
                    - Accept-Ranges: VAL [S]
                    - only one RANGE was requested:
                        Content-Range: bytes NUM-NUM2/TOTAL [S] 
                          - TOTAL can be * if unknown
                    - several RANGEs were requested:
                        Content-Type: "multipart/byteranges; boundary=STR" [S], with body:
                          STR	
                          [Content-Type: TYPE]
                          Content-Range: bytes NUM-NUM2/TOTAL
                          content as is
                          STR
                          ...
                          STR--
                 - failure:
                     416 (Requested Range Not Satisfiable)
                     Content-Range: bytes */TOTAL [S] 
  - partial body:
     - request:
        - PATCH method (see above)
     - response:
        - HEAD method (see above)
        - Prefer: return=minimal [C]:
           - like HEAD but can be done on other HTTP methods, and can include request body
        - Prefer: return=representation [C]:
           - should return only what has been changed by request, not full resource
           - should also include Content-Location [S] to full resource
  - empty body:
     - e.g. DELETE, If-Unmodified-Since [C], If-Match [C]
     - status code:
        - 204 (No Content): 
           - client should not refresh current resource|document
           - e.g. browsers will not reload after a <form> POST
        - 205 (Reset content): 
           - client should refresh current resource|document
           - not implemented by browsers

Request|response speed:
  - request:
     - 408 (Request timeout)
  - response:
     - 202 (Accepted): 
        - async processing
        - client can timeout
        - should include link to monitor processing status, e.g. using Content-Location [S]
     - Prefer: respond-async [C]:
        - should process async (if takes too long) and return 202
     - Prefer: wait=NUM [C]
        - should not wait more than NUM seconds to process async
        - can be combined with Prefer: respond-async [C]

Load:
  - throttle:
     - 429 (Too many requests) 
     - May include Retry-After [S]
  - 503 (Service unavailable): client cannot connect to server

Response processing:
  - Prefer [C]:
     - client:
        - Prefer: VAR[="VAL"][;ATTR="VAL"...] ,... [C]:
        - ask server to handle request body in a specific way
           - should not be used for content negotiation
        - can be present several times per request (with different VARs)
        - def VAL: ""
        - VAR: 
           - respond-async, time=NUM, return=minimal, return=representation, handling=strict|lenient, safe: see this doc
           - x-VAR
     - server:
        - Preference-Applied: VAR[="VAL"] ,... [S]: which Prefer [C] were honored

Content location:
  - Content-Location: URL [C|S]:
     - URL of request|response body itself
        - if GET|HEAD request and 200|203|204|206|304 response, response body is requested resource, i.e. Content-Location [S] def to request URI
     - body can be partial|symbolic, in which case URL points to full representation
     - use cases:
        - request body provenance
        - response body alternative|real provenance, e.g. server-side redirects or content negotiation
        - partial|symbolic body, e.g. Prefer: return=representation [S] or 202 (Accepted)
        - with unsafe methods, indicating response body is latest representation

Wrong request|response:
  - request:
     - syntax:
        - HTTP method: 405 (see HTTP methods)
        - URL
           - size: 414 (see request|response length)
           - 404 (Not Found): wrong and never was right 
           - 410 (Gone): wrong but used to be right 
        - headers:
           - size: 431 (see request|response length)
           - missing headers:
              - 411 (Length Required): Content-Length [C]
              - 426 (Upgrade Required): Upgrade [C]
              - 428 (Precondition Required): If-* [C]
        - body:
           - size: 413 (see request|response length)
           - 406 (Not Acceptable): wrong media type or encoding (See content negotiation, delta encoding, compression)
        - any:
           - 400 (Bad request): syntax error
     - semantic:
         - 409 (Conflict): multi-client conflict (see PATCH)
     - authentication: 401|407, 403, 419, 511 (see web authentication)
     - financial: 402 (Payment required)
     - legal: 451 (Unavailable for Legal Reasons):
        - censorship, copyright, privacy. 
        - can include Link [S] with rel="blocked-by"
  - response:
     - syntax: 500 (Internal server error)
     - not implemented: 501, 510 (see extensions), 505 (see architecture/versions)

Proxies:
  - types:
     - forward proxy: 
        - acts on behalf of client
     - tunnels (see below)
        - acts on behalf of client, but only to forward another protocol
     - transparent|intercepting|inline|forced proxy:
        - acts on behalf of the network
        - can be used e.g. for authentication ("captive portal"), enforce use policy, etc.
     - reverse proxy / surrogate / gateway:
        - acts on behalf of server
        - can be:
           - ISP
           - web accelerator: 
              - reverse proxy dedicated to caching
              - can also do prefetching, compression/minification
           - CDN: 
              - network across several geographical regions to be closer to clients
              - optimized for high availability
  - previous|current node info in the proxy chain:
     - comparison:
        - previous node: Forwarded [C], X-Forwarded-* [C] ; current node info: Forwarded [C], Via [C|S]
        - can add description: Via [C|S]
        - works also for responses: Via [C|S]
        - standard: Forwarded [C], Via [C|S]
        - record SCHEME change: Forwarded|X-Forwarded-* [C]
        - add each node to:
           - a new header value (all)
           - or a new header: Forwarded [C]
     - can use:
        - Forwarded: VAR=VAL;... ,... [C], with VAR:
           - host HOST, for NODE, proto SCHEME: 
              - previous node info
              - NODE:
                 - IP[:PORT]
                 - unknown
                 - CUSTOM_NAME (using [[:alnum:]._-])
           - by NODE: current node info
        - X-Forwarded-Host|For|Proto|Port: HOST|IP|SCHEME|PORT,... [C]: current node info
        - Via: [HTTP/]HTTP_VERSION HOST[:PORT]|CUSTOM_NAME [(DESCRIPTION)] ,... [C|S]: current node info
     - optional for each proxy in the chain (can even remove existing ones)
     - when several, the leftmost is the closest to origin
  - Max-Forwards: NUM [C]: max number of proxies
  - Warning: NUM - "DESCRIPTION" "DATE" [S]
     - 1**: caching-related, should be updated by 403:
        - 110 "Response is Stale": proxy served stale resource instead of retrieving fresh one from server
        - 111 "Revalidation Failed": same as 110, but reason is because server unavailable
        - 112 "Disconnected Operation": same as 110, but reason is proxy not connected to network
        - 113 "Heuristic Expiration"
        - 199 "Miscellaneous Warning"
     - 2**: other 
        - 214 "Transformation applied": 
           - e.g. ones prevented by "no-transform"
           - if 200 (OK), should transform to 203 (Non-Authoritative Information)
        - 299 "Miscellaneous Persistent Warning"
  - transformations:
     - see above for: Cache-Control: no-transform [S|C], Surrogate-Capabilities [C], Surrogate-Control: content [S]
  - error from proxy to server:
     - 502 (Bad gateway): error from server
     - 504 (Gateway timeout): server timeout
  - should always assume a proxy might be present

Security: See Websites_security doc

Authentication: see authentication doc

Instance integrity:
  - digest:
     - how:
        - Want-Digest: ALGO[;q=NUM],... [C]
           - ALGO: 
              - MD5|SHA[-256|512]|UNIXsum|UNIXcksum
              - MD5|SHA[-256|512] requires base64, other ASCII
           - NUM: like for Accept* [C]
        - Digest: ALGO=CHECKSUM[,...] [S]
     - check integrity for "instance" (not "entity"), body not headers
     - not implemented by most clients
  - Content-MD5 [C]: deprecated

Tracking:
  - Private browsing:
     - a private session erases at the end all the traces (history, cookies, cache) it created.
     - called Incognito in Chrome
  - Referer: URL [C]:
     - current URL
     - Link: noreferrer [S]: ask client not to send it
  - Do not track:
     - client:
        - DNT: VAL [C]
           - VAL is preference about tracking:
              - 1: disallow
              - 0: allow
              - (default) no preference
           - must be explicitely enabled inside browser settings
           - can check WINDOW|NAVIGATOR.doNotTrack (see DOM doc)
           - NAVIGATOR.store|remove|confirmSiteSpecific|WebSideTrackingException():
              - change site-specific or all-sites privacy settings (not implemented yet)
     - server:
        - Tk: VAL [S]:
           - VAL:
              - N: no tracking
              - T: tracking, normal
              - C: tracking, consent through a different way than DNT [C]
              - P: tracking, consent will come later. If constent rejected, previous data will be deleted|anonymized.
              - D: tracking, ignore DNT (e.g. for technical|legal reasons)
              - G: tracking, is only gateway
              - U: switched tracking, because of a different way than DNT [C]
              - ?: different VAL per request. VAL must be VAL;ID
              - !: currently implementing DNT
           - is per resource
        - 409 if refuse to deliver resource because of DNT: 1 [C]
     - GET /.well-known/dnt/[ID]:
        - must contain Content-Type "application/trackings-status+json":
           - tracking VAL (mandatory): current Tk [S]
           - compliance URL_ARR: privacy law/regulation
           - qualifiers STR: options opted in for the specific privacy law/regulation, as list of chars
           - controller URL_ARR: responsible for holding data
           - same-party URL_ARR: websites that have different domains but actually are first-party
           - audit URL_ARR: external audits of DNTs
           - policy URL: privacy policy
           - config URL:
              - where user can configure privacy
              - mandatory if Tk: C|P
        - ID is used with Tk: ? [S]
        - this GET request should never be tracked itself
     - what "tracking disallow" means with DNS: 1 [C]:
        - depends on compliance URL
        - W3C "Tracking Compliance and Scope" (http://www.w3.org/TR/2016/CR-tracking-compliance-20160426), tracking must:
           - anonymize data:
              - cannot link data to specific user
                 - user-agent, device, geolocation: allowed if general enough, e.g.:
                    - no IP address 
                    - no fingerprinting 
                    - no very specific geolocation
                 - that implies no cross-site tracking
              - cannot link patterns (i.e. several datapoints) to specific user|device, even anonymous
           - receive consent, except for (letters are "qualifiers", see above):
              - c: frequency capping (e.g. only showing something once)
              - s: security
              - f: financial/billing
              - d: debugging
           - sharing with service providers (e.g. AWS) require:
              - consent
              - qualifier "t"
           - not collect more nor longer than needed
              - retention period must be public
           - use sound security practices
     - should also have privacy policy
        - should also be at /.well-known/dnt-policy.txt

Cookies:
  - goal:
     - store state for a specific client+server pair
     - can be ignored by some clients
     - clients will remove them due to memory constraints or end-user demand
  - how:
     - server:
         Set-Cookie: VAR=VAL[;OPTIONS] [S]: one header per cookie
         OPTIONS is SVAR=VAL;...
     - client, next request on same domain+path:
         Cookie: VAR=VAL[;...] [C]: one header for all cookies
     - VAL are percent-encoded
     - SVAR:
        - domain STR:
           - must be same as server, or superdomain
           - subdomains will match
        - path '/PATH'
           - recursive
        - expires|max-age: 
           - DATE|NUM seconds before expiration 
           - max-age has priority
           - def: end of session
           - 0 deletes cookie
        - secure: can only get|set via HTTPS
        - HttpOnly: can't be used via JavaScript (document.cookies), for security reasons
  - limits:
     - 4KB/cookie (most browsers)
     - 50/domain (IE11)
     - 10KB/domain (IE11)
  - types:
     - first-party cookie:
        - cookie path/domain (i.e. HTTP request) is same as top-level page path/domain
     - third-party cookie:
        - inverse
        - can be blocked in browser settings
        - only disabled by default in Safari
     - Zombie cookie:
        - use cookies but also other storage at once, e.g. localStorage, ETag [S], Flash cookies, etc.
        - removing from one place -> others recreate it
  - security: see web security doc

Compression:
  - how:
     - client: Accept-Encoding: COMPRESSION_ALGO,... [C]:
        (standard)
        - "identity" (none)
        - "compress":
           - worst compression, older
           - older: not supported anymore
        - "deflate":
           - DEFLATE/INFLATE algorithm
           - inconsistent support: either without a wrapper format (IE) or with zlib wrapper format (other browsers)
        - "gzip":
           - DEFLATE/INFLATE algorithm, with gzip wrapper format
        - "exi":
           - better compression than DEFLATE, for XML files
           - w3c standard but no browser support
        (not standard)
        - "bzip2" 
           - better compression than DEFLATE but slower
           - browser support: Firefox only with specific build flag
        - "lzma":
           - better compression than DEFLATE but slower
           - better compression than bzip2, but slower, faster at decompressing but slower at compressing 
           - browser support: Opera
        - "xz":
           - LZMA2
           - browser support: Firefox only with specific build flag
        - "sdch": 
           - based on VCDIFF
           - does not seem really maintained anymore
           - browser support: Opera, Chrome
        - "br"
           - best compression. Same decompression speed as DEFLATE but slower at compressing.
           - browser support: Firefox, Chrome
     - server: 
        - Content-Encoding: COMPRESSION_ALGO,... [S]: which one picked
           - can also use Transfer-Encoding: COMPRESSION_ALGO [S]: more proper but less support, and forbidden by HTTP/2
        - Accept-Encoding: COMPRESSION_ALGO,... [S]: which one could have been possible
        - 406 (Not accepted): none could be picked
  - summary: server should offer in order: br, [sdch,] lzma, gzip, identity
  - server should cache compression

Push technologies:
  - allow server to initiate message to client
  - types:
     - XHR short polling: 
        - problems: 
           - minimum delay to receive message
           - waste resources when no message
     - HTTP server push / HTTP streaming / Comet / AJAX push / Reverse AJAX:
        - leaves XHR always open, using:
           - HTTP/1.*: Transfer-encoding: chunked [S]
           - HTTP/2: no END_STREAM flag
        - pushlet: 
           - variation where XHR is initial HTML page request
           - server sends new DOM without closing request
        - problems:
           - proxies might buffer XHR, making message not come
           - XHR might be closed by browser, forcing another request
        - problems (also shared with long polling)
           - collides with max number of TCP sockets in client, and pipelining of HTTP/1.*
           - collides with max number of TCP sockets in reverse proxies
     - Long polling: 
        - leaves XHR open, but close it (then start new one) with:
           - server response
           - timeout:
              - should be high enough for performance
              - but low enough so proxies/network do not time it out
              - usually 30 seconds is good
        - problems:
           - minimum delay to receive message after a message has just been received (because client need to start new request)
           - waste resources when timeout
     - TCP socket used by plugins like Flash or Java:
        - problems: 
           - rely on browser plugins
     - Websockets
        - problems:
           - no HTTP semantics
           - no multiplexing (as opposed to HTTP/2)
  - implementations:
     - Bayeux protocol: long polling or HTTP streaming
     - BOSH: long polling with a specific POST request with standardized parameters
     - Server-send events (SSE): HTTP steaming, using Content-Type "text/event-stream", triggering DOM events
  - best: Websockets or SSE

HTTP tunneling:
  - goal:
     - wrapping another protocol packets in HTTP
     - either:
        - proxy and endpoints wraps|unwraps request|response
        - initial setup is done with HTTP, then proxy forwards the other protocol (see CONNECT)
  - advantages:
     - compatibility with existing software, including firewalls
     - with HTTPS, can completely hide the other protocol packet (including which protocol it is)
     - can use HTTP features, e.g. caching
  - problems:
     - adds HTTP features that might not be needed -> complexity
     - slower
  - should register|use different:
     - URI scheme or HTTP methods: if very different from HTTP usual behavior
     - port: if separate from HTTP server (different goal|traffic|data)
     - status codes: never, should instead reuse existing ones and make sure it matches behavior:
        - because proxies will behave according to status code (e.g. for caching)
        - if nothing matches, use general ones like 200 or 500
  - methods:
     - CONNECT:
        - how:
           - client: HTTP method CONNECT, URI is ORIGIN only
           - server: 2**
           - then server will forward the TCP connection used by HTTP request
              - it will only forward without interpreting, i.e. can be any TCP-based protocol, including HTTP
        - use cases:
           - using HTTPS end-to-end, i.e. proxy forwards SSL packets without needing to decrypt/re-encrypt them
           - any other HTTP tunneling case
        - allow client to do any TCP request, which can be security concern:
           - should restrict to specific use case by whitelisting ORIGIN and|or PORT

Practices becoming bad with HTTP/2:
  - concatenation:
     - performance impact:
        - lower number of requests
        - but invalidates cache more often
     - HTTP/2:
        - does not have limit on number of parallel requests
        - keep TCP socket always alive
        - so roundtrip performance impact is less important
     - types of concatenation:
        - file plain concatenation
        - sprites
        - inlining, e.g. <link> -> <style>
        - data URIs
  - domain sharding

MIME TYPES ==>                                  #For { VAR: VAL, ... }:
                                                #  - "text/plain": 
																								#     - VAR=VAL, newline-separated
																								#  - "application/x-www-form-urlencoded" (def): 
																								#     - VAR=VAL, &-separated, percent-encoded, but space converted to + instead of %20
                                                #     - for nesting, can use VAR[VAR2]=VAL, but must be supported by server (e.g. Express BODY-PARSER)
																								#  - "multipart/form-data; boundary=STR": 
																								#         STR	
																								#         Content-Disposition: form-data; name="VAR"[; filename="FILE"]
																								#         [Content-Type: TYPE]
																								#         content as is
																								#         STR
																								#         ...
																								#         STR--
																								#     - more efficient than percent-encoding for binary|big request body, e.g. file upload.
																								#     - STR should be long enough and random. Can include a graphical line with "------" for humans reading the request.

Debugging:
  - HTTP: about:networking#http (Firefox)
  - HTTP/2: about:net-internals#http2 (Chrome)
