
         
   DOM   
         


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            GENERAL            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


VERSION ==>                                     #4

DOM ==>                                         #Document Object Model: WINDOW.document.*

BOM ==>                                         #Browser Object Model: browser elements, i.e. frames, history, location, window

WEB APIs ==>                                    #Usually on WINDOW, e.g. WebSocket, BatteryManager, SessionStorage, etc.

XML ==>                                         #This doc doesn't include objects, etc. related to XML: check XML doc.

INTEROPERABILITY ==>                            #See HTML doc for list of browsers


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             HTML              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


INCLUDING IN HTML ==>                           #Priority is from top to bottom

<script>
  src="script.js"                               #From external file.
HTMLDOCUMENT.scripts                            #SCRIPT_HTMLCOLLECTION

<script>CODE</script>                           #Inline.

<a|area>
  href="JavaScript:CODE"                        #
<any> 
  onEVENT="CODE"                                #Deprecated. EVENT lowercase.

<noscript>...</noscript>                        #When JavaScript not available.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           UTITILIES           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


DOMError                                        #
DOMError.name                                   #STR

WINDOW.btoa|atob(STR)                           #Convert to|from Base64


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            CONSOLE            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


WINDOW.console                                  #CONSOLE

CONSOLE.info|log|warn|error(VAL)                #Can use format strings:
                                                #  - "%d": NUM  
                                                #  - "%f": DOUBLE
                                                #  - "%s": STR
                                                #  - "%o": hyperlink
                                                #  - "%c": CSS "PROP:VAL;..."
CONSOLE.dir(OBJ)                                #Pretty prints OBJ with interactivity.

CONSOLE.group[Collapsed]()                      #Starts dropdown (if Collapsed: closed at start)
CONSOLE.groupEnd()                              #Ends dropdown

CONSOLE.time[End]('NAME')                       #

CONSOLE.trace()                                 #Prints current stack.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           TIMEOUTS            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


WINDOW.setTimeout(FUNC(), DOUBLE)->UINT         #
WINDOW.clearTimeout(UINT)                       #
WINDOW.setInterval(FUNC(), DOUBLE)->UINT        #
WINDOW.clearInterval(UINT)                      #

WINDOW.requestAnimationFrame(FUNC(FLOAT))->ID   #Fire FUNC:
                                                #  - before screen refresh (usually 60 times/sec)
                                                #     - this avoids changing UI several times while screen is not refreshing
                                                #       (optimized and smoother results)
                                                #  - once, so must be done again at end of FUNC
                                               ##Ext: webkit
WINDOW.cancelAnimationFrame(ID)                 #
                                               ##Ext: webkit


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            EVENTS             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


EventTarget                                     #Parent of any object that has events (not noted in this doc)
EVENTTARGET.add|removeEventListener             #BOOL: false (def) is bubbling, true is capturing.
('event', FUNC(EVENT)[, BOOL])                  #addEventListener() does not add twice same FUNC
<any onEVENT="CODE">                            #Same but:
EVENTTARGET.onEVENT = FUNC(EVENT)               #  - can only register one handler 
                                                #  - dispatchEvent() does not work
                                                #  - kept by cloneNode()
EVENTTARGET.dispatchEvent(EVENT)->BOOL          #Returns true if defaultPrevented.


Event                                           #
new Event('TYPE'[, OBJ])                        #OBJ are assigned to EVENT.*
                                                #Def: bubbles|cancelable false

EVENT.type                                      #'click|mouseover|...'
EVENT.eventPhase                                #Event handlers are fired in that order:
                                                #  - Event.CAPTURING_PHASE: capturing handlers, from outermost to target
                                                #  - Event.AT_TARGET:       target
                                                #  - Event.BUBBLING_PHASE:  bubbling handlers (def), from target to outermost, providing EVENT.bubbles true
EVENT.bubbles                                   #True for:
                                                #  - UI events:
                                                #     - except select, resize, scroll
                                                #     - focus|blur does not bubble, but focusin|out fixes it
                                                #     - mouse|pointerover|out does bubble (should not), but mouse|pointerleave|enter fixes it
                                                #  - UI-related events:
                                                #     - fullscreen*, selectstart, SVG* (except SVG[Un]Load), visibilitychange
                                                #  - location-related events:
                                                #     - DOMContentLoaded, hashchange, popstate
                                                #  - transitionend
                                                #  - resourcetimingbufferfull
EVENT.currentTarget                             #The current EVENTTARGET (=== this in event handler)
EVENT.target                                    #The original EVENTTARGET

EVENT.cancelable                                #True for:
                                                #  - bubbling UI events, except:
                                                #     - end|abort-related: abort, dragend|leave, pointer|touchcancel, pointerlockchange|error
                                                #     - input, change
                                                #     - animation*
                                                #  - selectstart, transitionend, resourcetimingbufferfull
                                                #  - reset, beforeunload, invalid
EVENT.preventDefault()                          #Cancel browser default handler (but not user handlers)
EVENT.defaultPrevented                          #preventDefault() has been called

EVENT.stopImmediatePropagation()                #Do not call any further user handlers
EVENT.stopPropagation()                         #Same, except for currentTarget's ones

EVENT.timeStamp                                 #DATE_NUM (Epoch in ms)


CustomEvent                                     #Child of EVENT
CUSTOMEVENT.detail                              #Anything


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            UIEVENT            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


UIEvent                                         #Child of EVENT
UIEVENT.view                                    #WINDOW

FocusEvent                                     ##UIEVENT child, for focus*|blur
                                               ##Needs jQuery right now.
FOCUSEVENT.relatedTarget                       ##For blur|focusout, the ELEM that gets focused instead. 
                                               ##For focus|focusin, the ELEM that lost the focus.

ALL                                             #Is HTMLELEM|DOCUMENT|WINDOW

ALL.onfocus|blur = FUNC(UIEVENT|FOCUSEVENT)     #Gains|loses focus. Not with links. Can sometimes fire twice.
ALL.onfocusin|out = FUNC(UIEVENT|FOCUSEVENT)   ##Like focus/blur, but bubbles. (needs jQuery)
HTMLELEM.focus|blur()                           #Emit those events
JQ.focus(UINT[, FUNC()])                       ##Same but with a delay (in ms) (jQuery UI)
HTMLDOCUMENT.activeElement                      #Currently focused ELEM. If none, BODY.
                                                #Readonly.

ALL.onselect = FUNC(UIEVENT)                    #Selection in a <textarea> or <input type="text">
ALL.oninput = FUNC(EVENT)                       #Form field value changes.
ALL.onchange = FUNC(EVENT)                      #Same but only when completed (<input> after entering Carriage return or lose 
                                                #focus e.g.)
ALL.onsubmit = FUNC(EVENT)                      #When submitting form


KeyboardEvent                                   #UIEVENT child
                                                #Not used by mobile devices.
                                                #Modifier keys launch event themselves.
KEYBOARDEVENT.ctrl|shift|alt|metaKey            #True if pressed while keyboard event
KEYBOARDEVENT.getModifierState(STR)->BOOL       #True if STR pressed while event, parmi "Ctrl", "Shift", "Alt", "AltGraph",
                                                #"CapsLock", "NumLock"
KEYBOARDEVENT.charCode                          #Character code (keypress only). 
                                                #Single keys: modifier keys don't have effect (but are themselves pressed).
                                               ##Can use jQuery instead.
KEYBOARDEVENT.keyCode                           #Code platform-dependant (all keyboad events)
                                               ##Can use jQuery instead.

ALL.onkeydown = FUNC(KEYBOARDEVENT)             #When key is down (repeats).
ALL.onkeypress = FUNC(KEYBOARDEVENT)            #Like keydown, but only for keys usually resulting in character being inserted.
ALL.onkeyup = FUNC(KEYBOARDEVENT)               #When key is not down anymore (only once).


MouseEvent                                      #UIEVENT child
MOUSEEVENT.screenX|Y                            #According to screen
MOUSEEVENT.clientX|Y                            #According to page (without scrolling)
MOUSEEVENT.pageX|Y                              #According to page (with scrolling)
MOUSEEVENT.ctrl|shift|alt|metaKey               #True if pressed while mouse event
MOUSEEVENT.getModifierState(STR)->BOOL          #See KEYBOARDEVENT
MOUSEEVENT.button                               #0|1|2 if left|middle|right click while mouse event
MOUSEEVENT.detail                               #Number of clicks.
                                                #  - only for [dbl]click, mousedown|up
MOUSEEVENT.relatedTarget                        #For:
                                                #  - mouseenter|over: left element
                                                #  - mouseleave|out: entered element
                                                #  - others: null

ALL.onclick = FUNC(MOUSEEVENT)                  #Left click down then up on same element.
HTMLELEM.click()                                #
ALL.oncontextmenu = FUNC(MOUSEEVENT)            #Same for right click.
ALL.ondblclick = FUNC(MOUSEEVENT)               #Same for double left click.
ALL.onmousedown|up = FUNC(MOUSEEVENT)           #Any mouse button down|up (only once).
ALL.onmousemove = FUNC(MOUSEEVENT)              #While moves (repeats).

ALL.onmouseover|out = FUNC(MOUSEEVENT)          #When enter|leaves (only once)
                                                #Bubbles, which means that anytime the mouse enters/leaves a child/inner 
                                                #element, it is fired again: prefer mouseenter|leave.
ALL.onmouseenter|leave = FUNC(MOUSEEVENT)      ##Same but doesn't bubble, so not this problem.
                                               ##Use jQuery right now.

ALL.onscroll = FUNC(UIEVENT)                    #When scrolling happens.
WINDOW.onresize = FUNC(UIEVENT)                 #When resizing window.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          LOAD EVENTS          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


WINDOW.onDOMContentLoaded = FUNC(EVENT)         #When page parsed
WINDOW.onload = FUNC(UIEVENT)                   #When resources done loading
DOCUMENT.readyState                             #Can be:
                                                #  - "loading": first
                                                #  - "interactive": after DOMContentLoaded
                                                #  - "complete": after load
DOCUMENT.onreadystatechange = FUNC(EVENT)       #When DOCUMENT.readyState changes
WINDOW.onbeforeunload = FUNC(EVENT)             #Just before unload
WINDOW.onunload = FUNC(UIEVENT)                 #On closing page

RESOURCE                                        #Any external|embedded resource: 
                                                #  - <script>, <style>, <link> 
                                                #  - <img>, <input type="image">, <video>, <audio>, <iframe>, <svg>
                                                #Also <body>
RESOURCE.onload = FUNC(UIEVENT)                 #When done loading
RESOURCE.onerror = FUNC(UIEVENT)                #
RESOURCE.onabort = FUNC(UIEVENT)                #When starts loading but stops.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           TOP-LEVEL           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Window                                          #
$.isWindow(VAL)                                ##True if WINDOW (jQuery)
Document                                        #NODE child, parent of HTML. 
                                                #Obtained e.g. with:
                                                #  - WINDOW.document
                                                #  - IFRAME.contentDocument
                                                #  - XHR.responseXML
HTMLDocument                                    #DOCUMENT child
DocumentType                                    #See HTML doc

WINDOW.opener                                   #WINDOW2|null: if WINDOW popup
WINDOW.frameElement                             #IFRAME|OBJECT|null
WINDOW.parent                                   #If WINDOW.frameElement, its WINDOW2. Otherwise WINDOW
WINDOW.top                                      #WINDOW.parent.parent...

WINDOW.document                                 #DOCUMENT
DOCUMENT.defaultView                            #WINDOW|null. Readonly
DOCUMENT.doctype                                #
DOCUMENT.documentElement                        #
HTMLDOCUMENT.body                               #
HTMLDOCUMENT.head                               #See HTML doc

HTMLDOCUMENT.title                              #
HTMLDOCUMENT.scripts                            #
HTMLDOCUMENT.images                             #
HTMLDOCUMENT.links                              #
HTMLDOCUMENT.forms                              #See HTML doc


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             QUERY             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Node                                            #Parent of ELEM, DOCUMENT, CHARDATA, DOCUMENTTYPE, DOCUMENTFRAG
                                                #Note: any whitespace between two ELEM is a CHARDATA
Element                                         #NODE being an HTML|SVG element
HTMLElement                                     #Cf doc HTML
NodeList                                        #Similar to HTMLCOLLECTION but for NODE

DOCUMENT.getElementsByClassName('CLASS')        #HTMLCOLLECTION
DOCUMENT.getElementsByName('NAME')              #HTMLCOLLECTION
DOCUMENT|ELEM.getElementsByTagName('tag|*')     #HTMLCOLLECTION|ELEM_ARR
DOCUMENT.getElementById('ID')                   #ELEM|null
DOCUMENT|ELEM.querySelector('CSS_SELECTOR')     #NODE|ELEM|null. Cannot use pseudo-element
DOCUMENT|ELEM.querySelectorAll('CSS_SELECTOR')  #NODELIST|ELEM_ARR

NODE|ELEM.childNodes|children                   #NODELIST|HTMLCOLLECTION. Readonly.
NODE.hasChildNodes()->BOOL                      #
NODE|ELEM.first|last[Element]Child              #NODE|ELEM|null. Readonly.
NODE|ELEM.previous|next[Element]Sibling         #NODE|ELEM|null. Readonly.
NODE|ELEM.parentNode|Element                    #NODE|ELEM|null. Readonly.
                                                #null for DOCUMENT, for HTML (parentElement only) and root NODE not attached in DOM
NODE.ownerDocument                              #DOCUMENT|null. Readonly. 
                                                #null for DOCUMENT


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             TEST              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


NODE.isEqualNode(NODE2)->BOOL                   #Same HTML content, i.e. same nodeType, nodeName, nodeValue, attributes, children.
NODE.contains(NODE2)->BOOL                      #Is child or same
NODE.compareDocumentPosition(NODE2)->NUM        #Returns or'd bitmask of relation of NODE2 to NODE:
                                                #  - DOCUMENT_POSITION_CONTAINS|CONTAINED_BY
                                                #  - DOCUMENT_POSITION_PRECEDING|FOLLOWING: of start tag, i.e. if contains, precedes
                                                #  - DOCUMENT_DISCONNECTED: not same DOCUMENT
                                                #None (i.e. 0) means NODE === NODE2


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         MANIPULATION          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


DOCUMENT.implementation.
createHTMLDocument(['TITLE'])->HTML             #
DOCUMENT.createElement('TAG')->ELEM             #
DOCUMENT.createTextNode(STR)->TEXT              #
DOCUMENT.createComment(STR)->COMMENT            #

NODE.insertBefore(NODE2, NODE3)->NODE2          #Insert NODE2 as NODE child, before sibling NODE3 (if null, put as last child).
NODE.appendChild(NODE2)->NODE2                  #Same as NODE.insertBefore(NODE2, null)
NODE.removeChild(NODE3)->NODE3                  #
NODE.replaceChild(NODE2, NODE3)->NODE3          #Same as NODE.insertBefore(NODE2, NODE3) + NODE.removeChild(NODE3)
NODE.cloneNode([BOOL])->NODE2                   #NODE2 is not attached to DOM.
                                                #Does not keep:
                                                #  - event listeners added with addEventListener()
                                                #  - children, unless BOOL true
                                                #NODE must be in current DOCUMENT
DOCUMENT.importNode(NODE[, BOOL])->NODE2        #Same but NODE does not have to be in current DOCUMENT
DOCUMENT.adoptNode(NODE)->NODE2                 #Same as DOCUMENT.importNode(NODE) but then remove NODE


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:      MUTATION OBSERVERS       :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


                                               ##Ext: webkit (Safari)
new MutationObserver                            #FUNC is listener aggregator:
(FUNC(RECORD_ARR, OBSERVER))                    #  - each RECORD represents a listener added by OBSERVER.observe()
                                                #RECORD (NODE2 insertion|removal):
                                                #  - type 'childList'
                                                #  - target NODE: NODE2's parent
                                                #  - added|removedNodes NODELIST|null
                                                #  - previous|nextSibling NODE|null
                                                #RECORD (CHARDATA modification):
                                                #  - type 'characterData'
                                                #  - target CHARDATA
                                                #  - oldValue STR
                                                #RECORD (ELEM's attributes insertion|removal|modification):
                                                #  - type 'attributes'
                                                #  - target ELEM
                                                #  - attributeName[space] STR
                                                #  - oldValue STR
OBSERVER.observe(NODE, OBJ)                     #OBJ:
                                                #  - childList|characterData|attributes BOOL (def: false): at least one must be true
                                                #  - attribute|characterDataOldValue BOOL (def: false): populate RECORD.oldValue
                                                #  - attributesFilter 'ATTR'_ARR: only observe those attributes
                                                #  - subtree BOOL (def: false): include descendants
OBSERVER.takeRecords()->RECORD_ARR              #OBSERVERS's FUNC is always fired after DOM events
                                                #So must call this to get access to pending RECORD_ARR in a DOM event handler
                                                #This empties RECORD_ARR
OBSERVER.disconnect()                           #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            CONTENT            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


DOCUMENT.compatMode                             #
DOCUMENT.characterSet                           #See HTML doc

NODE.nodeType                                   #Among DOCUMENT.DOCUMENT[_TYPE|FRAGMENT]|ELEM|TEXT|COMMENT_NODE
                                                #Readonly.
NODE.nodeName                                   #For ELEM: ELEM.tagName
                                                #For DOCUMENTTYPE: DOCUMENTTYPE.name
                                                #Others: '#comment|text|document[-fragment]'
                                                #Readonly.
ELEM.tagName                                    #'TAG|tag'

ELEM.inner|outerHTML                            #'HTML', with[out] ELEM itself
                                                #Can lead to XSS attacks, so prefer textContent if only TEXT.
ELEM.insertAdjacentHTML
('before|afterbegin|end', 'HTML')               #Inserts 'HTML' inside ELEM next to its start|end tag.

HTMLDOCUMENT.open()                             #Remove all 'HTML'
HTMLDOCUMENT.write[ln]('HTML')                  #Append 'HTML' (with newline if "ln") to BODY
                                                #Fires HTMLDOCUMENT.open() first
HTMLDOCUMENT.close()                            #To be invoked after HTMLDOCUMENT.write*()

NODE.textContent                                #Children TEXT concatenated as STR.
                                                #DOCUMENT: null
NODE.nodeValue                                  #For CHARDATA: NODE.textContent
                                                #Others: null
NODE.normalize()                                #Erase empty TEXT, and join adjacent TEXT.

HTMLELEM.getAttribute('ATTR')->'VAL'            #
HTMLELEM.setAttribute('ATTR', 'VAL')            #
HTMLELEM.hasAttribute('ATTR')->BOOL             #
HTMLELEM.removeAttribute('ATTR')                #
HTMLELEM.removeAttributeNode(ATTR)->ATTR        #See HTML doc


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:       ATTR/TEXT/COMMENT       :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/



Attr                                            #NODE child. HTML attribute
ATTR.name                                       #'ATTR'
ATTR.value                                      #'VAL'

CharacterData                                   #NODE child. TEXT|COMMENT parent
CHARDATA.data                                   #STR
CHARDATA.length                                 #NUM
CHARDATA.appendData(STR)                        #
CHARDATA.insertData(UINT, STR)                  #
CHARDATA.substringData(UINT, UINT2)->STR        #
CHARDATA.deleteData(UINT, UINT2)                #
CHARDATA.replaceData(UINT, UINT2, STR)          #

Text                                            #CHARDATA child. ELEM's text content
TEXT.wholeText                                  #STR
TEXT.splitText(UINT)                            #Split into two TEXT at position UINT

Comment                                         #CHARDATA child. HTML comment


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          DIMENSIONS           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


WINDOW.screen                                   #SCREEN
WINDOW.screenX|Y                                #Distance between real screen topleft corner and browser window topleft corner.
SCREEN.width|height                             #Real screen size.
                                                #IE: takes zoom into account
SCREEN.availWidth|Height                        #SCREEN.width|height minus OS's UI
WINDOW.outer|innerHeight|Width                  #Browser tab size, including|excluding browser UI

SCROLLING HEIGHT|WIDTH ==>                      #Unless specified, if scrollable, counts only visible part (including scrollbar)
                                                #'scrollable' does not include top-level scrolling
JQ.outerHeight|Width(true)                     ##Margin-box
HTMLELEM.offsetHeight|Width                     #Border-box (readonly)
JQ.outerHeight|Width(false)                    ##Border-box
JQ.innerHeight|Width                           ##Padding-box
ELEM.clientHeight|Width                         #Padding-box (display BLOCK only) (readonly) (scrollable: exclude scrollbar)
ELEM.scrollHeight|Width                         #Padding-box (display BLOCK only) (readonly) (scrollable: exclude scrollbar, includes scrollable part)
JQ.css('height|width'[, VAL|FUNC])             ##Content-box
JQ.height|width([VAL|FUNC])                    ##Content-box
                                               ##Same as JS.css('height|width') but:
                                               ##  - return a NUM (pixels) au lieu de STR.
                                               ##  - doesn't take box-sizing into account
ELEM.clientTop|Left                             #Top|Left border-width (display BLOCK only) (readonly)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           POSITION            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


ELEM.getBoundingClientRect()->OBJ               #Returns border-box offset compared to its DOCUMENT
                                                #OBJ: top|bottom, left|right, width|height
                                                #Readonly
JQ.offset([OBJ2|FUNC])->OBJ                    ##Same but:
                                               ##  - OBJ only: left|right
                                               ##  - can be set
                                               ##  - doesn't work on hidden objects
DOCUMENT.elementFromPoint(DOUBLE,DOUBLE2)->ELEM #innermost ELEM with boundingClientRect containing DOUBLE,DOUBLE2 point
                                                #null if out-of-bound
HTMLELEM.offsetParent                           #Is:
                                                #  - display absolute: closest Absolute parent (if none, BODY)
                                                #  - HTML|BODY or display fixed: null
                                                #  - others: BODY
                                                #Readonly
JQ.offsetParent()->JQ2                         ##Same except BODY|null -> HTML
HTMLELEM.offsetTop|Left                         #Shift from HTMLELEM border to HTMLELEM.offsetParent padding.
                                                #Readonly
JQ.position([OBJ2])->OBJ                       ##Same except:
                                               ##  - OBJ only: left|top
                                               ##  - can be set
                                               ##  - doesn't work on hidden objects
                                               ##  - does not use ELEM.offsetParent but union of border boxes of JQ.offsetParent()'s children
                                               ##OBJ2 (jQuery UI):
                                               ##  - of SELECTOR|MOUSEEVENT
                                               ##  - my|at POSITION (def: center): put JQ's MY at same place as OF's AT
                                               ##  - within (def: WINDOW)
                                               ##  - collision STR: if positionned outside of WITHIN, continue progression from:
                                               ##     - "none": same side
                                               ##     - "flip" (def): opposite side once
                                               ##     - "flipfit": opposite back and forth
                                               ##     - "fit": stop
                                               ##  - using(MY.offset(), OBJ3): does not do any positioning (let this function do it):
                                               ##      - OBJ3:
                                               ##        - element|target (MY|AT): left|top, width|height, element JQ
                                               ##        - horizontal|vertical DIRECTION: according to MY
                                               ##        - important 'horizontal|vertical'
                                               ##      - this is ELEM


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           SCROLLING           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


JQ.scrollParent()->JQ2                         ##Parent JQ will scroll into (jQuery UI)

WINDOW.pageX|YOffset                            #Top-level scrolling
ELEM.scrollTop|Left                             #Pixels having being scrolled
                                                #scrollLeft can be negative if dir="rtl". 
                                                #Block-level only. Readonly.
JQ.scrollLeft|Top()->NUM                       ##ELEM.scrollLeft|Top or WINDOW.pageX|YOffset

WINDOW.scroll(UINT, UINT2)                      #In pixels, absolute.
WINDOW.scrollBy(UINT, UINT2)                    #In pixels, relative.
ELEM.scrollIntoView([BOOL])                     #Scroll to put ELEM's top (or bottom if BOOL false) on viewport's top


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:       RANGE / SELECTION       :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


DOCUMENT.createRange()->RANGE                   #
Range                                           #NODE or parts of NODE following each other.
DOCUMENT.createDocumentFragment()->DOCUMENTFRAG #
DocumentFragment                                #NODE child. Several NODE or parts of NODe not attached to DOM

RANGE.start|endContainer                        #NODE
RANGE.start|endOffset                           #Offset after|before start|endContainer:
                                                #  - if start|endContainer CHARDATA, in UCHAR
                                                #  - otherwise in NODE
                                                #Readonly.
RANGE.setStart|End(NODE, UINT)                  #
RANGE.setStart|EndBefore|After(NODE)            #
RANGE.selectNode[Contents](NODE)                #Set start|endContainer|offset so it selects NODE (if 'Contents', its children)
RANGE.collapsed                                 #startContainer === endContainer
RANGE.collapse([BOOL])                          #Collapse to startContainer (BOOL true) or endContainer.

RANGE.commonAncestorContainer                   #Deepest NODE containing both startContainer et endContainer
RANGE.compareBoundaryPoints(ENUM,RANGE2)->-1|0|1#According to ENUM Range.END|START_TO_END|START

RANGE.insertNode(NODE)                          #At RANGE start
RANGE.surroundContents(NODE)                    #Wraps with NODE.
                                                #NODE must have no children.
                                                #RANGE boundaries cannot be inside a CHARDATA.
RANGE.cloneContents()->DOCUMENTFRAG             #Renvoie copie de même manière que NODE.cloneNode(), sauf que renvoie ici
RANGE.deleteContents()                          #
RANGE.extractContents()->DOCUMENTFRAG           #Like cloneContents() + deleteContents()

RANGE.cloneRange()->RANGE2                      #
RANGE.detach()                                  #Erase


WINDOW.getSelection()->SELECTION                #
Selection                                       #User selection, containing one or more RANGE.
SELECTION.anchor|focusNode                      #Like RANGE.start|endContainer
SELECTION.anchor|focusOffset                    #Like RANGE.start|endOffset
SELECTION.isCollapsed                           #Like RANGE.collapsed
SELECTION.collapseToStart|End()                 #Like RANGE.collapse()
SELECTION.collapse(NODE, UINT)                  #Like RANGE.setEnd() + RANGE.collapse()
SELECTION.selectAllChildren(NODE)               #Like RANGE.setNodeContents()

SELECTION.rangeCount                            #length (0 if none)
SELECTION.getRangeAt(UINT)->RANGE               #
SELECTION.addRange(RANGE)                       #Only works if RANGE includes a SELECTION's RANGE
SELECTION.removeAllRanges()                     #
SELECTION.toString()                            #Only keep the TEXT when converting to STRING.

SELECTION.deleteFromDocument()                  #Erase all TEXT's content (not node itself)


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           ITERATION           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


DOCUMENT.createNodeIterator
(NODE[, ENUM[, OBJ]])->NODEITERATOR             #Arguments are root, whatToShow (def: null), filter 
NodeIterator                                    #
NODEITERATOR.root                               #NODE. Iterate over its children
NODEITERATOR.whatToShow                         #or'd ENUM: NodeFilter.SHOW_ALL|ELEM|ATTRIBUTE|TEXT|COMMENT|
                                                #DOCUMENT|DOCUMENT_TYPE|DOCUMENT_FRAGMENT
NODEFILTER.filter                               #{ acceptNode(NODE)->NodeFilter.FILTER_ACCEPT|REJECT }
NODEITERATOR.next|previousNode()->NODE|null     #
NODEITERATOR.detach()                           #Removes


DOCUMENT.createTreeWalker
(NODE[, ENUM[, OBJ]])->TREEWALKER               #
TreeWalker                                      #Like NodeIterator but can iterate recursively over children
TREEWALKER.filter                               #Can also return NodeFilter.FILTER_SKIP, which rejects parent but not children
TREEWALKER.root                                 #
TREEWALKER.whatToShow                           #
TREEWALKER.next|previousNode()                  #
TREEWALKER.detach()                             #Like NODEITERATOR

TREEWALKER.currentNode                          #NODE
TREEWALKER.parentNode()->NODE|null              #
TREEWALKER.first|lastChild()->NODE|null         #
TREEWALKER.previous|nextSibling()->NODE|null    #Also moves cursor


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              RTF              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


HTMLDOCUMENT.designMode                         #If 'on' (def: 'off'), disable events and allow execCommand()
HTMLDOCUMENT.execCommand                        #Fire RTF (MIDAS) COMMAND on current selection
('COMMAND'[, false, 'ARG'])->BOOL               #Returns false if failed.
                                                #Available COMMAND ARG:
                                                #  - back|forecolor "#ffffff"
                                                #  - hilitecolor "#ffffff": only if styleWithCSS
                                                #  - bold|italic|strikethrough|underline
                                                #  - copy|cut|paste
                                                #  - createlink "URL" | unlink
                                                #  - de|increasefontsize
                                                #  - delete
                                                #  - fontname "FONT"
                                                #  - fontsize "NUM"
                                                #  - heading "H*"
                                                #  - out|indent
                                                #  - insertbronreturn BOOL : <CR> creates a new <p> or a <br>
                                                #  - inserthorizontalrule : replace by <hr>
                                                #  - inserthtml STR : replace by HTMLDOCUMENT code STR
                                                #  - insertimage STR
                                                #  - insert[un]ordererdlist
                                                #  - insertparagraph
                                                #  - justifycenter|full|left|right
                                                #  - undo|redo
                                                #  - removeformat
                                                #  - selectall
                                                #  - sub|superscript
                                                #  - styleWithCSS : change format with CSS, not HTMLDOCUMENT
                                                #  - contentReadOnly : all document becomes readonly
                                                #Browsers implement differently: use tags (e.g. <b>) or CSS (e.g. <... style="...">)
HTMLDOCUM.queryCommandEnabled('COMMAND')->BOOL  #
HTMLDOCUM.queryCommandIndeterm('COMMAND')->BOOL #
HTMLDOCUMENT.queryCommandState('COMMAND')->BOOL #
HTMLDOCUM.queryCommandSupported('COMMAND')->BOOL#
HTMLDOCUMENT.queryCommandValue('COMMAND')->'ARG'#For current selection


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           LOCATION            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


WINDOW.location                                 #LOCATION.

LOCATION.href                                   #
HTMLDOCUMENT.URL                                #Same but readonly
LOCATION.protocol                               #
LOCATION.hostname                               #Can only be set to a superdomain.
HTMLDOCUMENT.domain                             #Same but readonly
LOCATION.port                                   #
LOCATION.host                                   #
LOCATION.pathname                               #
LOCATION.search                                 #
LOCATION.hash                                   #Same as A et AREA.
LOCATION.assign(STR)                            #Navigate to URL STR.
LOCATION.replace(STR)                           #Same but don't save current page in history.
LOCATION.reload(BOOL)                           #Reload current page. If true, cache can't be used.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            HISTORY            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


HTMLDOCUMENT.referrer                           #Previous page's URL, or '' if none.

WINDOW.history                                  #Browser HISTORY

HISTORY.length                                  #
HISTORY.go(NUM)                                 #Navigates
HISTORY.back|forward()                          #Same as go(1|-1)
HISTORY.pushState(STATE, 'TITLE'[, 'URL'])      #Adds an history entry, and goes to it.
                                                #Must be handled server-side too.
HISTORY.replaceState(...)                       #Removes current history entry, then do HISTORY.pushState(...)
HISTORY.state                                   #STATE

WINDOW.onpopstate = FUNC(POPSTATEVENT)          #Triggered by:
                                                #  - user using browser history (e.g. Back|Forward buttons or shortcuts)
                                                #  - HISTORY.go(NUM)
                                                #Providing the later history entry was created by HISTORY.pushState|replaceState()
                                                #Not triggered by HISTORY.pushState|replaceState() itself.
PopStateEvent                                   #EVENT child
POPSTATEVENT.state                              #STATE|null

WINDOW.onhashchange = FUNC(HASHCHANGEEVENT)     #On LOCATION.hash change.
HashChangeEvent                                 #EVENT child
HASHCHANGEEVENT.old|newURL                      #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           PLATFORM            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


WINDOW.navigator                                #NAVIGATOR
NAVIGATOR.userAgent                             #Browser type|version. Not readonly.
                                                #Prefer feature detection to user agent.
NAVIGATOR.platform                              #OS and CPU, e.g. "Linux x86_64". Not readonly.

SCREEN.color|pixelDepth                         #E.g. 24 for 8/channel with RGB
SCREEN.pixelDepth                               #Usually same as colorDepth


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          GEOLOCATION          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


NAVIGATOR.geolocation                           #GEOLOCATION. Asks for user confirmation

GEOLOCATION.getCurrentPosition
(FUNC(POS), FUNC2(POS_ERR), POS_OPTS)           #
GEOLOCATION.watchPosition(...)->UINT            #Fires GEOLOCATION.getCurrentPosition(...) each time POS changes
GEOLOCATION.clearWatch(UINT)                    #

POS.coords.latitude|longitude                   #DOUBLE
POS.coords.accuracy                             #NUM (meters)
POS.coords.altitude[Accuracy]                   #null in many devices
POS.timestamp                                   #DATE_NUM

POS_ERR.code                                    #NUM:
                                                #  - 1: permission denied 
                                                #  - 2: position unavailable 
                                                #  - 3: timeout
POS_ERR.message                                 #STR

POS_OPTS.enableHighAccuracy                     #BOOL. If true, maybe higher accuracy, but more power consumption (def: false)
POS_OPTS.timeout                                #NUM (def: Infinity)
POS_OPTS.maximumAge                             #NUM for cache (in ms, 0 for none) (def: Infinity)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         HTTP HEADERS          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


HTMLDOCUMENT.lastModified                       #Returns Last-Modified [S] as 'DATE'
                                                #If not set, current date.

HTMLDOCUMENT.cookie                             #Get|set Set-Cookie [S]
                                                #Get all 'VAR=VAL;VAR=VAL...' but only set a single 'VAR=VAL[;SVAR=SVAL]...'
                                                #Should use en|decodeURIComponent(VAL)
                                                #Setting on Chrome when using file:/// does not work.
NAVIGATOR.cookieEnabled                         #BOOL. Readonly.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              XHR              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


XmlHttpRequest                                  #HTTP request|response
new XmlHttpRequest()                            #

XHR.open                                        #Specify the request:
(METHOD, URL[, BOOL[, USERNAME[, PASSWORD]]])   #  - BOOL: if true (def), async
XHR.setRequestHeader('VAR', 'VAL')              #Adds HTTP header
                                                #Some headers cannot be set via XHR
                                                #Some headers are set by def, e.g. for Chrome:
                                                #  - host, referer
                                                #  - user-agent 
                                                #  - connection: keepalive
                                                #  - content-length 
                                                #  - cache-control: no-cache
                                                #  - accept: */*, accept-encoding, accept-language
XHR.responseType                                #Modifies how XHR.response is interpreted:
                                                #  - 'text' or '' (def)
                                                #  - 'arraybuffer'
                                                #  - 'blob'
XHR.withCredentials                             #If true (def: false), send credentials (cookies and HTTP authentication data) with the request.

XHR.send([REQ_BODY])                            #Sends the request.
                                                #REQ_BODY (only if 'POST|PUT|DELETE|etc.'):
                                                #  - STR: 
                                                #     - body is STR as is
                                                #     - default Content-Type: "text/plain[;charset=CHARSET]" [C]
                                                #     - to use Content-Type: "application/x-www-form-urlencoded" [C] 
                                                #       with 'VAR=VAL&...', must manually:
                                                #        - use encodeURIComponent()
                                                #        - set Content-Type
                                                #  - DOCUMENT:
                                                #     - body is DOCUMENT as STR
                                                #     - default Content-Type: "application/xml[;charset=CHARSET]" [C]
                                                #  - BLOB:
                                                #     - body is binary as is
                                                #     - no default Content-Type [C]
                                                #  - FORMDATA:
                                                #     - body as "multipart/form-data" content (see HTML doc)
                                                #        - filename is "blob" for anonymous BLOB, real filename otherwise, and not set for STR
                                                #     - default Content-Type: "multipart/form-data;boundary=BOUNDARY" [C]
                                                #     - API:
                                                #        - new FormData([FORM])
                                                #        - FORMDATA.append('VAR', STR|BLOB)
XHR.abort()                                     #Emit event

XHR.onreadystatechange = FUNC(EVENT)            #When XHR.readyState changes
XHR.readyState                                  #Can be:
                                                #  - XHR.UNSENT: uninitialized
                                                #  - XHR.OPENED: open()
                                                #  - XHR.HEADER_RECEIVED: send() and response header received
                                                #  - XHR.LOADING: downloading response body
                                                #  - XHR.DONE: downloaded response body

XHR.onloadstart = FUNC(PROGRESSEVENT)           #When starts reading
XHR.onprogress = FUNC(PROGRESSEVENT)            #When is reading
XHR.onload[end] = FUNC(PROGRESSEVENT)           #When finishes. load is success, loadend is success or failure.
XHR.onabort = FUNC(PROGRESSEVENT)               #
XHR.onerror = FUNC(PROGRESSEVENT)               #

PROGRESSEVENT.lengthComputable                  #true if PROGRESSEVENT.loaded|total available
PROGRESSEVENT.loaded|total                      #Number of bytes

XHR.status[Text]                                #HTTP response status code as NUM|STR
XHR.response                                    #Server response as STR|ARRBUFFER|BLOB, depending on XHR.responseType
XHR.responseText                                #Server response as STR
XHR.responseXML                                 #Server response as XML
XHR.getResponseHeader('VAR')->'VAL'             #
XHR.getAllResponseHeaders()->OBJ                #


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             FILES             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


Blob                                            #Similar to ARRBUFFER but kept as temp file, not in memory.
BLOB(ARRBUFFER_ARR|DATAVIEW_ARR|TYPED_ARR_ARR|  #ARR will be concatenated.
BLOB_ARR|STR_ARR[, OBJ])                        #OBJ: type 'MIME'
BLOB.size                                       #
BLOB.type                                       #'MIME'
BLOB.slice(ULONG[, ULONG2[, 'MIME']])->BLOB2    #From byte ULONG to byte ULONG2 (def: end)

URL.createObjectURL(BLOB)->'URL'                #'URL' is an 'object URL':
                                                #  - manipulated like a data URI, but only contains name not data
                                                #  - invalid after tab closed
                                                #Can be used by other WINDOW.
                                               ##Ext: webkit
URL.revokeObjectURL('URL')                      #

FileList                                        #FILE_ARR (array-like)
File                                            #BLOB child
                                                #Obtained usually through: 
                                                #  - INPUT.files
                                                #  - DATATRANSFER.files
FILE.name                                       #Filename
FILE.lastModifiedDate                           #DATE


new FileReader()                                #
FILEREADER.readAsText(BLOB[, 'ENCODING'])       #Starts reading. FILEREADER.result will be STR
                                                #Def 'ENCODING': 'UTF-8'
FILEREADER.readAsArrayBuffer(BLOB)              #Same but result will be ARRBUFFER
FILEREADER.readAsDataURL(BLOB)                  #Same but result will be data URI
FILEREADER.result                               #VAL, or null (error or not read yet)
FILEREADER.readyState                           #Can be :
                                                #  - FileReader.EMPTY: before read
                                                #  - FileReader.LOADING : read in progress
                                                #  - FileReader.NONE : read complete|error|abort
FILEREADER.abort()                              #
FILEREADER.error                                #DOMERROR with name "NotFoundError|SecurityError|NotReadableError"

FILEREADER.onloadstart = FUNC(PROGRESSEVENT)    #
FILEREADER.onprogress = FUNC(PROGRESSEVENT)     #
FILEREADER.onload[end] = FUNC(PROGRESSEVENT)    #
FILEREADER.onabort = FUNC(PROGRESSEVENT)        #
FILEREADER.onerror = FUNC(PROGRESSEVENT)       #Cf XHR

FileReaderSync                                  #Same as as FileReader but:
                                                #  - sync: returns VAL instead of firing events
                                                #  - only available inside WORKER


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           WEBSOCKET           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


WebSocket                                       #
new WebSocket('URL'[, STR[_ARR]])               #Opens websocket (see HTTP doc)
                                                #STR[_ARR] are requested subprotocols.
                                                #Throws SECURITY_ERR if port blocked.
WEBSOCKET.send(STR|BLOB|ARRBUFFER)              #Can throw: 
                                                #  - INVALID_STATE_ERR: connection not opened 
                                                #  - SYNTAX_ERR: invalid data sent
WEBSOCKET.onopen = FUNC(EVENT)                  #
WEBSOCKET.binaryType                            #MESSAGEEVENT.data type: 'blob' (def) or 'arraybuffer'
WEBSOCKET.onmessage = FUNC(MESSAGEEVENT)        #

WEBSOCKET.url                                   #'URL'
WEBSOCKET.protocol                              #Subprotocol STR returned by server.
WEBSOCKET.extensions                            #Extensions STR, changed by server.
WEBSOCKET.bufferedAmount                        #Number of bytes sent buffered.

WEBSOCKET.readyState                            #Any of WebSocket.CONNECTING|OPEN|CLOSING|CLOSED

WEBSOCKET.close(UINT, STR)                      #UINT is error code (1000 or 3000-4999)
                                                #STR error message.
                                                #Should make sure bufferedAmount is 0 before.
                                                #Can throw:
                                                #  - INVALID_ACCESS_ERR: invalid UINT
                                                #  - SYNTAX_ERR: invalid STR
WEBSOCKET.onclose = FUNC(CLOSEEVENT)            #
CLOSEEVENT.wasClean                             #True if cleanly closed.
CLOSEEVENT.code                                 #UINT
CLOSEEVENT.reason                               #STR

WEBSOCKET.onerror = FUNC(EVENT)                 #


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          WEB STORAGE          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


WINDOW.localStorage                             #Persistent OBJ per domain.
                                                #Private browsing creates new STORAGE temp.
                                                #Cleaned when cleaning cookies.
WINDOW.sessionStorage                           #Same but cleaned when tab is closed.

STORAGE.length                                  #
STORAGE.key(UINT)->'VAR'                        #
STORAGE.getItem('VAR')->'VAL'                   #
STORAGE.setItem('VAR', 'VAL')                   #
STORAGE.removeItem('VAR')                       #
STORAGE.clear()                                 #

WINDOW.onstorage = FUNC(STORAGEEVENT)           #Triggered on WINDOW2.localStorage|sessionStorage.*() (different WINDOW2)
STORAGEEVENT.key                                #'VAR'
STORAGEEVENT.new|oldValue                       #'VAL'
STORAGEEVENT.storageArea                        #STORAGE
STORAGEEVENT.url                                #WINDOW2.URL


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:        STORAGE SUMMARY        :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


DIFFERENT STORAGE ==>                           #All storage : can be erased through private data erasing GUI for normal 
                                                #websites/hosted apps, but not for extensions/packaged apps.

                            +------------------+-----------------------+--------------------+--------------------------------+
                            | Avail.           | Limit                 | Model              | Other                          |
  +-------------------------+------------------+-----------------------+--------------------+--------------------------------+
  | cookies                 | All              | 4KB/cookie, 180/domain| Flat. As STR.      | Communicated to server         |
  +-------------------------+------------------+-----------------------+--------------------+--------------------------------+
  | localStorage            | All              | 2-10MB/domain         | Flat. As STR.      | Not async.                     |
  +-------------------------+------------------+-----------------------+--------------------+--------------------------------+
  | XHR                     | All              | None                  | None               | Slower. Persisted on server.   |
  |                         |                  |                       |                    | Requires network.              |
  +-------------------------+------------------+-----------------------+--------------------+--------------------------------+
  | chrome.storage          | Chrome apps/exts | Unlim (permissions)   | Flat. As OBJ.      | Can be used by content scripts |
  |                         |                  |                       |                    | Can Cloud sync.                |
  |                         |                  |                       |                    | Storage event.                 |
  +-------------------------+------------------+-----------------------+--------------------+--------------------------------+
  | indexedDB               | Not Safari       | Unlim (permissions)   | Database           |                                |
  +-------------------------+------------------+-----------------------+--------------------+--------------------------------+
  | chrome.downloads        | Chrome exts      | Unlim(only download)  | Real filesystem    | Filechooser popup or not       |
  +-------------------------+------------------+-----------------------+--------------------+--------------------------------+
  | chrome.[sync]filesystem | Chrome apps      | Unlim (permissions)   | Real filesystem    | Use fileSystem API.            |
  |                         |                  |                       |                    | Can sync with Google Drive.    |
  +-------------------------+------------------+-----------------------+--------------------+--------------------------------+


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           APPCACHE            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


MANIFEST FILE ==>                               #Prefetch resources so they are in browser cache.
                                                #Must be a single file on the server:
                                                #  - MIME type "text/cache-manifest"
                                                #  - filename usually "cache.manifest"
                                                #  - referenced by <html manifest="MANIFESTFILE">
                                                #Syntax :
                                                #  CACHE MANIFEST       #Required in beginning
                                                #  #COMMENT             #Whitespaces/newlines are ignored
                                                #  SECTION:             #There are three possible sections (if nothing, assume 
                                                #                       #CACHE:) : CACHE: NETWORK: and FALLBACK:
                                                #  URL                  #e.g. /resource.png (relative|absolute)
                                                #                       # * can be used on NETWORK|FALLBACK: URLs
                                                #CACHE :
                                                #  - files that need to be cached:
                                                #     - if online, downloaded by client
                                                #     - online or not, use cached version if available
                                                #        - needs new URL to redownload updated resource
                                                #        - MANIFESTFILE itself should not be cached
                                                #     - files being currently browsed by user do not need to be here 
                                                #       (automatically cached)
                                                #NETWORK:
                                                #  - files that should not be cached, and provoke an error if accessed offline
                                                #FALLBACK:
                                                #  - Use URL URL2
                                                #  - If URL is accessed offline (but usually can't be cached), URL2 is served instead
                                                #Ask permission to user the first time. There might be limit on max cache size.

APPLICTNCACHE.onnoupdate|checking = FUNC(EVENT) #Reading the html tag (if cache manifest previously cached and same, or not)
APPLICATIONCACHE.ondownloading = FUNC(EVENT)    #When manifest file is being downloaded 
APPLICATIONCACHE.onprogress = FUNC(PROGRESEVENT)#When manifest file is being read
APPLICTNCACHE.oncached|updateready = FUNC(EVENT)#When manifest file has been read (if was first time, or not)
APPLICATIONCACHE.onerror = FUNC(EVENT)          #
APPLICATIONCACHE.onobsolete = FUNC(EVENT)       #

WINDOW.applicationCache                         #APPLICATIONCACHE
APPLICATIONCACHE.state                          #Can be :
                                                #  - applicationCache.UNCACHED: no caching
                                                #  - applicationCache.IDLE: cache not in the process of being updated
                                                #  - applicationCache.CHECKING: checking if needs to update cache
                                                #  - applicationCache.DOWNLOADING: downloading cache
                                                #  - applicationCache.UPDATEREADY: cache complete
                                                #  - applicationCache.OBSOLETE: the file was referenced by another HTML file, 
                                                #    but the reference is gone.
APPLICATIONCACHE.update|swapCache()             #Useless methods to update cache manually.

WINDOW|WORKERGLOBALSCOPE.
onoffline|online = FUNC(EVENT)                  #

																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           DRAG&DROP           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


<any>
  draggable="true|false|"                       #Changes possibility to drag (user interaction + events):
                                                #  - "true" (def on links, images, selection)
                                                #  - "false"
                                                #  - "" (def otherwise): inherit

DragEvent                                       #MOUSEEVENT child
                                                #During a drag, keyboard and other mouse events are neutralized.
                                                #Drag and drop sources can also come from other applications.
DRAGEVENT.dataTransfer                          #DATATRANSFER

ELEM|DOCUMENT.ondragstart = FUNC(DRAGEVENT)     #When source starts being dragged
                                                #Should do DATATRANSFER.setData()
                                                #Can set DATATRANSFER.effectAllowed
ELEM|DOCUMENT.ondragend = FUNC(DRAGEVENT)       #When source stops being dragged (success or not)
                                                #Can check if operation was successful with DATATRANSFER.dropEffect
ELEM|DOCUMENT.ondrag = FUNC(DRAGEVENT)          #When source moves

ELEM|DOCUMENT.ondragenter|leave = FUNC(DRAGEVNT)#When target starts|ends being hovered
                                                #Should call DRAGEVENT.stopPropagation() + preventDefault()
ELEM|DOCUMENT.ondragover = FUNC(DRAGEVENT)      #When target is being hovered and source moves
                                                #Should call DRAGEVENT.stopPropagation() + preventDefault()
ELEM|DOCUMENT.ondrop = FUNC(DRAGEVENT)          #When target is being dropped on
                                                #Should do DATATRANSFER.getData()
                                                #Should call DRAGEVENT.stopPropagation() + preventDefault()

DATATRANSFER.setData('MIME', 'VAL')             #To do during dragstart.
                                                #Can set several types:
                                                #  - the most specific should be preferred on getData()
                                                #  - should include 'text/plain' as a fallback
                                                #Usual 'MIME':
                                                #  - "text/plain": 
                                                #     - default for links and selection
                                                #  - "text/uri-list": 
                                                #     - default for images
                                                #     - URLs, newline-separated. 
                                                #     - can have comments starting with #
                                                #     - will also define "URL" MIME with only the first URL
                                                #  - "text/html"
                                                #  - "Files": FILELIST
DATATRANSFER.getData('MIME')->'VAL'             #
DATATRANSFER.clearData(['MIME'])                #
DATATRANSFER.types                              #'MIME'_ARR
DATATRANSFER.files                              #Same as DATATRANSFER.getData('Files')

DATATRANSFER.effectAllowed                      #To do during dragstart. 
                                                #Restrict possible dropEffect:
                                                #  - 'copy|move|link|none'
                                                #  - 'copyLink|copyMove|linkMove|all': combination
                                                #  - 'uninitialized': like 'all'
                                                #If unallowed, drop will not be performed.
DATATRANSFER.dropEffect                         #Can be read on dragend (not drop)
                                                #Can be set on dragover|dragenter, but also default are chosen according to modifier:
                                                #  - 'copy' (def with shift)
                                                #  - 'move' (def with no modifier key)
                                                #  - 'link' (def with shift+ctrl)
                                                #  - 'none'


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           CLIPBOARD           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


DOCUMENT.oncopy|cut|paste = FUNC(CLIPBOARDEVENT)#Can call CLIPBOARDEVENT.stopPropagation|preventDefault()
                                                #Copy event handler should call CLIPBOARDEVENT.preventDefault()
CLIPBOARDEVENT.clipboardData                    #DATATRANSFER (with only getData(), setData() and clearData())


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           MESSAGING           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


WINDOW2.postMessage(VAL, 'PROTOCOL://HOST|*')   #WINDOW2 protocol+host must match second argument
WINDOW2.onmessage = FUNC(MESSAGEEVENT)          #
MESSAGEEVENT.data                               #VAL
MESSAGEEVENT.origin                             #PROTOCOL://HOST|*
                                                #Should be checked to prevent XSS and CSRF
MESSAGEEVENT.source                             #WINDOW having called postMessage()


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            WORKERS            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Worker                                          #Thread
new Worker('SCRIPT_URL')                        #
WORKER.terminate()                              #

WorkerGlobalScope                               #Global object available in a script launched as a WORKER
WORKERGLOBALSCOPE.self                          #Returns WORKERGLOBALSCOPE (used as shortcut, prefer over window)
WORKERGLOBALSCOPE.importScripts('SCRIPT_URL'...)#
WORKERGLOBALSCOPE.close()                       #
WORKERGLOBALSCOPE.navigator                     #WORKERNAVIGATOR, like NAVIGATOR with only userAgent and platform
WORKERGLOBALSCOPE.location                      #WORKERLOCATION, like LOCATION without methods

WORKER[GLOBALSCROPE].postMessage(VAL)           #
WORKER[GLOBALSCOPE].onmessage = FUNC(MESGEEVENT)#On WORKER[GLOBALSCOPE].postMessage()
WORKER[GLOBALSCOPE].onerror = FUNC(EVENT)       #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             POPUP             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


WINDOW.alert(STR)                               #Opens popup with OK button.
WINDOW.confirm(STR)->BOOL                       #Same with OK and Cancel buttons. Return true if OK.
WINDOW.prompt(STR[, 'PLACEHOLDER'])->STR2|null  #Same but asks for user input.

WINDOW.print()                                  #Opens print dialog


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         NOTIFICATION          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


NOTIFICATIONS ==>                               #Only Firefox, Chrome and Safari.
                                               ##Ext: webkit
new Notification('TITLE'[, OBJ])                #Creates a NOTIFICATION, and pops it up. It doesn't go away by itself.
                                                #Notifications are queued.
                                                #OBJ:
                                                #  - body STR
                                                #  - icon 'URL'
                                                #  - tag 'ID': if existing, updates instead of adding
                                                #  - lang, dir: like in HTML
NOTIFICATION.permission                         #"default|granted|denied"
                                                #Website needs to be whitelisted on browser preferences.
                                                #There should be a function NOTIFICATION.requestPermission() to show a popup
                                                #asking for it, but it's not implemented.
NOTIFICATION.close()                            #

NOTIFICATION.onshow = FUNC(EVENT)               #
NOTIFICATION.onclick = FUNC(EVENT)              #
NOTIFICATION.onerror = FUNC(EVENT)              #
NOTIFICATION.onclose = FUNC(EVENT)              #
