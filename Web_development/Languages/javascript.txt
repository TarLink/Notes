
                
   JAVASCRIPT   
                


TO DO ==>                                       #  - garbage collection

VERSION ==>                                     #Standard is called ECMAScript. JavaScript and ActionScript are dialects.
                                                #This doc shows ES6 in strict mode, with this notation for ES6 new features:
                                               |#  - works with Babel
                                               +#  - works with Babel, but require polyfill
                                               -#  - does not work with Babel
                                                #ES7 not documented yet.

MAIN PRINCIPLES ==>                             #Case-sensitive. Whitespaces are ignored.
                                                #Type: weak, dynamic, generic, late/duck.
                                                #Lexical-scope
                                                #Functional (first-class functions)
                                                #Object-oriented (prototype-based)
                                                #Imperative (structures close to C)
                                                #Does not have any I/O -> need a host environnement (generally browser) to
                                                #"do things".
                                                #Memory management: garbage collection.

EXECUTION ==>                                   #Each browser has own JavaScript engine, which was in the past interpreted,
                                                #but now is byte-compiled or compiled:
                                                #  - Chakra (IE9+)
                                                #  - SpiderMonkey (Firefox)
                                                #  - V8 (Chrome, Opera 12.15+)
                                                #  - SquirrelFish (Safari)

INCLUDING IN HTML ==>                           #Priority is from top to bottom

<script src="script.js"></script>               #From external file. Preferred. Should be in <head>.

<script>CODE</script>                           #Inline. If in <body>, execute while loading. Should be in <head>

<a href="JavaScript:CODE"></a>                  #
<any onEVENT="CODE"></any>                      #Deprecated

<noscript>
  Activez JavaScript pour voir contenu
</noscript>


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             SCOPE             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


GENERAL ==>                                     #  - variable scope is:
                                                #     - "var": function() {...}
                                                #     - "let|const": any {...}
                                                #  - any function is child scope of the function in which it is *declared* (not *fired*)
                                                #     - parent scope is a reference, not a snapshot, i.e. is is evaluated each
                                                #       time the function is fired
                                                #  - scopes inherits parent scope, but not inverse
                                                #  - global/root scope: usually available with global reference global|window 
                                                #    (depends on host)

DECLARATION ==>                                 #  - using undeclared VAR throws ReferenceError (except with typeof)
                                                #  - using VAR (even if declared in parent scope) declared later in current scope with:
                                                #     - "let|const": throws ReferenceError ("Temporal Dead Zone")
                                                #     - "var": adds an implicit empty declaration before, i.e. will be undefined (variable hoisting)
                                                #     - function FUNC(){}: adds an implicit declaration+assignment before

DECLARING FUNCTIONS ==>                         #  - FUNC = function [FUNC2](){}
                                                #     - declared+assigned at runtime (like other variables)
                                                #     - this also covers anonymous function, and void function [FUNC2](){}
                                                #     - FUNC2.name (read-only): used by ERROR.toString() in stack trace
                                                #     - Using "FUNC2":
                                                #        - equivalent of doing let FUNC2 = function(){} at the beginning of the same function
                                                #        - allow recursion to reference themselves without risk of parent scope
                                                #          to reassign FUNC2
                                                #  - function FUNC2(){}:
                                                #     - declared+assigned at parsetime 
                                                #        - i.e. equivalent of doing let FUNC2 = function () {} at {...} scope beginning
                                                #     - FUNC2.name: same
                                                #  - new Function(...): child of global scope

MEMORY MANAGEMENT ==>                           #Garbage collection:
                                                #  - periodically, iterates recursively over global object properties,
                                                #    including functions current|parent SCOPEs
                                                #  - clean any defined that cannot be reached anymore (because a function returned)
                                                #  - note that local functions:
                                                #     - can be assigned to parent SCOPE (and so live beyond current SCOPE) by
                                                #       direct assignment and be used as return value
                                                #     - carry references to parent SCOPEs
                                                #Memory leak happens with combination of variables being:
                                                #  - big, e.g.:
                                                #     - functions carrying parent SCOPEs
                                                #     - big objects
                                                #     - raw data returned from server
                                                #  - long-lived, e.g.:
                                                #     - attached to top/long-lived SCOPEs, e.g. global variables, e.g.:
                                                #        - long-lived DOM elements
                                                #        - global functions (e.g. global event handlers, setInterval(), ...)
                                                #Avoiding:
                                                #  - unset big variables just after being used, so that child SCOPEs do not
                                                #    carry them over


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         TYPES GENERAL         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


TYPING SYSTEM ==>                               #  - weak: no type specified at Declaration
                                                #  - generic: native operators accepts any type, since each native type
                                                #    transtype to any (except OBJ->undefined|null)
                                                #  - dynamic: type is not checked at compile-time nor (since generic) run-time

AVAILABLE TYPES ==>                             #  - simple: number|boolean|string|undefined|null
                                                #  - object (TYPE): Object and its children
                                                #    - native: Object|Array|Number|Boolean|String|Error|...
                                                #    - user-defined:
                                                #      - host objects: defined by browser (e.g. DOM elements)

Number|Boolean|String                           #Not same as number|boolean|string:
                                                #  - are objects, constructed as new TYPE([VAL])
                                                #  - but transtypes to|from simple types
                                                #     - STR|BOOL|(NUM).VAR work, because of transtype
                                                #     - not that null|undefined.VAR will throw error
                                                #Note: new Number|...(...) returns OBJ, whereas Number|...(...) returns native type

typeof VAR                                      #Returns "number|boolean|string|symbol|undefined|object|function"
                                                #"object": includes null, excludes FUNC
OBJ.constructor                                 #Returns TYPE (read-only)
VAR instanceof TYPE                             #Returns true if VAR is instance of TYPE (of a child of TYPE), i.e.:
                                                #  - VAR.[__proto__...]constructor === TYPE, 
                                                #    but without transtyping VAR if it is not an OBJ
                                                #  - VAR.[__proto__...]__proto__ === TYPE.prototype
TYPE.prototype.isPrototypeOf(VAR)               #Same

CHECKING TYPE ==>                               #  - number|boolean|string|symbol: typeof VAR === '...'
                                               ##     - $.isNumeric(VAL): isFinite(parseFloat(VAL)) (jQuery)
                                                #  - object: typeof VAR === 'object' && VAR !== null
                                                #  - null: VAR === null
                                                #  - null|undefined: VAR == null
                                                #  - undefined: 
                                                #     - (VAR declared) VAR === undefined
                                                #     - (VAR maybe not declared) typeof VAR === "undefined"
                                                #       Should never be necessary:
                                                #        - useless in local scopes
                                                #        - in global scope, use global.VAR === undefined
                                                #  - ARR: Array.isArray(VAR)
                                                #  - Node: VAR.nodeType === 1
                                                #  - TYPE (excluding children): OBJ.constructor === TYPE
                                                #  - TYPE (including children): OBJ instanceof TYPE
                                                #  - OBJ (no parent TYPE): OBJ.constructor === Object, or 
                                               ##    $.isPlainObject(VAL) (jQuery)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         SIMPLE TYPES          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


NUM                                             #Are all double-float.
                                                #Radix: 
                                                #  - NUM 
                                                #  - 0xNUM 0XNUM
                                               |#  - 0oNUM 0ONUM: always
                                                #    0NUM: providing in 0-7 range
                                                #  - 0bNUM 0BNUM
                                                #Decimal, scientific or hexadecimal (non octal).
                                                #Keywords (see below): 
                                                #  - NaN: possible illegal NUM operations
                                                #  - [-]Infinity: very low|high NUM
                                               |#  - Number.MIN|MAX_SAFE_INTEGER: very low|high integers
                                                #  - Number.MAX_VALUE: very low|high floats
                                                #  - Number.MIN_VALUE: very close to 0 floats
                                               |#  - Number.EPSILON: comparing floats
                                                #Operator:
                                                #  + - * / %
                                                #  -NUM
                                                #  NUM++ --NUM etc.
                                                #  ~ & ^ | >> << (bitwise)
                                                #  >>>  (like >>, but shiftes zeros on the left)
                                                #  OP=  (e.g. NUM += 2 or NUM %=10)

BOOL                                            #true|false
                                                #Operators:
                                                #  ! && ||

STR                                             #"STR"|'STR' (same, except for " or ' escaping)
                                               |#or `...` (can include ${EXPR})
                                                #Any backslash escape, except \a, \c et \e
                                                #Operators:
                                                #  STR + STR2
                                                #  STR += STR2

SYM                                            +#Symbol([STR])
                                               +#Used as OBJ key for private members, i.e. OBJ[SYM] is like OBJ['RANDOM']
                                               +#Operators:
                                               +#  OBJ[SYM]

undefined                                       #Valeur par défaut:
                                                #  - non-declared VAR: throw ReferenceError when used, except with typeof
                                                #  - declared but non-assigned VAR (including arguments and return value)

null                                            #Special keyword indicating emptiness


TEST                                            #Native types:
                                                #  - == != < <= > >= (transtypes)
                                                #  - === !== (does not transtype)
                                                #OBJ:
                                                #  - == === != !== (only check same reference)
                                               ##  - $.isEmptyObject(VAL): equal to {} (jQuery)
Object.is(VAL, VAL2)                           |#Same as ===, except !Object.is(+0,-0) and Object.is(NaN, NaN)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          TRANSTYPING          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


IMPLICIT ==>                                    #To STR:
                                                #  - BOOL|NUM|undefined|null|REGEXP|DATE|ERROR: 'BOOL|...'
                                                #  - OBJ: OBJ.toString|valueOf() (valueOf has priority) (otherwise "[object Object]")
                                                #  - ARR: 'VAL,...'
                                               +#  - SYM: 'Symbol(VAR)' (only with String(SYM) or SYM.toString())
                                                #To NUM:
                                                #  - STR: '' 0, 'NUM' NUM (trims whitespaces), '...' NaN
                                                #  - BOOL: true 1, false 0
                                                #  - undefined: NaN
                                                #  - null: 0
                                                #  - OBJ: OBJ.valueOf() (otherwise NaN)
                                                #  - DATE: DATE.getTime()
                                                #  - ARR: ARR[0] to NUM
                                               +#  - SYM: TypeError
                                                #To BOOL:
                                                #  - STR: '' false, '...' true
                                                #  - NUM: 1 true, 0 false
                                                #  - undefined|null: false
                                                #  - OBJ|SYM: true
                                                #To OBJ
                                                #  - NUM|STR|BOOL: use Number|String|Boolean()
                                                #  - SYM: use Object()
                                                #  - undefined|null: throws error
                                                #To null|undefined:
                                                #  - undefined|null: null|undefined

EXPLICIT (GENERAL) ==>                          #To BOOL: !!VAL, Boolean(VAL)
                                                #To NUM;
                                                #  - +VAL, Number(VAL), VAL*1, VAL/1, ~~VAL, VAL|0, VAL-0
                                                #  - parseFloat(VAL): same but:
                                                #     - removes leading|trailing non-numerical chars in STR
                                                #     - only understands decimal form
                                                #     - returns NaN for non-NUM|STR
                                                #  - parseInt(VAL[, NUM]): same as parseFloat() but:
                                                #     - removes decimals
                                                #     - understands decimal or hexadecimal form by default. If NUM, forces radix
                                               |#  - Number.parseFloat|Int(...): same
                                                #To STR: VAL + '', String(VAL)
                                                #To OBJ: [new ]Object(VAL): 
                                                #  - null|undefined -> {}
                                                #  - valueOf()->VAL
                                                #To SYM: impossible, except if converting to STR then using Symbol.for(STR)

EXPLICIT (SPECIFIC) ==>                         #To STR:
                                                #  - NUM:
                                                #     - NUM.toFixed|toPrecision|toExponential([NUM]): specify number
                                                #       of decimals, significant numbers or exponential notation.
                                                #     - NUM.toString(RADIX)
                                                #  - DATE:
                                                #     - DATE.toString(): "Day Mon DD YYYY HH:MM:SS TZ"
                                                #     - DATE.toISOString(): "YYYY-MM-DDTHH:MM:SS.SSSZ"
                                                #     - DATE.toUTCString(): "Day, DD Mon YYYY HH:MM:SS TZ" (UTC)
                                                #     - DATE.toDateString(): "Day Mon DD YYYY"
                                                #     - DATE.toTimeString(): "HH:MM:SS TZ"


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:       BASIC STATEMENTS        :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


RESERVED WORDS ==>                              #enum, await, implements, package, protected, public, private, interface, static

STATEMENT;                                      #; optional, but recommended in case could be interpreted as multiline

STATEMENT\                                      #Only required for multiline statements:
                                                #  - within a STR
                                                #  - if first line could be interpreted as standalone statement.

// COMMENT
/* COMMENT */

"use strict";                                   #Start strict mode, meaning strict ES6 conformance.
                                                #Must in top scope of a function|script|"CODE", before any statement.
                                                #Concatenating with other scripts make them strict too.
                                                #Allows faster optimization by browsers.
                                                #Not compatible until IE10.
                                                #In the web console, use an anonymous function in order to use strict mode.
                                                
var VAR[ = VAL]                                 #Declaration. Default value is undefined.
  [, VAR2[ = VAL2]]...                          #VAR must be [[:alnum:]$_], can't begin with number, can include Unicode.
VAR = VAL;                                      #Assignation. Returns VAL, so chain possible: VAR = VAR2 = VAL

var [ VAR[ = VAL], ... ] = ARR                 |#var VAR = ARR[NUM], ...
                                               |#VAL is default value
                                               |#Final VAR can be ...ARR2 for variadic assignment
var { KEY: VAR[ = VAL] } = OBJ                 |#var VAR = OBJ[KEY], ...
                                               |#VAL is default value
                                               |#Can be { KEY: { KEY2: ... } }
var { KEY[ = VAL] } = OBJ                      |#Same as var { KEY: KEY[ = VAL] } = OBJ

let VAR                                        |#Like var VAR, but {} block scoped.
const VAR                                      |#Like let VAR but read-only (throws error on assignments beyond declaration)

delete OBJ.VAR                                  #Like assigning undefined except:
                                                #  - remove key as well
                                                #  - cannot be performed if non-configurable
                                                #  - can be performed if non-writable
                                                #Note: for ARR[NUM], does not modify length (like assigning undefined)
                                                #Returns true if OBJ (not OBJ.VAR) exists.

void STATEMENT                                  #Same as STATEMENT, but returns undefined
                                                #Sometimes void 0 is used as synonym of undefined (for older browsers where
                                                #undefined can be reassigned)

eval("STATEMENT...")                            #Fire STATEMENT... in current scope. Return last STATEMENT return value.
                                                #To avoid.
                                                #If argument non STR, renvoie VAL.
                                                #"VAR = VAL" does not declare anything.
                                                #Can throw SyntaxError or EvalError.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           FUNCTIONS           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


FUNC                                            #Is OBJ, so can be assigned.
Function                                        #FUNC TYPE  
function [FUNC]([...]) { ... [return VAL;] ... }#Declare and returns FUNC.
                                                #See "Scope" above.
[new ]Function([...,]'...')                     #Same as function(...) { ... } but:
                                                #  - scope will be child of global scope.
                                                #  - body is STR can be dynamically created. Can create injection risk.
                                                #Use only if really necessary.

(...) => {...}                                 |#Same as (function(...) {...}).bind(this)
(...) => VAL                                   |#Same as (...) => { return VAL; }
ARG => {...}                                   |#Same as (ARG) => {...}

ARGUMENTS ==>                                   #  - positional
                                                #  - extra parameters do not fire exceptions
                                                #  - non-OBJ are passed by value, but OBJ always by reference:
                                                #     - including in assignment
                                                #     - left-hand value keeps reference to right-hand value, but not inverse
                                                #        - i.e. assigning to an OBJ argument removes precedent reference:
                                                #            function(OBJ){ OBJ = OBJ2 }     // Removes OBJ reference
                                                #            function(OBJ){ OBJ.VAR = VAL }  // Keep OBJ reference
                                               |#  - VAR = VAL: default value. Can refer to previous argument of same function.
                                               |#    VAL is evaluated at each function call, not at declaration.
                                               |#  - {...}: assigns var {...} = OBJ
                                               |#  - [VAR...]: assigns ARR = [VAL...]
                                               |#  - ...ARR: variadic argument
arguments                                       #Contains currently passed arguments
                                                #  - can only use arguments[NUM] and arguments.length
                                                #  - can be converted to ARR with Array.prototype.slice.call(arguments)
                                                #  - readonly

FUNC([VAL]...)                                  #Fire FUNC and returns its return value
                                                #Can be ...ITERABLE, replaced by NEXT...
FUNC.length                                     #Number of required arguments
FUNC.toString()                                 #Returns source code.

this                                            #OBJ if current function fired as OBJ.FUNC(), otherwise null|undefined
                                                #Read-only
                                                #Notes:
                                                #  - var FUNC2 = OBJ.FUNC or FUNC3(OBJ.FUNC)
                                                #     - must OBJ.FUNC.bind(OBJ) to keep "this"
                                                #  - var OBJ = new FUNC(); calls FUNC.call(OBJ) 
FUNC.bind(VAL[, ...])                           #Returns FUNC, but binds "this" to VAL (except if called with 'new'), 
                                                #and first arguments to ...
FUNC.call(VAL[, ...])                           #Same as FUNC.bind(VAL[, ...])()
FUNC.apply(VAL[, ARR])                          #Same but using an ARR instead of comma-separated arguments.
                                                #Often used to forward to another function: FUNC.apply(this, arguments)

VAR = FUNC([...]); return VAR;                 |#Two examples of a tail call optimization: 
return FUNC([...]);                            |#  - the last FUNC() performed before "return" (besides assignments)
                                               |#    (includes FUNC like native operators)
                                               |#This will optimize FUNC() call:
                                               |#  - faster, because optimizer can replace call stack current frame instead 
                                               |#    of adding to it
                                               |#  - allow infinite recursion


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            OBJECTS            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


[new ]Object()                                  #Base TYPE of all OBJ

OBJ.VAR                                         #Access property (can be any type)
OBJ['VAR']                                      #OBJ.VAR has same naming restrictions as var VAR, but not 'VAR'

{ VAR[: VAL] ... }                              #Literal OBJ.
                                                #If could be interpreted as a { ... } structure (e.g. beginning of line), wrap with ()      
                                               |#Def VAL is VAR
                                               |#VAR can be [STR], for dynamic property name
                                               |#If duplicate key, the last one will overwrite the ones before.
{ [*] FUNC() {...} ... }                       |#Same as { FUNC: function [*] FUNC() {...} ... }

ITERATING OVER PROPERTIES ==>                   #                    +-------------------------------+---------------------------+
                                                #                    | Own                           | Own+shared                |
                                                # +------------------+-------------------------------+---------------------------+
                                                # | enum             |Object.keys(OBJ)               | for (var|let 'VAR' in OBJ)|
                                                # +------------------+-------------------------------+---------------------------+
                                                # | [non-]enum       |Object.getOwnPropertyNames(OBJ)| 'VAR' in OBJ              |
                                                # +------------------+-------------------------------+---------------------------+

Object.keys(OBJ)                                #Returns own keys, excluding non-enumerable
Object.getOwnPropertyNames(OBJ)                 #Returns own keys, including enumerable
OBJ.propertyIsEnumerable('VAR')                 #Returns true if OBJ['VAR'] is in Object.keys()
OBJ.hasOwnProperty('VAR')                       #Returns true if OBJ['VAR'] is in Object.getOwnPropertyNames()

'VAR' in OBJ                                    #Returns true if OBJ['VAR'] is member, including shared or non-enumerable.
                                                #Negation: !('VAR' in OBJ)
                                                #Note: for (var|let STR in OBJ) includes shared, but excludes non-enumerable 

Object.assign(OBJ[, OBJ2...])                  |#Shallow copy of own enumerable OBJ2 members to OBJ, which is returned.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:      OBJECT DESCRIPTORS       :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


{ get|set VAR: FUNC() ... }                     #Like { VAR: FUNC() } followed by Object.defineProperty()

Object.defineProperty(OBJ, 'VAR', OBJ2)         #Assign OBJ['VAR'] = VAL, where VAL depends on OBJ2 ('descriptors'):
                                                #  - either:
                                                #     - value VAL (def: undefined)
                                                #     - get()->VAL and set(VAL), fired at OBJ.VAR and OBJ.VAR = VAL
                                                #  - enumerable BOOL (déf: false): if false, not listed by Object.keys(),
                                                #    OBJ.propertyIsEnumerable() and for (var|let STR in OBJ)
                                                #  - configurable BOOL (déf: false): 
                                                #     - if false, cannot call delete OBJ.VAR (do nothing) nor 
                                                #       Object.defineProperty(OBJ, 'VAR', OBJ2) (throws TypeError)
                                                #     - if get|set(), often non-configurable
                                                #  - writable BOOL (déf: false): 
                                                #     - if false, OBJ.VAR = VAL throws TypeError
                                                #     - not possible with get|set()
                                                #When fired several times, each call only overwrite the specified descriptors.
Object.defineProperties(OBJ, OBJ3)              #Same but using OBJ3 { 'VAR': OBJ2 ... } instead.
Object.getOwnPropertyDescriptor(OBJ, 'VAR')     #Returns OBJ.VAR descriptor OBJ2 (even if not declared through
                                                #Object.defineProperty()), if own [non-]enum member.

Object.preventExtensions(OBJ)                   #Make OBJ non-extensible (non-writable for new properties and __proto__, throwing TypeError)
                                                #Not recursive.
Object.isExtensible(OBJ)                        #

Object.seal(OBJ)                                #Make OBJ non-extensible, non-configurable
                                                #Not recursive.
Object.isSealed(OBJ)                            #

Object.freeze(OBJ)                              #Make OBJ non-extensible, non-configurable, non-writable.
                                                #Not recursive.
Object.isFrozen(OBJ)                            #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          INHERITANCE          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


OBJ.__proto__                                   #When OBJ.VAR is not defined:
Object.getPrototypeOf(OBJ)                      #  - tries OBJ.__proto__.VAR
                                                #     - if OBJ.__proto__
                                                #     - then tries OBJ.__proto__.__proto__.VAR, etc. (prototype chain)
                                                #     - Object.prototype.__proto__ === null
                                                #  - by convention, each __proto__ points to a TYPE.prototype 
                                                #    (first TYPE, then TYPE_PARENT, etc.)
                                                #Object.getPrototypeOf() is more standard.
Object.setPrototypeOf(OBJ, VAL)                |#Same as OBJ.__proto__ = VAL (to avoid because performance issues)
Object.create(TYPE.prototype[, OBJ])            #Returns OBJ2 { __proto__: TYPE.prototype }, then calls
                                                #Object.defineProperties(OBJ2, OBJ)
                                                #Can use null as first argument.
FUNC.prototype.constructor                      #Returns FUNC
new TYPE[(...)]                                 #Does:
                                                #  var OBJ = Object.create(TYPE.prototype);
                                                #  var ret = TYPE.call(OBJ, ...);
                                                #  return ret == null ? OBJ : ret;
                                                #Avoid returning in constructor (child constructor would not be able to inherit
                                                #own members)
                                                #By convention TYPE starts with uppercase
                                                #Requires:
                                                #  - TYPE.prototype OBJ: contains shared members
                                                #  - TYPE.prototype.constructor === TYPE: for type information (optional)

INHERITANCE ==>                                 #Prototype-based, using either:
                                                #  - own members:
                                                #     - accessed directly on OBJ: 
                                                #        - TYPE(...) assigning this OBJ (or returning OBJ (to avoid))
                                                #     - inheritance: children constructor fire parent constructor
                                                #     - created each time new TYPE(...) is fired
                                                #        - i.e. one object per instance
                                                #  - shared members:
                                                #     - accessed|inherited through prototype chain
                                                #     - created once declaration-time
                                                #        - i.e. single reference for all instances
                                                #Example:
																								#  function TYPE(...) { 
																								#    TYPE_PARENT.apply(this[, ...])  
																								#    this.VAR = ...; ...
																								#  }
																								#  TYPE.prototype = Object.create
																								#    (TYPE_PARENT.prototype)
																								#  TYPE.prototype.constructor = TYPE               

STATIC MEMBERS ==>                              #Own members of TYPE itself, i.e. TYPE.VAR = VAL:
                                                #  - not inherited (unless using Backbone extend())
                                                #  - must be called on TYPE itself, not an instance

class TYPE [extends TYPE_PARENT]               |#Other syntax to define inheritance, defining var TYPE = FUNC:
{                                              |#  - extends TYPE2:
  [constructor(...) { ... }]                   |#      constructor() -> function TYPE():
  [static] FUNC(...) { ... }                   |#       - must call super(...) before assigning to this 
}                                              |#       - by def: constructor() { super(arguments) }
                                               |#      TYPE.prototype = Object.create(TYPE2.prototype)
                                               |#      TYPE.prototype.constructor = TYPE (non-enumerable)
                                               |#      TYPE.__proto__ = TYPE2
                                               |#  (non-static)
                                               |#  - TYPE.prototype.FUNC = FUNC (non-enumerable)
                                               |#  (static)
                                               |#  - TYPE.FUNC = FUNC (non-enumerable)
                                               |#Throw error if not called with new.
                                               |#No comma between definition members.
super.*                                        |#Inside class {...}, same as TYPE_PARENT.prototype.*
super(...)                                     |#Inside class {...}, same as TYPE_PARENT.prototype.constructor(...)

UTIL.inherits(TYPE, TYPE_PARENT)               ##For Node.js:
                                               ##  TYPE.prototype = Object.create(TYPE_PARENT.prototype);
                                               ##  TYPE.prototype.constructor = TYPE;
                                               ##  TYPE.super_ = TYPE_PARENT;
                                               ##So setup shared members, and allow TYPE constructor to call parent constructor
                                               ##using this.constructor.super_.apply(this, arguments);

MULTIPLE INHERITANCE ==>                        #For:
                                                #  - own members: call several parent constructors in TYPE()
                                                #  - shared members: use mixins, i.e. assign TYPE_PARENT.prototype.* to 
                                                #    TYPE.prototype.* instead of using prototype chain.

USING EXTEND ==>                                #Basic extend() (like jQuery, Underscore, not like Backbone) are sometimes used
                                                #for inheriting shared members. They help for mixins (see above). However:
                                                #  - if does not include shared members (like Lodash), will not inherit grandparents
                                                #    members (unless copied to parent)
                                                #  - TYPE_PARENT.prototype.VAR will be copied, not referenced, if it is native type

NATIVE OBJECTS INHERITANCE ==>                  #Native objects constructors return a value instead of assigning to this.
                                                #So inheriting not possible, but can extend prototype (to avoid though).
                                                #new TYPE() vs TYPE():
                                                #  - Object|Array|Function|RegExp: no difference
                                                #  - String|Boolean|Number: without new, returns native type
                                                #  - Date: without new, returns DATE.toString()
                                                #  - Error: same except stack trace (prefer new Error)
                                                #  - ArrayBuffer: mandatory new


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            SYMBOLS            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


var SYM = Symbol([STR])                        +#Same as OBJ["RANDOM"], semantically for private members:
OBJ[SYM]                                       +#  - STR optional, just used for toString() description
                                               +#    OBJ[Symbol(STR)] !== OBJ[STR]
                                               +#  - not enumerable: 
                                               +#     - getOwnPropertyNames() -> getOwnPropertySymbols()
                                               +#     - Object.keys|getOwnPropertyNames() or '... in OBJ' will not show symbols.
                                               +#  - properties with a key of SYM will be ignored by JSON.stringify()

Symbol.for(STR)                                +#Like Symbol(STR), except register it to a global store using STR as a key,
                                               +#so that Symbol.for(STR) === Symbol.for(STR)
Symbol.keyFor(SYM)                             +#Returns STR if SYM was created as Symbol.for(STR), undefined otherwise.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          STRUCTURES           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


SINGLE LINE ==>                                 #Block braces can be skipped if only on single next line (to avoid)

VAL                                             #Anything that returns a VAL
EXPR                                            #Anything that could go on a single line of code ending with ;
...                                             #Several EXPR


TEST ? VAL1 : VAL2                              #Returns VAL1 or VAL2

VAL && VAL2                                     #Same as !!VAL ? VAL : VAL2, for any type (including BOOL)
VAL || VAL2                                     #Inverse

VAL1, VAL2                                      #Evaluates both, but returns VAL2.
                                                #Use case: in for or while loops.


{ ... }                                         #

if ( TEST ) { ... }
[else if ( TEST ) { ... }]... 
[else { ... }]

switch (VAL) {                                  #Use VAL === VAL2
  case VAL2: ...  [break;] ...                  #If no break, execute next case (including "default")
  case VAL3: case VAL4: ...  [break;] ...       #Case can be empty, meaning several "case" match when any matches.
  [default: ...  [break;]]                          
}                                               

for ( [EXPR1] ; [TEST] ; [EXPR2] ) { ... }      #Same as:
                                                #  EXPR1; while ( TEST ) { ...; EXPR2; }
while ( TEST ) { ... }
do { ... } while ( TEST ) 

for ( var|let VAR in OBJ ) { ... }              #Iterate over own+shared enumerable keys.
                                                #OBJ can be ITERATOR.
for ([var|let ]VAR of ITERABLE) {...}          |#Iterates with VAR = NEXT

break [LABEL]                                   #Stop current for|while|switch iteration.
                                                #Can target a specific for|while|switch iteration by specifying LABEL: before
                                                #it, e.g. LABEL: for ... (to avoid)
continue [LABEL]                                #Same but only current loop, and not for switch.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            ERRORS             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


throw VAL                                       #Throw exception VAL, i.e. interrupt each function in the call stack until
                                                #inside try { ... } followed by catch ( VAR ) { ... }
try { ...  }
[catch ( VAR ) { ... }]                         
[finally { ... }]                               #finally { ... } is always fired

[new ]Error([STR])                              #OBJ usually used when throw VAL, because better shown on console
                                                #  - nice ERROR.toString()
                                                #  - when instantiated, include current stack (which will be printed)
                                                #    Stack uses FUNC.name.
                                                #Prefer with "new"
                                                #STR is ERROR.message (def: "Error")
                                                #Some builtin ERROR thrown:
                                                #  - ReferenceError: console.log(notdeclared)
                                                #  - TypeError: null.FUNC()
                                                #  - SyntaxError: 5 *** 7
                                                #  - RangeError: new Array(Infinity)
                                                #  - URIError: decodeURIComponent('%')
                                                #  - EvalError: with eval()
ERROR.name                                      #ERROR type (def: "Error"), redefined by children.
ERROR.message                                   #


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            BOOLEAN            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


new Boolean(BOOL)                               #Returns OBJ (see above).
Boolean(BOOL)                                   #Returns BOOL (see above)


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            NUMBER             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


new Number(NUM)                                 #Returns OBJ (see above)
Number(NUM)                                     #Returns NUM (see above)

Number.isInteger(NUM)                          |#Does not coerce to NUM

[Number.]NaN                                    #Returned e.g. by √-1, 0/0 or wrong NUM conversion
                                                #Test:
                                                #  - NaN !== NaN but Object.is(NaN, NaN)
                                               |#  - Number.isNaN(VAL): same as Object.is(VAL, NaN)
                                                #  - isNaN(VAL): same as Number.isNaN(Number(VAL))
[-]Infinity                                     #Returned e.g. by overflow like 1e400, or 1/0
Number.POSITIVE_INFINITY|NEGATIVE_INFINITY      #Test:
                                                #  - [-]Infinity === [-]Infinity
                                               |#  - Number.isFinite(VAL): same as VAL !== Infinity && VAL !== -Infinity
                                                #  - isFinite(VAL): same as Number.isFinite(Number(VAL))
Number.MIN_VALUE                                #Closest to 0 (underflow) (about 5e-324)
Number.MAX_VALUE                                #After it is Infinity (overflow) (about 2e+308)
Number.MIN|MAX_SAFE_INTEGER                    |#Smallest|highest integer that can be represented as a float precisely (about +|-1e16)
                                               |#Test: Number.isSafeInteger(VAL) (does not coerce to NUM)
Number.EPSILON                                 |#NUM +|- NUM2 can create small discrepancies, e.g. 0.3 - 0.1 within a EPSILON range:
                                               |#  - When comparing non-integer NUMs, should check NUM-NUM2 < +|-EPSILON
                                               |#  - about 2e-16


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            STRING             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


new String(STR)                                 #Returns OBJ (see above)
String(STR)                                     #Returns STR (see above)

`...${EXPR}...`                                |#"..." + EXPR + "..."
                                               |#Escape everything in it, including " ' newline
FUNC`...`                                      |#FUNC(STR_ARR, VAL...):
FUNC `...`                                     |#  - VAL... are each ${EXPR}
                                               |#  - STR_ARR[.raw][NUM] are each `...` in-betwen, including empty "" at beginning|end if starts|ends
                                               |#    with ${EXPR}
                                               |#    If "raw", escape backslashes
                                               |#FUNC can be String.raw(), which concanates all like normal template, except it escape backslashes


STR[NUM]                                        #Read-only. undefined if out of range.
STR.charAt(NUM)                                 #Same except "" if out of range

STR.length                           

STR.match(REGEXP)                               #Like REGEXP.exec(STR), sauf que si g flag, renvoie ensemble des 
                                                #occurences dans l'ARRAY.
STR.search(REGEXP)                              #Renvoie index de première occurence de REGEXP dans STR (-1 si absent)
STR.replace(REGEXP, STR2)                       #Renvoie STR, avec replacement de REGEXP par STR2.
                                                #STR2 peut contenir :
                                                #  - $& : match total
                                                #  - $1, etc. : match (...) numéro 1, etc.
                                                #  - $` : caractères précédant match total
                                                #  - $' : caractères suivant match total
                                                #  - $$ : $ littéral
STR.replace(REGEXP,FUNC)                        #Renvoie STR, avec replacement de REGEXP par FUNC($&,$1...,INDEX,STR).
                                                #INDEX est STR.search(REGEXP). Le nombre de $1 dépend de nombre de (...).
                                                #FUNC peut omettre des arguments (à partir de la fin).
STR.split(REGEXP[, UINT])                       #Renvoie une ARRAY splittant STR, avec comme délimiteur REGEXP et, si UINT,
                                                #ne renvoie que les UINT premiers éléments.

STR.to[Upper/Lower]Case()                       #Renvoie sans modifier.
STR.trim()                                      #Remove whitespaces on left and right.

STR.concat(STR2...)                             #Préférer + et +=
STR.[lastI/i]ndexOf(STR[, NUM])              
STR.slice(NUM[, NUM2])                          #Comme pour ARRAY

STR.substring(NUM[, NUM2])                      #Comme .slice sauf que :
                                                #  - NUM2 négatif -> 0
                                                #  - Si NUM2 < NUM, swappe NUM et NUM2

en|decodeURI(STR)                               #Percent encore all non-ASCII chars
                                                #Result often used as URI
                                                #decodeURI() can throw URIError
en|decodeURIComponent(STR)                      #Same but also for ? & = # + $ ; , / : @
                                                #Result often used as URI part (e.g. path, fragment or query variable)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            UNICODE            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


STRING ==>                                      #Support it for Unicode chars <=FFFF: Unicode chars is a single char.
                                                #Specify CODEPOINT[_HEXA] if <=FFFF, S_CODEPOINT[_HEXA] if only <=FFFF.
\uCODEPOINT_HEXA                                #
\u{S_CODEPOINT_HEXA}                           |#

String.fromCharCode(CODEPOINT...)               #
String.fromCodePoint(S_CODEPOINT)              |#Returns STR

STR.charCodeAt(NUM)                             #Returns CODEPOINT
STR.codePointAt(NUM)                           |#Returns S_CODEPOINT

/REGEXP/u                                      |#Make . match a Unicode char, even >=FFFF


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             INTL              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


OBJ|ARR|NUM|DATE.toLocaleString()               #

STR.localCompare(STR2)                          #Correct way to compare STR : renvoie -1, 0 ou 1.
                                                #<, >, ==, etc. suffisent pour STR cependant (mais prennent pas en compte
                                                #locales)

STR.toLocale[Upper/Lower]Case()                 #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            REGEXP             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


[new ]RegExp([STR])                             #Can be expressed sous forme de REGEXP_LIT via /STR/[FLAGS]
                                                #Def STR: '(?:)'
                                                #Ex: var VAR = /.*/;
                                                #RegExp étendues avec quelques ajouts :
                                                #  - \w \W \s \S \d \D
                                                #  - \1 \2 etc.
                                                #  - Pas de \< \>
                                                #  - ^ et $ indiquent ensemble de STR, quel que soient newlines.
                                                #FLAGS possibles : 
                                                #  - g i : comme sed
                                                #  - m : on multiple lines (doesn't seem to change anything)
REGEXP(STR[, STR2])                             #STR2 sont les flags
                                                #STR Need to escape backslashes
                                                #Should escape all regex symbols before (unless intended as regex symbols) : 
                                                #  STR.replace( /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&" )
REGEXP.ignoreCase
REGEXP.global
REGEXP.multiline                                #Presence du flag sous BOOL
REGEXP.source                                   #STR d'origine.
REGEXP.lastIndex                                #Utiliser avec exec et test : si flag g, ne fait qu'une recherche, mais 
                                                #fera prochaine recherche après dernier caractère matché (indiqué par
                                                #lastIndex sous NUM)

REGEXP.exec(STR)                                #Search REGEXP in STR et renvoie ARRAY :
                                                #  - ARRAY[0] est le total match
                                                #  - ARRAY[n] sont les matches des (...) dans REGEXP (s'il y en a)
                                                #  - ARRAY.index est l'index du premier (Unicode) char matché
                                                #  - ARRAY.input est STR
                                                #Si ne trouve rien, renvoie null
REGEXP.test(STR)                                #Renvoie true si STR contient REGEXP.
                                                #Utiliser REGEXP.lastIndex


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             ARRAY             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


Array                                           #Array are objects. Indexs sont en fait des properties names (internally)
                                                #Eviter for ( in ) qui énumera également les membres d'ARRAY (hors indexs)
[new ]Array(VAL...)                             #Equivaut à [ VAL... ]
[ [VAL]... ]                                    #ARRAY. Peut être left-head : écriture et [...].FUNC()
                                                #VAL est par défaut undefined.
                                                #Peut contenir types différents.
                                               |#VAL can be ...ITERABLE (replaced by NEXT...)

Array(NUM)                                      #Renvoie ARRAY avec NUM éléments undefined.
                                                #Throw RangeError if non-positive or decimal.

Array.isArray(VAL)                              #Renvoie true si ARRAY (non enfant d'ARRAY)

ARRAY = ARRAY                                   #Assignation
                                                #Plutôt que de faire ARRAY = [ "STR", "STR2", "STR3", ... ], écrire
                                                #[ "STR STR2 STR3" ].split( " " ) si c'est qu'une seule fois, car plus simple
                                                #à écrire.
ARRAY[UINT]                                     #Déférencement. Index commence à 0. Si hors bound, renvoie undefined.
ARRAY[STR]                                      #Array associative. En fait, équivaut à ARRAY.STR. Préférer utiliser un OBJET
                                                #si seulement array associative.

ARRAY.length                                    #Il est possible de modifier pour étendre (avec des undefined) ou tronquer.

ARRAY.concat(VAL)                               #Renvoie ARRAY avec élément VAL (ou ARRAY2) à la fin d'ARRAY.
$.merge(ARRAY,ARRAY2)                          ##Concatène ARRAY2 à ARRAY, et renvoie ARRAY (jQuery).
ARRAY.slice(NUM[,NUM2])                         #Renvoie copy of ARRAY, de l'élément NUM à NUM2 (déf: fin). 
                                                #Si NUM2 négatif, signifie numéro de l'élément depuis a fin d'ARRAY.
ARRAY.splice(NUM, NUM2[, VAL...])               #Supprime et renvoie les NUM2 éléments après l'élement numéro NUM, et les 
                                                #remplace par VAL...
ARRAY.join([STR])                               #Renvoie ARRAY concaténés sous forme de STR, avec comme délimiteur STR
                                                #(déf: ,)

ARRAY.push(VAL)                                 #Rajoute ARRAY avec élément VAL à la fin d'ARRAY.
                                                #Renvoie ARRAY.length
ARRAY.pop()                                     #Supprime dernier élément. Renvoie ARRAY.length
ARRAY.unshift(VAL)                              #
ARRAY.shift()                                   #Comme push/pop, mais pour premier élément.

ARRAY.reverse()                                 #Modifie et renvoie.
ARRAY.sort([FUNC])                              #Modifie et renvoie.
                                                #Peut donner une fonction de comparaison FUNC(VAL,VAL2), renvoyant 1 si a>b,
                                                #-1 s a<b, 0 si a==b
                                                #Comparaison est STR. Pour sort des nombres, utiliser FUNC :
                                                #function(a,b) { return a == b ? 0 : ( a < b ? -1 : 1 ) }
                                                
ARRAY.indexOf(VAL[, NUM])                       #Renvoie position de VAL dans ARRAY (si NUM, skippe les NUM premiers éléments).
                                                #-1 si pas trouvé.
ARRAY.lastIndexOf(VAL[, NUM])                   #Pareil, mais position depuis la fin.

ARRAY.forEach(FUNCTION[, VAL])                  #Exécute FUNCTION(VAL2[, NUM[, ARRAY2]]) pour chaque VAL2 d'ARRAY.
                                                #NUM est l'index de l'élement. ARRAY2 est ARRAY.
                                                #VAL est this au sein de FUNCTION
ARRAY.map(FUNCTION[, VAL])                      #Pareil, mais renvoie également la concaténation des return value des 
                                                #invocation de FUNCTION.

ARRAY.reduce[Right](FUNC[, VAL])                #Exécute FUNCTION(VAL3,VAL2[, NUM[, ARRAY2]]) sur chaque VAL2 d'ARRAY de 
                                                #manière consécutive, où VAL3 est le résultat de l'exécution précédente.
                                                #Renvoie résultat VAL4 final.
                                                #VAL est la VAL3 initiale (déf: 0)
                                                #reduceRight va de droite à gauche.
ARRAY.filter(FUNC[, VAL])                       #Renvoie éléments dans ARRAY répondant true à FUNC(VAL2[, NUM[, ARRAY2]]).
                                                #VAL est this au sein de FUNCTION
ARRAY.every(FUNC[, VAL])                        #Renvoie true si FUNC(VAL2[, NUM[, ARRAY2]]) de chaque VAL2 d'ARRAY renvoie 
                                                #true.
                                                #VAL est this au sein de FUNCTION
ARRAY.some(FUNC[, VAL])                         #Pareil mais si au moins un renvoie true.

MULTIDIMENSIONAL ARRAYS ==>                     #Utiliser des ARRAY d'ARRAY : VAR[NUM][NUM2]


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:         TYPED ARRAYS          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


new ArrayBuffer(UINT)                           #Bytes chunk. Needs an ARRAYBUFFERVIEW to be manipulated.
                                                #Several ARRAYBUFFERVIEW can be applied to a single ARRAYBUFFER.
                                                #UINT is byteLength
ARRAYBUFFER.byteLength                          #Readonly.
ArrayBufferView                                 #A view is linked to an ARRAYBUFFER and has : 
                                                #  - a specific type to read it
                                                #  - an offset from the beginning of it
ARRAYBUFFERVIEW.buffer                          #The ARRAYBUFFER. Readonly
ARRAYBUFFERVIEW.byteLength                      #ARRAYBUFFER.byteLength. Readonly.
ARRAYBUFFERVIEW.byteOffset                      #The offset, in bytes.

[Ui|I]nt8|16|32Array                            #
Float32|64Array                                 #Enfant d'ARRAYBUFFERVIEW avec un type précis.
*ARRAY.BYTES_PER_ELEMENT                        #Byte length du type
*ARRAY(UINT)                                    #Constructor vide.
*ARRAY(ARRAY)
*ARRAY(*ARRAY2)                                 #Copy constructor
*ARRAY(ARRAYBUFFER[, UINT[, UINT2]])            #UINT est l'offset en byte (déf: 0) et UINT2 la taille en byte (déf: all), pour
                                                #pouvoir tronquer.
*ARRAY[UINT]                                    #
*ARRAY.set(ARRAY|*ARRAY2[, UINT])               #Remplace une partie d'*ARRAY avec ARRAY|*ARRAY2, depuis élément UINT (déf: 0)
*ARRAY.subarray(UINT[, UINT2])                  #Renvoie seulement de l'octet UINT à UINT2 (exclus) (déf: fin)

Array.apply([], *ARRAY)                         #Convertit en ARRAY

DataView                                        #Enfant d'ARRAYBUFFERVIEW avec types changeants.
DATAVIEW(ARRAYBUFFER[, UINT[, UINT2]])          #Comme *ARRAY
DATAVIEW.get[Ui|I]nt8|16|32([UINT[, BOOL]])     
DATAVIEW.getFloat32|64(UINT[, BOOL])            #UINT est l'offset en byte et BOOL l'endianness (déf: true, little endian)
DATAVIEW.set*(UINT, UINT2[, BOOL])              #UINT est l'offset en byte (attention) et UINT2 la valeur à mettre.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           ITERATORS           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


FUNC()->{ 
  next()->{done BOOL, value NEXT}              +#ITERATOR_FUNC, returning ITERATOR. Convention for a FUNC returning specific functions.
}                                              +#Consumers usually call var NEXT = next() until BOOL true.
ITERABLE                                       +#OBJ where OBJ[Symbol.iterator] is ITERATOR_FUNC.
                                               +#STR|ARR|TYPED_ARR|MAP|SET are ITERABLE.
function* [FUNC](){...}                        +#Generator. Translates to an ITERATOR_FUNC where next([VAL]):
                                               +#  - stops at the next "yield NEXT", returning VAL, making next() return {done false, value NEXT}
                                               +#  - then stops at "return NEXT" making next() return {done true, value FINAL_NEXT}
                                               +#  - then always return {done true}
                                               +#The ITERATOR returned by ITERATOR_FUNC():
                                               +#  - is also ITERABLE
                                               +#  - has extra members:
                                               +#     - return(FINAL_NEXT)->{done true, value FINAL_NEXT}
                                               +#     - throw(ERROR): thrown from the context of the last yield
                                               +#Can also use yield* ITERABLE:
                                               +#  - yield NEXT several times
                                               +#  - returns FINAL_NEXT
new GeneratorFunction(...)                     +#Like new Function(...) but for function*(){}


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             DATE              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


Date                                            #Milliseconds-precise. Use local time by default.
new Date(YEAR,MONTH,DAY,HOUR,MIN,SEC,MILLISEC)  #Each final arguments are optional. Def: now.
new Date(STR)                                   #InvalidDate if cannot parse.
Date()                                          #Same as (new Date()).toString()

DATE.*et[UTC][Time/FullYear/Month/Date/Day/     #Date is month day, Day week day (0 for Sunday)
Hours/Minutes/Seconds/Milliseconds/             #Time is Epoch in seconds
TimezoneOffset]()                               #TimezoneOffset is in minutes
                                                #UTC: instead of local time (not for UTC)
                                                #set* returns DATE.getTime()

Date.now()                                      #Like new DATE().getTime()
Date.parse(STR)                                 #Like new DATE(STR).getTime()
Date.UTC(...)                                   #Like new DATE(...).getTime() but for UTC


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             MATH              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


Math.min|max(NUM...)                            #NaN if one NUM not a number. [-]Infinity if no arguments.

Math.abs(NUM)                                   #
Math.sign(NUM)                                 |#Returns -|+ 0|1 or NaN

Math.ceil|floor|round(NUM)                      #Upper|lowest|nearest round
Math.trunc(NUM)                                |#Closest to 0 round
Math.fround(NUM)                               |#Converts to single-precision float

Math.PI                                         #
Math.E                                          #
Math.LN2                                        #ln(2)
Math.LN10                                       #ln(10)
Math.LOG2E                                      #log2(e)
Math.LOG10E                                     #log10(e)
Math.SQRT2                                      #
Math.SQRT1_2                                    #

Math.pow(NUM1, NUM2)                            #
Math.sqrt(NUM)                                  #NaN if negative
Math.cbrt(NUM)                                 |#
Math.exp(NUM)                                   #
Math.expm1(NUM)                                |#Same as Math.exp(NUM)-1
Math.log(NUM)                                   #Base e. NaN if negative
Math.log2|10(NUM)                              |#Base 2|10
Math.log1p(NUM)                                |#Same as Math.log(NUM+1)

Math.imul(NUM, NUM2)                           |#Like NUM*NUM2, except only for 32-bits signed integers, where the sign is the
                                               |#first bit, e.g. 4e9 is negative.
                                               |#Used to emulate x86 ASM imul.
Math.clz32(NUM)                                |#Number of leading zeros in a 32-bits signed binary format.

Math.[a]sin|cos|tan[2](NUM)                     #In radian
Math.[a]sin|cos|tan[2]h(NUM)                   |#Hyperbolic version
Math.hypot(NUM...)                             |#sqrt(NUM**2 + NUM2**2 ...)

Math.random()                                   #Float in [0,1). Seeded from current time.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             JSON              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


JSON ==>                                        #Un peu comme XML, sert à sérialiser objets.
                                                #Extension est ".json"
                                                #Est en fait même notation qu'un OBJ littéral, avec comme différence :
                                                #  - VAR: VAL -> "VAR": VAL
                                                #  - no leading zeros on NUM
                                                #  - seuls échappement backslash : \", \\, \b, \f, \n, \r, \t, \uXXXX
                                                #  - no undefined, FUNC or native objects (besides OBJ|ARR).
                                                #    Can howeve support:
                                                #     - if toJSON() defined. DATE.toJSON()->"DATE" defined by default.
                                                #     - by calling toString() prior.
                                                #     - via JSON.stringify|parse FUNC
                                                #  - no ES6 syntax like { [STR]: VAL }, { VAR }, etc.
                                                #Peut également être un VAL (dont [...]) au lieu de { VAL }
JSON                                            #Parser de JSON. A préférer à eval() ou à d'autres parsers. Enfant d'Object.
JSON.parse(STR[, FUNC])                         #Renvoie la conversion de JSON STR en VAL
                                                #Si FUNC, exécute FUNC(key,value) pour parser chaque value (avec this étant à
                                                #chaque fois le parent direct). Reste est comme FUNC de stringify.
                                                #Peut throw SyntaxError.
JSON.stringify(VAL[,VAL2[,VAL3]])               #Renvoie la conversion de VAL en JSON sous forme de STR
                                                #undefined, fonction, non supported objects -> omitted or converted to null
                                                #Si VAL2, peut être :
                                                #  - une FUNC(key,value) : chaque propriété passera par la fonction et :
                                                #      - la return value, transtyped vers STR, sera la value stringified pour
                                                #        cette propriété
                                                #      - si return value est undefined, skippe la propriété
                                                #    Pour un array key est le NUM, pour un objet c'est le name STR.
                                                #    L'objet global passe par la fonction à la fin (sa key est "")
                                                #  - une ARRAY de STR désignant les names des propriétés à inclure. Non
                                                #    récursif. Pour inclure enfant, parent doit être inclus.
                                                #Si VAL3, indente avec VAL3 (STR si STR, NUM spaces si NUM) et rajoute
                                                #newlines.
                                                #Si VAL.toJSON() existe, au lieu d'utiliser VAL, utilisera return value de 
                                                #VAL.toJSON().


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            MODULES            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


export var|let|const VAR = VAL
export function VAR(...){...}                  |#
export { VAR[ as VAR2] }                       |#With VAR name
export default VAL                             |#Without VAR name
export ... from "MDL"                          |#Same as import ... from "MDL", then multiple export

import {VAR[ as VAR2],...} 
from "MDL"                                     |#
import * as VAR2 from "MDL"                    |#With VAR name
import VAR from "MDL"                          |#Without VAR name. Can be combined, e.g. import VAR, {...} from "MDL"
import "MDL"                                   |#Do not import the variable, just execute the file
