
                
   JAVASCRIPT   
                



VERSION ==>                                     #Standard is called ECMAScript. JavaScript and ActionScript are dialects.
                                                #This doc shows ES6 in strict mode, with this notation for ES6 new features:
                                                #  - Babel (not Node): 
                                              *|#     - works with Babel
                                              *+#     - works with Babel, but require polyfill
                                              *-#     - does not work with Babel
                                                #  - Babel + Node 5.0:
                                               |#     
                                               +#     
                                               -#     
                                                #ES7 not documented yet.

MAIN PRINCIPLES ==>                             #Case-sensitive. Whitespaces are ignored.
                                                #Type: weak, dynamic, generic, late/duck.
                                                #Lexical-scope
                                                #Functional (first-class functions)
                                                #Object-oriented (prototype-based)
                                                #Imperative (structures close to C)
                                                #Need a host environnement (e.g. browser) for I/O
                                                #Memory management: garbage collection.

EXECUTION ==>                                   #Each browser has own JavaScript engine, which was in the past interpreted,
                                                #but now is byte-compiled or compiled:
                                                #  - Chakra (IE9+)
                                                #  - SpiderMonkey (Firefox)
                                                #  - V8 (Chrome, Opera 12.15+)
                                                #  - SquirrelFish (Safari)

EVENT LOOP ==>                                  #Each event add its listeners ('message') on top of the event stack (async):
                                                #  - this does not include events manually triggered, e.g. through dispatchEvents()
                                                #  - example of events:
                                                #     - parsing a <script>
                                                #     - DOM events, including click, XHR, etc.
                                                #     - setTimeout|Interval()
                                                #Each message on the event stack is run in order, synchronously:
                                                #  - if too long computation, other messages cannot be processed -> unresponsive.
                                                #    Should then use setTimeout|Interval() to yield control.
                                                #Each <iframe> or WEBWORKER has its own event loop.

INCLUDING IN HTML ==>                           #Priority is from top to bottom

<script src="script.js"></script>               #From external file. Preferred. Should be in <head>.

<script>CODE</script>                           #Inline. If in <body>, execute while loading. Should be in <head>

<a href="JavaScript:CODE"></a>                  #
<any onEVENT="CODE"></any>                      #Deprecated

<noscript>
  Activez JavaScript pour voir contenu
</noscript>


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             SCOPE             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


GENERAL ==>                                     #  - variable scope is:
                                                #     - "var": function() {...}
                                               |#     - "let|const": any {...}
                                                #  - any function is child scope of the function in which it is *declared* (not *fired*)
                                                #     - parent scope is a reference, not a snapshot, i.e. is is evaluated each
                                                #       time the function is fired
                                                #  - scopes inherits parent scope, but not inverse
                                                #  - global/root scope: usually available with global reference global|window 
                                                #    (depends on host)

DECLARATION ==>                                 #  - using undeclared VAR throws ReferenceError (except with typeof)
                                                #  - using VAR (even if declared in parent scope) declared later in current scope with:
                                               |#     - "let|const": throws ReferenceError ("Temporal Dead Zone")
                                                #     - "var": adds an implicit empty declaration before, i.e. will be undefined (variable hoisting)
                                                #     - function FUNC(){}: adds an implicit declaration+assignment before

DECLARING FUNCTIONS ==>                         #  - FUNC = function [FUNC2](){}
                                                #     - declared+assigned at runtime (like other variables)
                                                #     - this also covers anonymous function, and void function [FUNC2](){}
                                                #     - FUNC2.name (read-only): used by ERROR.toString() in stack trace
                                                #     - Using "FUNC2":
                                                #        - equivalent of doing let FUNC2 = function(){} at the beginning of the same function
                                                #        - allow recursion to reference themselves without risk of parent scope
                                                #          to reassign FUNC2
                                                #  - function FUNC2(){}:
                                                #     - declared+assigned at parsetime 
                                                #        - i.e. equivalent of doing let FUNC2 = function () {} at {...} scope beginning
                                                #     - FUNC2.name: same
                                                #  - new Function(...): child of global scope

MEMORY MANAGEMENT ==>                           #Garbage collection:
                                                #  - periodically, iterates recursively over global object properties,
                                                #    including functions SCOPEs
                                                #  - clean any defined that cannot be reached anymore (because a SCOPE ended)
                                                #  - note that local functions:
                                                #     - can be assigned to parent SCOPE (and so live beyond current SCOPE) by
                                                #       direct assignment and be used as return value
                                                #     - carry references to parent SCOPEs but only of the references they use
                                                #Memory leak happens with combination of variables being:
                                                #  - big, e.g.:
                                                #     - functions carrying parent SCOPEs
                                                #     - big objects
                                                #     - raw data returned from server
                                                #  - long-lived, e.g.:
                                                #     - attached to top/long-lived SCOPEs, e.g. global variables, e.g.:
                                                #        - long-lived DOM elements
                                                #        - global functions (e.g. global event handlers, setInterval(), ...)
                                                #Avoiding:
                                                #  - unset variables just after being used if they are big or attached to 
                                                #    long-lived objects. By "unset", prefer setting empty value than using
                                                #    "delete"
                                                #  - prefer top-level functions to local functions
                                      


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         TYPES GENERAL         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


TYPING SYSTEM ==>                               #  - weak: no type specified at Declaration
                                                #  - generic: native operators accepts any type, since each native type
                                                #    transtype to any (except OBJ->undefined|null)
                                                #  - dynamic: type is not checked at compile-time nor (since generic) run-time

AVAILABLE TYPES ==>                             #  - simple: number|boolean|string|undefined|null
                                                #  - object (TYPE): Object and its children
                                                #    - native: Object|Array|Number|Boolean|String|Error|...
                                                #    - user-defined:
                                                #      - host objects: defined by browser (e.g. DOM elements)

Number|Boolean|String                           #Not same as number|boolean|string:
                                                #  - are objects, constructed as new TYPE([VAL])
                                                #  - but transtypes to|from simple types
                                                #     - STR|BOOL|(NUM).VAR work, because of transtype
                                                #     - not that null|undefined.VAR will throw error
                                                #Note: new Number|...(...) returns OBJ, whereas Number|...(...) returns native type

typeof VAR                                      #Returns "number|boolean|string|symbol|undefined|object|function"
                                                #"object": includes null, excludes FUNC
OBJ.constructor                                 #Returns TYPE (read-only)
VAR instanceof TYPE                             #Returns true if VAR is instance of TYPE (of a child of TYPE), i.e.:
                                                #  - VAR.[__proto__...]constructor === TYPE, 
                                                #    but without transtyping VAR if it is not an OBJ
                                                #  - VAR.[__proto__...]__proto__ === TYPE.prototype
TYPE.prototype.isPrototypeOf(VAR)               #Same

TYPE[Symbol.hasInstance](VAR)->BOOL           *-#Define to override VAR instanceof TYPE

CHECKING TYPE ==>                               #  - number|boolean|string|symbol: typeof VAR === '...'
                                                #  - object: typeof VAR === 'object' && VAR !== null
                                                #  - null: VAR === null
                                                #  - null|undefined: VAR == null
                                                #  - undefined: 
                                                #     - (VAR declared) VAR === undefined
                                                #     - (VAR maybe not declared) typeof VAR === "undefined"
                                                #       Should never be necessary:
                                                #        - useless in local scopes
                                                #        - in global scope, use global.VAR === undefined
                                                #  - ARR: Array.isArray(VAR)
                                                #  - Node: VAR.nodeType === 1
                                                #  - TYPE (excluding children): OBJ.constructor === TYPE
                                                #  - TYPE (including children): OBJ instanceof TYPE
                                                #  - OBJ (no parent TYPE): OBJ.constructor === Object


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         SIMPLE TYPES          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


NUM                                             #Are all double-float.
                                                #Radix: 
                                                #  - NUM 
                                                #  - 0xNUM 0XNUM
                                               |#  - 0oNUM 0ONUM
                                               |#  - 0bNUM 0BNUM
                                                #Keywords (see below): 
                                                #  - NaN: possible illegal NUM operations
                                                #  - [-]Infinity: very low|high NUM
                                               +#  - Number.MIN|MAX_SAFE_INTEGER: very low|high integers
                                                #  - Number.MAX_VALUE: very low|high floats
                                                #  - Number.MIN_VALUE: very close to 0 floats
                                               +#  - Number.EPSILON: comparing floats
                                                #Operator:
                                                #  + - * / %
                                                #  -NUM
                                                #  NUM++ --NUM etc.
                                                #  ~ & ^ | >> << (bitwise)
                                                #  >>>  (like >>, but shiftes zeros on the left)
                                                #  OP=  (e.g. NUM += 2 or NUM %=10)
                                                #  < <= > >=

BOOL                                            #true|false
                                                #Operators:
                                                #  ! && ||

STR                                             #"STR"|'STR' (same, except for " or ' escaping)
                                               |#or [FUNC] `...` (can include ${EXPR})
                                                #Any backslash escape, except \a, \c et \e
                                                #If includes newlines, must either: `...`, trailing backslashes or concatenation
                                                #Operators:
                                                #  + +=
                                                #  < <= > >=: char by char, codepoint-wise

SYM                                            +#Symbol([STR])
                                               +#Used as OBJ key for private members, i.e. OBJ[SYM] is like OBJ['RANDOM']
                                               +#Operators:
                                               +#  OBJ[SYM]

undefined                                       #Valeur par défaut:
                                                #  - non-declared VAR: throw ReferenceError when used, except with typeof
                                                #  - declared but non-assigned VAR (including arguments and return value)

null                                            #Special keyword indicating emptiness


EQUALITY ==>                                    #Native types:
                                                #  - == != (transtypes)
                                                #  - === !== (does not transtype)
                                                #OBJ:
                                                #  - == === != !== (only check same reference)
Object.is(VAL, VAL2)                           |#Same as ===, except !Object.is(+0,-0) and Object.is(NaN, NaN)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          TRANSTYPING          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


IMPLICIT ==>                                    #To STR:
                                                #  - BOOL|NUM|undefined|null: 'BOOL|...'
                                               -#  - SYM: 'Symbol(VAR)' (only with String(SYM) or SYM.toString())
                                                #  - OBJ: 
                                                #     - OBJ.toString|valueOf() (valueOf has priority) (otherwise "[object NAME]")
                                              *|#        - NAME is OBJ[Symbol.toStringTag]()->'NAME': 'Object|Math|JSON'
                                                #        - REGEXP|DATE|ERROR: '...'
                                                #        - ARR: ARR.join(',')
                                              *-#     - or OBJ[Symbol.toPrimitive]('string')
                                                #To NUM:
                                                #  - STR: '' 0, 'NUM' NUM (trims whitespaces), '...' NaN
                                                #  - BOOL: true 1, false 0
                                                #  - undefined: NaN
                                                #  - null: 0
                                               -#  - SYM: TypeError
                                                #  - OBJ: 
                                                #     - OBJ.valueOf() (otherwise NaN)
                                                #        - DATE: DATE.getTime()
                                              *-#     - or OBJ[Symbol.toPrimitive]('number')
                                                #To BOOL:
                                                #  - STR: '' false, '...' true
                                                #  - NUM: 1 true, 0 false
                                                #  - undefined|null: false
                                                #  - OBJ|SYM: 
                                                #     - true
                                              *-#     - or OBJ[Symbol.toPrimitive]('boolean')
                                                #To OBJ
                                                #  - NUM|STR|BOOL: use Number|String|Boolean()
                                               -#  - SYM: use Object()
                                                #  - undefined|null: throws error
                                                #To null|undefined:
                                                #  - undefined|null: null|undefined

EXPLICIT (GENERAL) ==>                          #To BOOL: !!VAL, Boolean(VAL)
                                                #To NUM;
                                                #  - +VAL, Number(VAL), VAL*1, VAL/1, ~~VAL, VAL|0, VAL-0
                                                #  - parseFloat(VAL): same but:
                                                #     - removes leading|trailing non-numerical chars in STR
                                                #     - only understands decimal form
                                                #     - returns NaN for non-NUM|STR
                                                #  - parseInt(VAL[, NUM]): same as parseFloat() but:
                                                #     - removes decimals
                                                #     - understands decimal or hexadecimal form by default. If NUM, forces radix
                                               +#  - Number.parseFloat|Int(...): same
                                                #To STR: VAL + '', String(VAL)
                                                #To OBJ: [new ]Object(VAL): 
                                                #  - null|undefined -> {}
                                                #  - valueOf()->VAL
                                               -#To SYM: impossible, except if converting to STR then using Symbol.for(STR)

EXPLICIT (SPECIFIC) ==>                         #To STR:
                                                #  - NUM:
                                                #     - NUM.toFixed|toPrecision|toExponential([NUM]): specify number
                                                #       of decimals, significant numbers or exponential notation.
                                                #     - NUM.toString(RADIX)
                                                #  - DATE:
                                                #     - DATE.toString(): "Day Mon DD YYYY HH:MM:SS TZ"
                                                #     - DATE.toISOString(): "YYYY-MM-DDTHH:MM:SS.SSSZ"
                                                #     - DATE.toUTCString(): "Day, DD Mon YYYY HH:MM:SS TZ" (UTC)
                                                #     - DATE.toDateString(): "Day Mon DD YYYY"
                                                #     - DATE.toTimeString(): "HH:MM:SS TZ"


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:       BASIC STATEMENTS        :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


RESERVED WORDS ==>                              #enum, await, implements, package, protected, public, private, interface, static

STATEMENT;                                      #; optional, but recommended in case could be interpreted as multiline

STATEMENT\                                      #Only required for multiline statements:
                                                #  - within a STR
                                                #  - if first line could be interpreted as standalone statement.

// COMMENT
/* COMMENT */

"use strict";                                   #Start strict mode, meaning strict ES6 conformance.
                                                #Must in top scope of a function|script|"CODE", before any statement.
                                                #Concatenating with other scripts make them strict too.
                                                #Allows faster optimization by browsers.
                                                #Not compatible until IE10.
                                                #In the web console, use an anonymous function in order to use strict mode.
                                                
var VAR[ = VAL]                                 #Declaration. Default value is undefined.
  [, VAR2[ = VAL2]]...                          #VAR must be [[:alnum:]$_], can't begin with number, can include Unicode.
VAR = VAL;                                      #Assignation. Returns VAL, so chain possible: VAR = VAR2 = VAL

[var ][ VAR[ = VAL], ... ] = ARR              *|#[var ]VAR = ARR[NUM], ...
                                              *|#VAL is default value
                                              *|#Final VAR can be ...ITERABLE for variadic assignment
[var ]{ KEY: VAR[ = VAL] } = OBJ              *|#[var ]VAR = OBJ[KEY], ...
                                              *|#Without 'var', must wrap with ({...} = OBJ)
                                              *|#VAL is default value
                                              *|#Can be { KEY: { KEY2: ... } }
[var ]{ KEY[ = VAL] } = OBJ                   *|#Same as var { KEY: KEY[ = VAL] } = OBJ

let VAR                                        |#Like var VAR, but {} block scoped.
const VAR                                      |#Like let VAR but read-only, i.e. throws error on assignments beyond declaration
                                               |#Is shallow: if OBJ, only OBJ is read-only, not OBJ.VAR

delete OBJ.VAR                                  #Like assigning undefined except:
                                                #  - remove key as well
                                                #  - cannot be performed if non-configurable
                                                #  - can be performed if non-writable
                                                #Note: for ARR[NUM], does not modify length (like assigning undefined)
                                                #Returns true if OBJ (not OBJ.VAR) exists.

void STATEMENT                                  #Same as STATEMENT, but returns undefined
                                                #Sometimes void 0 is used as synonym of undefined (for older browsers where
                                                #undefined can be reassigned)

eval("STATEMENT...")                            #Fire STATEMENT... in current scope. Return last STATEMENT return value.
                                                #To avoid.
                                                #If argument non STR, renvoie VAL.
                                                #"VAR = VAL" does not declare anything.
                                                #Can throw SyntaxError or EvalError.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           FUNCTIONS           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


FUNC                                            #Is OBJ, so can be assigned.
Function                                        #FUNC TYPE  
function [FUNC]([...]) { ... [return VAL;] ... }#Declare and returns FUNC.
                                                #See "Scope" above.
[new ]Function([...,]'...')                     #Same as function(...) { ... } but:
                                                #  - scope will be child of global scope.
                                                #  - body is STR can be dynamically created. Can create injection risk.
                                                #Use only if really necessary.

(...) => {...}                                 |#Same as (function(...) {...}).bind(this), except:
                                               |#  - arguments|super|new.target refer to current function's
                                               |#  - cannot rebind this
(...) => VAL                                   |#Same as (...) => { return VAL; }
                                               |#To return an OBJ, wrap in ({...})
ARG => {...}                                   |#Same as (ARG) => {...}

ARGUMENTS ==>                                   #  - positional
                                                #  - extra parameters do not fire exceptions
                                                #  - non-OBJ are passed by value, but OBJ always by reference:
                                                #     - including in assignment
                                                #     - left-hand value keeps reference to right-hand value, but not inverse
                                                #        - i.e. assigning to an OBJ argument removes precedent reference:
                                                #            function(OBJ){ OBJ = OBJ2 }     // Removes OBJ reference
                                                #            function(OBJ){ OBJ.VAR = VAL }  // Keep OBJ reference
                                              *|#  - VAR = VAL: default value:
                                              *|#     - Can refer to previous argument of same function.
                                              *|#     - VAL is evaluated at each function call, not at declaration,
                                              *|#       in its own child scope.
                                              *|#     - explicitely passing undefined gets the default value
                                              *|#  - ...ARR: variadic argument
                                              *|#  - {...}: assigns var {...} = OBJ
                                              *|#  - [VAR...]: assigns ARR = [VAL...]
arguments                                       #Readonly ARRAYLIKE containing currently passed arguments.

FUNC([VAL]...)                                  #Fire FUNC and returns its return value
                                               |#Can be ...ITERABLE, replaced by NEXT...
FUNC.length                                     #Number of required arguments
FUNC.toString()                                 #Returns source code.

this                                            #OBJ if current function fired as OBJ.FUNC(), otherwise null|undefined
                                                #Read-only
                                                #Notes:
                                                #  - var FUNC2 = OBJ.FUNC or FUNC3(OBJ.FUNC)
                                                #     - must OBJ.FUNC.bind(OBJ) to keep "this"
                                                #  - var OBJ = new FUNC(); calls FUNC.call(OBJ) 
FUNC.bind(VAL[, ...])                           #Returns FUNC, but binds "this" to VAL (except if called with 'new'), 
                                                #and first arguments to ...
FUNC.call(VAL[, ...])                           #Same as FUNC.bind(VAL[, ...])()
FUNC.apply(VAL[, ARR])                          #Same but using an ARR instead of comma-separated arguments.
                                                #Often used to forward to another function: FUNC.apply(this, arguments)

VAR = FUNC([...]); return VAR;                *|#Two examples of a tail call optimization: 
return FUNC([...]);                           *|#  - the last FUNC() performed before "return" (besides assignments)
                                              *|#    (includes FUNC like native operators)
                                              *|#This will optimize FUNC() call:
                                              *|#  - faster, because optimizer can replace call stack current frame instead 
                                              *|#    of adding to it
                                              *|#  - allow infinite recursion


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            OBJECTS            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


[new ]Object()                                  #Base TYPE of all OBJ

OBJ.VAR                                         #Access property (can be any type)
OBJ['VAR']                                      #OBJ.VAR has same naming restrictions as var VAR, but not 'VAR'

{ VAR[: VAL] ... }                              #Literal OBJ.
                                                #If could be interpreted as a { ... } structure (e.g. beginning of line), wrap with ()      
                                               |#Def VAL is VAR
                                               |#VAR can be [STR], for dynamic property name
                                               |#If duplicate key, the last one will overwrite the ones before.
{ [*] FUNC() {...} ... }                       |#Same as { FUNC: function [*] FUNC() {...} ... }

ITERATING OVER PROPERTIES ==>                   #                    +-------------------------------+---------------------------+
                                                #                    | Own                           | Own+shared                |
                                                # +------------------+-------------------------------+---------------------------+
                                                # | enum             |Object.keys(OBJ)               | for (var|let 'VAR' in OBJ)|
                                                # +------------------+-------------------------------+---------------------------+
                                                # | [non-]enum       |Object.getOwnPropertyNames(OBJ)| 'VAR' in OBJ              |
                                                # +------------------+-------------------------------+---------------------------+

Object.keys(OBJ)                                #Returns own keys, excluding non-enumerable
Object.getOwnPropertyNames(OBJ)                 #Returns own keys, including enumerable
OBJ.propertyIsEnumerable('VAR')                 #Returns true if OBJ['VAR'] is in Object.keys()
OBJ.hasOwnProperty('VAR')                       #Returns true if OBJ['VAR'] is in Object.getOwnPropertyNames()

'VAR' in OBJ                                    #Returns true if OBJ['VAR'] is member, including shared or non-enumerable.
                                                #Negation: !('VAR' in OBJ)
                                                #Note: for (var|let STR in OBJ) includes shared, but excludes non-enumerable 

Object.assign(OBJ[, OBJ2...])                  +#Shallow copy of own enumerable OBJ2 members to OBJ, which is returned.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:      OBJECT DESCRIPTORS       :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


{ get|set VAR: FUNC() ... }                     #Like { VAR: FUNC() } followed by Object.defineProperty()

Object.defineProperty(OBJ, 'VAR', OBJ2)         #Assign OBJ['VAR'] = VAL, where VAL depends on OBJ2 ('descriptors'):
                                                #  - either:
                                                #     - value VAL (def: undefined)
                                                #     - get()->VAL and set(VAL), fired at OBJ.VAR and OBJ.VAR = VAL
                                                #  - enumerable BOOL (déf: false): if false, not listed by Object.keys(),
                                                #    OBJ.propertyIsEnumerable() and for (var|let STR in OBJ)
                                                #  - configurable BOOL (déf: false): 
                                                #     - if false, cannot call delete OBJ.VAR (do nothing) nor 
                                                #       Object.defineProperty(OBJ, 'VAR', OBJ2) (throws TypeError)
                                                #     - if get|set(), often non-configurable
                                                #  - writable BOOL (déf: false): 
                                                #     - if false, OBJ.VAR = VAL throws TypeError
                                                #     - not possible with get|set()
                                                #When fired several times, each call only overwrite the specified descriptors.
Object.defineProperties(OBJ, OBJ3)              #Same but using OBJ3 { 'VAR': OBJ2 ... } instead.
Object.getOwnPropertyDescriptor(OBJ, 'VAR')     #Returns OBJ.VAR descriptor OBJ2 (even if not declared through
                                                #Object.defineProperty()), if own [non-]enum member.

Object.preventExtensions(OBJ)                   #Make OBJ non-extensible (non-writable for new properties and __proto__, throwing TypeError)
                                                #Not recursive.
Object.isExtensible(OBJ)                        #

Object.seal(OBJ)                                #Make OBJ non-extensible, non-configurable
                                                #Not recursive.
Object.isSealed(OBJ)                            #

Object.freeze(OBJ)                              #Make OBJ non-extensible, non-configurable, non-writable.
                                                #Not recursive.
Object.isFrozen(OBJ)                            #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          INHERITANCE          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


OBJ.__proto__                                   #When OBJ.VAR is not defined:
Object.getPrototypeOf(OBJ)                      #  - tries OBJ.__proto__.VAR
                                                #     - if OBJ.__proto__
                                                #     - then tries OBJ.__proto__.__proto__.VAR, etc. (prototype chain)
                                                #     - Object.prototype.__proto__ === null
                                                #  - by convention, each __proto__ points to a TYPE.prototype 
                                                #    (first TYPE, then TYPE_PARENT, etc.)
                                                #Object.getPrototypeOf() is more standard.
Object.setPrototypeOf(OBJ, VAL)                |#Same as OBJ.__proto__ = VAL (to avoid because performance issues)
Object.create(TYPE.prototype[, OBJ])            #Returns OBJ2 { __proto__: TYPE.prototype }, then calls
                                                #Object.defineProperties(OBJ2, OBJ)
                                                #Can use null as first argument.
FUNC.prototype.constructor                      #Returns FUNC
new TYPE[(...)]                                 #Does:
                                                #  var OBJ = Object.create(TYPE.prototype);
                                                #  var ret = TYPE.call(OBJ, ...);
                                                #  return ret == null ? OBJ : ret;
                                                #Avoid returning in constructor (child constructor would not be able to inherit
                                                #own members)
                                                #By convention TYPE starts with uppercase
                                                #Requires:
                                                #  - TYPE.prototype OBJ: contains shared members
                                                #  - TYPE.prototype.constructor === TYPE: for type information (optional)
new.target                                     -#In TYPE(), === TYPE (i.e. this.constructor). Otherwise undefined.
                                               -#In CHILD_TYPE(), === CHILD_TYPE

INHERITANCE ==>                                 #Prototype-based, using either:
                                                #  - own members:
                                                #     - accessed directly on OBJ: 
                                                #        - TYPE(...) assigning this OBJ (or returning OBJ (to avoid))
                                                #     - inheritance: children constructor fire parent constructor
                                                #     - created each time new TYPE(...) is fired
                                                #        - i.e. one object per instance
                                                #  - shared members:
                                                #     - accessed|inherited through prototype chain
                                                #     - created once declaration-time
                                                #        - i.e. single reference for all instances
                                                #Example:
																								#  function TYPE(...) { 
																								#    TYPE_PARENT.apply(this[, ...])  
																								#    this.VAR = ...; ...
																								#  }
																								#  TYPE.prototype = Object.create
																								#    (TYPE_PARENT.prototype)
																								#  TYPE.prototype.constructor = TYPE               

STATIC MEMBERS ==>                              #Own members of TYPE itself, i.e. TYPE.VAR = VAL:
                                                #  - not inherited (unless using Backbone extend())
                                                #  - must be called on TYPE itself, not an instance

class [TYPE] [extends TYPE_PARENT]             |#Other syntax to define inheritance, defining let TYPE = FUNC:
{                                              |#  - extends TYPE2:
  [constructor(...) { ... }]                   |#      constructor() -> function TYPE():
  [static] FUNC(...) { ... }                   |#       - must call super(...) before assigning to this 
}                                              |#       - by def: constructor() { super(arguments) }
                                               |#      TYPE.prototype = Object.create(TYPE2.prototype)
                                               |#      TYPE.prototype.constructor = TYPE (non-enumerable)
                                               |#      TYPE.__proto__ = TYPE2
                                               |#  (non-static)
                                               |#  - TYPE.prototype.FUNC = FUNC (non-enumerable)
                                               |#  (static)
                                               |#  - TYPE.FUNC = FUNC (non-enumerable)
                                               |#Throw error if not called with new.
                                               |#No comma between definition members.
                                               |#Returns TYPE
super                                          |#Inside class {...}, same as TYPE_PARENT

UTIL.inherits(TYPE, TYPE_PARENT)               ##For Node.js:
                                               ##  TYPE.prototype = Object.create(TYPE_PARENT.prototype);
                                               ##  TYPE.prototype.constructor = TYPE;
                                               ##  TYPE.super_ = TYPE_PARENT;
                                               ##So setup shared members, and allow TYPE constructor to call parent constructor
                                               ##using this.constructor.super_.apply(this, arguments);

MULTIPLE INHERITANCE ==>                        #For:
                                                #  - own members: call several parent constructors in TYPE()
                                                #  - shared members: use mixins, i.e. assign TYPE_PARENT.prototype.* to 
                                                #    TYPE.prototype.* instead of using prototype chain.

USING EXTEND ==>                                #Basic extend() (like jQuery, Underscore, not like Backbone) are sometimes used
                                                #for inheriting shared members. They help for mixins (see above). However:
                                                #  - if does not include shared members (like Lodash), will not inherit grandparents
                                                #    members (unless copied to parent)
                                                #  - TYPE_PARENT.prototype.VAR will be copied, not referenced, if it is native type

NATIVE OBJECTS INHERITANCE ==>                  #Native objects constructors return a value instead of assigning to this.
                                                #So inheriting not possible, but can extend prototype (to avoid though).
                                                #new TYPE() vs TYPE():
                                                #  - Object|Array|Function|RegExp: no difference
                                                #  - String|Boolean|Number: without new, returns native type
                                                #  - Date: without new, returns DATE.toString()
                                                #  - Error: same except stack trace (prefer new Error)
                                                #  - ArrayBuffer: mandatory new
                                              *-#Can however use class ... extends syntax to extend native objects.

TYPE[Symbol.species]()                        *-#To override how TYPE create empty new objects.
                                              *-#Used e.g. by ARR.concat|filter|map|slice|splice() or STR.split(REGEXP)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            SYMBOLS            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


var SYM = Symbol([STR])                        -#Same as OBJ["RANDOM"], semantically for private members:
OBJ[SYM]                                       -#  - STR optional, just used for toString() description
                                               -#    OBJ[Symbol(STR)] !== OBJ[STR]
                                               -#  - not enumerable: 
                                               -#     - getOwnPropertyNames() -> getOwnPropertySymbols()
                                               -#     - Object.keys|getOwnPropertyNames() or '... in OBJ' will not show symbols.
                                               -#  - properties with a key of SYM will be ignored by JSON.stringify()

Symbol.for(STR)                                -#Like Symbol(STR), except register it to a global store using STR as a key,
                                               -#so that Symbol.for(STR) === Symbol.for(STR)
Symbol.keyFor(SYM)                             -#Returns STR if SYM was created as Symbol.for(STR), undefined otherwise.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          STRUCTURES           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


SINGLE LINE ==>                                 #Block braces can be skipped if only on single next line (to avoid)

VAL                                             #Anything that returns a VAL
EXPR                                            #Anything that could go on a single line of code ending with ;
...                                             #Several EXPR


TEST ? VAL1 : VAL2                              #Returns VAL1 or VAL2

VAL && VAL2                                     #Same as !!VAL ? VAL : VAL2, for any type (including BOOL)
VAL || VAL2                                     #Inverse

VAL1, VAL2                                      #Evaluates both, but returns VAL2.
                                                #Use case: in for or while loops.


{ ... }                                         #

(VAL)                                           #To increase precedence.

if ( TEST ) { ... }
[else if ( TEST ) { ... }]... 
[else { ... }]

switch (VAL) {                                  #Use VAL === VAL2
  case VAL2: ...  [break;] ...                  #If no break, execute next case (including "default")
  case VAL3: case VAL4: ...  [break;] ...       #Case can be empty, meaning several "case" match when any matches.
  [default: ...  [break;]]                          
}                                               

for ( [EXPR1] ; [TEST] ; [EXPR2] ) { ... }      #Same as:
                                                #  EXPR1; while ( TEST ) { ...; EXPR2; }
while ( TEST ) { ... }
do { ... } while ( TEST ) 

for ( var|let VAR in OBJ ) { ... }              #Iterate over own+shared enumerable keys.
                                                #OBJ can be ITERATOR.
for ( var|let VAR of ITERABLE ) {...}          |#Iterates with VAR = NEXT

break [LABEL]                                   #Stop current for|while|switch iteration or (only with LABEL) if_else|anonymous block
                                                #Can target a specific for|while|switch iteration by specifying LABEL: before
                                                #it (to avoid), e.g. LABEL: for ... or LABEL: if ...
continue [LABEL]                                #Same but only current loop, and only for|while


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            ERRORS             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


throw VAL                                       #Throw exception VAL, i.e. interrupt each function in the call stack until
                                                #inside try { ... } followed by catch ( VAR ) { ... }
try { ...  }
[catch ( VAR ) { ... }]                         
[finally { ... }]                               #finally { ... } is always fired

[new ]Error([STR])                              #OBJ usually used when throw VAL, because better shown on console
                                                #  - nice ERROR.toString()
                                                #  - when instantiated, include current stack (which will be printed)
                                                #    Stack uses FUNC.name.
                                                #Prefer with "new"
                                                #STR is ERROR.message (def: "Error")
                                                #Some builtin ERROR thrown:
                                                #  - ReferenceError: console.log(notdeclared)
                                                #  - TypeError: null.FUNC()
                                                #  - SyntaxError: 5 *** 7
                                                #  - RangeError: new Array(Infinity)
                                                #  - URIError: decodeURIComponent('%')
                                                #  - EvalError: with eval()
ERROR.name                                      #ERROR type (def: "Error"), redefined by children.
ERROR.message                                   #


debugger                                        #Sets a breakpoint


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            BOOLEAN            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


new Boolean(BOOL)                               #Returns OBJ (see above).
Boolean(BOOL)                                   #Returns BOOL (see above)


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            NUMBER             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


new Number(NUM)                                 #Returns OBJ (see above)
Number(NUM)                                     #Returns NUM (see above)

Number.isInteger(NUM)                          +#Does not coerce to NUM

[Number.]NaN                                    #Returned e.g. by √-1, 0/0 or wrong NUM conversion
                                                #Test:
                                                #  - NaN !== NaN but Object.is(NaN, NaN)
                                               +#  - Number.isNaN(VAL): same as Object.is(VAL, NaN)
                                                #  - isNaN(VAL): same as Number.isNaN(Number(VAL))
[-]Infinity                                     #Returned e.g. by overflow like 1e400, or 1/0
Number.POSITIVE_INFINITY|NEGATIVE_INFINITY      #Test:
                                                #  - [-]Infinity === [-]Infinity
                                               +#  - Number.isFinite(VAL): same as VAL !== Infinity && VAL !== -Infinity
                                                #  - isFinite(VAL): same as Number.isFinite(Number(VAL))
Number.MIN_VALUE                                #Closest to 0 (underflow) (about 5e-324)
Number.MAX_VALUE                                #After it is Infinity (overflow) (about 2e+308)
Number.MIN|MAX_SAFE_INTEGER                    +#Smallest|highest integer that can be represented as a float precisely (about +|-1e16)
                                               +#Test: Number.isSafeInteger(VAL) (does not coerce to NUM)
Number.EPSILON                                 +#NUM +|- NUM2 can create small discrepancies, e.g. 0.3 - 0.1 within a EPSILON range:
                                               +#  - When comparing non-integer NUMs, should check NUM-NUM2 < +|-EPSILON
                                               +#  - about 2e-16


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            STRING             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


new String(STR)                                 #Returns OBJ (see above)
String(STR)                                     #Returns STR (see above)

`...${EXPR}...`                                |#"..." + EXPR + "..."
                                               |#Escape everything in it, including " ' newline
FUNC`...`                                      |#FUNC(STR_ARR, VAL...):
FUNC `...`                                     |#  - VAL... are each ${EXPR}
                                               |#  - STR_ARR[.raw][NUM] are each `...` in-betwen, including empty "" at beginning|end if starts|ends
                                               |#    with ${EXPR}
                                               |#    If "raw", escape backslashes
                                               |#FUNC can be String.raw(), which concanates all like normal template, except it escape backslashes


STR[NUM]                                        #Read-only. undefined if out of range.
STR.charAt(NUM)                                 #Same except "" if out of range

STR.length                                      #

STR.match(REGEXP)                               #Like REGEXP.exec(STR), except that if g flag, returns all matches as ARR (or null)
STR.search(REGEXP)                              #Like STR.indexOf() but with a REGEXP
STR.starts|endsWith|includes(STR2[, NUM])      +#

STR.replace(REGEXP|STR2, STR3)                  #Returns STR, replacing REGEXP with STR3, which can contain:
                                                #  - $1, etc.: parenthesis group matches
                                                #  - $&: full match
                                                #  - $`: what's before full match
                                                #  - $': what's after full match
                                                #  - $$: $ littéral
STR.replace(REGEXP|STR2, 
FUNC($&, $1..., INDEX, STR))                    #Returs STR, replacing REGEXP with FUNC(...)
STR.split(REGEXP|STR2[, UINT])                  #Returns an ARR, with REGEXP|STR2 being split delimiter.
                                                #If STR2 is '', means between each characters.
                                                #If REGEXP contains parenthesis groups, each is included in ARR between each element.
                                                #If UINT, does ARR.slice(0, UINT)
STR.repeat(NUM)                                +#

OBJ[Symbol.match|search|replace|split](...)   *+#Methods to implement to be able to use STR.match|search|replace|split(OBJ). 
                                              *+#Implemented by REGEXP

STR.toUpper|LowerCase()                         #
STR.trim()                                      #Remove whitespaces on left and right.

STR.concat(STR2...)                             #Prefer + and +=

STR.[lastI/i]ndexOf(STR[, NUM])              
STR.slice(NUM[, NUM2])                          #Like ARR
STR.substring(NUM[, NUM2])                      #Like .slice() except:
                                                #  - negative NUM2 are ignored
                                                #  - If NUM2 < NUM, swap
STR.substr(NUM[, NUM2])                         #Like .slice() but extract from STR[NUM] (can be negative) NUM2 chars.

en|decodeURI(STR)                               #Percent encore all non-ASCII chars
                                                #Result often used as URI
                                                #decodeURI() can throw URIError
en|decodeURIComponent(STR)                      #Same but also for ? & = # + $ ; , / : @
                                                #Result often used as URI part (e.g. path, fragment or query variable)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            UNICODE            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


STRING ==>                                      #All STR methods support it for Unicode chars <=FFFF: Unicode chars are single chars.
                                                #For >FFFF, only few methods support it:
                                                #  - CODEPOINT[_HEXA]: supports only <=FFFF
                                                #  - S_CODEPOINT[_HEXA]: no restriction.
\uCODEPOINT_HEXA                                #
\u{S_CODEPOINT_HEXA}                           |#

String.fromCharCode(CODEPOINT...)               #
String.fromCodePoint(S_CODEPOINT...)           |#Returns STR

STR.charCodeAt(NUM)                             #Returns CODEPOINT. If out-of-range, returns ''.
STR.codePointAt(NUM)                           |#Returns S_CODEPOINT. If out-of-range, returns undefined.

STR.normalize([STR2])                          -#Compose|decompose combined Unicode (e.g. with diacretics):
                                               -#  - "NFC|NFD" (def: "NFC"): compose|decompose (canonical)
                                               -#  - "NFKC|NFKD": same for compatibility form

/REGEXP/u                                     *|#Make . match a Unicode char, even >=FFFF, and understands \u{S_CODEPOINT_HEXA}
                                              *|#in REGEXP


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             INTL              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


OBJ.toLocaleString()                            #Same as OBJ.toString(), but can be reimplemented by children (like OBJ.toString())
ARR.toLocaleString()                            #Same as ARR.toString() with locale commas
STR.toLocaleUpper|LowerCase()                   #Current locale

LOCALE ==>                                      |#OBJ > LOCALE > browser locale
                                                |#LOCALE:
                                                |#  - e.g. 'fr-FR'
                                                |#  - can have final -u-ARG-VAL to add options
                                                |#  - can be an ARR
                                                |#  - can be true for current locale
                                                |#OBJ always has members:
                                                |#  - localeMatcher 'best fit' (def) or 'lookup' (poorer algorithm)

STR.localCompare(STR2[, LOCALE[, OBJ]])         |#Like STR < <= >= > STR2, except returns as -1|0|1 and takes locales into account.
                                                |#OBJ:
                                                |#  - usage 'sort' (def) or 'search': use case
                                                |#  - sensitivity 'base|accent|case|variant' (def: 'variant'):
                                                |#     - case-sensitive: 'case|variant'
                                                |#     - accent-sensitive: 'accent|variant'
                                                |#  - ignorePunctuation BOOL (def: false)
                                                |#  - numeric BOOL (def: false): numeric sort
                                                |#  - caseFirst 'upper|lower' or 'false' (def, i.e. LOCALE's): whether
                                                |#    lowerCase|upperCase comes first
                                                |#LOCALE:
                                                |#  - co 'big5han|dict|direct|ducet|gb2312|phonebk|phonetic|pinyin|reformed|searchjl|
                                                |#    stroke|trad|unihan': collation
                                                |#  - kn 'true|false': same as OBJ.numeric
                                                |#  - kf 'upper|lower|false': same as OBJ.caseFirst

NUM.toLocaleString([LOCALE[, OBJ]])             |#Number locale formatting.
                                                |#OBJ:
                                                |#  - style 'decimal|currency|percent' (def: 'decimal')
                                                |#  - currency STR (no def)
                                                |#  - currencyDisplay 'symbol|code|name' (def: 'symbol')
                                                |#  - useGrouping BOOL (def: true): throusands separators
                                                |#  - minimum|maximumInteger|Fraction|SignificantDigits NUM
                                                |#LOCALE:
                                                |#  - nu "arab|arabext|bali|beng|deva|fullwide|gujr|guru|hanidec|khmr|knda|
                                                |#    laoo|latn|limb|mlym|mong|mymr|orya|tamldec|telu|thai|tibt": numbering system

DATE.toLocale[Date|Time]String([LOCALE[, OBJ]]) |#Date|Time|Date+Time locale formatting.
                                                |#OBJ:
                                                |#  - timeZone STR (def: locale's)
                                                |#  - hour12 BOOL (def: locale's)
                                                |#  - formatMatcher 'basic' or 'best fit' (def): like localeMatcher, but for
                                                |#    OBJ.weekday|etc.
                                                |#  - weekday|era 'narrow|short|long' (no def)
                                                |#  - month 'numeric|2-digit|narrow|short|long' (no def)
                                                |#  - year|day|hour|minute|second 'numeric|2-digit' (no def)
                                                |#  - timeZoneName 'short|long' (no def)
                                                |#LOCALE:
                                                |#  - nu: like NUM.toLocaleString()
                                                |#  - ca "buddhist|chinese|coptic|ethioaa|ethiopic|gregory|hebrew|indian|islamic|
                                                |#    islamicc|iso8601|japanese|persian|roc": calendar

[new ]Intl.Collator([LOCALE[, OBJ]])            |#Returns INTL, with methods:
                                                |#  - compare(STR, STR2): same as STR.localCompare(STR2, ...) but faster
                                                |#  - resolvedOptions(): returns OBJ, with also OBJ.locale LOCALE
[new ]Intl.NumberFormat([LOCALE[, OBJ]])        |#Same except with INTL.format(NUM), like NUM.toLocaleString(...)
[new ]Intl.DateTimeFormat([LOCALE[, OBJ]])      |#Same except with INTL.format(NUM), like DATE.toLocaleDateString(...)
                                                |#Using OBJ.year|etc., can mimic DATE.toLocale[Time]String(...) too
Intl.*.supportedLocalesOf([LOCALE[, OBJ]])      |#Returns LOCALE_ARR matching LOCALE + OBJ and being installed on client.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            REGEXP             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


/PATTERN/[FLAGS]                                #Def STR: '(?:)'
[new ]RegExp(['PATTERN'[, 'FLAGS']])            #Backslashes must be escaped in the second form
                                                #Perl RegExp except:
                                                #  - [[:CLASS:]] -> [:CLASS:]
                                                #  - ^ $, no \A \Z: see m flag
                                                #  - no \< \>, +-greediness, additional flags
                                                #Flags:
                                                #  - possible:
                                                #     - i: case insensitive
                                                #     - g: 
                                                #        - use REGEXP.lastIndex:
                                                #           - initially 0, set to last match index (or 0 if no match)
                                                #           - next REGEXP.exec|test() will start from there
                                                #        - function taking REGEXP as argument should iterate using REGEXP.lastIndex
                                                #           - this was do standard JavaScript methods, e.g. STR.match|replace()
                                                #     - m: ^ $ newline-wise (otherwise not)
                                              *-#     - y: same as g, except each search must match from lastIndex
                                              *-#          (cannot skip first chars)
                                                #  - available at REGEXP.ignoreCase|global|multiline|sticky BOOL
REGEXP.source                                   #'PATTERN' (read-only)
REGEXP.flags                                  *|#'FLAGS' (read-only)

REGEXP.exec(STR)                                #Search REGEXP in STR and returns ARR (or null):
                                                #  - ARR[0]: whole match
                                                #  - ARR[n]: parenthesis matches
                                                #  - ARR.index: first match index
                                                #  - ARR.input: STR
REGEXP.test(STR)                                #Returns BOOL


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             ARRAY             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


Array                                           #Are actually OBJ with numeric property names, so can do ARR[NUM]
                                                #Can contain different types.
                                                #Multidimensional ARR: use ARR of ARRs
[new ]Array(NUM)                                #Returns ARR with NUM undefined values.
                                                #Throw RangeError if non-positive or decimal.
[new ]Array(VAL...)                             #Like [ VAL... ]
Array.of(VAL...)                               |#Same as new Array(VAL...) except not interpreted as new Array(NUM) if only VAL
                                               |#is NUM
[ [VAL...] ]                                    #Literal form.
                                               |#VAL can be ...ITERABLE

ARRAYLIKE                                       #Any OBJ which understand OBJ[NUM] and OBJ.length
                                                #Can use all ARR methods, except concat() using:
                                                #  Array.prototype.FUNC.call(ARRAYLIKE, ...) is like ARR.FUNC(...)
                                                #If expected to return ARR, returns ARR not ARRAYLIKE.
Array.from(ARRAYLIKE|ITERABLE[, ...])          |#Returns as ARR
                                               |#If ..., returns ARR.map(...) instead

ARR.length                                      #Can be modified (will truncate or extend with undefined values)
                                                #Max 4 billions (32-bits).

ARR.concat(VAL)                                 #Pushes VAL (does not modify)
                                                #If VAL is ARR2, pushes ARR2 elements, not ARR2 itself, 
                                              *-#unless ARR[Symbol.isConcatSpreadable] false
ARR.slice([NUM[,NUM2]])                         #Returns ARR copy from index NUM (def: 0) to NUM2 (def: ARR.length). 
                                                #NUM2 can be negative, i.e. from ARR end.
ARR.splice(NUM, NUM2[, VAL...])                 #Erase and return NUM2 elements from index NUM, and replace them with VAL...
ARR.fill(VAL[, NUM[, NUM2]])                   |#Same as ARR.splice(NUM, NUM2, VAL...) with VAL being repeated NUM2-NUM times.
ARR.copyWithin(NUM, NUM2[, NUM3])              |#Copies ARR.slice(NUM2, NUM3) to ARR itself, starting at index NUM. Returns ARR.
ARR.join([STR])                                 #Returns as STR2, with STR delimiter (def: ',')

ARR.push|unshift(VAL)                           #Adds VAL to end|beginning (modifies). Returns ARR.length
ARR.pop|shift()                                 #Remove and returns last|first element (modifies).

ARR.reverse()                                   #Modifies and returns ARR.
ARR.sort([FUNC(VAL, VAL2)->-1|0|1])             #Modifies and returns ARR.
                                                #Default FUNC does STR comparison.
                                                
ARR.indexOf(VAL[, NUM])                         #Returns VAL index, or -1. Uses ===
                                                #If NUM, skip first NUM elements (but still returns index from beginning)
ARR.lastIndexOf(VAL[, NUM])                     #Same but from end.
AR.find[Index](FUNC(VAL,KEY,ARR)->BOOL[,THIS]) |#Returns first VAL|KEY that returns true. Otherwise does not return.

ARR.forEach(FUNC(VAL, KEY, ARR)[, THIS])        #
ARR.map(FUNC(VAL, KEY, ARR)->VAL[, THIS])       #Returns [VAL...]

ARR.reduce[Right]                               #MEMO is:
(FUNC(MEMO, VAL, KEY, ARR)[, MEMO])             #  - first: argument passed (def: 0)
                                                #  - then: previous FUNC() return value
                                                #  - final return value
                                                #reduceRight iterates from end to beginning
ARR.filter(FUNC(VAL, KEY, ARR)->BOOL[, THIS])   #Excludes if false
ARR.every|some(FUNC(VAL, KEY, ARR)->BOOL[,THIS])#Returns true if all|any true.

ARR.keys|values|entries(...)                   |#Returns all KEY|VAL|[KEY, VAL] as ITERABLETOR



                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:         TYPED ARRAYS          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


new ArrayBuffer(UINT)                           #Raw data chunk. UINT is byteLength.
                                                #Needs a DATAVIEW|TYPED_ARR to be manipulated, which gives:
                                                #  - a specific type to read it
                                                #  - an offset from the beginning of it
                                                #Available:
                                                #  - DATAVIEW: can change type
                                                #  - TYPED_ARR: more convenient because manipulated as an ARR
                                                #Several DATAVIEW|TYPED_ARR can be applied to a single ARRBUFFER.
ArrayBuffer.isView(OBJ)                         #True if DATAVIEW|TYPED_ARR
ARRBUFFER.byteLength                            #Readonly.
ARRBUFFER.slice(...)                            #Like ARR.slice(...)


new DataView(ARRBUFFER[, UINT[, UINT2]])        #UINT is offset (def: 0), UINT2 length (def: ARRBUFFER.byteLength)
DATAVIEW.buffer|byteLength|byteOffset           #Readonly

DATAVIEW.get[Ui|I]nt8|16|32([UINT[, BOOL]])     
DATAVIEW.getFloat32|64(UINT[, BOOL])            #UINT is byte offset, BOOL endianness (def: true, i.e. little endian)
DATAVIEW.set*(UINT, UINT2[, BOOL])              #UINT2 is the value to set


TypedArray                                      #Base prototype of [Ui|I]nt8|16|32Array or Float32|64Array (each having a
                                                #given associated type), not accessible globally but through prototype chain.
                                               -#Mixes in all ARR methods, including static ones.
                                               -#There is also a special Uint8ClampedArray, which do not 'roll' too low|high
                                               -#values, e.g.:
                                               -#  - UINT8_ARR[0] = -10 (246) vs UINT8_CLAMPED_ARR[0] = -1 (0)
                                               -#  - UINT8_ARR[0] = 260 (4) vs UINT8_CLAMPED_ARR[0] = 260 (255)
new TypedArray(ARRBUFFER[, UINT[, UINT2]])      #Same args as DataView
new TypedArray(NUM)                             #Same as new TypedArray(new ArrayBuffer(NUM))
new TypedArray(TYPED_ARR2)                      #Copy (no reference between each other)
new TypedArray(ARRAYLIKE|ITERABLE)              #Uses TYPED_ARR.from(...)

TypedArray|TYPED_ARR.BYTES_PER_ELEMENT          #
TYPED_ARR.buffer|byteLength|byteOffset          #Readonly
TYPED_ARR.length                                #

TYPED_ARR.subarray(...)                         #Like slice(...) except it shares same ARRBUFFER
TYPED_ARR.set(ARR|TYPED_ARR2[, UINT])           #Sets all ARR|TYPED_ARR2 values into TYPED_ARR, starting at index UINT (def: 0).
                                                #If ARR|TYPED_ARR2 too big, RangeError thrown
TYPED_ARR.toString()                            #Is like OBJ, not ARR, but with right Symbol.toStringTag


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           ITERATORS           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


ITERATOR                                       +#OBJ with OBJ.next()->{ done BOOL, value NEXT }
                                               +#Consumers usually call var NEXT = next() until BOOL true.
ITERABLE                                       +#OBJ where OBJ[Symbol.iterator]()->ITERATOR
                                               +#STR|[TYPED_]ARR|MAP|SET are ITERABLE.
ITERABLETOR                                    +#ITERABLE which is also an ITERATOR.

function* [FUNC](){...}                        +#Generator. 
                                               +#Returns a FUNC()->ITERABLETOR with members:
                                               +#  - next([VAL]):
                                               +#     - stops at the next "yield NEXT", returning VAL, making next() return {done false, value NEXT}
                                               +#     - then stops at "return FINAL_NEXT" making next() return {done true, value FINAL_NEXT}
                                               +#     - then always return {done true}
                                               +#  - return(FINAL_NEXT)->{ done true, value FINAL_NEXT }: stops iteration
                                               +#  - throw(ERROR): should throw from the context of the last yield
                                               +#Can also use yield* ITERABLE:
                                               +#  - yield NEXT several times
                                               +#  - returns FINAL_NEXT
new GeneratorFunction(...)                     +#Like new Function(...) but for function*(){}
                                               +#GeneratorFunction not available globally, but with:
                                               +#  Object.getPrototypeOf(function*(){}).constructor


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          MAPS & SETS          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


new Map([ITERABLE])                            +#ITERABLE must iterate over [KEY, VAL] elements.
                                               +#Is an ITERABLE itself, iterating over [KEY, VAL] in insertion order.
                                               +#To use instead of OBJ, when:
                                               +#  - KEY must be other than STR
                                               +#  - conceptually more like a 'store' of values

MAP.get(KEY)->VAL                              +#Like OBJ[KEY] and OBJ[KEY] = VAL, except KEY can be any type.
MAP.set(KEY, VAL)->MAP                         +#KEY equality uses Object.is() not ===
MAP.has(KEY)->BOOL                             +#
MAP.delete(KEY)->BOOL                          +#
MAP.clear()                                    +#

MAP.size                                       +#

MAP.keys|values|entries|forEach(...)           +#Like ARR


WeakMap                                        +#Like Map, except WEAKMAP does not own its children:
                                               +#  - VAL will be garbage collected when its KEY is, whether WEAKMAP is still
                                               +#    around or not
                                               +#  - will MAP.set(KEY, VAL) is conceptually like MAP.KEY = VAL, 
                                               +#    WEAKMAP.set(KEY, VAL) is like KEY.__value = VAL
                                               +#  - as such, cannot use clear|size|keys|values|entries|forEach()
                                               +#    and is not ITERABLE
                                               +#To use when passive relation to children (proxying, listening, etc.) not
                                               +#ownership (children existing mainly as MAP properties).

Set                                            +#Like a Map where KEY === VAL (i.e. keep unique values):
                                               +#  - ITERABLE iterates over VAL elements, not [KEY, VAL]
                                               +#  - entries() iterates over [VAL, VAL], keys|values() are same
                                               +#  - no SET.get()
                                               +#  - SET.set() -> SET.add(VAL) 

WeakSet                                        +#Like WeakMap, but for Set.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             DATE              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


Date                                            #Milliseconds-precise. Is internally:
                                                #  - only an Epoch NUM.
                                                #  - NaN for InvalidDate
                                                #UTC vs local:
                                                #  - input: 
                                                #     - local: new Date(...)
                                                #     - does not matter: new Date()
                                                #     - UTC: new Date(Date.UTC(...))
                                                #  - output: 
                                                #     - local: get|set*()
                                                #     - UTC: get|setUTC*(), getTime()
new Date([YEAR,MONTH,DAY,HOUR,MIN,SEC,MILLISEC])#Each final arguments are optional. Def: now.
new Date(STR)                                   #InvalidDate if cannot parse.
Date()                                          #Same as (new Date()).toString()

DATE.*et[UTC][Time/FullYear/Month/Date/Day/     #Date is month day, Day week day (0 for Sunday)
Hours/Minutes/Seconds/Milliseconds/             #Time is Epoch in seconds
TimezoneOffset]()                               #TimezoneOffset is in minutes
                                                #set* returns DATE.getTime()

Date.now()                                      #Like new DATE().getTime()
Date.parse(STR)                                 #Like new DATE(STR).getTime()
Date.UTC(...)                                   #Like new DATE(...).getTime() but new Date(...) uses UTC


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             MATH              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


Math.min|max(NUM...)                            #NaN if one NUM not a number. [-]Infinity if no arguments.

Math.abs(NUM)                                   #
Math.sign(NUM)                                 +#Returns -|+ 0|1 or NaN

Math.ceil|floor|round(NUM)                      #Upper|lowest|nearest round
Math.trunc(NUM)                                +#Closest to 0 round
Math.fround(NUM)                               +#Converts to single-precision float

Math.PI                                         #
Math.E                                          #
Math.LN2                                        #ln(2)
Math.LN10                                       #ln(10)
Math.LOG2E                                      #log2(e)
Math.LOG10E                                     #log10(e)
Math.SQRT2                                      #
Math.SQRT1_2                                    #

Math.pow(NUM1, NUM2)                            #
Math.sqrt(NUM)                                  #NaN if negative
Math.cbrt(NUM)                                 +#
Math.exp(NUM)                                   #
Math.expm1(NUM)                                +#Same as Math.exp(NUM)-1
Math.log(NUM)                                   #Base e. NaN if negative
Math.log2|10(NUM)                              +#Base 2|10
Math.log1p(NUM)                                +#Same as Math.log(NUM+1)

Math.imul(NUM, NUM2)                           +#Like NUM*NUM2, except only for 32-bits signed integers, where the sign is the
                                               +#first bit, e.g. 4e9 is negative.
                                               +#Used to emulate x86 ASM imul.
Math.clz32(NUM)                                +#Number of leading zeros in a 32-bits signed binary format.

Math.[a]sin|cos|tan[2](NUM)                     #In radian
Math.[a]sin|cos|tan[2]h(NUM)                   +#Hyperbolic version
Math.hypot(NUM...)                             +#sqrt(NUM**2 + NUM2**2 ...)

Math.random()                                   #Float in [0,1). Seeded from current time.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             JSON              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


JSON ==>                                        #Serialize objects. 
                                                #Extension is '.json'
                                                #Subset of literal OBJ:
                                                #  - VAR: VAL -> "VAR": VAL
                                                #  - only STR|NUM|BOOL|undefined|OBJ|ARR:
                                                #     - no undefined, FUNC or native objects (besides OBJ|ARR).
                                                #     - Can however support others:
                                                #        - if toJSON() defined:
                                                #           - DATE.toJSON()->DATE.toISOString()
                                                #        - by calling toString() prior.
                                                #        - via JSON.stringify|parse FUNC
                                                #  - no ES6 syntax like { [STR]: VAL }, { VAR }, etc.
                                                #  - no leading zeros on NUM
                                                #  - seuls échappement backslash : \", \\, \b, \f, \n, \r, \t, \uXXXX
                                                #Can also be a VAL by itself (i.e. STR|NUM|BOOL|undefined|OBJ|ARR)
JSON.parse('JSON'[, FUNC(KEY, VAL)[->VAL]])     #From 'JSON' to JavaScript.
                                                #FUNC():
                                                #  - postprocessing
                                                #  - from children to parent
                                                #     - ends with root object: key '', this {'': OBJ}
                                                #  - this is current [sub-]object
                                                #  - skips property if undefined
                                                #Can throw SyntaxError.
JSON.stringify(VAL[, VAL2[, STR|NUM]])          #From JavaScript to 'JSON'
                                                #Non-supported vals are omitted.
                                                #If VAL.toJSON() exist, will use VAL.toJSON() instead of VAL.
                                                #VAL2 can be:
                                                #  - FUNC(KEY, VAL)[->STR]: same as JSON.parse() but:
                                                #      - preprocessing
                                                #      - goes from parent to children
                                                #  - KEY_ARR: only includes those properties.
                                                #    To e.g. include subproperties 'a.b', must specify [ 'a', 'b' ]
                                                #STR|NUM adds newlines and indents with STR or NUM spaces.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            PROMISE            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


new Promise(FUNC(RESOLVE(VAL), REJECT(ERROR))) +#Returns PROMISE
                                               +#All PROMISE methods return PROMISE
PROMISABLE                                     +#Any OBJ with OBJ.then(FUNC, FUNC2)

Promise.resolve(VAL|PROMISABLE)                +#
Promise.reject(ERROR)                          +#Returns PROMISE

PROMISE.then(FUNC(VAL), FUNC(ERROR))           +#
PROMISE.catch(FUNC(ERROR))                     +#Same as PROMISE.then(undefined, FUNC(ERROR))

Promise.all(PROMISE2_ITERABLE)                 +#Returns union where:
                                               +#  - first PROMISE2 rejected -> PROMISE rejected
                                               +#  - all PROMISE2 resolved -> PROMISE resolved
Promise.race(PROMISE2_ITERABLE)                +#Returns union where:
                                               +#  - first PROMISE2 rejected|resolved -> PROMISE rejected|resolved


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             PROXY             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


new Proxy(OBJ, OBJ2)                          *-#Returns PROXY:
                                              *-#  - live deep mirror of OBJ: OBJ and PROXY are always deep equal
                                              *-#  - can override some basic object operations with OBJ2:
                                              *-#     - providing they are performed on PROXY (not on OBJ)
                                              *-#     - they usually have same arguments, plus a first argument being PROXY
                                              *-#     - can call themselves without creating infinite recursion,
                                              *-#        - but set|get() OBJ3 can't, i.e. OBJ3.VAR = VAL as opposed to
                                              *-#          PROXY.VAR = VAL
                                              *-#     - there are some special rules ('invariants') to handle 
                                              *-#       non-extensible|configurable|writable properties (see online doc)
                                              *-#       Should not worry unless writing a library.
                                              *-#OBJ2 members follow.
Proxy.revoke(OBJ, OBJ2)                       *-#Like new Proxy(OBJ, OBJ2) but returns OBJ3:
                                              *-#  - proxy PROXY
                                              *-#  - revoke(): make accessing OBJ3.proxy throw a TypeError

OBJ2.set(PROXY, 'VAR', VAL, OBJ3)             *-#PROXY.VAR = VAL
                                              *-#  - OBJ3 === PROXY, unless PROXY is in prototype chain, in which case OBJ3
                                              *-#    is the target child
                                              *-#  - must return BOOL. If false, will throw TypeError.
OBJ2.get(PROXY, 'VAR', OBJ3)                  *-#PROXY.VAR
                                              *-#  - OBJ3: see set(...)
OBJ2.delete(PROXY, 'VAR')                     *-#delete PROXY.VAR

OBJ2.has(PROXY, 'VAR')                        *-#'VAR' in PROXY
OBJ2.enumerate(PROXY)->ITERATOR               *-#for VAR in PROXY
OBJ2.ownKeys(PROXY)->STR_ARR                  *-#Object.getOwnPropertyNames(PROXY)
                                              *-#  - must at least contain same keys as original call

OBJ2.defineProperty(PROXY, 'VAR', OBJ3)       *-#Object.defineProperty(PROXY, 'VAR', OBJ3)
                                              *-#  - must return BOOL. If false, will throw TypeError.
OBJ2.getOwnPropertyDescriptor(PROXY, 'VAR')
  [->OBJ]                                     *-#Object.getOwnPropertyDescriptor(PROXY, 'VAR')
OBJ2.isExtensible(PROXY)->BOOL                *-#Object.isExtensible(PROXY)
                                              *-#  - must return same value
OBJ2.preventExtensions(PROXY)->BOOL           *-#Object.preventExtensions(PROXY)
                                              *-#  - must return Object.isExtensible(PROXY)

OBJ2.getPrototypeOf(PROXY)->OBJ|null          *-#PROXY.__proto__ or Object.getPrototypeOf(PROXY)
                                              *-#  - internally used by isPrototypeOf() and instanceof
OBJ2.setPrototypeOf(PROXY, OBJ3)              *-#PROXY.__proto__ = OBJ3 or Object.setPrototypeOf(PROXY, OBJ3)

OBJ2.apply(PROXY, THIS, ARGS_ARR)             *-#PROXY(ARGS...)
OBJ2.construct(PROXY, ARGS_ARR)->OBJ          *-#new PROXY(ARGS...)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            REFLECT            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Reflect.*(OBJ, ...)                           *+#Does same thing as what Proxy OBJ2.*(PROXY, ...) proxies.
                                              *+#E.g. Reflect.set(OBJ, 'VAR', VAL, OBJ3) will:
                                              *+#  - OBJ.VAR = VAL
                                              *+#  - must return BOOL


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            MODULES            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


export var|let|const VAR = VAL                *|#
export function VAR(...){...}                 *|#
export { VAR[ as VAR2] }                      *|#With VAR name
export default VAL                            *|#Without VAR name
export ... from "MDL"                         *|#Same as import ... from "MDL", then multiple export

import {VAR[ as VAR2],...} from "MDL"         *|#
import * as VAR2 from "MDL"                   *|#With VAR name
import VAR from "MDL"                          
import "MDL" as VAR                           *|#Without VAR name. Can be combined, e.g. import VAR, {...} from "MDL"
import "MDL"                                  *|#Do not import the variable, just execute the file
