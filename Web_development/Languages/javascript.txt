
                
   JAVASCRIPT   
                


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            GENERAL            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/

MAIN PRINCIPLES ==>                             #Case-sensitive. Whitespaces are ignored.
                                                #Weakly typed. No need to type TYPE VAL, just VAL.
                                                #Dynamic-typed. 
                                                #Generic et late-binding / duck-typing :
                                                #  - VAR.FUNC essaye d'exécuter la FUNC de VAR, quel que soit le type de VAR.
                                                #    Donc on peut ignorer type de VAR et juste exiger que le concept FUNC
                                                #    existe pour VAR.
                                                #Lexical-scope (fonction-scope).
                                                #Functional (first-class functions)
                                                #Object-oriented (prototype-based)
                                                #Imperative (structures close to C)
                                                #Does not have any I/O -> need a host environnement (generally browser) to
                                                #"do things".
                                                #Memory management: garbage collection.

EXECUTION ==>                                   #Each browser has own javascript engine, which was in the past interpreted,
                                                #but now is byte-compiled or compiled :
                                                #  - Chakra (IE9+)
                                                #  - SpiderMonkey (Firefox)
                                                #  - V8 (Chrome, Opera 12.15+)
                                                #  - SquirrelFish (Safari)
                                                #IE call it JScript, but it's just for trademark issues.

STANDARD ==>                                    #Latest release was 1.8.5, 2011, implemented by browsers I chose.
                                                #Standard is called ECMAScript. JavaScript and Actionscript are dialects.
                                                #Based on ECMAScript 5 (6 is work in progress)

                                                #CSS and JavaScript link to external file works as #include
                                                #La priorité est donnée de haut en bas. 
                                                #En général <link> sont mis avant inline CSS/JavaScript in <head>.
                                                #En conséquence priorité est :
                                                #  - link < head-inline < tag-inline
                                                #Préférer include from external file. Everything except in tag attributes 
                                                #should be in <head>

<script src="script.js">
</script>                                       #From external file.

<script>
  alert('oh');
</script>                                       #Inline. If in <body>, execute while loading. If declaration, usually in <head>

<a href="javascript:CODE"></a>                  #In tags. Can be a function() if defined. 
                                                #Also all attributes on* ("javascript:" can be skipped then)

<noscript>
  Activez JavaScript pour voir contenu
</noscript>

STATEMENT;                                      #; optional, but recommended to avoid confusion by interpreter in some cases
"STR\                                           #Trailing backslash works only within a STR
  STR2";                                        #For statement, nothing is required as long as the broken statement can't be
                                                #interpreted as a standalone statement.
// COMMENT
/* COMMENT */

PREPROCESSOR ==>                                #There is none in JavaScript (pas d'#include, ni de #define)

"use strict";                                   #Start strict mode, meaning strict Ecmascript 5 conformance:
                                                #  - cannot use VAR = VAL in declaration instead of var VAR = VAL
                                                #  - cannot use with (VAR)
                                                #  - eval("VAR = VAL") does not declare anything
                                                #  - arguments readonly
                                                #  - this:
                                                #     - does not have to be a OBJ
                                                #     - if null|undefined, does not become global object (stays null|undefined)
                                                #  - reserved words implements, interface, let, package, private, protected,
                                                #    public, static, yield
                                                #  - local function(){  } declaration
                                                #Must in top scope of a function|script, before any statement.
                                                #Concatenating with other scripts make them strict too.
                                                #Allows faster optimization by browsers.
                                                #Not compatible until IE10.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          BASIC TYPES          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


TYPE SYSTEM ==>                                 #Il y a deux catégories de types :
                                                #  - simple (number, boolean, string, undefined, null)
                                                #  - objets, tous descendants de Object :
                                                #    - objets natifs (Object, Array, String, Number, Error, etc.)
                                                #    - user-defined objects :
                                                #      - host objects sont ceux définis par browser (notamment DOM elements)
                                                #Ne pas confondre Number et number, Boolean et boolean, String et string.
                                                #Les premiers sont des objets.
                                                #Simple types can't have methods/attributes. However, they transtype 
                                                #automatically pour pouvoir utiliser les méthodes, et inversement :
                                                #  - STR <-> STRING
                                                #  - NUM <-> NUMBER
                                                #  - BOOL <-> BOOLEAN
                                                #Cela comprend les LIT, e.g. "STR".length, true.constructor, (NUM).constructor
                                                #TYPE désigne seulement un object type.

typeof VAR                                      #Renvoie type fondamental, parmi "string", "number", "boolean", "undefined",
                                                #"function", "object" (comprend ARRAY, NULL, STRING, tout autre OBJET)
VAR.constructor                                 #Renvoie le TYPE utilisé lors de la création de VAR. 
                                                #Sert en général à tester le TYPE d'un object type (préférer instanceof)
                                                #NUM sera transtypé vers NUMBER, etc., mais null et undefined provoqueront 
                                                #error.
                                                #Peut être modifié, mais ne change pas comportement ni état de VAR.
VAR instanceof TYPE                             #Renvoie true si VAR est instance de TYPE (ou TYPE_ENFANT). 
                                                #Donc si VAR.__proto__ = TYPE.prototype (ou TYPE_ENFANT.prototype)
OBJECT.prototype.isPrototypeOf(OBJ2)            #Renvoie true si OBJ2 a OBJECT.prototype dans sa prototype chain.

CHECK TYPE PREFERRED WAY ==>                    #string,number,boolean,object: typeof VAR === "..."
                                                #null: VAR === null
                                                #null,undefined: VAR == null
                                                #undefined: (global VAR) typeof VAR === "undefined" ; 
                                                #           (local VAR) VAR === undefined
                                                #Array: Array.isArray(VAR)
                                                #Node: VAR.nodeType === 1

TOUT TYPE ==>                                   #Opérateurs :
                                                #  == != < <= > >=   (Pour OBJECT, seuls == et != existent, et testent non
                                                #                     l'égalité des membres, mais le fait qu'il s'agisse de
                                                #                     référence au même objet)
                                                #  === !==  (Egal, et même type (ou inégal OU différent type))

SIMPLE NATIVE TYPES ==>                         #
NUM                                             #Are all double-float.
                                                #Decimal, scientific ou hexa (non octal).
                                                #Can be (also keywords) :
                                                #  - NaN (keyword). Renvoyé par ex. par √-1. NaN != NaN.
                                                #    - test avec isNaN(VAL)
                                                #  - Infinity or -Infinity.
                                                #    - test avec isFinite(VAL)
                                                #Opérateurs :
                                                #  + - * / %
                                                #  -NUM
                                                #  NUM++ --NUM etc.
                                                #  ~ & ^ | >> << (bitwise)
                                                #  >>>  (Comme >>, mais shift des zeros sur la gauche)
                                                #  OP=  (e.g. NUM += 2 ou NUM %=10)

BOOL                                            #true/false. 
                                                #Transtype to 1/0 (NUM)
                                                #Opérateurs :
                                                #  ! && ||

STR                                             #"STR" or 'STR' (same, except for " or ' escaping)
                                                #Tout échappement backslash, except \a, \c et \e
                                                #Can use Unicode characters or \uXXXX. However, some FUNC can't handle
                                                #them, but generally have a version FUNC"URI" which handle them.
                                                #"" transtype to false (BOOL) and 0 (NUM)
                                                #Autres STR transtype to true (BOOL) and NaN (NUM)
                                                #Opérateurs :
                                                #  STR + STR2 (Concaténation)
                                                #  STR += STR2

undefined                                       #Valeur par défaut d'une declared but non-defined VAR. Can be used as keyword. 
                                                #Can be tested. 
                                                #Coerced to false (BOOL) et NaN (NUM).
null                                            #NULL. Can be used as keyword. Can be tested.
                                                #Coerced to false (BOOL) et 0 (NUM).
                                                #null == undefined, mais null !== undefined

TRANSTYPAGE ==>                                 #Implicite transtypage :
                                                #OBJECT -> NUM utilise OBJECT.valueOf()
                                                #OBJECT -> STR utilise OBJECT.toString()

                                                #Explicite transtypage :
parseInt(STR, NUM)                              #STR to NUM. NUM est le radix (def: 8|10|16 accordint to STR start)
parseFloat(STR, NUM)                            #Si conversion impossible, renvoie NaN.
                                                #Pour transtypage vers STR, utiliser OBJECT.toString()
                                                #As opposed to Number(NUM), is more lenient (can remove non-NUM suffix).
$.isNumeric(VAL)                               ##True if NUM or if STR convertible in NUM, but false if NaN or Infinity.
                                               ##(jQuery)
!!VAL                                           #Transtypage vers BOOL.

var VAR[ = VAL]                                 #Déclaration. Default value is undefined.
  [, VAR2[ = VAL2]]...                          #Préférer déclarer au debut de la fonction.
                                                #Weakly typed et dynamic typed. Function scope.
                                                #Var names doivent être [[:alnum:]$_]. Can't begin with number.
                                                #Can include Unicode chars.
                                                #Trying to dereference une undeclared VAR throw une ReferenceError exception.
VAR = VAL;                                      #Assignation. Returns VAL, so chain possible: VAR = VAR2 = VAL

SCOPE ==>                                       #Lexical scope : block (function avec var, any structure avec let) a accès
                                                #environnements parents, mais environnements parents n'ont pas accès à lui.
                                                #Variables globales : 
                                                #  - VAR déclarée sans "var"
                                                #  - VAR déclarée hors d'un block.
                                                #  - utilisant object global, e.g. window.VAR
                                                #Global object has all global variables (e.g. window)

VARIABLE HOISTING ==>                           #When using variable (sauf functions) before being declared, it will be 
                                                #implicitely declared in global scope. 
                                                #That's VAR = VAL (without var) inside functions declare global functions
                                                #(but should be avoided).

delete VAR                                      #Supprime une VAR, y compris propriété d'OBJET ou élément d'ARRAY, si
                                                #configurable.
                                                #Contrairement à assigner undefined, qui conserve l'index de l'élément (ARRAY)/
                                                #name de la propriété (OBJET), l'élément disparaît complètement.
                                                #Cependant, ne change pas length d'une ARRAY (y compris dernier élément)
                                                #Renvoie false si échec (non-strict mode) ou throw (strict mode)


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           FUNCTIONS           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


Function                                        #Fonctions are objects
Function([ARG...,]STR)                          #Returns function anonymous(ARGS...) { ... } where ... is STR.
                                                #Préférer utiliser keyword function because of injection risk
function [FUNC]([ARG]...)                       #Peut être utilisé comme VAL (functor), y compris returned ou assigné à une VAR
{                                               #Assigner à la déclaration est en général inutile, car FUNC peut déjà servir
  [return VAL;]                                 #lui-même de fonctor.
}                                               #Difference between 1) FUNC = function(){} and 2) function FUNC(){}:
                                                #  - 1) is defined at runtime, 2) at parsetime:
                                                #     - 2) can be used even if declared later
                                                #     - 1) can be declared in a conditional block
                                                #  - 1) and 2) are scoped the same way
                                                #  - 2) defines FUNC.name, used in debugging
                                                #  - can combine FUNC = function FUNC2(){}, where FUNC and FUNC2 are 1), with
                                                #    FUNC[2].name "FUNC2"

ARGUMENTS ==>                                   #arguments est une VAR contenant les arguments, y compris variadic arguments.
                                                #Elle peut être indexée comme une ARRAY et possède arguments.length
                                                #Objects are passed by reference, native types by value.
                                                #Named arguments can be emulated by passing an OBJ.

SCOPE ==>                                       #Functions can be locale. They follow lexical scope rules.

CLOSURES ==>                                    #Lorsqu'une FUNC1 renvoie une FUNC2 (factory functions), FUNC2 has access to
                                                #variables available during return statement.
                                                #If factory function supposed to be invoqued only once, and we just care about
                                                #return value -> use an anonymous function.
                                                #Goal is encapsulation : VAR définie dans FUNC1 accessible seulement via FUNC2.
                                                #Utiliser factory methods que si fonctions créées diffèrent (si toujours même,
                                                #préférer définition simple, plus performant)

(function ([ARG...]) {...}())                   #Anonymous function
                                                #Agit comme une fonction locale, donc suit lexical scope.
FUNC([VAL]...)                                  #Exécute fonction et renvoie return value
                                                #Invoquer avec plus d'arguments que la déclaration n'est pas une erreur : il 
                                                #sont dropped (sauf si utilisés comme variadic args)
FUNC                                            #Renvoie FUNC comme un functor

FUNCTION.length                                 #Nombre d'args

FUNCTION.call(VAL[,ARG...])                     #Invoque FUNCTION([ARG...]), mais avec this set to VAL.
                                                #If VAL is null|undefined, use current this.
                                                #Goal is to fire OBJ.FUNC(), but for OBJ2 like it had OBJ2.FUNC()
FUNCTION.apply(VAL[,ARRAY])                     #Pareil, mais utilise un ARRAY d'arguments.
                                                #Useful when:
                                                #  - having all arguments of a function in a single ARR
                                                #  - passing current arguments to another function: FUNC.apply(null,arguments)
FUNCTION.bind(VAL[, ARG...])                    #Renvoie FUNC2 identique à FUNCTION, sauf que this est toujours VAL et
                                                #premiers arguments sont toujours ARG...

void(STATEMENT)                                 #Exécute STATEMENT sans renvoyer de value.
eval(STR)                                       #Exécute STR. Permet run-time evaluation. Try to avoid it.
                                                #If VAL non STR, renvoie VAL.
                                                #eval cannot be assigned to a functor : FUNC = eval;
                                                #Can throw SyntaxError ou EvalError.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            OBJECTS            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


Object                                          #Base type de tous les objects
$.isPlainObject(VAL)                           ##True if OBJECT (not derived) (jQuery)
$.isEmptyObject(VAL)                           ##True si OBJECT (not derived), and equal to {} (jQuery)

OBJ = OBJ2                                      #Objets sont toujours passés par référence, y compris comme arg de fonction.
                                                #OBJ2 n'est pas assigné à la précédente référence d'OBJ:
                                                #  OBJ = OBJ3; OBJ = OBJ2                   // OBJ3 stays the same
                                                #Which means assigning to an OBJ_ARG removes the precedent reference:
                                                #  (function(OBJ2){ OBJ2 = OBJ3 })(OBJ)     //OBJ stays the same
                                                #  (function(OBJ2){ OBJ2.VAR = VAL })(OBJ)  //OBJ.VAR = VAL
                                                #One way to avoid it when OBJ is a OBJ4.OBJ is using OBJ_STR instead:
                                                #  (function(OBJ2_STR){ OBJ4[OBJ2_STR] = OBJ3 })(OBJ2_STR)

OBJECT.to[Locale]String()                       #Renvoie OBJECT sous forme de STRING :
                                                #  - pour une FUNCTION, renvoie sa déclaration
                                                #toLocaleString prend en compte locale.

Object.keys(VAL)                                #Renvoie membres enumerables et non-hérités de VAL sous forme d'ARRAY_STR. 
                                                #Utiliser for in pour members enumerables et hérités included
Object.getOwnPropertyNames(VAL)                 #Pareil, mais même non enumerable
OBJECT.hasOwnProperty(STR)                      #Renvoie true si property OBJECT.STR est un membre, et non-hérité.
OBJECT.propertyIsEnumerable(STR)                #Renvoie true si property OBJECT.STR est enumerable, et non-hérité, et
                                                #(semble-t-il) dynamique.
NUM in ARRAY                                    #Renvoie true si l'index (ARRAY) ou la propriété (OBJET) STR existe (et non
STR in OBJET                                    #la valeur de cet index ou propriété), y compris hérités et non-enumerables
                                                #Si index/propriété deleted, renvoie false (par opposition à assigner
                                                #undefined au lieu de delete)
                                                #Mettre parenthèses pour ! ( STR in OBJET )

Object.preventExtensions(OBJ)                   #Fait qu'OBJ est non-extensible (impossible de rajouter new properties)
                                                #N'est pas récursif (OBJ, pas membres d'OBJ, ni membres hérités)
Object.isExtensible(OBJ)                        #
Object.seal(OBJ)                                #Fait qu'OBJ devient non-configurable et non-extensible.
                                                #N'est pas récursif (OBJ, pas membres d'OBJ)
Object.isSealed(OBJ)                            #
Object.freeze(OBJ)                              #Fait qu'OBJ devient non-writable, non-configurable et non-extensible.
                                                #N'est pas récursif (OBJ, pas membres d'OBJ)
Object.isFrozen(OBJ)                            #

VAR1.VAR                                        #Accède propriété (méthode ou attribut)
VAR1[STR]                                       #Objects are actually associative arrays of properties, VAR1.VAR can be written
VAR1[UINT]                                      #like that too. Using STR permet :
                                                #  - d'utiliser une variable comme member name (et donc avoir runtime variable
                                                #    name)
                                                #  - d'utiliser non [[:alnum:]$_] names, dont Unicode ou numbers seuls.
                                                #Les membres créés via un index UINT ne peuvent pas être accédés via un name et
                                                #vice-versa (except some DOM objects)
VAR1.VAR2 = VAL;                                #Rajoute une propriété à VAR1 si n'existe pas : si VAL est fonctor, méthode, 
                                                #sinon attribut.
{ [VAR: VAL]... }                               #Objet litéral. EN général assigné à une VAR (mais pas forcément), auquel
                                                #cas ici on aurait VAR2.VAR, valant VAL.
                                                #VAL peut être une FUNC pour avoir une méthode.
                                                #Si peut être interprété comme un block vide (par ex. dès le début d'un block
                                                #{ }), l'entourer de parenthèses.
                                                #Au lieu de VAR:VAL, get VAR() { ... } et set VAR(VAL) { ... } sont possibles.
                                                #Ils agissent comme les descriptors get/set.

this                                            #Désigne l'objet en cours :
                                                #  - member fonction : objet courant (don't forget it, non-implicite as 
                                                #    opposed to C++), dont:
                                                #     - function invoquée par new : nouvel objet créé (car function devient 
                                                #       une fonction membre constructor de l'objet avant invocation)
                                                #     - inline HTML : l'input object (e.g. <button>) ou si <a>: <body>
                                                #     - event handler : currentTarget
                                                #  - si pas d'objet courant : global object Window (non-strict mode) ou 
                                                #    plusieurs autres values possible (strict mode)
                                                #Assigner à this directement throw ReferenceError
                                                #Binding this:
                                                #  - If OBJ.FUNC() uses this, then:
                                                #      var FUNC2 = OBJ.FUNC; FUNC2() 
                                                #    In FUNC2, this will be resolved. So must do OBJ.FUNC.bind(OBJ) instead.
                                                #  - So when passing member functions callback FUNC2(OBJ.FUNC), must do
                                                #    OBJ.FUNC.bind(OBJ) instead.

function TYPE([ARGS]) {                         #Exemple d'héritage.
  TYPE_PARENT.call(this[, ...]);                #Object-oriented prototype-based : utilise des objets au lieu de classes.
  this.VAR = VAL;...                            #Static vs dynamic :
}                                               #  - Static members VAR2 ne dépendent pas d'ARGS (usually functions).
TYPE.prototype = Object.create                  #    Ils sont looked up via la prototype chain VAR3.__proto__.... (see below)
  (TYPE_PARENT.prototype[, {VAR2:OBJ...}])      #    qui pointent par reference vers each TYPE[_PARENT...].prototype. 
TYPE.prototype.constructor = TYPE               #    { VAR2: OBJ } is optional: if does not want to change enumerability, etc.
                                                #    or to define getter/setter, can just assign TYPE.prototype.VAR2 = VAL2
var VAR3 = new TYPE[(...)]                      #  - Dynamic members VAR dépendent d'ARGS (usually non functions)
                                                #    Ils sont initialisés locally dans VAR3, via la constructor chain:     
                                                #    TYPE(), qui invoque TYPE_PARENT().
                                                #    Si TYPE pas de parent, le faire hériter d'Object.
                                                #Comme .__proto__ sont des référence, modifier une static VAR2:
                                                #  - via la prototype chain (e.g. VAR3.__proto__.VAR2) la change pour ensemble 
                                                #    des variables instantiées.
                                                #  - directement (e.g. VAR3.VAR2) en fait un dynamic member (local copie).
                                                #new TYPE[(...)] invoque TYPE.prototype.constructor(...):
                                                #  - with this being { __proto__: TYPE.prototype }
                                                #  - Si TYPE() return un OBJ, return it. Otherwise return this.
                                                #Constructor TYPE():
                                                #  - peut être changée dynamiquement. 
                                                #  - Par convention commence par majuscule (et autres variables sont lowercase)
                                                #Own members are non-herited members (herited sometimes called "shared").

TYPE.prototype                                  #Own static members d'un type. Pointé par :
                                                #  - TYPE_ENFANT.prototype.__proto__, après assignation via 
                                                #    Object.create(TYPE.prototype)
                                                #  - instantiation VAR.__proto__
                                                #  - so VAR.__proto__.__proto__... go through the prototype of all parents
Object.getPrototypeOf(OBJECT)                   #Renvoie VAR.__proto__. Préférer à VAR.__proto__ pour lecture (en écriture
                                                #seul __proto__ est possible)
                                                #Throw TypeError if not OBJECT.
Object.create(VAR[, OBJ])                       #Renvoie une VAR2 où :
                                                #  - VAR2.__proto__ pointe vers VAR (en général TYPE_PARENT.prototype)
                                                #  - chaque membre d'OBJ est rajouté à VAR2, avec les descriptors désignés.
                                                #OBJ contient des OBJ, dont chaque désigne un nouveau membre pour VAR2.
                                                #Membres possibles, peut être ou bien :
                                                #  - un data descriptor avec :
                                                #    - get/set : FUNC/FUNC(VAL) à invoquer quand le membre est lu/écrit. 
                                                #      En général contrôle un autre membre non enumerable mais writable.
                                                #  - un access descriptor avec :
                                                #    - value : VAL. Préférer à get/set si écriture/lecture est simple. Déf:
                                                #      undefined.
                                                #    - writable (BOOL, déf: false) : si false, VAR = VAL renvoie VAL, mais ne
                                                #      modifie pas VAR
                                                #  - data et access descriptors peuvent utiliser tous deux :
                                                #    - enumerable (BOOL, déf: false) : would appear in a for in loop.
                                                #    - configurable (BOOL, déf: false) : possibilité de delete le membre, ou de
                                                #      changer descriptors (non writable never possibilité de changer).
                                                #      En général, get/set sont non-configurable et values le sont.
                                                #Ex. d'OBJ : {VAR: {value: VAL, writable: BOOL}...}
                                                #TypeError exception si VAR non-object (null authorisé), si get/set n'a pas
                                                #une FUNC assignée, ou si get/set alors que value ou writable.
Object.defineProperty(VAR,STR,OBJ)              #Assigne les descriptors OBJ à VAR.STR. Descriptor non explicité sont conservés
                                                #Only own members.
Object.defineProperties(VAR,OBJ)                #Pareil mais utilise un OBJ d'OBJ pour plusieurs VAR.STR, comme dans
                                                #Object.create()
Object.getOwnPropertyDescriptor(OBJ,STR)        #Renvoie les descriptors de OBJ.STR (si own member), sous forme d'OBJ2.
                                                #Only if OBJ a été assigné via set/get ou Object.create()

NATIVE OBJECTS ==>                              #Le constructor des native objects, plutôt que d'assigner les membres de this,
                                                #construit et renvoie un objet (comme new). En conséquence, TYPE.call(this)
                                                #ignore this, et construit un objet non utilisé par la fonction parente.
                                                #Pour hériter de native objects:
                                                #  var VAR = NATIVE_TYPE();
                                                #  NATIVE_TYPE.VAR2 = VAL2;
                                                #  return NATIVE_TYPE;
                                                #De même, ne pas faire new NATIVE_TYPE(), mais NATIVE_TYPE() (sauf DATE et 
                                                #NUMBER)

require("util").inherits(TYPE, TYPE_PARENT)    ##For Node.js:
                                               ##  TYPE.prototype = Object.create(TYPE_PARENT.prototype);
                                               ##  TYPE.prototype.constructor = TYPE;
                                               ##  TYPE.super_ = TYPE_PARENT;
                                               ##So only need: if dynamic members, setting TYPE constructor, which should call
                                               ##TYPE.super_.call(this[, ...]);

MULTIPLE INHERITANCE ==>                        #Pour:
                                                #  - dynamic members: calling TYPE_PARENT1() and TYPE_PARENT2() dans TYPE().
                                                #  - static members: more problematic. Can't add several TYPE_PARENT in the
                                                #    prototype chain. One solution is to add TYPE_PARENT1 in the prototype
                                                #    chain, and add TYPE_PARENT2 prototype properties to TYPE: becomes
                                                #    own static members instead of shared static members ("mixin").
$.extend([BOOL, ]OBJ, OBJ2...)                 ##Merge les propriétés (hérités ou non) de l'ensemble des OBJ2 dans OBJ, et le
                                               ##renvoie (jQuery)
                                               ##Si OBJ.VAR et OBJ2.VAR existent tous deux :
                                               ##  - si false (déf), OBJ2.VAR overwrite OBJ.VAR
                                               ##  - si true, deep merge de OBJ2.VAR et OBJ.VAR
$.fn.extend(OBJ)                               ##Same as $.extend(OBJ, $.fn) : rajoute méthode jQuery ($.fn is jQuery 
                                               ##prototype) à OBJ. (jQuery)


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          STRUCTURES           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


{ }                                             #All blocks can be erased if only on single next line. But avoid it.

if ( TEST ) 
{ 
  ...  
}
[else if ( TEST ) 
{ 
  ...  
}]... 
[else 
{ 
  ...  
}]

TEST ? VAL1 : VAL2                              #Comme en C
TEST ? ( STATEMENT... ) : ( STATEMENT2... )

TEST && STATEMENT
TEST || STATEMENT                               #And/or chains

STATEMENT1, STATEMENT2                          #Evalue deux STATEMENT mais ne renvoie que STATEMENT2. Avoid it.

switch (VAR)
{
  case STR:
      ...
      [break;]
  ...
  default :
      ...
      break;                                    #Exécute next case (sans passer le test) si absence de break. But est de mettre
}                                               #plusieurs case STR: se suivant pour une alternative.

for ( [STATMT1]... ; [STATMT2]... ; 
      [STATMT3]... ) { }                        #Can use let in STATEMENT1
for      ( var VAR in ARRAY/OBJ ) { }           #Itère dans indices (NUM) d'ARRAY / noms (STR) des membres d'OBJET, à condition
                                                #qu'ils soient enumerable (y compris hérités)
                                                #OBJ peut être ITERATOR.
for each ( var VAR in ARRAY/OBJ ) { }           #Itère dans éléments d'ARRAY / valeurs des membres d'OBJET, à condition qu'ils
                                                #soient enumerable (y compris hérités)
                                                #Dépréciée.
while ( TEST ) { }
do { } while ( TEST ) 

break [LABEL]                                   #Stoppe la boucle for, while ou switch courante.
                                                #Pour stopper une boucle de niveau supérieure, celle-ci doit être précédée de
                                                #LABEL:, e.g. :
                                                #  - LABEL: for ...
                                                #  - LABEL:
                                                #      for ...
                                                #Avoid using labels.
continue [LABEL]                                #Retourne au début de la boucle.



                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            ERRORS             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


ERRORS ==>                                      #Exception-based.
throw VAL                                       #Lance exception VAL. Préférer utiliser erreurs standards.
try
{
  ...
}
[catch ( VAR [if TEST] )
{
  ...                                           #Si exception thrown in try-block, exécute catch-block avec EXCEPTION VAL in
}]                                              #VAR. Un seul bloc catch that catches all exceptions.
[finally                                        #finally-block always executed avec ou sans exception. Pour statements toujours
{                                               #effectués, avec ou sans exceptions (par exemple close the files).
  ...                                           #TEST est souvent VAR instanceof EXCEPTION
}]                                              

Error                                           #Base classe des erreurs. Enfant de FUNCTION.
ERROR(STR)                                      #Remplie .message avec STR
ERROR.name                                      #"Error" (redéfinie par classes enfants avec leur propre nom)
ERROR.message                                   #Description de l'erreur.
ERROR.toString()                                #Renvoie "name: message"

TypeError                                       #Erreur quand fonction reçoit un argument du wrong type. Enfant d'ERROR.
ReferenceError                                  #Erreur quand déréférence une VAR est undeclared (et non undefined).
                                                #Enfant d'ERROR.
SyntaxError                                     #Enfant d'ERROR.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            BOOLEAN            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/

Boolean                                         #Objet, non type simple BOOL. Enfant de Function.
BOOLEAN(VAL)                                    #Renvoie BOOL, non BOOLEAN
                                                #Not really useful.

                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            NUMBER             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/

Number                                          #Objet, non type simple NUM.
Number[(VAL)]                                   #Utiliser new.

NUMBER.toFixed([NUM])                           #Renvoie sous forme de STR, avec décimale notation (NUM décimales)
NUMBER.toExponential([NUM])                     #Pareil pour exponential
NUMBER.toPrecision([NUM])                       #Pareil, avec une précision décimale de NUM.

Number.MIN_VALUE
Number.MAX_VALUE
Number.POSITIVE_INFINITY
Number.NEGATIVE_INFINITY
Number.NaN                                      #Préférer Infinity, -Infinity et NaN


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            STRING             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


String                                          #Objet, non type simple STR.
                                                #STRING est en fait une ARRAY_LIKE de chars.
String[(VAL)]                                   #Déf: ""
                                                #En dehors des types simples (dont STR), utilise OBJ.toString(). 
                                                #Si pas utilisé avec new, renvoie STR, non STRING.
                                                #STRING semble supporter Unicode chars, compris comme un seul char.
String.fromCharCode(NUM...)                     #Renvoie STR avec Unicode codepoint NUM...

STRING[NUM]                                     #Read-only. undefined if out of range.
STRING.charAt(NUM)                              #Same except "" if out of range
STRING.charCodeAt(NUM)                          #Unicode codepoint.

String.length                           

STRING.localCompare(STRING2)                    #Correct way to compare STRING : renvoie -1, 0 ou 1.
                                                #<, >, ==, etc. suffisent pour STR cependant (mais prennent pas en compte
                                                #locales)

STRING.match(REGEXP)                            #Comme REGEXP.exec(STRING), sauf que si g flag, renvoie ensemble des 
                                                #occurences dans l'ARRAY.
STRING.search(REGEXP)                           #Renvoie index de première occurence de REGEXP dans STRING (-1 si absent)
STRING.replace(REGEXP,STR)                      #Renvoie STRING, avec replacement de REGEXP par STR.
                                                #STR peut contenir :
                                                #  - $& : match total
                                                #  - $1, etc. : match (...) numéro 1, etc.
                                                #  - $` : caractères précédant match total
                                                #  - $' : caractères suivant match total
                                                #  - $$ : $ littéral
STRING.replace(REGEXP,FUNC)                     #Renvoie STRING, avec replacement de REGEXP par FUNC($&,$1...,INDEX,STRING).
                                                #INDEX est STRING.search(REGEXP). Le nombre de $1 dépend de nombre de (...).
                                                #FUNC peut omettre des arguments (à partir de la fin).
STRING.split(REGEXP[, UINT])                    #Renvoie une ARRAY splittant STRING, avec comme délimiteur REGEXP et, si UINT,
                                                #ne renvoie que les UINT premiers éléments.

STRING.to[Locale][Upper/Lower]Case()            #Renvoie sans modifier. Préférer avec Locale
STRING.trim()                                   #Remove whitespaces on left and right.

STRING.concat(STR...)                           #Préférer + et +=
STRING.[lastI/i]ndexOf(STR[, NUM])              
STRING.slice(NUM[, NUM2])                       #Comme pour ARRAY

STRING.substring(NUM[, NUM2])                   #Comme .slice sauf que :
                                                #  - NUM2 négatif -> 0
                                                #  - Si NUM2 < NUM, swappe NUM et NUM2

RegExp                                          #Can be expressed sous forme de REGEXP_LIT via /STR/[FLAGS]
                                                #Ex: var VAR = /.*/;
                                                #RegExp étendues avec quelques ajouts :
                                                #  - \w \W \s \S \d \D
                                                #  - \1 \2 etc.
                                                #  - Pas de \< \>
                                                #  - ^ et $ indiquent ensemble de STR, quel que soient newlines.
                                                #FLAGS possibles : 
                                                #  - g i : comme sed
                                                #  - m : on multiple lines (doesn't seem to change anything)
REGEXP(STR[, STR2])                             #STR2 sont les flags
                                                #STR Need to escape backslashes
                                                #Should escape all regex symbols before (unless intended as regex symbols) : 
                                                #  STR.replace( /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&" )
REGEXP.ignoreCase
REGEXP.global
REGEXP.multiline                                #Presence du flag sous BOOL
REGEXP.source                                   #STR d'origine.
REGEXP.lastIndex                                #Utiliser avec exec et test : si flag g, ne fait qu'une recherche, mais 
                                                #fera prochaine recherche après dernier caractère matché (indiqué par
                                                #lastIndex sous NUM)

REGEXP.exec(STR)                                #Search REGEXP in STR et renvoie ARRAY :
                                                #  - ARRAY[0] est le total match
                                                #  - ARRAY[n] sont les matches des (...) dans REGEXP (s'il y en a)
                                                #  - ARRAY.index est l'index du premier (Unicode) char matché
                                                #  - ARRAY.input est STR
                                                #Si ne trouve rien, renvoie null
REGEXP.test(STR)                                #Renvoie true si STR contient REGEXP.
                                                #Utiliser REGEXP.lastIndex

en|decodeURI(STR)                               #Percent encore all non-ASCII chars
                                                #To use in a URI to escape its data
                                                #decodeURI() can throw URIError
en|decodeURIComponent(STR)                      #Percent encode all non-ASCII chars, plus ? & = # + $ ; , / : @
                                                #To use in the data part of an URI


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             ARRAY             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/

Array                                           #Array are objects. Indexs sont en fait des properties names (internally)
                                                #Eviter for ( in ) qui énumera également les membres d'ARRAY (hors indexs)
Array(VAL...)                                   #Equivaut à [ VAL... ]
[ [VAL]... ]                                    #ARRAY. Peut être left-head : écriture et [...].FUNC()
                                                #VAL est par défaut undefined.
                                                #Peut contenir types différents.
Array(NUM)                                      #Renvoie ARRAY avec NUM éléments undefined.
                                                #Throw RangeError if non-positive or decimal.

Array.isArray(VAL)                              #Renvoie true si ARRAY (non enfant d'ARRAY)

ARRAY = ARRAY                                   #Assignation
                                                #Plutôt que de faire ARRAY = [ "STR", "STR2", "STR3", ... ], écrire
                                                #[ "STR STR2 STR3" ].split( " " ) si c'est qu'une seule fois, car plus simple
                                                #à écrire.
ARRAY[UINT]                                     #Déférencement. Index commence à 0. Si hors bound, renvoie undefined.
ARRAY[STR]                                      #Array associative. En fait, équivaut à ARRAY.STR. Préférer utiliser un OBJET
                                                #si seulement array associative.

ARRAY.length                                    #Il est possible de modifier pour étendre (avec des undefined) ou tronquer.

ARRAY.concat(VAL)                               #Renvoie ARRAY avec élément VAL (ou ARRAY2) à la fin d'ARRAY.
$.merge(ARRAY,ARRAY2)                          ##Concatène ARRAY2 à ARRAY, et renvoie ARRAY (jQuery).
ARRAY.slice(NUM[,NUM2])                         #Renvoie copy of ARRAY, de l'élément NUM à NUM2 (déf: fin). 
                                                #Si NUM2 négatif, signifie numéro de l'élément depuis a fin d'ARRAY.
ARRAY.splice(NUM, NUM2[, VAL...])               #Supprime et renvoie les NUM2 éléments après l'élement numéro NUM, et les 
                                                #remplace par VAL...
ARRAY.join([STR])                               #Renvoie ARRAY concaténés sous forme de STR, avec comme délimiteur STR
                                                #(déf: ,)

ARRAY.push(VAL)                                 #Rajoute ARRAY avec élément VAL à la fin d'ARRAY.
                                                #Renvoie ARRAY.length
ARRAY.pop()                                     #Supprime dernier élément. Renvoie ARRAY.length
ARRAY.unshift(VAL)                              #
ARRAY.shift()                                   #Comme push/pop, mais pour premier élément.

ARRAY.reverse()                                 #Modifie et renvoie.
ARRAY.sort([FUNC])                              #Modifie et renvoie.
                                                #Peut donner une fonction de comparaison FUNC(VAL,VAL2), renvoyant 1 si a>b,
                                                #-1 s a<b, 0 si a==b
                                                #Comparaison est STR. Pour sort des nombres, utiliser FUNC :
                                                #function(a,b) { return a == b ? 0 : ( a < b ? -1 : 1 ) }
                                                
ARRAY.indexOf(VAL[, NUM])                       #Renvoie position de VAL dans ARRAY (si NUM, skippe les NUM premiers éléments).
                                                #-1 si pas trouvé.
ARRAY.lastIndexOf(VAL[, NUM])                   #Pareil, mais position depuis la fin.

ARRAY.forEach(FUNCTION[, VAL])                  #Exécute FUNCTION(VAL2[, NUM[, ARRAY2]]) pour chaque VAL2 d'ARRAY.
                                                #NUM est l'index de l'élement. ARRAY2 est ARRAY.
                                                #VAL est this au sein de FUNCTION
ARRAY.map(FUNCTION[, VAL])                      #Pareil, mais renvoie également la concaténation des return value des 
                                                #invocation de FUNCTION.

ARRAY.reduce[Right](FUNC[, VAL])                #Exécute FUNCTION(VAL3,VAL2[, NUM[, ARRAY2]]) sur chaque VAL2 d'ARRAY de 
                                                #manière consécutive, où VAL3 est le résultat de l'exécution précédente.
                                                #Renvoie résultat VAL4 final.
                                                #VAL est la VAL3 initiale (déf: 0)
                                                #reduceRight va de droite à gauche.
ARRAY.filter(FUNC[, VAL])                       #Renvoie éléments dans ARRAY répondant true à FUNC(VAL2[, NUM[, ARRAY2]]).
                                                #VAL est this au sein de FUNCTION
ARRAY.every(FUNC[, VAL])                        #Renvoie true si FUNC(VAL2[, NUM[, ARRAY2]]) de chaque VAL2 d'ARRAY renvoie 
                                                #true.
                                                #VAL est this au sein de FUNCTION
ARRAY.some(FUNC[, VAL])                         #Pareil mais si au moins un renvoie true.

MULTIDIMENSIONAL ARRAYS ==>                     #Utiliser des ARRAY d'ARRAY : VAR[NUM][NUM2]

ARRAY-LIKE OBJECTS ==>                          #Certains objets ont l'air d'ARRAY, mais n'en sont pas : 
                                                #  - arguments, String, NodeList
                                                #Can however convert using Array.prototype.slice.call(arguments)


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:         TYPED ARRAYS          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


ArrayBuffer                                     #Bytes chunk. Needs an ARRAYBUFFERVIEW to be manipulated.
                                                #Several ARRAYBUFFERVIEW can be applied to a single ARRAYBUFFER.
ARRAYBUFFER(UINT)                               #UINT is byteLength
ARRAYBUFFER.byteLength                          #Readonly.
ArrayBufferView                                 #A view is linked to an ARRAYBUFFER and has : 
                                                #  - a specific type to read it
                                                #  - an offset from the beginning of it
ARRAYBUFFERVIEW.buffer                          #The ARRAYBUFFER. Readonly
ARRAYBUFFERVIEW.byteLength                      #ARRAYBUFFER.byteLength. Readonly.
ARRAYBUFFERVIEW.byteOffset                      #The offset, in bytes.

[Ui|I]nt8|16|32Array                            #
Float32|64Array                                 #Enfant d'ARRAYBUFFERVIEW avec un type précis.
*ARRAY.BYTES_PER_ELEMENT                        #Byte length du type
*ARRAY(UINT)                                    #Constructor vide.
*ARRAY(ARRAY)
*ARRAY(*ARRAY2)                                 #Copy constructor
*ARRAY(ARRAYBUFFER[, UINT[, UINT2]])            #UINT est l'offset en byte (déf: 0) et UINT2 la taille en byte (déf: all), pour
                                                #pouvoir tronquer.
*ARRAY[UINT]                                    #
*ARRAY.set(ARRAY|*ARRAY2[, UINT])               #Remplace une partie d'*ARRAY avec ARRAY|*ARRAY2, depuis élément UINT (déf: 0)
*ARRAY.subarray(UINT[, UINT2])                  #Renvoie seulement de l'octet UINT à UINT2 (exclus) (déf: fin)

Array.apply([], *ARRAY)                         #Convertit en ARRAY

DataView                                        #Enfant d'ARRAYBUFFERVIEW avec types changeants.
DATAVIEW(ARRAYBUFFER[, UINT[, UINT2]])          #Comme *ARRAY
DATAVIEW.get[Ui|I]nt8|16|32([UINT[, BOOL]])     
DATAVIEW.getFloat32|64(UINT[, BOOL])            #UINT est l'offset en byte et BOOL l'endianness (déf: true, little endian)
DATAVIEW.set*(UINT, UINT2[, BOOL])              #UINT est l'offset en byte (attention) et UINT2 la valeur à mettre.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             DATE              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/

Date                                            #Stored internally as number of seconds since Epoch. Enfant de Function.
                                                #Granularité est millisecondes.
                                                #Constructor sans new renvoie sous forme de STR. Avec new une DATE.
DATE(YEAR,MONTH,DAY,HOUR,MIN,SEC,MILLISEC)      #Chaque final argument est optionnel. (local)
DATE(STR)                                       #Essaie de parser. Sinon DATE = InvalidDate (local)
DATE()                                          #Now (local), as STR


DATE.*et[UTC][Time/FullYear/Month/Date/Day/     #Date est jour du mois, Day jour de la semaine (0 dimanche)
Hours/Minutes/Seconds/Milliseconds/             #Time est nombre de secondes depuis Epoch
TimezoneOffset]()                               #TimezoneOffset est en minutes.
                                                #Si UTC : non-local mais UTC time.
                                                #Pour set* : si month, etc. dépasse du max., prend sur l'année, etc. suivante.
                                                #set* renvoie DATE.getTime()

DATE.parse(STR)                                 #Equivaut à new DATE(STR).getTime()
Date.UTC(ARGS)                                  #Comme new DATE(ARGS).getTime(), mais UTC-time.
Date.now()                                      #Equivaut à new DATE().getTime()

DATE.to[locale][ISO/UTC/Date/Time]String()      #Plusieurs formats :
                                                #  - normal : "Day Mon DD YYYY HH:MM:SS TZ"
                                                #  - Date : "Day Mon DD YYYY"
                                                #  - Time : "HH:MM:SS TZ"
                                                #  - ISO : "YYYY-MM-DDTHH:MM:SS.SSSZ"
                                                #  - UTC : "Day, DD Mon YYYY HH:MM:SS TZ" (UTC)
                                                #locale rajouteoptions pour timezones ou calendriers différents.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             MATH              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


Math                                            #A des méthodes, mais n'est pas utilisé comme objet lui-même.

Math.pow(NUM1,NUM2)
Math.min(NUM...)
Math.max(NUM...)

Math.abs(NUM)
Math.ceil(NUM)                                  #Troncature supérieure
Math.floor(NUM)                                 #Troncature inférieure
Math.round(NUM)                                 #Troncature nearest

Math.PI
Math.E
Math.LN2                                        #ln(2)
Math.LN10                                       #ln(10)
Math.LOG2E                                      #log2(e)
Math.LOG10E                                     #log10(e)
Math.SQRT2
Math.SQRT1_2

Math.sqrt(NUM)
Math.exp(NUM)
Math.[a][sin/cos/tan[2]](NUM)

Math.random()                                   #Renvoie PRN entre 0 et 1. Seeded from current time.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           ITERATOR            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


(*slt Firefox*)                                 #Pour ensemble de section.

ITERATOR ==>                                    #Doit :
                                                #  - définir .next() : itération dans un objet VAR2 et return d'un élément VAR 
                                                #  - raise une StopIteration exception si fin de l'itération
Iterator                                        #Enfant de Function.
                                                #Plus court en mémoire qu'un long array, et ne se multiplie pas -> plus 
                                                #efficient
Iterator(OBJ[, BOOL])                           #Crée un iterator traversant membres d'OBJ
                                                #If true (def: false), only ITERATOR return only index/names, not pairs
ITERATOR.next()                                 #Renvoie paire key (index pour ARRAY)/élement sous forme d'ARRAY
                                                #Si fin, raise StopIteration exception.

for ( QUAL VAR in ITERATOR )                    #Each VAR will be each ITERATOR.next(), until StopIteration.
[EXPR for ( VAR of ITERATOR ) [if TEST]]        #Comme pour ARRAY.

CUSTOM ITERATOR ==>                             #Pour une VAR :
                                                #  - définir type/constructor CUSTOMITO(VAR) et CUSTOMITO.next(), renvoyant une
                                                #    VAR et lançant StopIteration si fin d'itération.
                                                #  - définir VAR.prototype.__iterator__(), renvoyant new CUSTOMITO(this)
                                                #Permet de traverser via for in.
              
yield [VAL]                                     #Dans une FUNC, fait qu'elle renverra un GENERATOR au lieu de s'éxécuter.
                                                #GENERATOR est un CUSTOMITO :
                                                #  - GENERATOR.next() : s'arrêtera au prochain yield de FUNC, renverra VAL 
                                                #    (déf: undefined) puis recommencera à cet endroit la prochaîne fois 
                                                #    (conserve donc la valeur des variables de FUNC lors dernière exécution).
                                                #    Plus besoin d'utiliser de state variable/counter donc.
                                                #    return statements (dont fin de FUNC) throw StopIteration.
                                                #  - GENERATOR.send(VAL) : comme .next(), mais fait que l'expression yield 
                                                #    stoppée renverra une return VAL (déf: undefined). 
                                                #    Possible donc seulement après le premier .next() (sinon TypeError 
                                                #    exception). Permet de rendre plus interactive le séquencement, voire
                                                #    d'implémenter random access.
                                                #  - GENERATOR.close() : go after the end of iteration. 
                                                #    Exécute toute close finally {} si FUNC était dans un bloc try {}
                                                #  - GENERATOR.throw([VAL]) : throw StopIteration (ou VAL)
                                                #  - GENERATOR.iterator() : renvoie GENERATOR.
                                                #Par conséquent, définir une FUNC où l'ensemble des yield successifs définit 
                                                #une séquence, et l'assigner à .prototype.__iterator__ est un moyen simple 
                                                #de définir un CUSTOMITO sur cette séquence.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             JSON              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


JSON ==>                                        #Un peu comme XML, sert à sérialiser objets.
                                                #Extension est ".json"
                                                #Est en fait même notation qu'un OBJ littéral, avec comme différence :
                                                #  - VAR: VAL -> "VAR": VAL
                                                #  - pas de leading zeros sur les NUM
                                                #  - seuls échappement backslash : \", \\, \b, \f, \n, \r, \t, \uXXXX
                                                #  - pas de undefined, ni de fonction, ni other native objects (regex, etc.)
                                                #    - cependant, il est possible de convertir en STR via une FUNC dans
                                                #      .stringify()
                                                #    - Date supportées car DATE.toJSON() existe
                                                #Peut également être un VAL (dont [...]) au lieu de { VAL }
JSON                                            #Parser de JSON. A préférer à eval() ou à d'autres parsers. Enfant d'Object.
JSON.parse(STR[, FUNC])                         #Renvoie la conversion de JSON STR en VAL
                                                #Si FUNC, exécute FUNC(key,value) pour parser chaque value (avec this étant à
                                                #chaque fois le parent direct). Reste est comme FUNC de stringify.
                                                #Peut throw SyntaxError.
JSON.stringify(VAL[,VAL2[,VAL3]])               #Renvoie la conversion de VAL en JSON sous forme de STR
                                                #undefined, fonction, non supported objects -> omitted or converted to null
                                                #Si VAL2, peut être :
                                                #  - une FUNC(key,value) : chaque propriété passera par la fonction et :
                                                #      - la return value, transtyped vers STR, sera la value stringified pour
                                                #        cette propriété
                                                #      - si return value est undefined, skippe la propriété
                                                #    Pour un array key est le NUM, pour un objet c'est le name STR.
                                                #    L'objet global passe par la fonction à la fin (sa key est "")
                                                #  - une ARRAY de STR désignant les names des propriétés à inclure. Non
                                                #    récursif. Pour inclure enfant, parent doit être inclus.
                                                #Si VAL3, indente avec VAL3 (STR si STR, NUM spaces si NUM) et rajoute
                                                #newlines.
                                                #Si VAL.toJSON() existe, au lieu d'utiliser VAL, utilisera return value de 
                                                #VAL.toJSON().


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            AUTRES             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


NOT SUPPORTED ==>                               #En général ECMAScript6 :
                                                #  - let
                                                #  - const
                                                #  - Iterator et yield
                                                #  - Quasi-literals
                                                #  - Proxy
                                                #  - Object.mixin()
                                                #  - for ... of : array compréhension
                                                #  - Arrow function: VAL => EXPR
                                                #  - class and extends
                                                #  - [Weak]Map, Set
                                                #  - regexp "y" flag
                                                #  - \u{XXXXXX}
                                                #  - ARRAYBUFFER.slice(), Uint8ClampedArray
                                                #  - default arg value : FUNC(VAR = VAL)
                                                #  - better variadic args : FUNC(ARG, ..., ...rest), and spread ...VAR
                                                #  - Object.assign()
                                                #  - Object.getOwnPropertyDescriptors(), .getPropertyName|Descriptor
                                                #  - Object.is[nt]()
                                                #  - Array.from(), Array.of(), Array.items, Array.keys|values
                                                #  - String.fromCodePoint(), String.codePointAt(), String.contains(),
                                                #    String.starts|endsWith(), String.repeat(), String.toArray(), String.raw
                                                #  - Number.isFinite, Number.isNaN, Number.isInteger, Number.toInteger
                                                #  - Math.[a][cos|sin|tan]h(), Math.cbrt(), Math.hypot(), Math.log*(), 
                                                #    Math.sign(), Math.trunc(), Math.expm1()
