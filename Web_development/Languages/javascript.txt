
                
   JAVASCRIPT   
                


TO DO ==>                                       #  - garbage collection

VERSION ==>                                     #Standard is called ECMAScript. JavaScript and ActionScript are dialects.
                                                #This doc shows ES6 in strict mode, with this notation for ES6 new features:
                                               |#  - works with Babel
                                               +#  - works with Babel, but require polyfill
                                               -#  - does not work with Babel

MAIN PRINCIPLES ==>                             #Case-sensitive. Whitespaces are ignored.
                                                #Type: weak, dynamic, generic, late/duck.
                                                #Lexical-scope
                                                #Functional (first-class functions)
                                                #Object-oriented (prototype-based)
                                                #Imperative (structures close to C)
                                                #Does not have any I/O -> need a host environnement (generally browser) to
                                                #"do things".
                                                #Memory management: garbage collection.

EXECUTION ==>                                   #Each browser has own JavaScript engine, which was in the past interpreted,
                                                #but now is byte-compiled or compiled:
                                                #  - Chakra (IE9+)
                                                #  - SpiderMonkey (Firefox)
                                                #  - V8 (Chrome, Opera 12.15+)
                                                #  - SquirrelFish (Safari)

INCLUDING IN HTML ==>                           #Priority is from top to bottom

<script src="script.js"></script>               #From external file. Preferred. Should be in <head>.

<script>CODE</script>                           #Inline. If in <body>, execute while loading. Should be in <head>

<a href="JavaScript:CODE"></a>                  #
<any onEVENT="CODE"></any>                      #Deprecated

<noscript>
  Activez JavaScript pour voir contenu
</noscript>


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             SCOPE             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


GENERAL ==>                                     #  - variable scope is:
                                                #     - "var": function() {...}
                                                #     - "let|const": any {...}
                                                #  - any function is child scope of the function in which it is *declared* (not *fired*)
                                                #     - parent scope is a reference, not a snapshot, i.e. is is evaluated each
                                                #       time the function is fired
                                                #  - scopes inherits parent scope, but not inverse
                                                #  - global/root scope: usually available with global reference global|window 
                                                #    (depends on host)

DECLARATION ==>                                 #  - using undeclared VAR throws ReferenceError (except with typeof)
                                                #  - using VAR (even if declared in parent scope) declared later in current scope with:
                                                #     - "let|const": throws ReferenceError ("Temporal Dead Zone")
                                                #     - "var": adds an implicit empty declaration before, i.e. will be undefined (variable hoisting)
                                                #     - function FUNC(){}: adds an implicit declaration+assignment before

DECLARING FUNCTIONS ==>                         #  - FUNC = function [FUNC2](){}
                                                #     - declared+assigned at runtime (like other variables)
                                                #     - this also covers anonymous function, and void function [FUNC2](){}
                                                #     - FUNC2.name (read-only): used by ERROR.toString() in stack trace
                                                #     - Using "FUNC2":
                                                #        - equivalent of doing let FUNC2 = function(){} at the beginning of the same function
                                                #        - allow recursion to reference themselves without risk of parent scope
                                                #          to reassign FUNC2
                                                #  - function FUNC2(){}:
                                                #     - declared+assigned at parsetime 
                                                #        - i.e. equivalent of doing let FUNC2 = function () {} at {...} scope beginning
                                                #     - FUNC2.name: same
                                                #  - new Function(...): child of global scope

MEMORY MANAGEMENT ==>                           #Garbage collection:
                                                #  - periodically, iterates recursively over global object properties,
                                                #    including functions current|parent SCOPEs
                                                #  - clean any defined that cannot be reached anymore (because a function returned)
                                                #  - note that local functions:
                                                #     - can be assigned to parent SCOPE (and so live beyond current SCOPE) by
                                                #       direct assignment and be used as return value
                                                #     - carry references to parent SCOPEs
                                                #Memory leak happens with combination of variables being:
                                                #  - big, e.g.:
                                                #     - functions carrying parent SCOPEs
                                                #     - big objects
                                                #     - raw data returned from server
                                                #  - long-lived, e.g.:
                                                #     - attached to top/long-lived SCOPEs, e.g. global variables, e.g.:
                                                #        - long-lived DOM elements
                                                #        - global functions (e.g. global event handlers, setInterval(), ...)
                                                #Avoiding:
                                                #  - unset big variables just after being used, so that child SCOPEs do not
                                                #    carry them over


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         TYPES GENERAL         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


TYPING SYSTEM ==>                               #  - weak: no type specified at Declaration
                                                #  - generic: native operators accepts any type, since each native type
                                                #    transtype to any (except OBJ->undefined|null)
                                                #  - dynamic: type is not checked at compile-time nor (since generic) run-time

AVAILABLE TYPES ==>                             #  - simple: number|boolean|string|undefined|null
                                                #  - object (TYPE): Object and its children
                                                #    - native: Object|Array|Number|Boolean|String|Error|...
                                                #    - user-defined:
                                                #      - host objects: defined by browser (e.g. DOM elements)

Number|Boolean|String                           #Not same as number|boolean|string:
                                                #  - are objects, constructed as new TYPE([VAL])
                                                #  - but transtypes to|from simple types
                                                #     - STR|BOOL|(NUM).VAR work, because of transtype
                                                #     - not that null|undefined.VAR will throw error
                                                #Note: new Number|...(...) returns OBJ, whereas Number|...(...) returns native type

typeof VAR                                      #Returns "number|boolean|string|undefined|object|function"
                                                #"object": includes null, excludes FUNC
OBJ.constructor                                 #Returns TYPE (read-only)
VAR instanceof TYPE                             #Returns true if VAR is instance of TYPE (of a child of TYPE), i.e.:
                                                #  - VAR.[__proto__...]constructor === TYPE, 
                                                #    but without transtyping VAR if it is not an OBJ
                                                #  - VAR.[__proto__...]__proto__ === TYPE.prototype
TYPE.prototype.isPrototypeOf(VAR)               #Same

CHECKING TYPE ==>                               #  - number|boolean|string: typeof VAR === '...'
                                               ##     - $.isNumeric(VAL): isFinite(parseFloat(VAL)) (jQuery)
                                                #  - object: typeof VAR === 'object' && VAR !== null
                                                #  - null: VAR === null
                                                #  - null|undefined: VAR == null
                                                #  - undefined: 
                                                #     - (VAR declared) VAR === undefined
                                                #     - (VAR maybe not declared) typeof VAR === "undefined"
                                                #  - ARR: Array.isArray(VAR)
                                                #  - Node: VAR.nodeType === 1
                                                #  - TYPE (excluding children): OBJ.constructor === TYPE
                                                #  - TYPE (including children): OBJ instanceof TYPE
                                                #  - OBJ (no parent TYPE): OBJ.constructor === Object, or 
                                               ##    $.isPlainObject(VAL) (jQuery)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         SIMPLE TYPES          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


NUM                                             #Are all double-float.
                                                #Decimal, scientific ou hexa (non octal).
                                                #Can be:
                                                #  - NaN:
                                                #     - returned e.g. by √-1 or 0/0
                                                #     - NaN != NaN
                                                #     - test with isNaN(VAL)
                                                #  - Infinity or -Infinity.
                                                #     - returned e.g. by overflow like 1e400, or 1/0
                                                #     - test with isFinite(VAL) (return false for NaN too)
                                                #Operator:
                                                #  + - * / %
                                                #  -NUM
                                                #  NUM++ --NUM etc.
                                                #  ~ & ^ | >> << (bitwise)
                                                #  >>>  (like >>, but shiftes zeroes on the left)
                                                #  OP=  (e.g. NUM += 2 or NUM %=10)

BOOL                                            #true|false
                                                #Operators:
                                                #  ! && ||

STR                                             #"STR"|'STR' (same, except for " or ' escaping)
                                                #Any backslash escape, except \a, \c et \e
                                                #Can use Unicode chars or \uXXXX.
                                                #Operators:
                                                #  STR + STR2
                                                #  STR += STR2

undefined                                       #Valeur par défaut:
                                                #  - non-declared VAR: throw ReferenceError when used, except with typeof
                                                #  - declared but non-defined VAR
null                                            #Special keyword indicated emptiness


TEST                                            #Native types:
                                                #  - == != < <= > >= (transtypes)
                                                #  - === !== (does not transtype)
                                                #OBJ:
                                                #  - == === != !== (only check same reference)
                                               ##  - $.isEmptyObject(VAL): equal to {} (jQuery)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          TRANSTYPING          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


IMPLICIT ==>                                    #To STR:
                                                #  - NUM|BOOL|undefined|null: "NUM"
                                                #  - OBJ: OBJ.toString()
                                                #To NUM:
                                                #  - STR: '' 0, '...' NaN
                                                #  - BOOL: true 1, false 0
                                                #  - undefined: NaN
                                                #  - null: 0
                                                #  - OBJ: OBJ.valueOf()
                                                #To BOOL:
                                                #  - STR: '' false, '...' true
                                                #  - NUM: 1 true, 0 false
                                                #  - undefined|null: false
                                                #  - OBJ: true
                                                #To OBJ
                                                #  - NUM|STR|BOOL: use Number|String|Boolean()
                                                #  - undefined|null: throws error
                                                #To null|undefined:
                                                #  - undefined|null: null|undefined

EXPLICIT ==>                                    #To BOOL: !!VAL, Boolean(VAL)
                                                #To NUM;
                                                #  - +VAL, Number(VAL), VAL*1, VAL/1, ~~VAL, VAL|0, VAL-0
                                                #  - parseFloat(VAL): same but:
                                                #     - removes trailing non-numerical chars in STR
                                                #     - only understands decimal form
                                                #     - returns NaN for non-NUM|STR
                                                #  - parseInt(VAL[, NUM]): same as parseFloat() but:
                                                #     - removes decimals
                                                #     - understands any radix form. If NUM, forces radix
                                                #To STR: VAL + '', String(VAL)
                                                #To OBJ: [new ]Object(VAL): null|undefined -> {}


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:       BASIC STATEMENTS        :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


RESERVED WORDS ==>                              #enum, await, implements, package, protected, public, private, interface, static

STATEMENT;                                      #; optional, but recommended in case could be interpreted as multiline

STATEMENT\                                      #Only required for multiline statements:
                                                #  - within a STR
                                                #  - if first line could be interpreted as standalone statement.

// COMMENT
/* COMMENT */

"use strict";                                   #Start strict mode, meaning strict ES6 conformance.
                                                #Must in top scope of a function|script|"CODE", before any statement.
                                                #Concatenating with other scripts make them strict too.
                                                #Allows faster optimization by browsers.
                                                #Not compatible until IE10.
                                                #In the web console, use an anonymous function in order to use strict mode.
                                                
var VAR[ = VAL]                                 #Declaration. Default value is undefined.
  [, VAR2[ = VAL2]]...                          #VAR must be [[:alnum:]$_], can't begin with number, can include Unicode.
VAR = VAL;                                      #Assignation. Returns VAL, so chain possible: VAR = VAR2 = VAL

delete OBJ.VAR                                  #Like assigning undefined except:
                                                #  - remove key as well
                                                #  - cannot be performed if non-configurable
                                                #  - can be performed if non-writable
                                                #Note: for ARR[NUM], does not modify length (like assigning undefined)
                                                #Returns true if OBJ (not OBJ.VAR) exists.

void STATEMENT                                  #Same as STATEMENT, but returns undefined

eval("STATEMENT...")                            #Fire STATEMENT... in current scope. To avoid.
                                                #If argument non STR, renvoie VAL.
                                                #"VAR = VAL" does not declare anything.
                                                #Can throw SyntaxError or EvalError.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           FUNCTIONS           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


FUNC                                            #Is OBJ, so can be assigned.
Function                                        #FUNC TYPE  
function [FUNC]([...]) { ... [return VAL;] ... }#Declare and returns FUNC.
                                                #See "Scope" above.
[new ]Function([...,]'...')                     #Same as function(...) { ... } but:
                                                #  - scope will be child of global scope.
                                                #  - body is STR can be dynamically created. Can create injection risk.
                                                #Use only if really necessary.

FUNC([VAL]...)                                  #Fire FUNC and returns its return value
                                                #Arguments:
                                                #  - positional
                                                #  - extra parameters do not fire exceptions
                                                #  - non-OBJ are passed by value, but OBJ always by reference:
                                                #     - including in assignment
                                                #     - left-hand value keeps reference to right-hand value, but not inverse
                                                #        - i.e. assigning to an OBJ argument removes precedent reference:
                                                #            function(OBJ){ OBJ = OBJ2 }     // Removes OBJ reference
                                                #            function(OBJ){ OBJ.VAR = VAL }  // Keep OBJ reference
arguments                                       #Contains currently passed arguments
                                                #  - can only use arguments[NUM] and arguments.length
                                                #  - can be converted to ARR with Array.prototype.slice.call(arguments)
                                                #  - readonly
FUNC.length                                     #Number of required arguments
FUNC.toString()                                 #Returns source code.

this                                            #OBJ if current function fired as OBJ.FUNC(), otherwise null|undefined
                                                #Read-only
                                                #Notes:
                                                #  - var FUNC2 = OBJ.FUNC or FUNC3(OBJ.FUNC)
                                                #     - must OBJ.FUNC.bind(OBJ) to keep "this"
                                                #  - var OBJ = new FUNC(): 
                                                #     - actually does OBJ.constructor = FUNC; OBJ.constructor()
                                                #     - so "this" is OBJ
FUNC.bind(VAL[, ...])                           #Returns FUNC, but binds "this" to VAL, and first arguments to ...
                                                #VAL does not have to be OBJ|null|undefined
FUNC.call(VAL[, ...])                           #Same as FUNC.bind(VAL[, ...])()
FUNC.apply(VAL[, ARR])                          #Same but using an ARR instead of comma-separated arguments.
                                                #Often used to forward to another function: FUNC.apply(this, arguments)


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            OBJECTS            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


Object                                          #Base TYPE of all OBJ

OBJ.VAR                                         #Access property (can be any type)
OBJ['VAR']                                      #OBJ.VAR has same naming restrictions as var VAR, but not 'VAR'

{ VAR: VAL ... }                                #Literal OBJ.
                                                #If could be interpreted as a { ... } structure (e.g. beginning of line), wrap with ()      

ITERATING OVER PROPERTIES ==>                   #                    +-------------------------------+---------------------------+
                                                #                    | Own                           | Own+shared                |
                                                # +------------------+-------------------------------+---------------------------+
                                                # | enum             |Object.keys(OBJ)               | for ('VAR' in OBJ)        |
                                                # +------------------+-------------------------------+---------------------------+
                                                # | [non-]enum       |Object.getOwnPropertyNames(OBJ)| 'VAR' in OBJ              |
                                                # +------------------+-------------------------------+---------------------------+

Object.keys(OBJ)                                #Returns own keys, excluding non-enumerable
Object.getOwnPropertyNames(OBJ)                 #Returns own keys, including enumerable
OBJ.propertyIsEnumerable('VAR')                 #Returns true if OBJ['VAR'] is in Object.keys()
OBJ.hasOwnProperty('VAR')                       #Returns true if OBJ['VAR'] is in Object.getOwnPropertyNames()

'VAR' in OBJ                                    #Returns true if OBJ['VAR'] is member, including shared or non-enumerable.
                                                #Negation: !('VAR' in OBJ)
                                                #Note: for (var STR in OBJ) includes shared, but excludes non-enumerable 


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:      OBJECT DESCRIPTORS       :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


{ get|set VAR: FUNC() ... }                     #Like { VAR: FUNC() } followed by Object.defineProperty()

Object.defineProperty(OBJ, 'VAR', OBJ2)         #Assign OBJ['VAR'] = VAL, where VAL depends on OBJ2 ('descriptors'):
                                                #  - either:
                                                #     - value VAL (def: undefined)
                                                #     - get()->VAL and set(VAL), fired at OBJ.VAR and OBJ.VAR = VAL
                                                #  - writable BOOL (déf: false): 
                                                #     - if false, OBJ.VAR = VAL returns VAL but does not modify OBJ.VAR
                                                #     - not possible with get|set()
                                                #  - enumerable BOOL (déf: false): if false, not listed by Object.keys(),
                                                #    OBJ.propertyIsEnumerable() and for (var STR in OBJ)
                                                #  - configurable BOOL (déf: false): 
                                                #     - if false, cannot call delete OBJ.VAR nor 
                                                #       Object.defineProperty(OBJ, 'VAR', OBJ2)
                                                #     - if get|set(), often non-configurable
                                                #     - non-writable implies non-configurable?
                                                #When fired several times, each call only overwrite the specified descriptors.
Object.defineProperties(OBJ2, OBJ)              #Pareil mais utilise un OBJ d'OBJ pour plusieurs VAR.STR, comme dans
                                                #Object.create()
                                                #OBJ contient des OBJ, dont chaque désigne un nouveau membre pour VAR2.
                                                #Ex. d'OBJ : {VAR: {value: VAL, writable: BOOL}...}
Object.getOwnPropertyDescriptor(OBJ, STR)       #Renvoie les descriptors de OBJ.STR (si own [non-]enum member), sous forme d'OBJ2.


Object.preventExtensions(OBJ)                   #Make OBJ non-extensible (non-writable for new properties)
                                                #Not recursive.
Object.isExtensible(OBJ)                        #

Object.seal(OBJ)                                #Make OBJ non-configurable and non-extensible.
                                                #Not recursive.
Object.isSealed(OBJ)                            #

Object.freeze(OBJ)                              #Make OBJ non-configurable and non-writable.
                                                #Not recursive.
Object.isFrozen(OBJ)                            #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          INHERITANCE          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


OBJ.__proto__                                   #When OBJ.VAR is not defined:
Object.getPrototypeOf(OBJ)                      #  - tries OBJ.__proto__.VAR
                                                #     - if OBJ.__proto__
                                                #     - then tries OBJ.__proto__.__proto__.VAR, etc. (prototype chain)
                                                #  - by convention, each __proto__ points to a TYPE.prototype 
                                                #    (first TYPE, then TYPE_PARENT, etc.)
                                                #Object.getPrototypeOf() is more standard.
Object.create(TYPE.prototype[, OBJ])            #Returns OBJ2 { __proto__: TYPE.prototype }, then calls
                                                #Object.defineProperties(OBJ2, OBJ)
new TYPE(...)                                   #Does:
                                                #  var OBJ = Object.create(TYPE.prototype);
                                                #  if (!OBJ.constructor) OBJ.constructor = TYPE;
                                                #  var ret = OBJ.constructor(...);
                                                #  return ret == null ? OBJ : ret;
                                                #TYPE is constructor function. By convention starts with uppercase
                                                #Requires:
                                                #  - TYPE.prototype OBJ: contains shared members
                                                #  - TYPE.prototype.constructor === TYPE: for type information (optional)

INHERITANCE ==>                                 #Prototype-based, using either:
                                                #  - own/dynamic members:
                                                #     - accessed directly on OBJ: 
                                                #        - TYPE(...) assigning this OBJ (or returning OBJ)
                                                #     - inheritance: children constructor fire parent constructor
                                                #     - created each time new TYPE(...) is fired
                                                #        - i.e. one object per instance
                                                #  - shared/static members:
                                                #     - accessed|inherited through prototype chain
                                                #     - created once declaration-time
                                                #        - i.e. single reference for all instances
                                                #Example:
																								#  function TYPE(...) { 
																								#    TYPE_PARENT.apply(this[, ...])  
																								#    this.VAR = ...; ...
																								#  }
																								#  TYPE.prototype = Object.create
																								#    (TYPE_PARENT.prototype)
																								#  TYPE.prototype.constructor = TYPE               

STATIC MEMBERS ==>                              #Own members of TYPE itself, i.e. TYPE.VAR = VAL:
                                                #  - not inherited
                                                #  - must be called on TYPE itself, not an instance

NATIVE OBJS ==>                                 #Le constructor des native objects, plutôt que d'assigner les membres de this,
                                                #construit et renvoie un objet (comme new). En conséquence, TYPE.call(this)
                                                #ignore this, et construit un objet non utilisé par la fonction parente.
                                                #Pour hériter de native objects:
                                                #  var VAR = NATIVE_TYPE();
                                                #  NATIVE_TYPE.VAR2 = VAL2;
                                                #  return NATIVE_TYPE;
                                                #De même, ne pas faire new NATIVE_TYPE(), mais NATIVE_TYPE() (sauf DATE et 
                                                #NUMBER)

require("util").inherits(TYPE, TYPE_PARENT)    ##For Node.js:
                                               ##  TYPE.prototype = Object.create(TYPE_PARENT.prototype);
                                               ##  TYPE.prototype.constructor = TYPE;
                                               ##  TYPE.super_ = TYPE_PARENT;
                                               ##So only need: if dynamic members, setting TYPE constructor, which should call
                                               ##TYPE.super_.call(this[, ...]);

MULTIPLE INHERITANCE ==>                        #Pour:
                                                #  - dynamic members: calling TYPE_PARENT1() and TYPE_PARENT2() dans TYPE().
                                                #  - static members: more problematic. Can't add several TYPE_PARENT in the
                                                #    prototype chain. One solution is to add TYPE_PARENT1 in the prototype
                                                #    chain, and add TYPE_PARENT2 prototype properties to TYPE: becomes
                                                #    own static members instead of shared static members ("mixin").
$.extend([BOOL, ]OBJ, OBJ2...)                 ##Merge les propriétés (hérités ou non) de l'ensemble des OBJ2 dans OBJ, et le
                                               ##renvoie (jQuery)
                                               ##Si OBJ.VAR et OBJ2.VAR existent tous deux :
                                               ##  - si false (déf), OBJ2.VAR overwrite OBJ.VAR
                                               ##  - si true, deep merge de OBJ2.VAR et OBJ.VAR
$.fn.extend(OBJ)                               ##Same as $.extend(OBJ, $.fn) : rajoute méthode jQuery ($.fn is jQuery 
                                               ##prototype) à OBJ. (jQuery)


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          STRUCTURES           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


SINGLE LINE ==>                                 #All blocks can be erased if only on single next line. But avoid it.

{ ... }                                         #

if ( TEST ) 
{ 
  ...  
}
[else if ( TEST ) 
{ 
  ...  
}]... 
[else 
{ 
  ...  
}]

TEST ? VAL1 : VAL2                              #Comme en C
TEST ? ( STATEMENT... ) : ( STATEMENT2... )

TEST && STATEMENT
TEST || STATEMENT                               #And/or chains

STATEMENT1, STATEMENT2                          #Evalue deux STATEMENT mais ne renvoie que STATEMENT2. Avoid it.

switch (VAR)
{
  case STR:
      ...
      [break;]
  ...
  default :
      ...
      break;                                    #Exécute next case (sans passer le test) si absence de break. But est de mettre
}                                               #plusieurs case STR: se suivant pour une alternative.

for ( [STATMT1]... ; [STATMT2]... ; 
      [STATMT3]... ) { }                        #Can use let in STATEMENT1
for ( var STR in OBJ ) { }                      #Iterate over enumerable keys (including static, shared)
                                                #OBJ peut être ITERATOR.
while ( TEST ) { }
do { } while ( TEST ) 

break [LABEL]                                   #Stoppe la boucle for, while ou switch courante.
                                                #Pour stopper une boucle de niveau supérieure, celle-ci doit être précédée de
                                                #LABEL:, e.g. :
                                                #  - LABEL: for ...
                                                #  - LABEL:
                                                #      for ...
                                                #Avoid using labels.
continue [LABEL]                                #Retourne au début de la boucle.



                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            ERRORS             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


ERRORS ==>                                      #Exception-based.
throw VAL                                       #Lance exception VAL.
try
{
  ...
}
[catch ( VAR [if TEST] )
{
  ...                                           #Si exception thrown in try-block, exécute catch-block avec EXCEPTION VAL in
}]                                              #VAR. Un seul bloc catch that catches all exceptions.
[finally                                        #finally-block always executed avec ou sans exception. Pour statements toujours
{                                               #effectués, avec ou sans exceptions (par exemple close the files).
  ...                                           #TEST est souvent VAR instanceof EXCEPTION
}]                                              

Error                                           #Base classe des erreurs. Enfant de FUNCTION.
                                                #Uncaught exceptions are better shown in browsers when they are instances of ERROR.
ERROR(STR)                                      #Remplie .message avec STR
ERROR.name                                      #"Error" (redéfinie par classes enfants avec leur propre nom)
ERROR.message                                   #Description de l'erreur.
ERROR.toString()                                #Renvoie "name: message", often with stack as well
                                                #Stack is using FUNC.name, and is constructed when ERROR is.

TypeError                                       #Erreur quand fonction reçoit un argument du wrong type. Enfant d'ERROR.
ReferenceError                                  #Erreur quand déréférence une VAR est undeclared (et non undefined).
                                                #Enfant d'ERROR.
SyntaxError                                     #Enfant d'ERROR.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            BOOLEAN            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/

Boolean                                         #Objet, non type simple BOOL. Enfant de Function.
BOOLEAN(VAL)                                    #Renvoie BOOL, non BOOLEAN
                                                #Not really useful.

                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            NUMBER             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/

Number                                          #Objet, non type simple NUM.
Number[(VAL)]                                   #Utiliser new.

NUMBER.toFixed([NUM])                           #Renvoie sous forme de STR, avec décimale notation (NUM décimales)
NUMBER.toExponential([NUM])                     #Pareil pour exponential
NUMBER.toPrecision([NUM])                       #Pareil, avec une précision décimale de NUM.

Number.MIN_VALUE
Number.MAX_VALUE
Number.POSITIVE_INFINITY
Number.NEGATIVE_INFINITY
Number.NaN                                      #Préférer Infinity, -Infinity et NaN


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            STRING             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


String                                          #Objet, non type simple STR.
                                                #STRING est en fait une ARRAY_LIKE de chars.
String[(VAL)]                                   #Déf: ""
                                                #En dehors des types simples (dont STR), utilise OBJ.toString(). 
                                                #Si pas utilisé avec new, renvoie STR, non STRING.
                                                #STRING semble supporter Unicode chars, compris comme un seul char.
String.fromCharCode(NUM...)                     #Renvoie STR avec Unicode codepoint NUM...

STRING[NUM]                                     #Read-only. undefined if out of range.
STRING.charAt(NUM)                              #Same except "" if out of range
STRING.charCodeAt(NUM)                          #Unicode codepoint.

String.length                           

STRING.localCompare(STRING2)                    #Correct way to compare STRING : renvoie -1, 0 ou 1.
                                                #<, >, ==, etc. suffisent pour STR cependant (mais prennent pas en compte
                                                #locales)

STRING.match(REGEXP)                            #Comme REGEXP.exec(STRING), sauf que si g flag, renvoie ensemble des 
                                                #occurences dans l'ARRAY.
STRING.search(REGEXP)                           #Renvoie index de première occurence de REGEXP dans STRING (-1 si absent)
STRING.replace(REGEXP,STR)                      #Renvoie STRING, avec replacement de REGEXP par STR.
                                                #STR peut contenir :
                                                #  - $& : match total
                                                #  - $1, etc. : match (...) numéro 1, etc.
                                                #  - $` : caractères précédant match total
                                                #  - $' : caractères suivant match total
                                                #  - $$ : $ littéral
STRING.replace(REGEXP,FUNC)                     #Renvoie STRING, avec replacement de REGEXP par FUNC($&,$1...,INDEX,STRING).
                                                #INDEX est STRING.search(REGEXP). Le nombre de $1 dépend de nombre de (...).
                                                #FUNC peut omettre des arguments (à partir de la fin).
STRING.split(REGEXP[, UINT])                    #Renvoie une ARRAY splittant STRING, avec comme délimiteur REGEXP et, si UINT,
                                                #ne renvoie que les UINT premiers éléments.

STRING.to[Locale][Upper/Lower]Case()            #Renvoie sans modifier. Préférer avec Locale
STRING.trim()                                   #Remove whitespaces on left and right.

STRING.concat(STR...)                           #Préférer + et +=
STRING.[lastI/i]ndexOf(STR[, NUM])              
STRING.slice(NUM[, NUM2])                       #Comme pour ARRAY

STRING.substring(NUM[, NUM2])                   #Comme .slice sauf que :
                                                #  - NUM2 négatif -> 0
                                                #  - Si NUM2 < NUM, swappe NUM et NUM2

RegExp                                          #Can be expressed sous forme de REGEXP_LIT via /STR/[FLAGS]
                                                #Ex: var VAR = /.*/;
                                                #RegExp étendues avec quelques ajouts :
                                                #  - \w \W \s \S \d \D
                                                #  - \1 \2 etc.
                                                #  - Pas de \< \>
                                                #  - ^ et $ indiquent ensemble de STR, quel que soient newlines.
                                                #FLAGS possibles : 
                                                #  - g i : comme sed
                                                #  - m : on multiple lines (doesn't seem to change anything)
REGEXP(STR[, STR2])                             #STR2 sont les flags
                                                #STR Need to escape backslashes
                                                #Should escape all regex symbols before (unless intended as regex symbols) : 
                                                #  STR.replace( /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&" )
REGEXP.ignoreCase
REGEXP.global
REGEXP.multiline                                #Presence du flag sous BOOL
REGEXP.source                                   #STR d'origine.
REGEXP.lastIndex                                #Utiliser avec exec et test : si flag g, ne fait qu'une recherche, mais 
                                                #fera prochaine recherche après dernier caractère matché (indiqué par
                                                #lastIndex sous NUM)

REGEXP.exec(STR)                                #Search REGEXP in STR et renvoie ARRAY :
                                                #  - ARRAY[0] est le total match
                                                #  - ARRAY[n] sont les matches des (...) dans REGEXP (s'il y en a)
                                                #  - ARRAY.index est l'index du premier (Unicode) char matché
                                                #  - ARRAY.input est STR
                                                #Si ne trouve rien, renvoie null
REGEXP.test(STR)                                #Renvoie true si STR contient REGEXP.
                                                #Utiliser REGEXP.lastIndex

en|decodeURI(STR)                               #Percent encore all non-ASCII chars
                                                #To use in a URI to escape its data
                                                #decodeURI() can throw URIError
en|decodeURIComponent(STR)                      #Percent encode all non-ASCII chars, plus ? & = # + $ ; , / : @
                                                #To use in the data part of an URI


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             ARRAY             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/

Array                                           #Array are objects. Indexs sont en fait des properties names (internally)
                                                #Eviter for ( in ) qui énumera également les membres d'ARRAY (hors indexs)
Array(VAL...)                                   #Equivaut à [ VAL... ]
[ [VAL]... ]                                    #ARRAY. Peut être left-head : écriture et [...].FUNC()
                                                #VAL est par défaut undefined.
                                                #Peut contenir types différents.
Array(NUM)                                      #Renvoie ARRAY avec NUM éléments undefined.
                                                #Throw RangeError if non-positive or decimal.

Array.isArray(VAL)                              #Renvoie true si ARRAY (non enfant d'ARRAY)

ARRAY = ARRAY                                   #Assignation
                                                #Plutôt que de faire ARRAY = [ "STR", "STR2", "STR3", ... ], écrire
                                                #[ "STR STR2 STR3" ].split( " " ) si c'est qu'une seule fois, car plus simple
                                                #à écrire.
ARRAY[UINT]                                     #Déférencement. Index commence à 0. Si hors bound, renvoie undefined.
ARRAY[STR]                                      #Array associative. En fait, équivaut à ARRAY.STR. Préférer utiliser un OBJET
                                                #si seulement array associative.

ARRAY.length                                    #Il est possible de modifier pour étendre (avec des undefined) ou tronquer.

ARRAY.concat(VAL)                               #Renvoie ARRAY avec élément VAL (ou ARRAY2) à la fin d'ARRAY.
$.merge(ARRAY,ARRAY2)                          ##Concatène ARRAY2 à ARRAY, et renvoie ARRAY (jQuery).
ARRAY.slice(NUM[,NUM2])                         #Renvoie copy of ARRAY, de l'élément NUM à NUM2 (déf: fin). 
                                                #Si NUM2 négatif, signifie numéro de l'élément depuis a fin d'ARRAY.
ARRAY.splice(NUM, NUM2[, VAL...])               #Supprime et renvoie les NUM2 éléments après l'élement numéro NUM, et les 
                                                #remplace par VAL...
ARRAY.join([STR])                               #Renvoie ARRAY concaténés sous forme de STR, avec comme délimiteur STR
                                                #(déf: ,)

ARRAY.push(VAL)                                 #Rajoute ARRAY avec élément VAL à la fin d'ARRAY.
                                                #Renvoie ARRAY.length
ARRAY.pop()                                     #Supprime dernier élément. Renvoie ARRAY.length
ARRAY.unshift(VAL)                              #
ARRAY.shift()                                   #Comme push/pop, mais pour premier élément.

ARRAY.reverse()                                 #Modifie et renvoie.
ARRAY.sort([FUNC])                              #Modifie et renvoie.
                                                #Peut donner une fonction de comparaison FUNC(VAL,VAL2), renvoyant 1 si a>b,
                                                #-1 s a<b, 0 si a==b
                                                #Comparaison est STR. Pour sort des nombres, utiliser FUNC :
                                                #function(a,b) { return a == b ? 0 : ( a < b ? -1 : 1 ) }
                                                
ARRAY.indexOf(VAL[, NUM])                       #Renvoie position de VAL dans ARRAY (si NUM, skippe les NUM premiers éléments).
                                                #-1 si pas trouvé.
ARRAY.lastIndexOf(VAL[, NUM])                   #Pareil, mais position depuis la fin.

ARRAY.forEach(FUNCTION[, VAL])                  #Exécute FUNCTION(VAL2[, NUM[, ARRAY2]]) pour chaque VAL2 d'ARRAY.
                                                #NUM est l'index de l'élement. ARRAY2 est ARRAY.
                                                #VAL est this au sein de FUNCTION
ARRAY.map(FUNCTION[, VAL])                      #Pareil, mais renvoie également la concaténation des return value des 
                                                #invocation de FUNCTION.

ARRAY.reduce[Right](FUNC[, VAL])                #Exécute FUNCTION(VAL3,VAL2[, NUM[, ARRAY2]]) sur chaque VAL2 d'ARRAY de 
                                                #manière consécutive, où VAL3 est le résultat de l'exécution précédente.
                                                #Renvoie résultat VAL4 final.
                                                #VAL est la VAL3 initiale (déf: 0)
                                                #reduceRight va de droite à gauche.
ARRAY.filter(FUNC[, VAL])                       #Renvoie éléments dans ARRAY répondant true à FUNC(VAL2[, NUM[, ARRAY2]]).
                                                #VAL est this au sein de FUNCTION
ARRAY.every(FUNC[, VAL])                        #Renvoie true si FUNC(VAL2[, NUM[, ARRAY2]]) de chaque VAL2 d'ARRAY renvoie 
                                                #true.
                                                #VAL est this au sein de FUNCTION
ARRAY.some(FUNC[, VAL])                         #Pareil mais si au moins un renvoie true.

MULTIDIMENSIONAL ARRAYS ==>                     #Utiliser des ARRAY d'ARRAY : VAR[NUM][NUM2]


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:         TYPED ARRAYS          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


ArrayBuffer                                     #Bytes chunk. Needs an ARRAYBUFFERVIEW to be manipulated.
                                                #Several ARRAYBUFFERVIEW can be applied to a single ARRAYBUFFER.
ARRAYBUFFER(UINT)                               #UINT is byteLength
ARRAYBUFFER.byteLength                          #Readonly.
ArrayBufferView                                 #A view is linked to an ARRAYBUFFER and has : 
                                                #  - a specific type to read it
                                                #  - an offset from the beginning of it
ARRAYBUFFERVIEW.buffer                          #The ARRAYBUFFER. Readonly
ARRAYBUFFERVIEW.byteLength                      #ARRAYBUFFER.byteLength. Readonly.
ARRAYBUFFERVIEW.byteOffset                      #The offset, in bytes.

[Ui|I]nt8|16|32Array                            #
Float32|64Array                                 #Enfant d'ARRAYBUFFERVIEW avec un type précis.
*ARRAY.BYTES_PER_ELEMENT                        #Byte length du type
*ARRAY(UINT)                                    #Constructor vide.
*ARRAY(ARRAY)
*ARRAY(*ARRAY2)                                 #Copy constructor
*ARRAY(ARRAYBUFFER[, UINT[, UINT2]])            #UINT est l'offset en byte (déf: 0) et UINT2 la taille en byte (déf: all), pour
                                                #pouvoir tronquer.
*ARRAY[UINT]                                    #
*ARRAY.set(ARRAY|*ARRAY2[, UINT])               #Remplace une partie d'*ARRAY avec ARRAY|*ARRAY2, depuis élément UINT (déf: 0)
*ARRAY.subarray(UINT[, UINT2])                  #Renvoie seulement de l'octet UINT à UINT2 (exclus) (déf: fin)

Array.apply([], *ARRAY)                         #Convertit en ARRAY

DataView                                        #Enfant d'ARRAYBUFFERVIEW avec types changeants.
DATAVIEW(ARRAYBUFFER[, UINT[, UINT2]])          #Comme *ARRAY
DATAVIEW.get[Ui|I]nt8|16|32([UINT[, BOOL]])     
DATAVIEW.getFloat32|64(UINT[, BOOL])            #UINT est l'offset en byte et BOOL l'endianness (déf: true, little endian)
DATAVIEW.set*(UINT, UINT2[, BOOL])              #UINT est l'offset en byte (attention) et UINT2 la valeur à mettre.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             DATE              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/

Date                                            #Stored internally as number of seconds since Epoch. Enfant de Function.
                                                #Granularité est millisecondes.
                                                #Constructor sans new renvoie sous forme de STR. Avec new une DATE.
DATE(YEAR,MONTH,DAY,HOUR,MIN,SEC,MILLISEC)      #Chaque final argument est optionnel. (local)
DATE(STR)                                       #Essaie de parser. Sinon DATE = InvalidDate (local)
DATE()                                          #Now (local), as STR


DATE.*et[UTC][Time/FullYear/Month/Date/Day/     #Date est jour du mois, Day jour de la semaine (0 dimanche)
Hours/Minutes/Seconds/Milliseconds/             #Time est nombre de secondes depuis Epoch
TimezoneOffset]()                               #TimezoneOffset est en minutes.
                                                #Si UTC : non-local mais UTC time.
                                                #Pour set* : si month, etc. dépasse du max., prend sur l'année, etc. suivante.
                                                #set* renvoie DATE.getTime()

DATE.parse(STR)                                 #Equivaut à new DATE(STR).getTime()
Date.UTC(ARGS)                                  #Comme new DATE(ARGS).getTime(), mais UTC-time.
Date.now()                                      #Equivaut à new DATE().getTime()

DATE.to[locale][ISO/UTC/Date/Time]String()      #Plusieurs formats :
                                                #  - normal : "Day Mon DD YYYY HH:MM:SS TZ"
                                                #  - Date : "Day Mon DD YYYY"
                                                #  - Time : "HH:MM:SS TZ"
                                                #  - ISO : "YYYY-MM-DDTHH:MM:SS.SSSZ"
                                                #  - UTC : "Day, DD Mon YYYY HH:MM:SS TZ" (UTC)
                                                #locale rajouteoptions pour timezones ou calendriers différents.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             MATH              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


Math                                            #A des méthodes, mais n'est pas utilisé comme objet lui-même.

Math.pow(NUM1,NUM2)
Math.min(NUM...)
Math.max(NUM...)

Math.abs(NUM)
Math.ceil(NUM)                                  #Troncature supérieure
Math.floor(NUM)                                 #Troncature inférieure
Math.round(NUM)                                 #Troncature nearest

Math.PI
Math.E
Math.LN2                                        #ln(2)
Math.LN10                                       #ln(10)
Math.LOG2E                                      #log2(e)
Math.LOG10E                                     #log10(e)
Math.SQRT2
Math.SQRT1_2

Math.sqrt(NUM)
Math.exp(NUM)
Math.[a][sin/cos/tan[2]](NUM)

Math.random()                                   #Renvoie PRN entre 0 et 1. Seeded from current time.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             JSON              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


JSON ==>                                        #Un peu comme XML, sert à sérialiser objets.
                                                #Extension est ".json"
                                                #Est en fait même notation qu'un OBJ littéral, avec comme différence :
                                                #  - VAR: VAL -> "VAR": VAL
                                                #  - pas de leading zeros sur les NUM
                                                #  - seuls échappement backslash : \", \\, \b, \f, \n, \r, \t, \uXXXX
                                                #  - pas de undefined, ni de fonction, ni other native objects (regex, etc.)
                                                #    - cependant, il est possible de convertir en STR via une FUNC dans
                                                #      .stringify()
                                                #    - Date supportées car DATE.toJSON() existe
                                                #Peut également être un VAL (dont [...]) au lieu de { VAL }
JSON                                            #Parser de JSON. A préférer à eval() ou à d'autres parsers. Enfant d'Object.
JSON.parse(STR[, FUNC])                         #Renvoie la conversion de JSON STR en VAL
                                                #Si FUNC, exécute FUNC(key,value) pour parser chaque value (avec this étant à
                                                #chaque fois le parent direct). Reste est comme FUNC de stringify.
                                                #Peut throw SyntaxError.
JSON.stringify(VAL[,VAL2[,VAL3]])               #Renvoie la conversion de VAL en JSON sous forme de STR
                                                #undefined, fonction, non supported objects -> omitted or converted to null
                                                #Si VAL2, peut être :
                                                #  - une FUNC(key,value) : chaque propriété passera par la fonction et :
                                                #      - la return value, transtyped vers STR, sera la value stringified pour
                                                #        cette propriété
                                                #      - si return value est undefined, skippe la propriété
                                                #    Pour un array key est le NUM, pour un objet c'est le name STR.
                                                #    L'objet global passe par la fonction à la fin (sa key est "")
                                                #  - une ARRAY de STR désignant les names des propriétés à inclure. Non
                                                #    récursif. Pour inclure enfant, parent doit être inclus.
                                                #Si VAL3, indente avec VAL3 (STR si STR, NUM spaces si NUM) et rajoute
                                                #newlines.
                                                #Si VAL.toJSON() existe, au lieu d'utiliser VAL, utilisera return value de 
                                                #VAL.toJSON().


