
          
   HTTP   
          



Architecture:
  - version 2
     - HTTP/2 uses ALPN for client to let server know support
  - layers:
     - application layer
     - usually on top of TCP/IP
        - SSDP is like HTTP, but above UDP
     - TLS:
        - HTTP/2: not required by specs, but browser implementation does
        - HTTP/1.*: not required
  - client-server:
     - client: "user agents", e.g. web browser, web crawler, app, etc.
     - resource can be dynamic (server modifies content) or static
  - stateless: 
     - requests independant from each other
     - but URL/headers/payload can keep state (e.g. cookies)
  - session:
     - set of TCP sockets:
        - HTTP/2: one per server, sending unlim HTTP requests (multiplexing)
        - HTTP/1.*: 
           - NUM per domain, sending one HTTP request at a time
           - NUM depends on client (usually 4-8). Can be set with Keep-Alive: max=NUM [S]
           - hostname sharding: using different domains on a server to overcome limit
     - how long:
        - HTTP/*: until Connection: close [C|S]
        - HTTP/1.*: timeout depending on client. Can be set by Keep-Alive: timeout=NUM [S]
        - HTTP/1.0: requires Connection: Keep-Alive [C|S] to remain open
  - subresources:
     - number of concurrent requests per TCP socket: 
        - HTTP/2: multiplexing: unlim with no order
        - HTTP/1.1: pipelining: unlim with head-of-line blocking (answers in same order as requests)
        - HTTP/1.0: serial: one
     - discovery:
        - HTTP/2:
           - client-initiated
           - server hints ("resource hints"), to tell client to initiate request
           - server pushes, that bundle extra subresources:
              - performance:
                 - less roundtrips than resource hints
                 - but should push only resources that would have been requested, e.g. where data URIs would otherwise be used
              - send in order:
                 - what request would look like
                 - response: header then body
              - client caching works the same as normal request
              - need to be initiated by a request (so not realtime)
        - HTTP/1.*: client-initiated only

Request from client (newline is \n\r) :
  - case insensitive
  - headers:
     - HTTP/2: compress HTTP headers (algo is 'HPACK')
     - HTTP/1.*: text HTTP headers
  - HTTP/2 replace status line with headers:
     - request status line with :host: URL [C], :method METHOD [C], :path PATH [C], :scheme: https [C], :version HTTP/1.1 [C]
     - response line with version: HTTP/1.1 [C], status: UINT STR [S]
  - METHODE URL HTTP/1.1
    VAR: VAL... (header fields, separated by newline. Host is mandatory)

    [BODY] (second newline if none)
  - Explication : 
    - METHODE :
      - "safe" (lecture) :
        - GET : ask resource
        - HEAD : ask resource (header only)
        - OPTIONS : ask metadata (e.g. functionalities of web server). Usually use * as URL
        - TRACE : echoes request (to see changes introduced by servers|proxies)
      - "unsafe" (écriture) :
        - idempotent (plusieurs requêtes donnent le même résultat) :
          - PUT : create resource
          - DELETE : erase resource
        - ou non :
          - POST : modify resource completely
          - PATCH: modify resource partially
          - CONNECT: do HTTP Tunneling
    - URL : relatif à DOMAIN, e.g. "/images/image.pgn"
    - Header fields:
      - in theory no limit, but in practice e.g. Apache limits 8MB/header and 1000 headers, Node.js 80KB/header
      - options, VAR: VAL (written [S|C] for server|client in my doc), followed by newlines
    - BODY :
      - data sent from client to server (usually for unsafe methods)

Response from server:
  - HTTP/1.1 UINT STR
    [VAR: VAL...]

    [BODY]
  - Meaning:
    - UINT : 
      - exit code (others are mentioned in this doc)
      - can also use Status: UINT STR [S]:
      - type:
         - 1**: information
            - 100 (Continue): client sent partial request and need to keep going
            - 101 (Switching Protocols): switch protocol success, e.g. from HTTP to HTTPS
            - 102 (Processing): response is ongoing and will take some time to know if success or failure (client should not timeout)
         - 2**: success
            - 200 (OK): simple
            - 201 (Created): new resource (e.g. PUT). Use Location: URL [S] for new resource URL.
            - 202 (Accepted): response is ongoing and will take some time to proccess (client can timeout). Usually response include links to monitor processing status.
            - 203 (Non-Authoritative Information): proxy transformed server response, which was originally 200
            - 204 (No Content): OK, but nothing is to be returned. Client should stay on same resource/document. E.g. successful DELETE, If-Modified-Since header.
            - 205 (Reset content): like 204 but client should reset/refresh current resource/document.
            - 206 (Partial content): response is only a subset of the full resource, e.g. with Range [C]
            - 207???
            - 208???
            - 214 (Transformation applied): proxy transformed server response, which was originally not 200
            - 226???
         - 3**: redirection to be performed by client
            - 300???
            - 301 (Moved Permanently): permanent, GET (whether it was GET or not)
            - 302 (Found): temp, GET (whether it was GET or not)
            - 303 (See other): different resource (not only different URL) than requested
            - 304 (Not Modified): resource did not change  (client should use cache)
            - 305???
            - 307 (Temporary Redirect): temp, same HTTP method
            - 308 (Permanent Redirect): permanent, same HTTP method
         - 4**: client-side failure
            - 400 (Bad request): syntax error
            - 401 (Unauthorized): authentication problem
            - 402???
            - 403 (Forbidden): authorization problem. Prefer 404 when location itself is secret.
            - 404 (Not Found): wrong URL, but correct domain.
            - 405 (Method not allowed): HTTP method not implemented or not allowed
            - 406 (Not Acceptable): wrong requested media type, e.g. Accept [C]
            - 407???
            - 408 (Request Timeout): as opposed to response timeout
            - 409 (Conflict): multi-client conflict
            - 410 (Gone): like 404, but indicates URL was present before
            - 411 (Length Required): missing request body length, e.g. Content-Length [C]
            - 412 (Precondition Failed): resource changed even though client assumed it did not, e.g. with PUT + If-Unmodified-Since [C]
            - 413 (Request Entity too large)
            - 414 (Request URI too long) 
            - 415 (Unsupported Media Type): server does not support requested media type
            - 416 (Requested Range Not Satisfiable): e.g. wrong Range [C]
            - 417 (Expectation failed): e.g. wrong Expect [C]
            - 420???
            - 421???
            - 422 (Unprocessable Entity): request syntactically correct but not semantically
            - 423???
            - 424???
            - 426 (Upgrade Required): switch protocol denied, e.g. from HTTP to HTTPS
            - 428???
            - 429 (Too many requests): throttle
            - 431 (Request header fields too large)
            - 451???
            - 499???
         - 5**: server-side failure
            - 500 (Internal server error): bug in server, e.g. syntax error
            - 501 (Not implemented): feature not available yet
            - 502 (Bad gateway): sent by proxy when it received error from server
            - 503 (Service unavailable): server is down (cannot connect)
            - 504 (Gateway timeout): sent by proxy on server timeout
            - 505 (HTTP version not supported)
            - 506: negotiation circular loop
            - 507???
            - 508???
            - 510???
            - 511???
            - 599???
    - STR: status text
    - Header fields
    - BODY: depends on request

<meta http-equiv="HEADER" content="VAL">:
  - client (not server) will add HTTP HEADER: VAL to the server's response. 
  - Does not always work.

Redirections:
  - Redirection is using Location: URL [S]
     - Can also avoid client redirection by fetching it server-side, but notify with Content-Location: URL [S]
  - More than five redirections is considered infinite loop.
  - Use 3** status codes
  - Refresh: NUM, url=URL [S], like <meta http-equiv="refresh" content="NUM; url=URL"> redirection 
  - Retry-After: NUM|DATE [S], tells client to try again after a specific period of time

Time:
  - Date: DATE [C]: when request was sent 
  - Accept-Datetime [C]: which response it wants, to allow getting older versions.

Sending data:
  - <a|area> click event: change current URL
  - <form> submit event: change current URL (see HTML doc)
  - XHR.send():
     - HTTP request without changing current URL
     - more flexibility on request method|headers|body

Query strings:
  - only advantage over request body is when need to keep state in URL, e.g. bookmark
  - but:
     - it clutters URL, and is bad practice (bad SEO)
     - can grow too big
  - Can use VAR[VAR2]=VAL, but must be supported by server:
     - query string: supported by Express REQ.query
     - request body: supported by Express BODY-PARSER

Software identity:
  - User-agent: STR [C] and Server: STR [S]. Can also instruct rendering engine to client with 
    X-UA-Compatible: BROWSER=VAL [S]
  - X-Powered-By: STR [S], e.g. "PHP/5.4.0"
  - X-Request-With: FUNC (e.g. XMLHttpRequest) [C], often used in AJAX
  - Pragma: VAL [C|S], for server-specific lingo

Client identity:
  - From: EMAIL_ADDRESS [C]

Destination:
  - Host: HOST[:PORT] [C], mandatory. DOMAIN might be case-sensitive on some servers.
     - virtual hosting (several HOST on same machine): 
       - name-based: 
          - using several HOST names under same IP. 
          - Is harder to implement with HTTPS. 
          - When DNS doesn't work, harder to reach directly through IP.
       - IP-based:
          - using one IP by HOST

Content:
  - content negotiation (client gives several options, and server picks one):
     - server-side:
        - Content-Type: MIME_TYPE[; charset=CHARSET] [S]. 
        - Accept: MIME_TYPE and Accept-Charset: CHARSET [C] to notify the server. 
          Server can use status code 415 (Unsupported Media Type)
        - Accept-language: LANGUAGE [C], Content-language: LANG [S]
        - Accept-features: FEATURE [C]
        - each header [C] can be followed by [; q=NUM] to put preferences on each option
        - 406 (Not Acceptable): wrong Accept-* [C]
     - transparent:
        - Negociate [C] then server:
           - respond with normal response body after server-side negotiation
              - unless 300 status code and TCN: list [S], otherwise TCN: choice [S]
           - Alternates: URL,... [S]
           - sends 506 when server has circular references due to choice picking
        - Negociate: VAL [C]:
           - trans: support, but don't ask for it
           - vlist: support and ask for it
        - Goal: not having to send too many Accept* [C], which increase packet size and allow privacy concern (fingerprinting)
        - Problem: need to perform two requests
  - Content-Disposition: attachment[; filename="..."] [S], ask to download with a file chooser
  - Content-Type "multipart/form-data; boundary=STR" [S]:
     - forces download box
     - download box otherwise present on any Content-Type not supported by browser renderer
     - if no filename="...", will create a default one according to Content-Type

Control:
  - Content-MD5: CHECKSUM [C|S], usually with Trailer: HEADER_VAR [S]

Cache:
	- vocabulary:
		 - cache hits ratio: % of requests that could use the cache
		 - stale resources: cached but not valid any more
  - proxy/server caching:
		 - CDN: fast servers for caching, spurned across several geographical regions to be closer to clients
		 - Memcached/Redis are between the server and the DB, while web accelerators are between server and client
		 - proxy caching:
		    - types: 
	 				 - ISP can cache
	 				 - web accelerator: reverse proxy dedicated to caching (closer to end client)
				- Vary: HEADER [S] tells the client to use different entry caches for requests on same URLs but using different
				  request HEADER value.
					Usually used with Vary: Accept-Encoding towards cache proxies, so they don't serve gzipped cache entries to clients
					not able to gunzip, or cleartext cache entries to clients that requested gzipped and will try to gunzip.
					Also sometimes Vary: User-Agent if served files vary according to User-Agent (will increase SEO)
		 - server and proxy caching can cache for all clients based on the request of a single client
	- cache HTTP headers tell browser how to cache given response (if none, browser guess using heuristic, to avoid):
		 - unconditional caching:
				- browser should not ask server and only use cache for a given time period
          Does not apply on page refresh.
				- fastest cache method, but requires timestamp updates, so should be done on asset files (CSS, images, JavaScript,
					etc.) but not HTML (it would break timestamping).
					Usually asset files are in /static PATH on server, and in Express served with static file server, while rest is not.
		    - Cache-Control: STR,... [S] where STR can be:
					 - [s-]max-age NUM: how long to cache
						 "s-" is for cache proxies only like CDN
						 Should not be more than 1 year later, but:
 							 - if fingerstamping ok, should be as long as possible (so should be 1 year)
							 - otherwise, set longest time you estimate clients can have a good experience with a stale resource
					   Can also use instead Expires: DATE [S]:
						   - same but using a given DATE
							 - older header
					 - public|private: can [not] be cached by intermediate proxy, not only end-client:
					    - public: allow proxy caching
							- private: good if data is sensitive, including headers e.g. cookies (even if SSL if the proxy needs to 
							  decrypt/encrypt in the middle)
					 - no-transform: don't allow proxy to recompress images/videos.
					   Some proxies also inject JavaScript code which might mess up with the application.
           - must|proxy-revalidate: 
              - when expires, if conditional caching setup, will do conditional cache request
              - however it is the default of most clients
				- Cache-Control: STR,... [C]:
           - max-age=0: forces all proxies in between to use conditional caching, and server to check if need to respond with 
             304
			 	   - no-cache: forces all proxies in between not to use conditional caching, and server not to respond with 304
				-	timestamping:
				   - using an ID in the URL (e.g. version of JavaScript file). 
					 - When resource changes, change ID, update links to resource.
					 - new calls will get new version (because different URL).
           - query string is taken into account: careful not to timestamp a resource by mistake by unconditionally caching a 
             URL with query string
				- When using conditional caching too (ETag or Last-Modified):
           - unconditional caching has precedence
           - but when unconditional cache expires, uses conditional caching, so good idea to set it
		 - conditional caching:
				- browser should first send request to check if resource has changed. If 304 response, should use cache.
				- best cache method when it's impractical to timestamp, e.g. HTML and AJAX calls.
				  Faster to get 304 response with empty body, and no need for server to fetch data.
				- Headers:
					 - Can be based on (cannot be both):
					    - mtime: Last-Modified: DATE [S], If-Modified-Since: DATE [C]
				      - content hash: ETag: HASH [S], If-None-Match: HASH [C]:
                 - W/"...": weak, which means are just identical semantically, but not byte by byte. Used with dynamic websites
                 - "...": strong
					 - If-Unmodified-Since, If-Match: inverse, e.g. to do PUT only if resource is still the same
             Uses 412 instead of 304
		 - no caching:
		    - faster than conditional caching if resource is never the same (avoid 304 response)
        - often done for security reasons
				- Cache-Control: no-cache, no-store, private, must-revalidate
				  Pragma: no-cache
					Expires: 0
				   - both values are same but for different browsers
					 - Pragma if for HTTP/1.0
        - can use no-cache="HEADER" for a specific header
	 - can see all in chrome://cache on Chrome
	 - security:
	    - client's cache entries containing confidential info (e.g. login info) could be accessed (by exploiting another 
			  vulnaribility or someone else having physical access to computer)
			- POST replay attack: use same URL to authenticate (thanks to cached entry) even if logged out
			- countermeasure: no caching for sensitive body or headers

Long request:
  - sends only header with Expect: "100-continue" [C]
  - server sends 100 (Continue) if success, 417 (Expectation Failed) if failure
  - client sends body

Long response:
  - Content-Length [C|S]: nombre d'octets du BODY:
      - If required, server can send status-code 411 (Length Required) or 413 (Request Entity too large). 
      - There is also (for the URL) 414 (Request URI too long) and 431 (Request header fields too large).
  - Can use Transfer-Encoding: chunked [S] instead, which will send BODY in several times, signalling end by sending empty 
    BODY. 
      - can be requested by TE: chunked [C]
      - Trailer: HEADER_VAR [S], sends additional headers, but at the end.
      - Good for big file or HTTP live streaming (different from HTTP streaming)
      - Should be used with compression
  - Another approach is byte serving: knowing size but dividing it:
     - Range: bytes=NUM-NUM2 [C], and If-Range: ETAG [C] (sends rest if still the same). 
       Accept-Ranges: bytes [S] and Content-Range: bytes NUM-NUM2/TOTAL [S] with status code 206 (Partial content)
       Server can use 416 (Requested Range Not Satisfiable)

Proxies:
  - X-Forwarded-For: HOST... [C], indidates previous clients in a proxy chain.
  - X-Forwarded-Proto: PROTOCOL... [C], same for protocols, when changing protocols along the chain (e.g. HTTP to HTTPS)
  - X-Forwarded-Port: PORT... [C]: same for port
  - Via: HTTP_VERSION URL SERVER ... [C|S], proxies
  - Max-Forwards: NUM [C], max number of proxies

Security: See Websites_security

Tracking:
  - Referer: URL [C], current URL (so new URL can see where navigation originates)
    <link|a rel="noreferrer"> asks client not to send it.
  - DNT: 1 [C], "Do-not-track" tells server:
     - doesn't want any trace/unique ID/cookie that could correlates its visit of different websites
     - this includes tracking cookies, third-party ads tracking, but does not include Google Analytics, user preferences on 
       one site or targetting ads according to one single site preferences
  - Set-Cookie: VAR=VAL;SVAR=VAL;... [S]:
     - Asks client to send Cookie: VAR=VAL[;...] [C] again when visiting a specific path on a specific domain
     - Used to introduce a state: authentication, tracking, etc.
     - One Set-Cookie [S] per cookie, but one Cookie [C] for all cookies
     - VAL are percent-encoded
     - SVAR are:
        - path (récursif) (e.g. "/index.html") et domain (e.g. "www.a.org"):
           - when same as current: first-party cookies, often for authentication or for traffic analytics.
           - when different: third-party cookie
              - often tracking cookies : same domain accross different visited websites to connect different websites 
                someone visits, for advertising purposes
              - needs to trick the browser which otherwise blocks it (can only use cookie from same domain), e.g. hidden 
                iframes.
        - expires|max-age: DATE|NUM secondes before expiration (nothing for end of session). Put to 0 to delete cookie.
        - secure: can only transmit|receive via https.
        - HttpOnly: can't be used via JavaScript (document.cookies) (considered unsecure), can be used e.g. by PHP
     - Zombie cookie :
        - copies in several places.
        - if some absent, reduplicate them 
        - evercookie is an open source implementation
  - Private browsing :
     - a private session erases at the end all the traces (history, cookies, cache) it created.
     - called Incognito in Chrome

Compression:
  - Accept-Encoding: PROGRAM... [C], then Content-encoding: PROGRAM [S]
  - PROGRAM can be: 
      - "identity" (none) 
      - "gzip/deflate": Zlib. Same compression but different header (gzip conserves files info but bigger). 
        However, as a client should ask for gzip, because deflate is handled differently by some servers.
        Other compression methods are way less supported.
      - "bzip2" 
      - "lzma"
      - "shdc": by Google, supported natively by Chrome (seems inactive)
  - server should cache the input/output of compression to avoid doing twice the same compression on same input, because
    compression is long

HTTPS:
  - using HTTP over SSL/TLS over TCP
  - needs to be enable on all website resources, including scripts, all pages, etc., otherwise could attack on specific
    unsecure resources
     - this includes cookies. To have secure cookies, provide the secure attribute, which says it can only be used with HTTPS
  - Strict-Transport-Security: max-age=NUM (seconds from now); includeSubDomains [S]: specify clients it only allows HTTPS 
    connections. Client should resend the request using HTTPS if HTTP was used.
  - Upgrade: PROTOCOL/VERSION [C] is to start a session in HTTP then continue in HTTPS. 
     - Should not be used. Client can just specify https:// to signify it wants HTTPS
     - Server sends 426 if require Upgrade: HTTPS [C]
     - Server sends 101 if switch protocols

Profiling:
  - X-Response-Time: NUM [S]: time taken by server to process answer

REST:
  - X-HTTP-Method-Override: METHOD [C]:
     - tells server that request should be interpreted as if HTTP METHOD has been used. 
	   - goal is to overcome network limitations (firewalls, etc.) protecting client from using methods like PUT, DELETE, etc. 
       on a REST API

Push technologies / server push:
  - allow server to initiate message to client
  - types:
     - short polling with AJAX requests
     - HTTP server push / HTTP streaming: using Transfer-encoding: chunked [S]
     - Comet:
        - Pushlet: leaves HTTP connection open, sending new bits from time to time
        - Long polling: waits for server events to return the reply to client, then ask client to request again. Uses timeouts.
           - BOSH: variation of long polling
     - Server-sent events (SSE)
     - TCP socket used by plugins like Flash or Java: bi-directional
     - Websockets: same idea but standardized

Lower latency (keep TCP connection):
  - Require smaller packets (not HTTP):
     - Websockets: for small messages
     - WebRTC: for video/audio/etc.
  - HTTP/2
  - Link prefetching / resource hints

HTTP Tunneling:
  - client wraps a TCP packet in a HTTP packet request body
  - tells proxy to unwrap HTTP packet and send TCP packet, and wrap received TCP packets as HTTP packet
  - can be used to bypass firewalls
  - CONNECT method:
     - use only first HTTP handshake with proxy, then use TCP connection
     - can be used to access HTTPS using a HTTP proxy (TCP between client-proxy, SSL between proxy-server)
