
          
   HTTP   
          



Headers to check: Age, Allow, Proxy-Authenticate
RFC: 2068, 2227, 2295, 2310, 2616, 2660, 2774, 3229, 3230, 5988
See also: PEP, P3P, DRP (Content-ID), OPS over HTTP (GetProfile), PICSLabels, Selecting Payment Mechanisms (Protocol-Info), Proxy Notification, SOAP, edge-arch, atom publishing protocol, webdav

List of headers:
  - look at individual specs, including HTTP/1.1 spec
  - look at list on hpack spec
  - look at iana list
  - look at status-codes-related RFC (see Wikipedia)
  - finish temp_sync doc
  - go back to CSS architecture to_learn list

Architecture:
  - version 2. To guess support, can use:
     - ALPN, TLS extension (see SSL/TLS doc)
     - Upgrade: h2[c] [C|S] (see below)
        - h2 is HTTS, h2c HTTPS
        - must include SETTINGS frame as HTTP2-Settings [C] (base64-encoded)
        - not supported by most browsers
     - prior knowledge: client already knows server supports HTTP/2
  - layers:
     - application layer
     - usually on top of TCP/IP
        - TCP ports: 80 (HTTP), 443 (HTTPS)
        - SSDP is like HTTP, but above UDP
     - TLS:
        - HTTP/2: 
           - not required by specs, but browser implementation does
           - when used:
              - must use TLS 1.2+ with SNI extension
              - if using TLS 1.2, must disable compression, renegotiation
        - HTTP/1.*: not required
  - URI scheme: http[s]://
  - client-server:
     - client: "user agents", e.g. web browser, web crawler, app, etc.
     - resource can be dynamic (server modifies content) or static
  - state:
     - streams independant from each other
     - but headers/payload can keep state (e.g. cookies)
     - a stream need to keep its own state though
  - session:
     - set of TCP sockets:
        - HTTP/2: 
           - one per host (not hostname) + port
        - HTTP/1.*: 
           - 6 (depends on client) per hostname + port
           - hostname sharding: using different domains on a server to overcome limit
     - parallel requests per TCP socket: 
        - HTTP/2: multiplexing: SETTINGS_MAX_CONCURRENT_STREAMS (def: unlim) with no order (unless client suggest specific order)
        - HTTP/1.1: pipelining: 4-8 (depends on client) with head-of-line blocking (answers in same order as requests)
        - HTTP/1.0: serial: one
     - how long:
        - HTTP/2: 
           - until GOAWAY frame
           - timeout not mandatory nor forbidden
        - HTTP/1.*: 
           - until Connection: close [C|S]
           - timeout 10-15 secs (depends on server). Can be set by Keep-Alive: timeout=NUM [S]
           - NUM requests using Keep-Alive: max=NUM [S]
        - HTTP/1.0: requires Connection: Keep-Alive [C|S] to remain open

Format (HTTP/2):
  - stream: one request+response, or server push:
     - several ordered frames connected by stream ID
     - is what makes multiplexing possible
     - steam ID:
        - 0: hypothetical main stream
        - odd is started by client, even by server
        - incremental ID
  - frames:
     - headers: length [0-2], type [3], flags [4], reserved [5.0], stream ID [5.1-8], payload [*]
     - payload:
        - DATA (0x0): [padding length [0], ]data [*][, padding [*]]
        - HEADERS (0x1): [padding length [0], ][exclusive [1.0], stream parent ID [1.1-4], weight [5]], headers [*][, padding [*]]
        - PRIORITY (0x2): exclusive [0.0], stream parent ID [0.1-3], weight [4]
        - RST_STREAM (0x3): error code [0-3]
        - SETTINGS (0x4): several times: VAR [0-1], VAL [2-5]
        - PUSH_PROMISE (0x5): [padding length [0], ]reserved [1.0], promise stream ID [1.1-4], headers [*][, padding [*]]
        - PING (0x6): data [0-7]
        - GOAWAY (0x7): reserved [0.0], last stream ID [0.1-3], error code [4-7], debug data [*]
        - WINDOW_UPDATE (0x8): reserved [0.0], increment [0.1-3]
        - CONTINUATION (0x9): headers [*]
     - flags:
        - END_STREAM (0x1) (DATA, HEADERS)
        - ACK (0x1) (SETTINGS, PING)
        - END_HEADERS (0x4) (HEADERS, PUSH_PROMISE, CONTINUATION)
        - PADDED (0x8) (DATA, HEADERS, PUSH_PROMISE)
        - PRIORITY (0x20) (HEADERS)
  - init (for each endpoint):
     - start:
         PRI * HTTP/2.0

         SM

     - SETTINGS frame:
        - options, noted SETTINGS_*
        - receiver must respond with empty SETTINGS frame with ACK flag
        - can be sent again later to change settings
  - normal (request/response) stream:
     - request:
        - 1 HEADERS, 0-n DATA (payload), 0-1 trailing HEADERS
        - HEADERS:
           - must contain pseudo-headers: 
               :method METHOD [C] 
               :authority URL [C] 
               :path PATH [C] : can be *
               :scheme PROTOCOL [C]
           - if 1 frame not enough, send extra CONTINUATION frames with extra headers
           - last frame should have flag END_HEADERS
     - response:
        - same but HEADERS must contain instead pseudo-header :status UINT [S]
  - server push stream:
     - enabled by SETTINGS_ENABLE_PUSH (0x2) (def: true)
     - initiated by server, in reaction to client request
     - server: PUSH_PROMISE frame:
        - contains HEADERS frame information that client would send if it was to request this stream
        - the original request cannot contain payload
        - the pushed request must be cacheable, e.g. use safe method
     - client:
        - RST_STREAM frame to cancel request, e.g. if cached
        - server reacts to RST_STREAM but does not wait for client to send next frames
     - server: 
        - HEADERS, DATA: like normal response
  - end:
     - END_STREAM flag:
        - normal stream end
        - on last DATA frame (or last HEADERS if none) for each endpoint
        - might be followed by CONTINUATION frames
     - RST_STREAM frame: 
        - cancels current stream
     - GOAWAY frame: 
        - end of session , i.e. stops any new stream
        - keep processing existing streams
        - contains last stream ID that will be processed
        - can contain arbitrary debug info
        - should respond with another GOAWAY

Format (HTTP/1.*):
  - newline is \n\r
  - request:
      METHOD URL HTTP/1.*
      HEADER: VAL
      ...

      [BODY]
  - response:
      HTTP/1.1 UINT STR
      [HEADER: VAL
      ...]

      [BODY]
  - Host [C] is mandatory

Error codes (HTTP/2):
  - types:
     - NO_ERROR (0x0)
     - PROTOCOL_ERROR (0x1): e.g. wrong frame order or content
     - INTERNAL_ERROR (0x2)
     - FLOW_CONTROL_ERROR (0x3): too much buffered DATA because of flow control
     - SETTINGS_TIMEOUT (0x4): SETTINGS response timeout
     - STREAM_CLOSED (0x5)
     - FRAME_SIZE_ERROR (0x6): frame too small|big
     - REFUSED_STREAM (0x7): sender notifies receiver that reqyest has not been processed, allowing safe retry. E.g. too many concurrent streams or refused server push
     - CANCEL (0x8): stream no longer needed or server push refused
     - COMPRESSION_ERROR (0x9)
     - CONNECT_ERROR (0xa): when using CONNECT method
     - ENHANCE_YOUR_CALM (0xb): throttling, e.g. too many server pushes
     - INADEQUATE_SECURITY (0xc): does not use TLS or wrong TLS setup
     - HTTP_1_1_ERROR (0xd): should downgrade to HTTP/1.1
  - contained in GOAWAY|RST_FRAME frame

Limits (HTTP/2):
  - SETTINGS_MAX_CONCURRENT_STREAMS (0x3) (def: unlim)
  - SETTINGS_MAX_FRAME_SIZE (0x5) (def/min: 16KB, max: 16MB)
  - HEADERS frames:
     - SETINGS_MAX_HEADER_LIST_SIZE (0x6) (def: unlim):
        - max HEADERS frame size, uncompressed, with extra 32 bytes per header. 
        - not mandatory to respect it.
     - SETTINGS_HEADER_TABLE_SIZE (0x1) (def: 4KB): headers dynamic table size
     - implementation additional limits, e.g. Apache limits 8MB/header and 1000 headers, Node.js 80KB/header
  - DATA frames: max receiver buffer (flow control):
     - counter SETTINGS_INITIAL_WINDOW_SIZE (0x4) bytes (def: 64KB, max: 2GB):
        - decreased when sender sends
        - increased when receiver sends WINDOW_UPDATE frame:
           - includes how much to increase
           - e.g. when receiver consumed (i.e. received and do not buffer anymore)
        - if exhausted, each endpoint should terminate stream
        - should amount to how much receiver can buffer
     - can be for a stream, or whole connection (if stream ID is 0)

Format extensions:
  - new frame type
  - new SETTINGS_*
  - new *_ERROR
  - new headers

PING frame (HTTP/2):
  - used to calculate round-trip time
  - contains 8 bytes of arbitrary data
  - have priority over other frame types
  - must respond with another PING frame with flag ACK

Stream prioritization (HTTP/2):
  - receiver is not constrained to respect it
  - fields/flags on HEADERS|PRIORITY frame. Must set PRIORITY flag
  - priority: Weight field 1-256 (def: 16): how much resources server should allocate
  - dependency:
     - Parent stream ID field (def: 0, i.e. none): current stream must only start once stream ID is done
     - Exclusive field: make siblings become children of current stream

Method:
  - safe (read):
     - GET: retrieve resource
     - HEAD: retrieve resource (header only)
     - OPTIONS:
        - retrieve metadata (e.g. functionalities of web server).
        - usually use * as URL
     - TRACE: 
        - echoes request
        - to see changes introduced by servers|proxies
  - unsafe (write):
     - idempotent (resource returned is always same if called again):
        - PUT: replace/create resource with specific ID
        - DELETE: erase resource
     - not idempotent:
        - POST: create resource without specific ID
        - PATCH: modify resource
        - CONNECT: HTTP Tunneling

Headers:
  - case insensitive
  - written [S|C] for server|client in my doc
  - binary compressed (HTTP/2)
     - algo is 'HPACK'
     - common HEADER or HEADER: VAL have predefined numbers
     - each endpoint caches HEADER: VAL in a dynamic table
  - :HEADER are called pseudo-headers: same as headers but with extra restrictions on when can be used (HTTP/2)

Status codes:
  - WebDAV-only: 102, 207, 208, 422, 423, 424, 507, 508
  - default caching:
     -- cached
     +- not cached
      - not specified, i.e. not cached
  - 1**: information
     - 100 (Continue)                         client sent only headers and can proceed to send body (see Expect: 100-continue [C])
     - 101 (Switching Protocols)              switch protocol success, e.g. from HTTP to HTTPS (see Upgrade [C])
  - 2**: success
    -- 200 (OK)                               simple
     - 201 (Created)                          new resource (e.g. POST). Use Location: URL [S] for new resource URL.
     - 202 (Accepted)                         response is ongoing and will take some time to proccess (client can timeout). Usually response include links to monitor processing status.
    -- 203 (Non-Authoritative Information)    proxy transformed server response, which was originally 200
    -- 204 (No Content)                       OK, but nothing is to be returned. Client should stay on same resource/document. E.g. successful DELETE, If-Modified-Since header.
     - 205 (Reset content)                    like 204 but client should reset/refresh current resource/document.
    -- 206 (Partial content)                  response is only a subset of the full resource, (see Range [C])
     - 214 (Transformation applied)           proxy transformed server response, which was originally not 200
    -- 226 (IM used)                          returns diff not full resource. Uses HTTP delta compression, an RFC which seems old.
  - 3**: redirection to be performed by client
    -- 300 (Multiple choices)                 redirection need client input
    -- 301 (Moved Permanently)                permanent, GET (even if different method, but should ask first). Cacheable.
    +- 302 (Found)                            temp, GET (even if different method, but should ask first)
    +- 303 (See other)                        different resource (not only different URL) than requested
    +- 304 (Not Modified)                     resource did not change (see caching)
    +- 305 (Use proxy)                        redirect to a proxy
    +- 307 (Temporary Redirect)               temp, same HTTP method
    -- 308 (Permanent Redirect)               permanent, same HTTP method
  - 4**: client-side failure
     - 400 (Bad request)                      syntax error
     - 401 (Unauthorized)                     authentication problem
     - 402 (Payment required)                 e.g. should pay to increase request rate
     - 403 (Forbidden)                        authorization problem. Prefer 404 when location itself is secret.
    -- 404 (Not Found)                        wrong URL, but correct domain.
    -- 405 (Method not allowed)               HTTP method not implemented or not allowed
     - 406 (Not Acceptable)                   wrong requested media type (see Accept [C])
     - 407 (Proxy authentication required)    like 401 but for application proxy
     - 408 (Request Timeout)                  as opposed to response timeout
     - 409 (Conflict)                         multi-client conflict
    -- 410 (Gone)                             like 404, but indicates URL was present before
     - 411 (Length Required)                  missing request body length (see Content-Length [C])
     - 412 (Precondition Failed)              resource changed even though client assumed it did not, e.g. with If-Unmodified-Since [C] (see caching)
     - 413 (Payload too large)
    -- 414 (URI too long) 
     - 415 (Unsupported Media Type)           server does not support payload media type (inverse of 406)
     - 416 (Range Not Satisfiable)            wrong Range [C]
     - 417 (Expectation failed)               wrong Expect [C]
    -- 421 (Misredirected request)            request picked wrong server
     - 426 (Upgrade Required)                 switch protocol denied, e.g. from HTTP to HTTPS
    +- 428 (Precondition required)            must use If-* [C]
    +- 429 (Too many requests)                throttle
    +- 431 (Request header fields too large)
    -- 451 (Unavailable for Legal Reasons)    e.g. censorship, copyright, privacy
  - 5**: server-side failure
     - 500 (Internal server error)            bug in server, e.g. syntax error
    -- 501 (Not implemented)                  feature not available yet
     - 502 (Bad gateway)                      sent by proxy when it received error from server
     - 503 (Service unavailable)              server is down (cannot connect)
     - 504 (Gateway timeout)                  sent by proxy on server timeout
     - 505 (HTTP version not supported)
     - 506 (Variant also negotiates)          negotiation circular loop (see Negotiate [C])
     - 510 (Not extended)                     HTTP extension not implemented
    +- 511 (Network authentication required)  like 401 but for network proxy, containing link where to authenticate.

<meta http-equiv="HEADER" content="VAL">:
  - add HTTP header client-side
  - only ones that are crossbrowser: refresh, Content-Security-Policy

Redirections:
  - use 3** status code and:
     - client should request again:
        - Location: URL [S]: right away
        - Retry-After: NUM|DATE [S]: in future, same URL
        - Refresh: NUM[, url=URL] [S]: in future, same URL or not. Can be used as <meta http-equiv>
     - server fetched it without additional request:
        - Content-Location: URL [S]
  - 5+ redirections is considered infinite loop.

Time:
  - Date: DATE [C]: when request was sent 
  - Accept-Datetime [C]: ask for past|present versions

Browser HTTP requests:
  - by changing current URL:
     - UI: 
        - browser chrome: back|forward|home button, URL bar, searchbar, bookmarks, etc.
        - <a|area> click event 
        - <form> submit event
     - programatically:
        - WINDOW.location|history
  - XHR.send(), FETCH

Query strings:
  - use URL?VAR=VAL&...: 
     - instead of request body 
     - like 'application/x-www-form-urlencoded' but:
        - %20 instead of +
        - nesting support: Express REQ.query
  - advantages:
     - recommended way to send request body with GET|HEAD
     - easier to set non-programatically (e.g. by typing URL)
     - stateful URL, e.g. for bookmarks
  - disadvantages:
     - non-separation of concern between resource location and request body
     - longer URL
     - SEO

Software identity:
  - User-agent: STR [C]: client technology
  - X-Requested-With: STR [C]:
     - how request was performed
     - often used: XMLHttpRequest
  - Server: STR [S]: server name
  - X-Powered-By: STR [S]: server technology
  - Pragma: VAL [C|S]: headers specific to a given client|server technology
  - X-UA-Compatible: CLIENT=VERSION;... [S]: 
     - client, if CLIENT, should render as it was VERSION
     - used with IE, e.g. IE=NUM|edge

Client identity:
  - From: EMAIL_ADDRESS [C]: often used with bots for support email
Destination:
  - Host: HOST[:PORT] [C] (HTTP/1.1) or :authority HOST[:PORT] [C] (HTTP/2) 
     - HOST case sensitivity depends on server

Content:
  - content negotiation:
     - server has several variants for one resource
     - server-side:
        - client informs of accepted variants (NUM is preference):
           - Accept:         MIME_TYPE[; q=NUM],... [C]
           - Accept-Charset:   CHARSET[; q=NUM],... [C]
           - Accept-language: LANGUAGE[; q=NUM],... [C] 
           - Accept-features:  FEATURE[; q=NUM],... [C]
        - server picks one:
           - Content-Type: MIME_TYPE[; charset=CHARSET] [S]
           - Content-language: LANG [S]
           - 406 (Not Acceptable): wrong Accept-* [C]
     - transparent:
        - client asks for possible variants:
           - Accept* [C] (optional)
           - Negotiate: VAL [C]:
              - trans: support transparent content negotiation, let server decide if should use
              - vlist: support, ask server to use
        - server informs of possible variants:
           - TCN: VAL [S]: type of response:
              - ad-hoc: same as server-side negotiation, i.e. server picked
              - choice: like ad-hoc but also:
                  Alternates: URL,... [S]: other possible representations
              - list: 
                 - gives only possible representations, do not pick one
                 - 300 status code
           - 506 status code: circular references due to choice picking
        - client accepts chosen variant (ad-hoc, choice) or ask for a specific one (choice, list)
     - trade-offs:
        - mandatory Accept* [C]: allows fingerprinting user agent (privacy concern)
        - transparent negotiation with list: extra HTTP request
  - request payload:
     - 415 (Unsupported Media Type): wrong request payload MIME_TYPE
  - response payload:
     - render vs download:
        - depends if Content-Type [S] rendering is supported by client
           - Content-Type "multipart/form-data; boundary=STR" [S]: always download
        - Content-Disposition: attachment[; filename="..."] [S]: forces download


Cache:
	- vocabulary:
		 - cache hits ratio: % of requests that used cache instead
		 - stale resource: cached but not valid anymore
     - cache invalidation: removing caching on stale resources
  - types:
     - client caching: 
        - e.g. browser caching
        - best performance but for single client
     - server caching:
        - across many clients but less performant
        - types:
           - reverse proxy (between client and server)
              - ISP
              - web accelerator: 
                 - reverse proxy dedicated to caching. 
                 - can also do prefetching, compression/minification
              - CDN: 
                - network across several geographical regions to be closer to clients
                - optimized for high availability
           - between server and database: 
              - e.g. Memcached/Redis
  - Vary: HEADER [S]:
     - notifies client to use different entry caches on same URL if different HEADER [C] value
     - to use when headers have impact on content, i.e. usually on Accept* [C]
     - usually towards proxies, since browsers usually use only one set of headers
	- cache HTTP headers tell browser how to cache given response:
     - if no HTTP headers, browser guess using heuristic, to avoid
     - caching takes query string into account
		 - unconditional caching:
				- client uses cache for a given time period, without server interaction
           - does not apply on page refresh.
        - features:
           - fastest cache method
           - highest probability of stale resources, except when using timestamping
           - best for asset files
		    - Cache-Control: STR,... [S]:
					 - [s-]max-age NUM: 
              - how long to cache
              - max: 1 year
						  - should be:
 							   - if fingerstamped, max value
						  	 - otherwise, how long stale resources are ok
						  - "s-": reverse proxies only
					 - Expires: DATE [S]:
						  - same as max-age but using a given DATE
							- older header
           - must-revalidate: 
              - when expires, if conditional caching setup, will do conditional cache request
              - default of most clients
           - proxy-revalidate: same as must-revalidate but for reverse proxies
					 - public|private:
					    - public (def): allow reverse proxy caching
							- private: 
                 - inverse
                 - good for sensitive data, e.g. cookies
					 - no-transform: don't allow reverse proxy to compress|minify resources (e.g. images/videos) or inject JavaScript code
				- Cache-Control: STR,... [C]:
           - max-age=0: forces reverse proxies to use conditional caching, and server to check if need to respond with 304
			 	   - no-cache: forces reverse proxies not to use conditional caching, and server not to respond with 304
				-	timestamping:
				   - using an ID in the URL that changes when resource changes
              - e.g. version number, modification date or content checksum
           - used to invalidate cache on modified resources
           - resource that require timestamped resources (e.g. main HTML file) cannot be timestamped itself
				- When using conditional caching too (ETag or Last-Modified):
           - unconditional caching has precedence
           - but when unconditional cache expires, uses conditional caching, so good idea to set it
		 - conditional caching:
				- browser should first send request to check if resource has changed. If 304 response, should use cache.
				- best cache method when it's impractical to timestamp, e.g. HTML and AJAX calls.
				  Faster to get 304 response with empty body, and no need for server to fetch data.
				- Headers:
					 - Can be based on (cannot be both):
					    - mtime: Last-Modified: DATE [S], If-Modified-Since: DATE [C]
				      - content hash: ETag: HASH [S], If-None-Match: HASH [C]:
                 - W/"...": weak, which means are just identical semantically, but not byte by byte. Used with dynamic websites
                 - "...": strong
					 - If-Unmodified-Since, If-Match: inverse, e.g. to do PUT only if resource is still the same
             Uses 412 instead of 304. If-None-Match with unsafe methods also use 412 instead of 304.
		 - no caching:
		    - faster than conditional caching if resource is never the same (avoid 304 response)
        - often done for security reasons
				- Cache-Control: no-cache, no-store, private, must-revalidate
				  Pragma: no-cache
					Expires: 0
				   - both values are same but for different browsers
					 - Pragma if for HTTP/1.0
        - can use no-cache="HEADER" for a specific header
	 - can see all in chrome://cache on Chrome
	 - security:
	    - client's cache entries containing confidential info (e.g. login info) could be accessed (by exploiting another 
			  vulnaribility or someone else having physical access to computer)
			- POST replay attack: use same URL to authenticate (thanks to cached entry) even if logged out
			- countermeasure: no caching for sensitive body or headers

Can indicate required If-* [C] with 428

Cacheability:
  - cache headers override default, but client default should be:
     - methods:
        - cached: GET|HEAD
        - not cached: others
     - status codes: see status codes
  - server should invalidate cache when receiving PUT|DELETE|POST|PATCH

Prefetching (resource hints, server push):
  - types, from most performant to least:
+--------------+----------------------------------------------+---------------------------------------------------------------------+------------------------------------+
| Type/REL     | Use case                                     | Effects                                                             | Browser support                    |
|              +--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+                                    |
|              | Resource for which | Known path | Likelihood | Initiated | When is resource        | Loads | Parse + | Protocols   |                                    |
|              | navigation action  |            |            | by        | fetched                 |       | render  |             |                                    |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| server push  | Current            | Yes        | Certain    | server    | right away (no request) | Yes   | Yes     | HTTP        | All                                |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| preload      | Current            | Yes        | Certain    | client    | async right away        | No    | No      | HTTP        | Chrome/Opera                       |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| preconnect   | Current            | No         | Certain    | client    | async right away        | No    | No      | DNS         | Chrome/Opera/Firefox               |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| prerender    | Next               | Yes        | High       | client    | after document.onload   | No    | Yes     | HTTP        | Chrome/Opera/IE                    |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| prefetch     | Next               | Yes        | Middle/low | client    | after document.onload   | No    | No      | HTTP        | not [mobile] Safari nor Opera mini |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| dns-prefetch | Next               | No         | Middle/low | client    | after document.onload   | No    | No      | DNS+TCP/TLS | not Opera mini                     |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
  - server push:
     - send additional resources in a single response
     - performance:
        - less roundtrips than resource hints
        - but should push only resources that would have been requested
     - caching:
        - uses pseudo-client request for caching, so works the same as normal request
        - client request must be cacheable, i.e. GET with cache headers
     - not actual prefetching (it loads resource)
     - need to be initiated by a request (so not realtime)
     - as opposed to resource hints, initiated by server so cannot be used if:
        - client needs knowledge about fetching: resource path, load|error event
        - fetching needs knowledge about client: state (cookies, localStorage), user agent info (Accept [C], etc.)
  - resource hints:
     - use either:
         Link: <URL>; rel=REL[; ATTR=VAL]... [, <URL>...] [S]
         <link href="URL" rel="REL" ATTR="VAL" ...>...
     - ATTR:
        - pr 'FLOAT' (0-1) (all)
           - probability the link will be followed 
           - used for prioritization or reducing optimization/fetching
        - as TYPE (preload|prefetch): 
           - WINDOW.fetch() destination type, 
             i.e. script|style|image|font|media|object|embed|document|xslt|manifest|report|service|shared]worker
           - used for CSP and Accept [C]
        - nopush (preload): if a HTTP2 server push has been received for that resource, do not use it
     - prerender parsing/execution:
        - in the background, i.e. not visible but will provide very fast cache
        - only kept for short while, so should be next navigation
        - resource intensive: should only be used when confident about next navigation action
        - only HTML resources
     - does not delay document.onload
     - could previously use noop XHR to achieve something similar
     - cannot see in devtools network tab, but can see "prerender" using chrome://net-internals/#prerender
     - can be:
        - speculative: before user interaction that might trigger HTTP request
        - reactive: after user interaction that will certainly trigger HTTP request, after some delay
     - possible problems:
        - when HTTP GET request has side effects (which is improper)
        - increase bandwith usage
        - overestimate tracking (ads, analytics):
           - can use document.visibilityState 'prerender' to handle it
        - security: website make decision (not user) to trust content by browsing it

Long request:
  - 100-continue:
     - Expect: "100-continue" [C], no request body
     - server sends 100 (Continue) if success, 417 (Expectation Failed) if failure
     - client sends body
  - Content-Length [C|S]: BODY length:
     - can use 411 (Length Required)
  - request too large:
     - 414 (Request URI too long)
     - 431 (Request header fields too large)
     - 413 (Request Entity too large)

Long response:
  - byte serving:
     - allow client to request specific ranges:
     - init: Accept-Ranges: bytes [S] 
     - each range:
        - client:
           - Range: bytes=NUM-NUM2 [C]
           - If-Range: ETAG|MDATE [C]:
              - if content changed, sends entire file (not only RANGE)
              - otherwise, sends RANGE
        - server success:
           - Content-Range: bytes NUM-NUM2/TOTAL [S] 
             206 (Partial content)
        - server failure:
           - 416 (Requested Range Not Satisfiable)
  (HTTP/1.* only)
  - Can use Transfer-Encoding: chunked [S] instead:
      - send BODY in several times, signalling end by sending empty BODY
      - requested by TE: chunked [C]
      - Trailer: HEADER_VAR [S], sends additional headers, but at the end.
      - Good for big file or HTTP live streaming (different from HTTP streaming)
      - Should be used with compression

Proxies:
  - X-Forwarded-For: HOST... [C], indidates previous clients in a proxy chain.
  - X-Forwarded-Proto: PROTOCOL... [C], same for protocols, when changing protocols along the chain (e.g. HTTP to HTTPS)
  - X-Forwarded-Port: PORT... [C]: same for port
  - Via: HTTP_VERSION URL SERVER ... [C|S], proxies
  - Max-Forwards: NUM [C], max number of proxies

Security: See Websites_security

Tracking:
  - Referer: URL [C], current URL (so new URL can see where navigation originates)
    <link|a rel="noreferrer"> asks client not to send it.
  - DNT: 1 [C], "Do-not-track" tells server:
     - doesn't want any trace/unique ID/cookie that could correlates its visit of different websites
     - this includes tracking cookies, third-party ads tracking, but does not include Google Analytics, user preferences on 
       one site or targetting ads according to one single site preferences
  - Set-Cookie: VAR=VAL;SVAR=VAL;... [S]:
     - Asks client to send Cookie: VAR=VAL[;...] [C] again when visiting a specific path on a specific domain
     - Used to introduce a state: authentication, tracking, etc.
     - One Set-Cookie [S] per cookie, but one Cookie [C] for all cookies
     - VAL are percent-encoded
     - SVAR are:
        - path (récursif) (e.g. "/index.html") et domain (e.g. "www.a.org"):
           - when same as current: first-party cookies, often for authentication or for traffic analytics.
           - when different: third-party cookie
              - often tracking cookies : same domain accross different visited websites to connect different websites 
                someone visits, for advertising purposes
              - needs to trick the browser which otherwise blocks it (can only use cookie from same domain), e.g. hidden 
                iframes.
        - expires|max-age: DATE|NUM secondes before expiration (nothing for end of session). Put to 0 to delete cookie.
        - secure: can only transmit|receive via https.
        - HttpOnly: can't be used via JavaScript (document.cookies) (considered unsecure), can be used e.g. by PHP
     - Zombie cookie :
        - copies in several places.
        - if some absent, reduplicate them 
        - evercookie is an open source implementation
  - Private browsing :
     - a private session erases at the end all the traces (history, cookies, cache) it created.
     - called Incognito in Chrome

Compression:
  - Accept-Encoding: PROGRAM,... [C], then Content-encoding: PROGRAM [S]
  - PROGRAM can be: 
      - "identity" (none) 
      - "gzip/deflate": Zlib. Same compression but different header (gzip conserves files info but bigger). 
        However, as a client should ask for gzip, because deflate is handled differently by some servers.
        Other compression methods are way less supported.
      - "bzip2" 
      - "lzma"
      - "shdc": by Google, supported natively by Chrome (seems inactive)
  - server should cache the input/output of compression to avoid doing twice the same compression on same input, because
    compression is long

HTTPS:
  - using HTTP over SSL/TLS over TCP
  - needs to be enable on all website resources, including scripts, all pages, etc., otherwise could attack on specific
    unsecure resources
     - this includes cookies. To have secure cookies, provide the secure attribute, which says it can only be used with HTTPS
  - Strict-Transport-Security: max-age=NUM (seconds from now); includeSubDomains [S]: specify clients it only allows HTTPS 
    connections. Client should resend the request using HTTPS if HTTP was used.
  - initiating connection:
     - Upgrade [C] for HTTPS: should not be used as it leaves beginning of communication unencrypted
     - https:// protocol

Switching protocols:
  - Upgrade: PROTOCOL/VERSION [C] to start a session in HTTP then continue in another protocol:
     - server sends 426 if failed
     - server sends 101 and Upgrade: PROTOCOL/VERSION [S] if success
     - can Upgrade to but not from HTTP/2

Profiling:
  - X-Response-Time: NUM [S]: time taken by server to process answer

REST:
  - X-HTTP-Method-Override: METHOD [C]:
     - tells server that request should be interpreted as if HTTP METHOD has been used. 
	   - goal is to overcome network limitations (firewalls, etc.) protecting client from using methods like PUT, DELETE, etc. 
       on a REST API

Push technologies:
  - allow server to initiate message to client
  - types:
     - short polling with AJAX requests
     - HTTP server push / HTTP streaming (HTTP/1.1): using Transfer-encoding: chunked [S]
     - Comet:
        - Pushlet: leaves HTTP connection open, sending new bits from time to time
        - Long polling: waits for server events to return the reply to client, then ask client to request again. Uses timeouts.
           - BOSH: variation of long polling
     - Server-sent events (SSE)
     - TCP socket used by plugins like Flash or Java: bi-directional
     - Websockets: same idea but standardized

HTTP Tunneling:
  - wrapping another protocol packets in a HTTP payload
  - proxy and endpoints wraps|unwraps request|response
  - CONNECT method:
     - wraps TCP protocol
     - use only first HTTP handshake with proxy, then use TCP connection
     - can be used to access HTTPS using a HTTP proxy (TCP between client-proxy, SSL between proxy-server)

Practices becoming bad with HTTP/2:
  - concatenation:
     - performance impact:
        - lower number of requests
        - but invalidates cache more often
     - HTTP/2:
        - does not have limit on number of parallel requests
        - keep TCP socket always alive
        - so roundtrip performance impact is less important
     - types of concatenation:
        - file plain concatenation
        - sprites
        - inlining, e.g. <link> -> <style>
        - data URIs
  - domain sharding
