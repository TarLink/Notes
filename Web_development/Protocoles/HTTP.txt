
          
   HTTP   
          



Architecture:
  - version 2
     - to guess HTTP/2 version, can use:
        - ALPN, TLS extension (see SSL/TLS doc)
        - Upgrade: h2[c] [C|S] (see below)
           - h2 is HTTS, h2c HTTPS
           - must include SETTINGS frame as HTTP2-Settings [C] (base64-encoded)
           - not supported by most browsers
        - prior knowledge: client already knows server supports HTTP/2
  - layers:
     - application layer
     - usually on top of TCP/IP
        - TCP ports: 80 (HTTP), 443 (HTTPS)
        - SSDP is like HTTP, but above UDP
     - TLS:
        - HTTP/2: not required by specs, but browser implementation does
        - HTTP/1.*: not required
  - URI scheme: http[s]://
  - client-server:
     - client: "user agents", e.g. web browser, web crawler, app, etc.
     - resource can be dynamic (server modifies content) or static
  - stateless: 
     - requests independant from each other
     - but URL/headers/payload can keep state (e.g. cookies)
  - session:
     - set of TCP sockets:
        - HTTP/2: one per host (not hostname)
        - HTTP/1.*: 
           - 6 (depends on client) per hostname
           - hostname sharding: using different domains on a server to overcome limit
     - parallel requests per TCP socket: 
        - HTTP/2: multiplexing: SETTINGS_MAX_CONCURRENT_STREAMS (def: unlim) with no default order (but client can ask for specific order)
        - HTTP/1.1: pipelining: 4-8 (depends on client) with head-of-line blocking (answers in same order as requests)
        - HTTP/1.0: serial: one
     - how long:
        - HTTP/*: until Connection: close [C|S]
        - HTTP/1.*: 
           - timeout 10-15 secs (depends on server). Can be set by Keep-Alive: timeout=NUM [S]
           - NUM requests using Keep-Alive: max=NUM [S]
        - HTTP/1.0: requires Connection: Keep-Alive [C|S] to remain open

Request/response:
  - case insensitive
  - format:
     - HTTP/2:
        - error codes:
           - PROTOCOL_ERROR: wrong frame order or content
           - FRAME_SIZE_ERROR: frame too small|big
           - REFUSED_STREAM|PROTOCOL_ERROR: to many concurrent streams
           - FLOW_CONTROL_ERROR: too much buffered DATA because of flow control
        - stream:
           - one request+response, or server push:
              - several ordered frames connected by stream ID
              - is what makes multiplexing possible
           - prioritization:
              - initiated by client, server might ignore
              - dependency:
                 - Exclusive ID (def: 0) [C]: current stream must only start once stream ID is done
              - priority:
                 - Weight 1-256 (def: 16) [C]: how much resources server should allocate
                 - can be changed with PRIORITY frame
        - frames:
           - size [0-2]
              - max: SETTINGS_MAX_FRAME_SIZE (def/min: 16KB, max: 16MB)
           - type [3]:
              - RST_STREAM: stops current stream
              - GOAWAY: stops any new stream
              - PING: used to calculate round-trip time
              - see below for other types
              - can send non-standard one (extension). If one end does not support, should ignore.
           - flags [4]
           - stream ID [5-8]:
              - 0: hypothetical main stream
              - odd is started by client, even by server
        - init (for each endpoint):
           - start:
               PRI * HTTP/2.0

               SM

           - SETTINGS frame:
              - options, noted SETTINGS_* in this doc
        - normal (request/response) stream:
           - client HEADERS frame:
              - max size: SETTINGS_MAX_HEADER_LIST_SIZE (def: unlim)
              - binary compressed:
                 - algo is 'HPACK'
                 - common HEADER or HEADER: VAL have predefined numbers
              - each endpoint caches HEADER: VAL in a dynamic table of SETTINGS_HEADER_TABLE_SIZE (def: 4KB)
              - must contain pseudo-headers: 
                  :method METHOD [C] 
                  :authority URL [C] 
                  :path PATH [C] 
                  :scheme PROTOCOL [C]
              - end:
                 - if this frame too small, send extra CONTINUATION frames with extra headers
                 - last frame should have flag END_HEADERS
           - client DATA frames:
              - payload
              - max receiver buffer (flow control):
                 - counter SETTINGS_INITIAL_WINDOW_SIZE bytes (def: 64KB, max: 2GB):
                    - decreased when sender sends
                    - increased when receiver sends WINDOW_UPDATE frame:
                       - includes how much to increase
                       - e.g. when receiver consumed (i.e. received and do not buffer anymore)
                    - if exhausted, each endpoint should terminate stream
                    - should amount to how much receiver can buffer
                 - can be for a stream, or whole connection (if stream ID is 0)
              - end:
                 - last DATA frame (or last HEADERS frame if no DATA) should have flag END_STREAM
           - server HEADERS frame:
              - like client except must contain pseudo-header :status UINT [S]
           - server DATA frames: like client
        - server push stream:
           - enabled by SETTINGS_ENABLE_PUSH (def: true)
           - server: PUSH_PROMISE frame:
              - contains HEADERS frames that client would send if it was to request all streams
           (cached)
           - client: RST_STREAM frame to cancel request
           (not cached)
           - server: HEADERS, DATA: like normal response
     - HTTP/1.*:
        - request:
            METHOD URL HTTP/1.*
            HEADER: VAL
            ...

            [BODY]
        - response:
            HTTP/1.1 UINT STR
            [HEADER: VAL
            ...]

            [BODY]
        - headers:
           - newline is \n\r
           - Host [C] is mandatory

Request/response:
  - Request explanation: 
    - METHODE :
      - "safe" (lecture) :
        - GET : ask resource
        - HEAD : ask resource (header only)
        - OPTIONS : ask metadata (e.g. functionalities of web server). Usually use * as URL
        - TRACE : echoes request (to see changes introduced by servers|proxies)
      - "unsafe" (écriture) :
        - idempotent (plusieurs requêtes donnent le même résultat) :
          - PUT : create resource
          - DELETE : erase resource
        - ou non :
          - POST : modify resource completely
          - PATCH: modify resource partially
          - CONNECT: do HTTP Tunneling
    - URL : relatif à DOMAIN, e.g. "/images/image.pgn"
    - Header fields:
      - in theory no limit, but in practice e.g. Apache limits 8MB/header and 1000 headers, Node.js 80KB/header
      - options, VAR: VAL (written [S|C] for server|client in my doc), followed by newlines
    - BODY :
      - data sent from client to server (usually for unsafe methods)
  - Response explanation:
    - UINT : 
      - exit code (others are mentioned in this doc)
      - can also use Status: UINT STR [S]:
      - type:
         - 1**: information
            - 100 (Continue): client sent partial request and need to keep going
            - 101 (Switching Protocols): switch protocol success, e.g. from HTTP to HTTPS
            - 102 (Processing): response is ongoing and will take some time to know if success or failure (client should not timeout)
         - 2**: success
            - 200 (OK): simple
            - 201 (Created): new resource (e.g. PUT). Use Location: URL [S] for new resource URL.
            - 202 (Accepted): response is ongoing and will take some time to proccess (client can timeout). Usually response include links to monitor processing status.
            - 203 (Non-Authoritative Information): proxy transformed server response, which was originally 200
            - 204 (No Content): OK, but nothing is to be returned. Client should stay on same resource/document. E.g. successful DELETE, If-Modified-Since header.
            - 205 (Reset content): like 204 but client should reset/refresh current resource/document.
            - 206 (Partial content): response is only a subset of the full resource, e.g. with Range [C]
            - 207???
            - 208???
            - 214 (Transformation applied): proxy transformed server response, which was originally not 200
            - 226???
         - 3**: redirection to be performed by client
            - 300???
            - 301 (Moved Permanently): permanent, GET (whether it was GET or not)
            - 302 (Found): temp, GET (whether it was GET or not)
            - 303 (See other): different resource (not only different URL) than requested
            - 304 (Not Modified): resource did not change  (client should use cache)
            - 305???
            - 307 (Temporary Redirect): temp, same HTTP method
            - 308 (Permanent Redirect): permanent, same HTTP method
         - 4**: client-side failure
            - 400 (Bad request): syntax error
            - 401 (Unauthorized): authentication problem
            - 402???
            - 403 (Forbidden): authorization problem. Prefer 404 when location itself is secret.
            - 404 (Not Found): wrong URL, but correct domain.
            - 405 (Method not allowed): HTTP method not implemented or not allowed
            - 406 (Not Acceptable): wrong requested media type, e.g. Accept [C]
            - 407???
            - 408 (Request Timeout): as opposed to response timeout
            - 409 (Conflict): multi-client conflict
            - 410 (Gone): like 404, but indicates URL was present before
            - 411 (Length Required): missing request body length, e.g. Content-Length [C]
            - 412 (Precondition Failed): resource changed even though client assumed it did not, e.g. with PUT + If-Unmodified-Since [C]
            - 413 (Request Entity too large)
            - 414 (Request URI too long) 
            - 415 (Unsupported Media Type): server does not support requested media type
            - 416 (Requested Range Not Satisfiable): e.g. wrong Range [C]
            - 417 (Expectation failed): e.g. wrong Expect [C]
            - 420???
            - 421???
            - 422 (Unprocessable Entity): request syntactically correct but not semantically
            - 423???
            - 424???
            - 426 (Upgrade Required): switch protocol denied, e.g. from HTTP to HTTPS
            - 428???
            - 429 (Too many requests): throttle
            - 431 (Request header fields too large)
            - 451???
            - 499???
         - 5**: server-side failure
            - 500 (Internal server error): bug in server, e.g. syntax error
            - 501 (Not implemented): feature not available yet
            - 502 (Bad gateway): sent by proxy when it received error from server
            - 503 (Service unavailable): server is down (cannot connect)
            - 504 (Gateway timeout): sent by proxy on server timeout
            - 505 (HTTP version not supported)
            - 506: negotiation circular loop
            - 507???
            - 508???
            - 510???
            - 511???
            - 599???
    - STR: status text
    - Header fields
    - BODY: depends on request

<meta http-equiv="HEADER" content="VAL">:
  - client (not server) will add HTTP HEADER: VAL to the server's response. 
  - Does not always work.

Redirections:
  - Redirection is using Location: URL [S]
     - Can also avoid client redirection by fetching it server-side, but notify with Content-Location: URL [S]
  - More than five redirections is considered infinite loop.
  - Use 3** status codes
  - Refresh: NUM, url=URL [S], like <meta http-equiv="refresh" content="NUM; url=URL"> redirection 
  - Retry-After: NUM|DATE [S], tells client to try again after a specific period of time

Time:
  - Date: DATE [C]: when request was sent 
  - Accept-Datetime [C]: which response it wants, to allow getting older versions.

Sending data:
  - <a|area> click event: change current URL
  - <form> submit event: change current URL (see HTML doc)
  - XHR.send():
     - HTTP request without changing current URL
     - more flexibility on request method|headers|body

Query strings:
  - only advantage over request body is when need to keep state in URL, e.g. bookmark
  - but:
     - it clutters URL, and is bad practice (bad SEO)
     - can grow too big
  - Can use VAR[VAR2]=VAL, but must be supported by server:
     - query string: supported by Express REQ.query
     - request body: supported by Express BODY-PARSER

Software identity:
  - User-agent: STR [C] and Server: STR [S]. Can also instruct rendering engine to client with 
    X-UA-Compatible: BROWSER=VAL [S]
  - X-Powered-By: STR [S], e.g. "PHP/5.4.0"
  - X-Request-With: FUNC (e.g. XMLHttpRequest) [C], often used in AJAX
  - Pragma: VAL [C|S], for server-specific lingo

Client identity:
  - From: EMAIL_ADDRESS [C]

Destination:
  - Host: HOST[:PORT] [C], mandatory. DOMAIN might be case-sensitive on some servers.
     - virtual hosting (several HOST on same machine): 
       - name-based: 
          - using several HOST names under same IP. 
          - Is harder to implement with HTTPS. 
          - When DNS doesn't work, harder to reach directly through IP.
       - IP-based:
          - using one IP by HOST

Content:
  - content negotiation (client gives several options, and server picks one):
     - server-side:
        - Content-Type: MIME_TYPE[; charset=CHARSET] [S]. 
        - Accept: MIME_TYPE and Accept-Charset: CHARSET [C] to notify the server. 
          Server can use status code 415 (Unsupported Media Type)
        - Accept-language: LANGUAGE [C], Content-language: LANG [S]
        - Accept-features: FEATURE [C]
        - each header [C] can be followed by [; q=NUM] to put preferences on each option
        - 406 (Not Acceptable): wrong Accept-* [C]
     - transparent:
        - Negociate [C] then server:
           - respond with normal response body after server-side negotiation
              - unless 300 status code and TCN: list [S], otherwise TCN: choice [S]
           - Alternates: URL,... [S]
           - sends 506 when server has circular references due to choice picking
        - Negociate: VAL [C]:
           - trans: support, but don't ask for it
           - vlist: support and ask for it
        - Goal: not having to send too many Accept* [C], which increase packet size and allow privacy concern (fingerprinting)
        - Problem: need to perform two requests
  - Content-Disposition: attachment[; filename="..."] [S], ask to download with a file chooser
  - Content-Type "multipart/form-data; boundary=STR" [S]:
     - forces download box
     - download box otherwise present on any Content-Type not supported by browser renderer
     - if no filename="...", will create a default one according to Content-Type

Control:
  - Content-MD5: CHECKSUM [C|S], usually with Trailer: HEADER_VAR [S]

Cache:
	- vocabulary:
		 - cache hits ratio: % of requests that could use the cache
		 - stale resources: cached but not valid any more
  - proxy/server caching:
		 - CDN: fast servers for caching, spurned across several geographical regions to be closer to clients
		 - Memcached/Redis are between the server and the DB, while web accelerators are between server and client
		 - proxy caching:
		    - types: 
	 				 - ISP can cache
	 				 - web accelerator: reverse proxy dedicated to caching (closer to end client)
				- Vary: HEADER [S] tells the client to use different entry caches for requests on same URLs but using different
				  request HEADER value.
					Usually used with Vary: Accept-Encoding towards cache proxies, so they don't serve gzipped cache entries to clients
					not able to gunzip, or cleartext cache entries to clients that requested gzipped and will try to gunzip.
					Also sometimes Vary: User-Agent if served files vary according to User-Agent (will increase SEO)
		 - server and proxy caching can cache for all clients based on the request of a single client
	- cache HTTP headers tell browser how to cache given response (if none, browser guess using heuristic, to avoid):
		 - unconditional caching:
				- browser should not ask server and only use cache for a given time period
          Does not apply on page refresh.
				- fastest cache method, but requires timestamp updates, so should be done on asset files (CSS, images, JavaScript,
					etc.) but not HTML (it would break timestamping).
					Usually asset files are in /static PATH on server, and in Express served with static file server, while rest is not.
		    - Cache-Control: STR,... [S] where STR can be:
					 - [s-]max-age NUM: how long to cache
						 "s-" is for cache proxies only like CDN
						 Should not be more than 1 year later, but:
 							 - if fingerstamping ok, should be as long as possible (so should be 1 year)
							 - otherwise, set longest time you estimate clients can have a good experience with a stale resource
					   Can also use instead Expires: DATE [S]:
						   - same but using a given DATE
							 - older header
					 - public|private: can [not] be cached by intermediate proxy, not only end-client:
					    - public: allow proxy caching
							- private: good if data is sensitive, including headers e.g. cookies (even if SSL if the proxy needs to 
							  decrypt/encrypt in the middle)
					 - no-transform: don't allow proxy to recompress images/videos.
					   Some proxies also inject JavaScript code which might mess up with the application.
           - must|proxy-revalidate: 
              - when expires, if conditional caching setup, will do conditional cache request
              - however it is the default of most clients
				- Cache-Control: STR,... [C]:
           - max-age=0: forces all proxies in between to use conditional caching, and server to check if need to respond with 
             304
			 	   - no-cache: forces all proxies in between not to use conditional caching, and server not to respond with 304
				-	timestamping:
				   - using an ID in the URL (e.g. version of JavaScript file). 
					 - When resource changes, change ID, update links to resource.
					 - new calls will get new version (because different URL).
           - query string is taken into account: careful not to timestamp a resource by mistake by unconditionally caching a 
             URL with query string
				- When using conditional caching too (ETag or Last-Modified):
           - unconditional caching has precedence
           - but when unconditional cache expires, uses conditional caching, so good idea to set it
		 - conditional caching:
				- browser should first send request to check if resource has changed. If 304 response, should use cache.
				- best cache method when it's impractical to timestamp, e.g. HTML and AJAX calls.
				  Faster to get 304 response with empty body, and no need for server to fetch data.
				- Headers:
					 - Can be based on (cannot be both):
					    - mtime: Last-Modified: DATE [S], If-Modified-Since: DATE [C]
				      - content hash: ETag: HASH [S], If-None-Match: HASH [C]:
                 - W/"...": weak, which means are just identical semantically, but not byte by byte. Used with dynamic websites
                 - "...": strong
					 - If-Unmodified-Since, If-Match: inverse, e.g. to do PUT only if resource is still the same
             Uses 412 instead of 304
		 - no caching:
		    - faster than conditional caching if resource is never the same (avoid 304 response)
        - often done for security reasons
				- Cache-Control: no-cache, no-store, private, must-revalidate
				  Pragma: no-cache
					Expires: 0
				   - both values are same but for different browsers
					 - Pragma if for HTTP/1.0
        - can use no-cache="HEADER" for a specific header
	 - can see all in chrome://cache on Chrome
	 - security:
	    - client's cache entries containing confidential info (e.g. login info) could be accessed (by exploiting another 
			  vulnaribility or someone else having physical access to computer)
			- POST replay attack: use same URL to authenticate (thanks to cached entry) even if logged out
			- countermeasure: no caching for sensitive body or headers

Prefetching (resource hints, server push):
  - types, from most performant to least:
+--------------+----------------------------------------------+---------------------------------------------------------------------+------------------------------------+
| Type/REL     | Use case                                     | Effects                                                             | Browser support                    |
|              +--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+                                    |
|              | Resource for which | Known path | Likelihood | Initiated | When is resource        | Loads | Parse + | Protocols   |                                    |
|              | navigation action  |            |            | by        | fetched                 |       | render  |             |                                    |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| server push  | Current            | Yes        | Certain    | server    | right away (no request) | Yes   | Yes     | HTTP        | All                                |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| preload      | Current            | Yes        | Certain    | client    | async right away        | No    | No      | HTTP        | Chrome/Opera                       |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| preconnect   | Current            | No         | Certain    | client    | async right away        | No    | No      | DNS         | Chrome/Opera/Firefox               |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| prerender    | Next               | Yes        | High       | client    | after document.onload   | No    | Yes     | HTTP        | Chrome/Opera/IE                    |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| prefetch     | Next               | Yes        | Middle/low | client    | after document.onload   | No    | No      | HTTP        | not [mobile] Safari nor Opera mini |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| dns-prefetch | Next               | No         | Middle/low | client    | after document.onload   | No    | No      | DNS+TCP/TLS | not Opera mini                     |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
  - server push:
     - send additional resources in a single response:
        - first send pseudo-client request to client (see PUSH_PROMISE)
        - if cached, client sends RST_STREAM
        - otherwise response header then response body
     - performance:
        - less roundtrips than resource hints
        - but should push only resources that would have been requested
     - caching:
        - uses pseudo-client request for caching, so works the same as normal request
        - client request must be cacheable, i.e. GET with cache headers
     - not actual prefetching (it loads resource)
     - need to be initiated by a request (so not realtime)
     - as opposed to resource hints, initiated by server so cannot be used if:
        - client needs knowledge about fetching: resource path, load|error event
        - fetching needs knowledge about client: state (cookies, localStorage), user agent info (Accept [C], etc.)
  - resource hints:
     - use either:
         Link: <URL>; rel=REL[; ATTR=VAL]... [, <URL>...] [S]
         <link href="URL" rel="REL" ATTR="VAL" ...>...
     - ATTR:
        - pr 'FLOAT' (0-1) (all)
           - probability the link will be followed 
           - used for prioritization or reducing optimization/fetching
        - as TYPE (preload|prefetch): 
           - WINDOW.fetch() destination type, 
             i.e. script|style|image|font|media|object|embed|document|xslt|manifest|report|service|shared]worker
           - used for CSP and Accept [C]
        - nopush (preload): if a HTTP2 server push has been received for that resource, do not use it
     - prerender parsing/execution:
        - in the background, i.e. not visible but will provide very fast cache
        - only kept for short while, so should be next navigation
        - resource intensive: should only be used when confident about next navigation action
        - only HTML resources
     - does not delay document.onload
     - could previously use noop XHR to achieve something similar
     - cannot see in devtools network tab, but can see "prerender" using chrome://net-internals/#prerender
     - can be:
        - speculative: before user interaction that might trigger HTTP request
        - reactive: after user interaction that will certainly trigger HTTP request, after some delay
     - possible problems:
        - when HTTP GET request has side effects (which is improper)
        - increase bandwith usage
        - overestimate tracking (ads, analytics):
           - can use document.visibilityState 'prerender' to handle it
        - security: website make decision (not user) to trust content by browsing it

Long request:
  - 100-continue:
     - sends only header with Expect: "100-continue" [C]
     - server sends 100 (Continue) if success, 417 (Expectation Failed) if failure
     - client sends body
  - Content-Length [C|S]: BODY length:
     - can use 411 (Length Required)
  - request too large:
     - 414 (Request URI too long)
     - 431 (Request header fields too large)
     - 413 (Request Entity too large)

Long response:
  - byte serving:
     - allow client to request specific ranges:
     - init: Accept-Ranges: bytes [S] 
     - each range:
        - client:
           - Range: bytes=NUM-NUM2 [C]
           - If-Range: ETAG|MDATE [C]:
              - if content changed, sends entire file (not only RANGE)
              - otherwise, sends RANGE
        - server success:
           - Content-Range: bytes NUM-NUM2/TOTAL [S] 
             206 (Partial content)
        - server failure:
           - 416 (Requested Range Not Satisfiable)
  (HTTP/1.* only)
  - Can use Transfer-Encoding: chunked [S] instead:
      - send BODY in several times, signalling end by sending empty BODY
      - requested by TE: chunked [C]
      - Trailer: HEADER_VAR [S], sends additional headers, but at the end.
      - Good for big file or HTTP live streaming (different from HTTP streaming)
      - Should be used with compression

Proxies:
  - X-Forwarded-For: HOST... [C], indidates previous clients in a proxy chain.
  - X-Forwarded-Proto: PROTOCOL... [C], same for protocols, when changing protocols along the chain (e.g. HTTP to HTTPS)
  - X-Forwarded-Port: PORT... [C]: same for port
  - Via: HTTP_VERSION URL SERVER ... [C|S], proxies
  - Max-Forwards: NUM [C], max number of proxies

Security: See Websites_security

Tracking:
  - Referer: URL [C], current URL (so new URL can see where navigation originates)
    <link|a rel="noreferrer"> asks client not to send it.
  - DNT: 1 [C], "Do-not-track" tells server:
     - doesn't want any trace/unique ID/cookie that could correlates its visit of different websites
     - this includes tracking cookies, third-party ads tracking, but does not include Google Analytics, user preferences on 
       one site or targetting ads according to one single site preferences
  - Set-Cookie: VAR=VAL;SVAR=VAL;... [S]:
     - Asks client to send Cookie: VAR=VAL[;...] [C] again when visiting a specific path on a specific domain
     - Used to introduce a state: authentication, tracking, etc.
     - One Set-Cookie [S] per cookie, but one Cookie [C] for all cookies
     - VAL are percent-encoded
     - SVAR are:
        - path (récursif) (e.g. "/index.html") et domain (e.g. "www.a.org"):
           - when same as current: first-party cookies, often for authentication or for traffic analytics.
           - when different: third-party cookie
              - often tracking cookies : same domain accross different visited websites to connect different websites 
                someone visits, for advertising purposes
              - needs to trick the browser which otherwise blocks it (can only use cookie from same domain), e.g. hidden 
                iframes.
        - expires|max-age: DATE|NUM secondes before expiration (nothing for end of session). Put to 0 to delete cookie.
        - secure: can only transmit|receive via https.
        - HttpOnly: can't be used via JavaScript (document.cookies) (considered unsecure), can be used e.g. by PHP
     - Zombie cookie :
        - copies in several places.
        - if some absent, reduplicate them 
        - evercookie is an open source implementation
  - Private browsing :
     - a private session erases at the end all the traces (history, cookies, cache) it created.
     - called Incognito in Chrome

Compression:
  - Accept-Encoding: PROGRAM... [C], then Content-encoding: PROGRAM [S]
  - PROGRAM can be: 
      - "identity" (none) 
      - "gzip/deflate": Zlib. Same compression but different header (gzip conserves files info but bigger). 
        However, as a client should ask for gzip, because deflate is handled differently by some servers.
        Other compression methods are way less supported.
      - "bzip2" 
      - "lzma"
      - "shdc": by Google, supported natively by Chrome (seems inactive)
  - server should cache the input/output of compression to avoid doing twice the same compression on same input, because
    compression is long

HTTPS:
  - using HTTP over SSL/TLS over TCP
  - needs to be enable on all website resources, including scripts, all pages, etc., otherwise could attack on specific
    unsecure resources
     - this includes cookies. To have secure cookies, provide the secure attribute, which says it can only be used with HTTPS
  - Strict-Transport-Security: max-age=NUM (seconds from now); includeSubDomains [S]: specify clients it only allows HTTPS 
    connections. Client should resend the request using HTTPS if HTTP was used.
  - initiating connection:
     - Upgrade [C] for HTTPS: should not be used as it leaves beginning of communication unencrypted
     - https:// protocol

Switching protocols:
  - Upgrade: PROTOCOL/VERSION [C] to start a session in HTTP then continue in another protocol:
     - server sends 426 if failed
     - server sends 101 and Updgrade: PROTOCOL/VERSION [S] if success

Profiling:
  - X-Response-Time: NUM [S]: time taken by server to process answer

REST:
  - X-HTTP-Method-Override: METHOD [C]:
     - tells server that request should be interpreted as if HTTP METHOD has been used. 
	   - goal is to overcome network limitations (firewalls, etc.) protecting client from using methods like PUT, DELETE, etc. 
       on a REST API

Push technologies:
  - allow server to initiate message to client
  - types:
     - short polling with AJAX requests
     - HTTP server push / HTTP streaming: using Transfer-encoding: chunked [S]
     - Comet:
        - Pushlet: leaves HTTP connection open, sending new bits from time to time
        - Long polling: waits for server events to return the reply to client, then ask client to request again. Uses timeouts.
           - BOSH: variation of long polling
     - Server-sent events (SSE)
     - TCP socket used by plugins like Flash or Java: bi-directional
     - Websockets: same idea but standardized

HTTP Tunneling:
  - client wraps a TCP packet in a HTTP packet request body
  - tells proxy to unwrap HTTP packet and send TCP packet, and wrap received TCP packets as HTTP packet
  - can be used to bypass firewalls
  - CONNECT method:
     - use only first HTTP handshake with proxy, then use TCP connection
     - can be used to access HTTPS using a HTTP proxy (TCP between client-proxy, SSL between proxy-server)

Practices becoming bad with HTTP/2:
  - concatenation:
     - performance impact:
        - lower number of requests
        - but invalidates cache more often
     - HTTP/2:
        - does not have limit on number of parallel requests
        - keep TCP socket always alive
        - so roundtrip performance impact is less important
     - types of concatenation:
        - file plain concatenation
        - sprites
        - inlining, e.g. <link> -> <style>
        - data URIs
  - domain sharding
