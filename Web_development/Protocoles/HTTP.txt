
          
   HTTP   
          


To finish:
  - HTTP-related RFCs
  - format this doc
  - finish temp_sync doc
  - go back to CSS architecture to_learn list

HTTP-related RFCs:
  - URN/URI:
     - general: 1630, 2141, 3305, 3986, 7320
     - templates: 6570
     - well known URI: 5785
     - i18n: 3987
     - namespaces: 3406, 3553
     - resolution: 2169, 2276, 2483
     - Same origin policy: 6454
     - examples: 6963
     - data URI: 2397
     - IPv6: 6874
     - OID: 3061
     - tel://: 3966
     - UUID: 4122
     - tag://: 4151
     - about://: 6694
     - CSV: 7111
  - MIME: 
     - General: 2017, 2045, 2046, 2047, 2049, 2936, 6839
     - S-MIME: 2311, 2312, 7114
     - MIME text/plain: 3676, 5147
     - MIME charset: 2231, 5987, 6657
  - HTTP authentication:
     - General: 7615, 7617
     - HTTP basic authentication: 7235
     - HTTP digest authentication: 5843, 7616
     - HTTP bearer authentication: 6750
  - Language tag: 4645, 4647, 5645, 5646
  - PATCH: 5789, 7396
  - HTTP/1.*: 1945, 7231
  - Caching: 5861, 7232, 7234, https://www.w3.org/TR/edge-arch/
  - Content negotiation: 2295, 2296, 7240, 7694
  - Content-disposition: 6266
  - Compression, chunked encoding: 7230
  - Range [C]: 7233
  - Proxies: 3143, 3205, 7239
  - Long polling: 6202
  - Accept-Datetime [C]: 7089
  - Link [S]: 5988, 6903
  - LINK: https://tools.ietf.org/html/rfc2068#section-19.6.1.2, https://tools.ietf.org/html/draft-snell-link-method-12, https://www.w3.org/Protocols/HTTP/Methods/Link.html
  - Metalinks: 5854, 6249
  - Extensions: 2774
  - Diff: 3229, 3284
  - Alt-* [S]: 7838

Architecture:
  - mostly maintained by IETF RTCs
  - version 2. To guess support, can use:
     - ALPN, TLS extension (see SSL/TLS doc)
     - Upgrade: h2[c] [C|S] (see below)
        - h2 is HTTS, h2c HTTPS
        - must include SETTINGS frame as HTTP2-Settings [C] (base64-encoded)
        - not supported by most browsers
        - can Upgrade to but not from HTTP/2
     - prior knowledge: client already knows server supports HTTP/2
  - layers:
     - application layer
     - usually on top of TCP/IP
        - TCP ports: 80 (HTTP), 443 (HTTPS)
     - TLS:
        - HTTP/2: 
           - not required by specs, but browser implementation does
           - when used:
              - must use TLS 1.2+ with SNI extension
              - if using TLS 1.2, must disable compression, renegotiation
        - HTTP/1.*: not required
  - URI scheme: http[s]://
  - client-server:
     - client: "user agents", e.g. web browser, web crawler, app, etc.
     - order is always: client request -> server response (can include several streams)
     - resource can be dynamic (server modifies content) or static
  - state:
     - streams independant from each other
     - but headers/payload can keep state (e.g. cookies)
     - a stream need to keep its own state though
  - session:
     - set of TCP sockets:
        - HTTP/2: 
           - one per host (not hostname) + port
        - HTTP/1.*: 
           - 6 (depends on client) per hostname + port
           - hostname sharding: using different domains on a server to overcome limit
     - parallel requests per TCP socket: 
        - HTTP/2: multiplexing: SETTINGS_MAX_CONCURRENT_STREAMS (def: unlim) with no order (unless client suggest specific order)
        - HTTP/1.1: pipelining: 4-8 (depends on client) with head-of-line blocking (answers in same order as requests)
        - HTTP/1.0: serial: one
     - how long:
        - HTTP/2: 
           - until GOAWAY frame
           - timeout not mandatory nor forbidden
        - HTTP/1.*: 
           - until Connection: close [C|S]
           - timeout 10-15 secs (depends on server). Can be set by Keep-Alive: timeout=NUM [S]
           - NUM requests using Keep-Alive: max=NUM [S]
        - HTTP/1.0: requires Connection: Keep-Alive [C|S] to remain open

Format (HTTP/2):
  - stream: one request+response, or server push:
     - several ordered frames connected by stream ID
     - is what makes multiplexing possible
     - steam ID:
        - 0: hypothetical main stream
        - odd is started by client, even by server
        - incremental ID
  - frames:
     - headers: length [0-2], type [3], flags [4], reserved [5.0], stream ID [5.1-8], payload [*]
     - payload:
        - DATA (0x0): [padding length [0], ]data [*][, padding [*]]
        - HEADERS (0x1): [padding length [0], ][exclusive [1.0], stream parent ID [1.1-4], weight [5]], headers [*][, padding [*]]
        - PRIORITY (0x2): exclusive [0.0], stream parent ID [0.1-3], weight [4]
        - RST_STREAM (0x3): error code [0-3]
        - SETTINGS (0x4): several times: VAR [0-1], VAL [2-5]
        - PUSH_PROMISE (0x5): [padding length [0], ]reserved [1.0], promise stream ID [1.1-4], headers [*][, padding [*]]
        - PING (0x6): data [0-7]
        - GOAWAY (0x7): reserved [0.0], last stream ID [0.1-3], error code [4-7], debug data [*]
        - WINDOW_UPDATE (0x8): reserved [0.0], increment [0.1-3]
        - CONTINUATION (0x9): headers [*]
     - flags:
        - END_STREAM (0x1) (DATA, HEADERS)
        - ACK (0x1) (SETTINGS, PING)
        - END_HEADERS (0x4) (HEADERS, PUSH_PROMISE, CONTINUATION)
        - PADDED (0x8) (DATA, HEADERS, PUSH_PROMISE)
        - PRIORITY (0x20) (HEADERS)
  - init (for each endpoint):
     - start:
         PRI * HTTP/2.0

         SM

     - SETTINGS frame:
        - options, noted SETTINGS_*
        - receiver must respond with empty SETTINGS frame with ACK flag
        - can be sent again later to change settings
  - normal (request/response) stream:
     - request:
        - 1 HEADERS, 0-n DATA (payload), 0-1 trailing HEADERS
        - HEADERS:
           - must contain pseudo-headers: 
               :method METHOD [C] 
               :authority URL [C] 
               :path PATH [C] : can be *
               :scheme PROTOCOL [C]
           - if 1 frame not enough, send extra CONTINUATION frames with extra headers
           - last frame should have flag END_HEADERS
     - response:
        - same but HEADERS must contain instead pseudo-header :status UINT [S]
  - server push stream:
     - enabled by SETTINGS_ENABLE_PUSH (0x2) (def: true)
     - initiated by server, in reaction to client request
     - server: PUSH_PROMISE frame:
        - contains HEADERS frame information that client would send if it was to request this stream
        - the original request cannot contain payload
        - the pushed request must be cacheable, e.g. use safe method
     - client:
        - RST_STREAM frame to cancel request, e.g. if cached
        - server reacts to RST_STREAM but does not wait for client to send next frames
     - server: 
        - HEADERS, DATA: like normal response
  - end:
     - END_STREAM flag:
        - normal stream end
        - on last DATA frame (or last HEADERS if none) for each endpoint
        - might be followed by CONTINUATION frames
     - RST_STREAM frame: 
        - cancels current stream
     - GOAWAY frame: 
        - end of session , i.e. stops any new stream
        - keep processing existing streams
        - contains last stream ID that will be processed
        - can contain arbitrary debug info
        - should respond with another GOAWAY

Error codes (HTTP/2):
  - types:
     - NO_ERROR (0x0)
     - PROTOCOL_ERROR (0x1): e.g. wrong frame order or content
     - INTERNAL_ERROR (0x2)
     - FLOW_CONTROL_ERROR (0x3): too much buffered DATA because of flow control
     - SETTINGS_TIMEOUT (0x4): SETTINGS response timeout
     - STREAM_CLOSED (0x5)
     - FRAME_SIZE_ERROR (0x6): frame too small|big
     - REFUSED_STREAM (0x7): sender notifies receiver that reqyest has not been processed, allowing safe retry. E.g. too many concurrent streams or refused server push
     - CANCEL (0x8): stream no longer needed or server push refused
     - COMPRESSION_ERROR (0x9)
     - CONNECT_ERROR (0xa): when using CONNECT method
     - ENHANCE_YOUR_CALM (0xb): throttling, e.g. too many server pushes
     - INADEQUATE_SECURITY (0xc): does not use TLS or wrong TLS setup
     - HTTP_1_1_ERROR (0xd): should downgrade to HTTP/1.1
  - contained in GOAWAY|RST_FRAME frame

Limits (HTTP/2):
  - SETTINGS_MAX_CONCURRENT_STREAMS (0x3) (def: unlim)
  - SETTINGS_MAX_FRAME_SIZE (0x5) (def/min: 16KB, max: 16MB)
  - HEADERS frames:
     - SETINGS_MAX_HEADER_LIST_SIZE (0x6) (def: unlim):
        - max HEADERS frame size, uncompressed, with extra 32 bytes per header. 
        - not mandatory to respect it.
     - SETTINGS_HEADER_TABLE_SIZE (0x1) (def: 4KB): headers dynamic table size
     - implementation additional limits, e.g. Apache limits 8MB/header and 1000 headers, Node.js 80KB/header
  - DATA frames: max receiver buffer (flow control):
     - counter SETTINGS_INITIAL_WINDOW_SIZE (0x4) bytes (def: 64KB, max: 2GB):
        - decreased when sender sends
        - increased when receiver sends WINDOW_UPDATE frame:
           - includes how much to increase
           - e.g. when receiver consumed (i.e. received and do not buffer anymore)
        - if exhausted, each endpoint should terminate stream
        - should amount to how much receiver can buffer
     - can be for a stream, or whole connection (if stream ID is 0)

PING frame (HTTP/2):
  - used to calculate round-trip time
  - contains 8 bytes of arbitrary data
  - have priority over other frame types
  - must respond with another PING frame with flag ACK

Stream prioritization (HTTP/2):
  - receiver is not constrained to respect it
  - fields/flags on HEADERS|PRIORITY frame. Must set PRIORITY flag
  - priority: Weight field 1-256 (def: 16): how much resources server should allocate
  - dependency:
     - Parent stream ID field (def: 0, i.e. none): current stream must only start once stream ID is done
     - Exclusive field: make siblings become children of current stream

Format (HTTP/1.*):
  - newline is \n\r
  - request:
      METHOD URL HTTP/1.*
      HEADER: VAL
      ...

      [BODY]
  - response:
      HTTP/1.1 UINT STR
      [HEADER: VAL
      ...]

      [BODY]
  - Host [C] is mandatory

Format extensions:
  - new headers
  - HTTP/2:
     - new frame type
     - new SETTINGS_*
     - new *_ERROR

Switching protocols:
  - starting a session in HTTP then continuing in another protocol
  - how:
     - client: 
        - Upgrade: PROTOCOL/VERSION [C]
     - server:
        - 101 (Switching Protocols) + Upgrade: PROTOCOL/VERSION [S]: success
        - 426 (Upgrade Required): failure

Method:
  - concepts:
     - safety:
        - unsafe means side-effects on the resource
        - can be thought as safe (read) and unsafe (write)
        - safe implies idempotent
        - Safe [C]: 
           - declares method safe
           - useless for methods safe by default
           - other methods should remain unsafe. However ther are cases where a safe POST is needed, e.g. when need to submit
             x-www-urlencoded safe request without using XHR
           - goal is to imply idempotency, i.e. client can retry without prompting user
           - not implemented by clients
     - idempotency:
        - resource returned is always same if called again (with same parameters)
        - mean client can repeat request without risk
  - types:
     - safe:
        - GET: retrieve resource
        - HEAD: retrieve resource (header only)
        - OPTIONS:
           - retrieve metadata (e.g. functionalities of web server).
           - usually use * as URL
        - TRACE: 
           - echoes request
           - to see changes introduced by servers|proxies
     - unsafe:
        - idempotent:
           - PUT: replace/create (completely) resource with specific ID
           - DELETE: erase resource
        - not idempotent:
           - POST: create resource without specific ID
           - PATCH: 
              - modify (partially) resource
              - while PUT|POST sends resource itself, PATCH sends resource diff (which might be different format)
              - can create, or not (preferred)
              - should require If-* [C], unless it just appends
              - consider 409 for conflicts
           - CONNECT: HTTP Tunneling
  - whitelisting:
     - Allow: HTTP_METHOD,... [S], usually in response to OPTIONS request
     - 405 (Method not allowed)
  - X-HTTP-Method-Override: METHOD [C]:
     - request should be interpreted as if HTTP METHOD had been used
     - goal is to overcome proxies HTTP methods restrictions

Headers:
  - case insensitive
  - written [S|C] for server|client in my doc
  - binary compressed (HTTP/2)
     - algo is 'HPACK'
     - common HEADER or HEADER: VAL have predefined numbers
     - each endpoint caches HEADER: VAL in a dynamic table
  - :HEADER are called pseudo-headers: same as headers but with extra restrictions on when can be used (HTTP/2)

Status codes:
  - WebDAV-only: 102, 207, 208, 422, 423, 424, 507, 508
  - default caching:
     -- cached
     +- not cached
      - not specified, i.e. not cached
  - 1**: information
     - 100 (Continue)                         client sent only headers and can proceed to send body (see Expect: 100-continue [C])
     - 101 (Switching Protocols)              switch protocol success, e.g. from HTTP to HTTPS (see Upgrade [C])
  - 2**: success
    -- 200 (OK)                               simple
     - 201 (Created)                          new resource (e.g. POST). Use Location: URL [S] for new resource URL.
     - 202 (Accepted)                         response is ongoing and will take some time to proccess (client can timeout). Usually response include links to monitor processing status.
    -- 203 (Non-Authoritative Information)    proxy transformed server response, which was originally 200
    -- 204 (No Content)                       OK, but nothing is to be returned. Client should stay on same resource/document. E.g. successful DELETE, If-Modified-Since header.
     - 205 (Reset content)                    like 204 but client should reset/refresh current resource/document.
    -- 206 (Partial content)                  response is only a subset of the full resource, (see Range [C])
     - 214 (Transformation applied)           proxy transformed server response, which was originally not 200
    -- 226 (IM used)                          returns diff not full resource. Uses HTTP delta compression, an RFC which seems old.
  - 3**: redirection to be performed by client
    -- 300 (Multiple choices)                 redirection need client input
    -- 301 (Moved Permanently)                permanent, GET (even if different method, but should ask first). Cacheable.
    +- 302 (Found)                            temp, GET (even if different method, but should ask first)
    +- 303 (See other)                        different resource (not only different URL) than requested
    +- 304 (Not Modified)                     resource did not change (see caching)
    +- 305 (Use proxy)                        redirect to a proxy
    +- 307 (Temporary Redirect)               temp, same HTTP method
    -- 308 (Permanent Redirect)               permanent, same HTTP method
  - 4**: client-side failure
     - 400 (Bad request)                      syntax error
     - 401 (Unauthorized)                     authentication problem
     - 402 (Payment required)                 e.g. should pay to increase request rate
     - 403 (Forbidden)                        authorization problem. Prefer 404 when location itself is secret.
    -- 404 (Not Found)                        wrong URL, but correct domain.
    -- 405 (Method not allowed)               HTTP method not implemented or not allowed
     - 406 (Not Acceptable)                   wrong requested media type (see Accept [C])
     - 407 (Proxy authentication required)    like 401 but for application proxy
     - 408 (Request Timeout)                  as opposed to response timeout
     - 409 (Conflict)                         multi-client conflict
    -- 410 (Gone)                             like 404, but indicates URL was present before
     - 411 (Length Required)                  missing request body length (see Content-Length [C])
     - 412 (Precondition Failed)              resource changed even though client assumed it did not, e.g. with If-Unmodified-Since [C] (see caching)
     - 413 (Payload too large)
    -- 414 (URI too long) 
     - 415 (Unsupported Media Type)           server does not support payload media type (inverse of 406)
     - 416 (Range Not Satisfiable)            wrong Range [C]
     - 417 (Expectation failed)               wrong Expect [C]
    -- 421 (Misredirected request)            request picked wrong server
     - 422 (Unprocessable Entity)             request payload has correct syntax and media type, but wrong instructions that cannot be applied
     - 426 (Upgrade Required)                 switch protocol denied, e.g. from HTTP to HTTPS
    +- 428 (Precondition required)            must use If-* [C]
    +- 429 (Too many requests)                throttle. May include Retry-After [S]
    +- 431 (Request header fields too large)
    -- 451 (Unavailable for Legal Reasons)    e.g. censorship, copyright, privacy. Can include Link [S] with rel="blocked-by"
  - 5**: server-side failure
     - 500 (Internal server error)            bug in server, e.g. syntax error
    -- 501 (Not implemented)                  feature not available yet
     - 502 (Bad gateway)                      sent by proxy when it received error from server
     - 503 (Service unavailable)              server is down (cannot connect)
     - 504 (Gateway timeout)                  sent by proxy on server timeout
     - 505 (HTTP version not supported)
     - 506 (Variant also negotiates)          negotiation circular loop (see Negotiate [C])
     - 510 (Not extended)                     HTTP extension not implemented
    +- 511 (Network authentication required)  like 401 but for network proxy, containing link where to authenticate.

<meta http-equiv="HEADER" content="VAL">:
  - add HTTP header client-side
  - only ones that are crossbrowser: refresh, Content-Security-Policy

Redirections:
  - use 3** status code and:
     - client should request again:
        - Location: URL [S]: right away
        - Retry-After: NUM|DATE [S]: in future, same URL
        - Refresh: NUM[, url=URL] [S]: in future, same URL or not. Can be used as <meta http-equiv>
     - server fetched it without additional request:
        - Content-Location: URL [S]
  - 5+ redirections is considered infinite loop.

Time:
  - Date: DATE [C]: when request was sent 
  - X-Response-Time: NUM [S]: time taken by server to process answer
  - Accept-Datetime [C]: ask for past|present versions

Browser HTTP requests:
  - by changing current URL:
     - UI: 
        - browser chrome: back|forward|home button, URL bar, searchbar, bookmarks, etc.
        - <a|area> click event 
        - <form> submit event
     - programatically:
        - WINDOW.location|history
  - XHR.send(), FETCH

Query strings:
  - use URL?VAR=VAL&...: 
     - instead of request body 
     - like 'application/x-www-form-urlencoded' but:
        - %20 instead of +
        - nesting support: Express REQ.query
  - advantages:
     - recommended way to send request body with GET|HEAD
     - easier to set non-programatically (e.g. by typing URL)
     - stateful URL, e.g. for bookmarks
  - disadvantages:
     - non-separation of concern between resource location and request body
     - longer URL
     - SEO

Software identity:
  - User-agent: STR [C]: client technology
  - X-Requested-With: STR [C]:
     - how request was performed
     - often used: XMLHttpRequest
  - Server: STR [S]: server name
  - X-Powered-By: STR [S]: server technology
  - Pragma: VAL [C|S]: headers specific to a given client|server technology
  - X-UA-Compatible: CLIENT=VERSION;... [S]: 
     - client, if CLIENT, should render as it was VERSION
     - used with IE, e.g. IE=NUM|edge

Client identity:
  - From: EMAIL_ADDRESS [C]: often used with bots for support email
Destination:
  - Host: HOST[:PORT] [C] (HTTP/1.1) or :authority HOST[:PORT] [C] (HTTP/2) 
     - HOST case sensitivity depends on server

Content:
  - vocabulary:
     - resource: highest-level
     - variant: a resource with a specific representation (e.g. language, Content-Type, etc.)
     - instance: a variant inside a request/response payload, without transfer-related encoding (e.g. compression, Range [C])
     - entity: same as instance, but with transfer-related encoding (i.e. what is actually sent)
  - content negotiation:
     - server-side:
        - client informs of accepted variants (NUM is preference):
           - Accept:         MIME_TYPE[; q=NUM],... [C]
           - Accept-Charset:   CHARSET[; q=NUM],... [C]
           - Accept-language: LANGUAGE[; q=NUM],... [C] 
           - Accept-features:  FEATURE[; q=NUM],... [C]
        - server picks one:
           - Content-Type: MIME_TYPE[; charset=CHARSET] [S]
           - Content-language: LANG [S]
           - 406 (Not Acceptable): wrong Accept-* [C]
     - transparent:
        - client asks for possible variants:
           - Accept* [C] (optional)
           - Negotiate: VAL [C]:
              - trans: support transparent content negotiation, let server decide if should use
              - vlist: support, ask server to use
        - server informs of possible variants:
           - TCN: VAL [S]: type of response:
              - ad-hoc: same as server-side negotiation, i.e. server picked
              - choice: like ad-hoc but also:
                  Alternates: URL,... [S]: other possible representations
              - list: 
                 - gives only possible representations, do not pick one
                 - 300 status code
           - 506 status code: circular references due to choice picking
        - client accepts chosen variant (ad-hoc, choice) or ask for a specific one (choice, list)
     - trade-offs:
        - mandatory Accept* [C]: allows fingerprinting user agent (privacy concern)
        - transparent negotiation with list: extra HTTP request
  - request payload:
     - 415 (Unsupported Media Type): wrong request payload MIME_TYPE
  - response payload:
     - render vs download:
        - depends if Content-Type [S] rendering is supported by client
           - Content-Type "multipart/form-data; boundary=STR" [S]: always download
        - Content-Disposition: attachment[; filename="..."] [S]: forces download

Cache:
  - vocabulary:
     - cache hits ratio: % of requests that used cache instead
     - stale resource: cached but not valid anymore
     - cache invalidation: removing caching on stale resources
  - types:
     - client caching: 
        - best performance but for single client
        - e.g. browser caching
     - server caching:
        - across many clients but less performant
        - types:
           - reverse proxy (between client and server)
              - ISP
              - web accelerator: 
                 - reverse proxy dedicated to caching
                 - can also do prefetching, compression/minification
              - CDN: 
                 - network across several geographical regions to be closer to clients
                 - optimized for high availability
           - between server and database: 
              - e.g. Memcached/Redis
  - Vary: HEADER [S]:
     - notifies client to use different entry caches on same URL if different HEADER [C] value
     - to use when headers have impact on content, i.e. usually on Accept* [C]
     - usually towards proxies, since browsers usually use only one set of headers
  - debug: chrome://cache on Chrome
  - see above for which status code usually cache or not
  - caching is based on URL, including query string, excluding #HASH or request body
  - types:
     - default caching:
        - depends on browser, heuristics to guess which type of caching should be used and how long
        - to avoid
     - history backward/forward caching:
        - no control over it
     - unconditional caching:
        - client uses cache for a given time period, without server interaction
           - does not apply on page refresh
           - has priority over conditional caching
        - features:
           - fastest cache method
           - highest probability of stale resources, except when using timestamping
           - best for asset files
        - Cache-Control: STR,... [S|C]:
           - client override server
           - STR:
              - no-cache[="HEADER"]: no unconditional caching [a specific header]
              - no-store: no unconditional nor conditional caching
              - max-age NUM: 
                 - how long to cache, i.e. how long stale resources are ok
                 - max: 1 year
                 - if fingerstamped, can be max value
              - Expires: DATE [S]:
                 - same as max-age but using a given DATE
                 - older header
              - must-revalidate: 
                 - when expires, use conditional caching (if setup)
                 - default of most clients
              - public|private:
                 - allow or prohibit (def) reverse proxy caching
                 - private: good for sensitive data, e.g. cookies
              - s-max-age: same as max-age but for reverse proxies
              - proxy-revalidate: same as must-revalidate but for reverse proxies
              - no-transform: don't allow reverse proxy to compress|minify resources (e.g. images/videos) or inject JavaScript code
        - timestamping:
           - using an ID in the URL that changes when resource changes
              - e.g. version number, modification date or content checksum
           - used to invalidate cache on modified resources
           - top-level resources (i.e. that require timestamped resources) (e.g. main HTML file) cannot be timestamped itself
     - conditional caching:
        - client sends request with information about latest representation, and server does not send body if resource has not changed
        - features:
           - slower method but no possibility of stale resources
           - does not require timestamping
           - best for top-level resources, e.g. main HTML file or AJAX calls
        - how:
           - server:
              - Last-Modified: DATE [S] (mtime)
              - ETag: HASH [S] (content hash):
                 - W/"...": weak, same resource, i.e. same semantically but not necessarily byte-wise
                 - "...": strong, same instance, i.e. same byte-wise
           - client include latest representation:
              - If-[Un]Modified-Since: DATE [C]
              - If-[None-]Match: HASH [C] (if specified, If-[Un]Modified-Since is ignored)
           - server:
              - if condition does not match:
                 - 304 (Not modified) with no body: If-Modified-Since or If-None-Match, and safe HTTP method
                 - 412 (Precondition failed) otherwise:
                    - not used for caching, but e.g. do not DELETE if resource has changed
              - can use 428 (Precondition required) to force conditional caching
     - no caching:
        - features:
           - slowest method, but:
              - best if resource never same, e.g. anything that contains time-dependent/always-unique server-side content
              - prevent caching credentials
        - how:
           - server:
               Cache-Control: no-cache[="HEADER"], no-store, private
           - client (works also for HTTP/1.0 servers):
               Cache-Control: no-cache, no-store, private, must-revalidate
               Pragma: no-cache
               Expires: 0

Prefetching (resource hints, server push):
  - types, from most performant to least:
+--------------+----------------------------------------------+---------------------------------------------------------------------+------------------------------------+
| Type/REL     | Use case                                     | Effects                                                             | Browser support                    |
|              +--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+                                    |
|              | Resource for which | Known path | Likelihood | Initiated | When is resource        | Loads | Parse + | Protocols   |                                    |
|              | navigation action  |            |            | by        | fetched                 |       | render  |             |                                    |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| server push  | Current            | Yes        | Certain    | server    | right away (no request) | Yes   | Yes     | HTTP        | All                                |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| preload      | Current            | Yes        | Certain    | client    | async right away        | No    | No      | HTTP        | Chrome/Opera                       |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| preconnect   | Current            | No         | Certain    | client    | async right away        | No    | No      | DNS         | Chrome/Opera/Firefox               |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| prerender    | Next               | Yes        | High       | client    | after document.onload   | No    | Yes     | HTTP        | Chrome/Opera/IE                    |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| prefetch     | Next               | Yes        | Middle/low | client    | after document.onload   | No    | No      | HTTP        | not [mobile] Safari nor Opera mini |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| dns-prefetch | Next               | No         | Middle/low | client    | after document.onload   | No    | No      | DNS+TCP/TLS | not Opera mini                     |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
  - server push:
     - send additional resources in a single response
     - performance:
        - less roundtrips than resource hints
        - but should push only resources that would have been requested
     - caching:
        - uses pseudo-client request for caching, so works the same as normal request
        - client request must be cacheable, i.e. GET with cache headers
     - not actual prefetching (it loads resource)
     - need to be initiated by a request (so not realtime)
     - as opposed to resource hints, initiated by server so cannot be used if:
        - client needs knowledge about fetching: resource path, load|error event
        - fetching needs knowledge about client: state (cookies, localStorage), user agent info (Accept [C], etc.)
  - resource hints:
     - use either:
         Link: <URL>; rel=REL[; ATTR=VAL]... [, <URL>...] [S]
         <link href="URL" rel="REL" ATTR="VAL" ...>...
     - ATTR:
        - pr 'FLOAT' (0-1) (all)
           - probability the link will be followed 
           - used for prioritization or reducing optimization/fetching
        - as TYPE (preload|prefetch): 
           - WINDOW.fetch() destination type, 
             i.e. script|style|image|font|media|object|embed|document|xslt|manifest|report|service|shared]worker
           - used for CSP and Accept [C]
        - nopush (preload): if a HTTP2 server push has been received for that resource, do not use it
     - prerender parsing/execution:
        - in the background, i.e. not visible but will provide very fast cache
        - only kept for short while, so should be next navigation
        - resource intensive: should only be used when confident about next navigation action
        - only HTML resources
     - does not delay document.onload
     - could previously use noop XHR to achieve something similar
     - cannot see in devtools network tab, but can see "prerender" using chrome://net-internals/#prerender
     - can be:
        - speculative: before user interaction that might trigger HTTP request
        - reactive: after user interaction that will certainly trigger HTTP request, after some delay
     - possible problems:
        - when HTTP GET request has side effects (which is improper)
        - increase bandwith usage
        - overestimate tracking (ads, analytics):
           - can use document.visibilityState 'prerender' to handle it
        - security: website make decision (not user) to trust content by browsing it

Long request:
  - header first, then body:
     - client: Expect: "100-continue" [C], no request body
     - server:
        - 100 (Continue) if success
        - 417 (Expectation Failed) if failure
     - client: request body body
  - Content-Length [C|S]:
     - request body length
     - can use 411 (Length Required)
  - request too large:
     - 414 (Request URI too long)
     - 431 (Request header fields too large)
     - 413 (Request Entity too large)

Long response:
  - request specific ranges (byte serving):
     - init: Accept-Ranges: bytes [S]
     - each range:
        - client:
           - Range: bytes=NUM-NUM2 [C]
           - If-Range: ETAG|MDATE [C] (optional)
              - if content changed, sends entire file (not only RANGE)
              - otherwise, sends RANGE
        - server:
           - success:
               Content-Range: bytes NUM-NUM2/TOTAL [S] 
               206 (Partial content)
           - failure:
               416 (Requested Range Not Satisfiable)
  (HTTP/1.* only)
  - send response body in several times:
     - how:
        - client: TE: chunked [C]
        - server:
           - Trailer: HEADER [S] (optional) to indicate trailer headers
           - Transfer-Encoding: chunked [S], sendind each chunk
           - trailing headers
           - empty chunk
     - should use compression

Proxies:
  - X-Forwarded-For|Proto|Port: HOST|PROTOCOL|PORT... [C]: forwarded server info
  - Via: HTTP_VERSION URL SERVER ... [C|S]: proxy info
  - Max-Forwards: NUM [C]: max number of proxies

Security: See Websites_security doc

Authentication: see authentication doc

Instance integrity:
  - digest:
     - how:
        - Want-Digest: ALGO[;q=NUM],... [C]
           - ALGO: 
              - MD5|SHA|UNIXsum|UNIXcksum
              - SHA is SHA-1
              - MD5|SHA requires base64, other ASCII
           - NUM: like for Accept* [C]
        - Digest: ALGO=CHECKSUM[,...] [S]
     - check integrity for "instance", i.e.:
        - body not headers
        - not "entity", i.e. without taking compression, Range [C], etc. into account
     - not implemented by most clients
  - Content-MD5 [C]: deprecated

Tracking:
  - Private browsing:
     - a private session erases at the end all the traces (history, cookies, cache) it created.
     - called Incognito in Chrome
  - Referer: URL [C]:
     - current URL
     - Link: noreferrer [S]: ask client not to send it
  - DNT: 1|0 [C]:
     - "Do-not-track". Ask server not to be cross-site tracked.
     - Must be explicitely enabled inside browser settings

Cookies:
  - goal:
     - store state for a specific client+server pair
     - can be ignored by some clients
     - clients will remove them due to memory constraints or end-user demand
  - how:
     - server:
         Set-Cookie: VAR=VAL[;OPTIONS] [S]: one header per cookie
         OPTIONS is SVAR=VAL;...
     - client, next request on same domain+path:
         Cookie: VAR=VAL[;...] [C]: one header for all cookies
     - VAL are percent-encoded
     - SVAR:
        - domain STR:
           - must be same as server, or superdomain
           - subdomains will match
        - path '/PATH'
           - recursive
        - expires|max-age: 
           - DATE|NUM seconds before expiration 
           - max-age has priority
           - def: end of session
           - 0 deletes cookie
        - secure: can only get|set via HTTPS
        - HttpOnly: can't be used via JavaScript (document.cookies), for security reasons
  - limits:
     - 4KB/cookie (most browsers)
     - 50/domain (IE11)
     - 10KB/domain (IE11)
  - types:
     - first-party cookie:
        - cookie path/domain (i.e. HTTP request) is same as top-level page path/domain
     - third-party cookie:
        - inverse
        - can be blocked in browser settings
        - only disabled by default in Safari
     - Zombie cookie:
        - use cookies but also other storage at once, e.g. localStorage, ETag [C], Flash cookies, etc.
        - removing from one place -> others recreate it
  - security:
     - cannot rely only on cookies for authorization, must also use anti-CSRF measures
     - content should be encrypted (for confidentiality) and signed (for authenticity) even over HTTPS
     - should use secure and HttpOnly
     - content should contain key (to server-side hash table, e.g. session id) not direct information
     - service on same URL but different port can access cookie
     - service on same domain or superdomain can set cookies

Compression:
  - how:
     - client: Accept-Encoding: PROGRAM,... [C]:
        (standard)
        - "identity" (none)
        - "compress":
           - worst compression, older
           - older: not supported anymore
        - "deflate":
           - DEFLATE/INFLATE algorithm
           - inconsistent support: either without a wrapper format (IE) or with zlib wrapper format (other browsers)
        - "gzip":
           - DEFLATE/INFLATE algorithm, with gzip wrapper format
        - "exi":
           - better compression than DEFLATE, for XML files
           - w3c standard but no browser support
        (not standard)
        - "bzip2" 
           - better compression than DEFLATE but slower
           - browser support: Firefox only with specific build flag
        - "lzma":
           - better compression than DEFLATE but slower
           - better compression than bzip2, but slower, faster at decompressing but slower at compressing 
           - browser support: Opera
        - "xz":
           - LZMA2
           - browser support: Firefox only with specific build flag
        - "sdch": 
           - based on VCDIFF
           - does not seem really maintained anymore
           - browser support: Opera, Chrome
        - "br"
           - best compression. Same decompression speed as DEFLATE but slower at compressing.
           - browser support: Firefox, Chrome
     - server: Content-encoding: PROGRAM [S]
  - summary: server should offer in order: br, [sdch,] lzma, gzip, identity
  - server should cache compression

Push technologies:
  - allow server to initiate message to client
  - types:
     - XHR short polling: not really realtime
     - HTTP server push / HTTP streaming / Comet / AJAX push / Reverse AJAX (HTTP/1.1): using Transfer-encoding: chunked [S]
     - Pushlet: 
        - leaves initial HTML page request open
        - server sends new DOM without closing request
     - Long polling: 
        - leaves XHR open
        - server sends response, closing request, then client starts a new one
        - client might use timeout for XHR
        - BOSH: long polling with a specific POST request with standardized parameters
     - TCP socket used by plugins like Flash or Java:
        - problem: rely on other technologies
     - Websockets
     - Server-sent events (SSE): like websockets but for HTTP
  - best: Websockets or SSE

HTTP Tunneling:
  - wrapping another protocol packets in a HTTP payload
  - proxy and endpoints wraps|unwraps request|response
  - CONNECT method:
     - wraps TCP protocol
     - use only first HTTP handshake with proxy, then use TCP connection
     - can be used to access HTTPS using a HTTP proxy (TCP between client-proxy, SSL between proxy-server)

Practices becoming bad with HTTP/2:
  - concatenation:
     - performance impact:
        - lower number of requests
        - but invalidates cache more often
     - HTTP/2:
        - does not have limit on number of parallel requests
        - keep TCP socket always alive
        - so roundtrip performance impact is less important
     - types of concatenation:
        - file plain concatenation
        - sprites
        - inlining, e.g. <link> -> <style>
        - data URIs
  - domain sharding

URL                                             #Can be:
                                                #  - [..|./]URL: relative
                                                #  - [PROT:]/[/]URL: absolute
                                                #     - should use //URL if available under both HTTP and HTTPS
                                                #  - "[URL]#ID|NAME": anchor
                                                #  - data URI:
                                                #     - "data:[MIMETYPE];base64,CODE":
                                                #        - CODE: data encoded in base64 (e.g. using WINDOW.btoa|atob())
                                                #           - base64 discard whitespaces
                                                #        - def MIMETYPE: text/plain
                                                #     - "data:[MIMETYPE];charset=utf-8,CODE":
                                                #        - CODE: data URI encoded (e.g. with encode|decodeURIComponent())
