
          
   HTTP   
          


List of headers:
  - look at list on hpack spec
  - look at iana list
  - look at individual speca, including HTTP/1.1 spec


Architecture:
  - version 2
     - to guess HTTP/2 version, can use:
        - ALPN, TLS extension (see SSL/TLS doc)
        - Upgrade: h2[c] [C|S] (see below)
           - h2 is HTTS, h2c HTTPS
           - must include SETTINGS frame as HTTP2-Settings [C] (base64-encoded)
           - not supported by most browsers
        - prior knowledge: client already knows server supports HTTP/2
  - layers:
     - application layer
     - usually on top of TCP/IP
        - TCP ports: 80 (HTTP), 443 (HTTPS)
        - SSDP is like HTTP, but above UDP
     - TLS:
        - HTTP/2: 
           - not required by specs, but browser implementation does
           - when used:
              - must use TLS 1.2+ with SNI extension
              - if using TLS 1.2, must disable compression, renegotiation
        - HTTP/1.*: not required
  - URI scheme: http[s]://
  - client-server:
     - client: "user agents", e.g. web browser, web crawler, app, etc.
     - resource can be dynamic (server modifies content) or static
  - state:
     - streams independant from each other
     - but URL/headers/payload can keep state (e.g. cookies)
     - a stream need to keep its own state though
  - session:
     - set of TCP sockets:
        - HTTP/2: 
           - one per host (not hostname) + port
        - HTTP/1.*: 
           - 6 (depends on client) per hostname + port
           - hostname sharding: using different domains on a server to overcome limit
     - parallel requests per TCP socket: 
        - HTTP/2: multiplexing: SETTINGS_MAX_CONCURRENT_STREAMS (def: unlim) with no order (unless client suggest specific order)
        - HTTP/1.1: pipelining: 4-8 (depends on client) with head-of-line blocking (answers in same order as requests)
        - HTTP/1.0: serial: one
     - how long:
        - HTTP/2: 
           - until GOAWAY frame
           - timeout not mandatory nor forbidden
        - HTTP/1.*: 
           - until Connection: close [C|S]
           - timeout 10-15 secs (depends on server). Can be set by Keep-Alive: timeout=NUM [S]
           - NUM requests using Keep-Alive: max=NUM [S]
        - HTTP/1.0: requires Connection: Keep-Alive [C|S] to remain open

Low-level format (HTTP/2): ???

Error codes (HTTP/2):
           - types:
              - NO_ERROR
              - PROTOCOL_ERROR: e.g. wrong frame order or content
              - INTERNAL_ERROR
              - FLOW_CONTROL_ERROR: too much buffered DATA because of flow control
              - SETTINGS_TIMEOUT: SETTINGS response timeout
              - STREAM_CLOSED
              - FRAME_SIZE_ERROR: frame too small|big
              - REFUSED_STREAM: sender notifies receiver that reqyest has not been processed, allowing safe retry. E.g. too many concurrent streams or refused server push
              - CANCEL: stream no longer needed or server push refused
              - COMPRESSION_ERROR
              - CONNECT_ERROR: when using CONNECT method
              - ENHANCE_YOUR_CALM: throttling, e.g. too many server pushes
              - INADEQUATE_SECURITY: does not use TLS or wrong TLS setup
              - HTTP_1_1_ERROR: should downgrade to HTTP/1.1
           - contained in GOAWAY|RST_FRAME frame

Stream prioritization (HTTP/2):
              - receiver is not constrained to respect it
              - fields/flags on HEADERS|PRIORITY frame
              - dependency:
                 - Parent stream ID field (def: 0): current stream must only start once stream ID is done
                 - EXCLUSIVE flag: make siblings become children of current stream
              - priority: Weight field 1-256 (def: 16): how much resources server should allocate

Format (HTTP/2)
        - stream: one request+response, or server push:
           - several ordered frames connected by stream ID
           - is what makes multiplexing possible
        - frames:
           - size
           - type
           - flags
           - stream ID:
              - 0: hypothetical main stream
              - odd is started by client, even by server
              - incremental ID
        - init (for each endpoint):
           - start:
               PRI * HTTP/2.0

               SM

           - SETTINGS frame:
              - options, noted SETTINGS_* in this doc
              - receiver must respond with empty SETTINGS frame with ACK flag set
              - can be sent again later to change settings
        - normal (request/response) stream:
           - request:
              - HEADERS, DATA (payload), optional trailing HEADERS
              - HEADERS:
                 - must contain pseudo-headers: 
                     :method METHOD [C] 
                     :authority URL [C] 
                     :path PATH [C] : can be *
                     :scheme PROTOCOL [C]
                 - if frame too small, send extra CONTINUATION frames with extra headers
                 - last frame should have flag END_HEADERS
           - response:
              - same but HEADERS must contain instead pseudo-header :status UINT [S]
        - server push stream:
           - enabled by SETTINGS_ENABLE_PUSH (def: true)
           - initiated by server, in reaction to client request
           - server: PUSH_PROMISE frame:
              - contains HEADERS frame information that client would send if it was to request this stream
              - the original request cannot contain payload
              - the pushed request must be cacheable, e.g. use safe method
           - client:
              - RST_STREAM frame to cancel request, e.g. if cached
              - server reacts to RST_STREAM but does not wait for client to send next frames
           - server: 
              - HEADERS, DATA: like normal response
        - end:
           - END_STREAM flag:
              - normal stream end
              - on last DATA frame (or last HEADERS if none) for each endpoint
              - might be followed by CONTINUATION frames
           - RST_STREAM frame: 
              - cancels current stream
           - GOAWAY frame: 
              - end of session , i.e. stops any new stream
              - keep processing existing streams
              - contains last stream ID that will be processed
              - can contain arbitrary debug info
              - should respond with another GOAWAY

Limits (HTTP/2):
  - SETTINGS_MAX_CONCURRENT_STREAMS (def: unlim)
  - SETTINGS_MAX_FRAME_SIZE (def/min: 16KB, max: 16MB)
  - HEADERS frames:
     - SETINGS_MAX_HEADER_LIST_SIZE (def: unlim):
        - max HEADERS frame size, uncompressed, with extra 32 bytes per header. 
        - not mandatory to respect it.
     - SETTINGS_HEADER_TABLE_SIZE (def: 4KB): headers dynamic table size
     - implementation additional limits, e.g. Apache limits 8MB/header and 1000 headers, Node.js 80KB/header
  - DATA frames: max receiver buffer (flow control):
     - counter SETTINGS_INITIAL_WINDOW_SIZE bytes (def: 64KB, max: 2GB):
        - decreased when sender sends
        - increased when receiver sends WINDOW_UPDATE frame:
           - includes how much to increase
           - e.g. when receiver consumed (i.e. received and do not buffer anymore)
        - if exhausted, each endpoint should terminate stream
        - should amount to how much receiver can buffer
     - can be for a stream, or whole connection (if stream ID is 0)

Ping (HTTP/2):
           - PING frame:
              - used to calculate round-trip time
              - contains 8 bytes of arbitrary data
              - have priority
              - must respond with another PING frame with flag ACK
Format extensions:
           - new frame type
           - new SETTINGS_*
           - new *_ERROR
           - new headers

Format (HTTP/1.*):
        - newline is \n\r
        - request:
            METHOD URL HTTP/1.*
            HEADER: VAL
            ...

            [BODY]
        - response:
            HTTP/1.1 UINT STR
            [HEADER: VAL
            ...]

            [BODY]
        - Host [C] is mandatory


Method:
  - safe (read):
     - GET: retrieve resource
     - HEAD: retrieve resource (header only)
     - OPTIONS:
        - retrieve metadata (e.g. functionalities of web server).
        - usually use * as URL
     - TRACE: echoes request (to see changes introduced by servers|proxies)
  - unsafe (wtite):
     - idempotent (resource returned is always same if called again):
        - PUT: replace/create resource with specific ID
        - DELETE: erase resource
     - not idempotent:
        - POST: create resource without specific ID
        - PATCH: modify resource
        - CONNECT: do HTTP Tunneling

Headers:
  - case insensitive
  - written [S|C] for server|client in my doc
  - binary compressed (HTTP/2)
     - algo is 'HPACK'
     - common HEADER or HEADER: VAL have predefined numbers
     - each endpoint caches HEADER: VAL in a dynamic table
  - :HEADER are called pseudo-headers: same as headers but with extra restrictions on when can be used (HTTP/2)

Status codes:
         - WebDAV-only: 102, 207, 208, 422, 423, 424, 507, 508
         - 1**: information
            - 100 (Continue): client sent only headers and can proceed to send body (see Expect: 100-continue [C])
            - 101 (Switching Protocols): switch protocol success, e.g. from HTTP to HTTPS (see Upgrade [C])
         - 2**: success
            - 200 (OK): simple
            - 201 (Created): new resource (e.g. POST). Use Location: URL [S] for new resource URL.
            - 202 (Accepted): response is ongoing and will take some time to proccess (client can timeout). Usually response include links to monitor processing status.
            - 203 (Non-Authoritative Information): proxy transformed server response, which was originally 200
            - 204 (No Content): OK, but nothing is to be returned. Client should stay on same resource/document. E.g. successful DELETE, If-Modified-Since header.
            - 205 (Reset content): like 204 but client should reset/refresh current resource/document.
            - 206 (Partial content): response is only a subset of the full resource, (see Range [C])
            - 214 (Transformation applied): proxy transformed server response, which was originally not 200
            - 226 (IM used): returns diff not full resource. Uses HTTP delta compression, an RFC which seems old.
         - 3**: redirection to be performed by client
            - 300 (Multiple choices): redirection need client input
            - 301 (Moved Permanently): permanent, GET (even if different method, but should ask first). Cacheable.
            - 302 (Found): temp, GET (even if different method, but should ask first)
            - 303 (See other): different resource (not only different URL) than requested
            - 304 (Not Modified): resource did not change (see caching)
            - 305 (Use proxy): redirect to a proxy
            - 307 (Temporary Redirect): temp, same HTTP method
            - 308 (Permanent Redirect): permanent, same HTTP method
         - 4**: client-side failure
            - 400 (Bad request): syntax error
            - 401 (Unauthorized): authentication problem
            - 402 (Payment required): e.g. should pay to increase request rate
            - 403 (Forbidden): authorization problem. Prefer 404 when location itself is secret.
            - 404 (Not Found): wrong URL, but correct domain.
            - 405 (Method not allowed): HTTP method not implemented or not allowed
            - 406 (Not Acceptable): wrong requested media type (see Accept [C])
            - 407 (Proxy authentication required): like 401 but for application proxy
            - 408 (Request Timeout): as opposed to response timeout
            - 409 (Conflict): multi-client conflict
            - 410 (Gone): like 404, but indicates URL was present before
            - 411 (Length Required): missing request body length (see Content-Length [C])
            - 412 (Precondition Failed): resource changed even though client assumed it did not, e.g. with If-Unmodified-Since [C] (see caching)
            - 413 (Payload too large)
            - 414 (URI too long) 
            - 415 (Unsupported Media Type): server does not support payload media type (inverse of 406)
            - 416 (Range Not Satisfiable): wrong Range [C]
            - 417 (Expectation failed): e.g. wrong Expect [C]
            - 421 (Misredirected request): request picked wrong server
            - 426 (Upgrade Required): switch protocol denied, e.g. from HTTP to HTTPS
            - 428 (Precondition required): must use If-* [C]
            - 429 (Too many requests): throttle
            - 431 (Request header fields too large)
            - 451 (Unavailable for Legal Reasons): e.g. censorship, copyright, privacy
         - 5**: server-side failure
            - 500 (Internal server error): bug in server, e.g. syntax error
            - 501 (Not implemented): feature not available yet
            - 502 (Bad gateway): sent by proxy when it received error from server
            - 503 (Service unavailable): server is down (cannot connect)
            - 504 (Gateway timeout): sent by proxy on server timeout
            - 505 (HTTP version not supported)
            - 506 (Variant also negotiates): negotiation circular loop (see Negotiate [C])
            - 510 (Not extended): HTTP extension not implemented
            - 511 (Network authentication required): like 401 but for network proxy, containing link where to authenticate.

<meta http-equiv="HEADER" content="VAL">:
  - client (not server) will add HTTP HEADER: VAL to the server's response. 
  - Does not always work. Which one works???

Redirections:
  - Redirection is using Location: URL [S]
     - Can also avoid client redirection by fetching it server-side, but notify with Content-Location: URL [S]
  - More than five redirections is considered infinite loop.
  - Use 3** status codes
  - Refresh: NUM, url=URL [S], like <meta http-equiv="refresh" content="NUM; url=URL"> redirection 
  - Retry-After: NUM|DATE [S], tells client to try again after a specific period of time

Time:
  - Date: DATE [C]: when request was sent 
  - Accept-Datetime [C]: which response it wants, to allow getting older versions.

Sending data:
  - <a|area> click event: change current URL
  - <form> submit event: change current URL (see HTML doc)
  - XHR.send():
     - HTTP request without changing current URL
     - more flexibility on request method|headers|body

Query strings:
  - only advantage over request body is when need to keep state in URL, e.g. bookmark
  - but:
     - it clutters URL, and is bad practice (bad SEO)
     - can grow too big
  - Can use VAR[VAR2]=VAL, but must be supported by server:
     - query string: supported by Express REQ.query
     - request body: supported by Express BODY-PARSER

Software identity:
  - User-agent: STR [C] and Server: STR [S]. Can also instruct rendering engine to client with 
    X-UA-Compatible: BROWSER=VAL [S]
  - X-Powered-By: STR [S], e.g. "PHP/5.4.0"
  - X-Request-With: FUNC (e.g. XMLHttpRequest) [C], often used in AJAX
  - Pragma: VAL [C|S], for server-specific lingo

Client identity:
  - From: EMAIL_ADDRESS [C]

Destination:
  - Host: HOST[:PORT] [C] (HTTP/1.1) or :authority [C] (HTTP/2). DOMAIN might be case-sensitive on some servers.
     - virtual hosting (several HOST on same machine): 
       - name-based: 
          - using several HOST names under same IP. 
          - Is harder to implement with HTTPS. 
          - When DNS doesn't work, harder to reach directly through IP.
       - IP-based:
          - using one IP by HOST

Can indicate required If-* [C] with 428

Content:
  - content negotiation (client gives several options, and server picks one):
     - server-side:
        - Content-Type: MIME_TYPE[; charset=CHARSET] [S]. 
        - Accept: MIME_TYPE and Accept-Charset: CHARSET [C] to notify the server. 
          Server can use status code 415 (Unsupported Media Type)
        - Accept-language: LANGUAGE [C], Content-language: LANG [S]
        - Accept-features: FEATURE [C]
        - each header [C] can be followed by [; q=NUM] to put preferences on each option
        - 406 (Not Acceptable): wrong Accept-* [C]
     - transparent:
        - Negociate [C] then server:
           - respond with normal response body after server-side negotiation
              - unless 300 status code and TCN: list [S], otherwise TCN: choice [S]
           - Alternates: URL,... [S]
           - sends 506 when server has circular references due to choice picking
        - Negociate: VAL [C]:
           - trans: support, but don't ask for it
           - vlist: support and ask for it
        - Goal: not having to send too many Accept* [C], which increase packet size and allow privacy concern (fingerprinting)
        - Problem: need to perform two requests
  - Content-Disposition: attachment[; filename="..."] [S], ask to download with a file chooser
  - Content-Type "multipart/form-data; boundary=STR" [S]:
     - forces download box
     - download box otherwise present on any Content-Type not supported by browser renderer
     - if no filename="...", will create a default one according to Content-Type

Control:
  - Content-MD5: CHECKSUM [C|S], usually with Trailer: HEADER_VAR [S]

Cache:
	- vocabulary:
		 - cache hits ratio: % of requests that could use the cache
		 - stale resources: cached but not valid any more
  - proxy/server caching:
		 - CDN: fast servers for caching, spurned across several geographical regions to be closer to clients
		 - Memcached/Redis are between the server and the DB, while web accelerators are between server and client
		 - proxy caching:
		    - types: 
	 				 - ISP can cache
	 				 - web accelerator: reverse proxy dedicated to caching (closer to end client)
				- Vary: HEADER [S] tells the client to use different entry caches for requests on same URLs but using different
				  request HEADER value.
					Usually used with Vary: Accept-Encoding towards cache proxies, so they don't serve gzipped cache entries to clients
					not able to gunzip, or cleartext cache entries to clients that requested gzipped and will try to gunzip.
					Also sometimes Vary: User-Agent if served files vary according to User-Agent (will increase SEO)
		 - server and proxy caching can cache for all clients based on the request of a single client
	- cache HTTP headers tell browser how to cache given response (if none, browser guess using heuristic, to avoid):
		 - unconditional caching:
				- browser should not ask server and only use cache for a given time period
          Does not apply on page refresh.
				- fastest cache method, but requires timestamp updates, so should be done on asset files (CSS, images, JavaScript,
					etc.) but not HTML (it would break timestamping).
					Usually asset files are in /static PATH on server, and in Express served with static file server, while rest is not.
		    - Cache-Control: STR,... [S] where STR can be:
					 - [s-]max-age NUM: how long to cache
						 "s-" is for cache proxies only like CDN
						 Should not be more than 1 year later, but:
 							 - if fingerstamping ok, should be as long as possible (so should be 1 year)
							 - otherwise, set longest time you estimate clients can have a good experience with a stale resource
					   Can also use instead Expires: DATE [S]:
						   - same but using a given DATE
							 - older header
					 - public|private: can [not] be cached by intermediate proxy, not only end-client:
					    - public: allow proxy caching
							- private: good if data is sensitive, including headers e.g. cookies (even if SSL if the proxy needs to 
							  decrypt/encrypt in the middle)
					 - no-transform: don't allow proxy to recompress images/videos.
					   Some proxies also inject JavaScript code which might mess up with the application.
           - must|proxy-revalidate: 
              - when expires, if conditional caching setup, will do conditional cache request
              - however it is the default of most clients
				- Cache-Control: STR,... [C]:
           - max-age=0: forces all proxies in between to use conditional caching, and server to check if need to respond with 
             304
			 	   - no-cache: forces all proxies in between not to use conditional caching, and server not to respond with 304
				-	timestamping:
				   - using an ID in the URL (e.g. version of JavaScript file). 
					 - When resource changes, change ID, update links to resource.
					 - new calls will get new version (because different URL).
           - query string is taken into account: careful not to timestamp a resource by mistake by unconditionally caching a 
             URL with query string
				- When using conditional caching too (ETag or Last-Modified):
           - unconditional caching has precedence
           - but when unconditional cache expires, uses conditional caching, so good idea to set it
		 - conditional caching:
				- browser should first send request to check if resource has changed. If 304 response, should use cache.
				- best cache method when it's impractical to timestamp, e.g. HTML and AJAX calls.
				  Faster to get 304 response with empty body, and no need for server to fetch data.
				- Headers:
					 - Can be based on (cannot be both):
					    - mtime: Last-Modified: DATE [S], If-Modified-Since: DATE [C]
				      - content hash: ETag: HASH [S], If-None-Match: HASH [C]:
                 - W/"...": weak, which means are just identical semantically, but not byte by byte. Used with dynamic websites
                 - "...": strong
					 - If-Unmodified-Since, If-Match: inverse, e.g. to do PUT only if resource is still the same
             Uses 412 instead of 304. If-None-Match with unsafe methods also use 412 instead of 304.
		 - no caching:
		    - faster than conditional caching if resource is never the same (avoid 304 response)
        - often done for security reasons
				- Cache-Control: no-cache, no-store, private, must-revalidate
				  Pragma: no-cache
					Expires: 0
				   - both values are same but for different browsers
					 - Pragma if for HTTP/1.0
        - can use no-cache="HEADER" for a specific header
	 - can see all in chrome://cache on Chrome
	 - security:
	    - client's cache entries containing confidential info (e.g. login info) could be accessed (by exploiting another 
			  vulnaribility or someone else having physical access to computer)
			- POST replay attack: use same URL to authenticate (thanks to cached entry) even if logged out
			- countermeasure: no caching for sensitive body or headers

Prefetching (resource hints, server push):
  - types, from most performant to least:
+--------------+----------------------------------------------+---------------------------------------------------------------------+------------------------------------+
| Type/REL     | Use case                                     | Effects                                                             | Browser support                    |
|              +--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+                                    |
|              | Resource for which | Known path | Likelihood | Initiated | When is resource        | Loads | Parse + | Protocols   |                                    |
|              | navigation action  |            |            | by        | fetched                 |       | render  |             |                                    |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| server push  | Current            | Yes        | Certain    | server    | right away (no request) | Yes   | Yes     | HTTP        | All                                |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| preload      | Current            | Yes        | Certain    | client    | async right away        | No    | No      | HTTP        | Chrome/Opera                       |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| preconnect   | Current            | No         | Certain    | client    | async right away        | No    | No      | DNS         | Chrome/Opera/Firefox               |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| prerender    | Next               | Yes        | High       | client    | after document.onload   | No    | Yes     | HTTP        | Chrome/Opera/IE                    |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| prefetch     | Next               | Yes        | Middle/low | client    | after document.onload   | No    | No      | HTTP        | not [mobile] Safari nor Opera mini |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
| dns-prefetch | Next               | No         | Middle/low | client    | after document.onload   | No    | No      | DNS+TCP/TLS | not Opera mini                     |
+--------------+--------------------+------------+------------+-----------+-------------------------+-------+---------+-------------+------------------------------------+
  - server push:
     - send additional resources in a single response
     - performance:
        - less roundtrips than resource hints
        - but should push only resources that would have been requested
     - caching:
        - uses pseudo-client request for caching, so works the same as normal request
        - client request must be cacheable, i.e. GET with cache headers
     - not actual prefetching (it loads resource)
     - need to be initiated by a request (so not realtime)
     - as opposed to resource hints, initiated by server so cannot be used if:
        - client needs knowledge about fetching: resource path, load|error event
        - fetching needs knowledge about client: state (cookies, localStorage), user agent info (Accept [C], etc.)
  - resource hints:
     - use either:
         Link: <URL>; rel=REL[; ATTR=VAL]... [, <URL>...] [S]
         <link href="URL" rel="REL" ATTR="VAL" ...>...
     - ATTR:
        - pr 'FLOAT' (0-1) (all)
           - probability the link will be followed 
           - used for prioritization or reducing optimization/fetching
        - as TYPE (preload|prefetch): 
           - WINDOW.fetch() destination type, 
             i.e. script|style|image|font|media|object|embed|document|xslt|manifest|report|service|shared]worker
           - used for CSP and Accept [C]
        - nopush (preload): if a HTTP2 server push has been received for that resource, do not use it
     - prerender parsing/execution:
        - in the background, i.e. not visible but will provide very fast cache
        - only kept for short while, so should be next navigation
        - resource intensive: should only be used when confident about next navigation action
        - only HTML resources
     - does not delay document.onload
     - could previously use noop XHR to achieve something similar
     - cannot see in devtools network tab, but can see "prerender" using chrome://net-internals/#prerender
     - can be:
        - speculative: before user interaction that might trigger HTTP request
        - reactive: after user interaction that will certainly trigger HTTP request, after some delay
     - possible problems:
        - when HTTP GET request has side effects (which is improper)
        - increase bandwith usage
        - overestimate tracking (ads, analytics):
           - can use document.visibilityState 'prerender' to handle it
        - security: website make decision (not user) to trust content by browsing it

Long request:
  - 100-continue:
     - sends only header with Expect: "100-continue" [C]
     - server sends 100 (Continue) if success, 417 (Expectation Failed) if failure
     - client sends body
  - Content-Length [C|S]: BODY length:
     - can use 411 (Length Required)
  - request too large:
     - 414 (Request URI too long)
     - 431 (Request header fields too large)
     - 413 (Request Entity too large)

Long response:
  - byte serving:
     - allow client to request specific ranges:
     - init: Accept-Ranges: bytes [S] 
     - each range:
        - client:
           - Range: bytes=NUM-NUM2 [C]
           - If-Range: ETAG|MDATE [C]:
              - if content changed, sends entire file (not only RANGE)
              - otherwise, sends RANGE
        - server success:
           - Content-Range: bytes NUM-NUM2/TOTAL [S] 
             206 (Partial content)
        - server failure:
           - 416 (Requested Range Not Satisfiable)
  (HTTP/1.* only)
  - Can use Transfer-Encoding: chunked [S] instead:
      - send BODY in several times, signalling end by sending empty BODY
      - requested by TE: chunked [C]
      - Trailer: HEADER_VAR [S], sends additional headers, but at the end.
      - Good for big file or HTTP live streaming (different from HTTP streaming)
      - Should be used with compression

Proxies:
  - X-Forwarded-For: HOST... [C], indidates previous clients in a proxy chain.
  - X-Forwarded-Proto: PROTOCOL... [C], same for protocols, when changing protocols along the chain (e.g. HTTP to HTTPS)
  - X-Forwarded-Port: PORT... [C]: same for port
  - Via: HTTP_VERSION URL SERVER ... [C|S], proxies
  - Max-Forwards: NUM [C], max number of proxies

Security: See Websites_security

Tracking:
  - Referer: URL [C], current URL (so new URL can see where navigation originates)
    <link|a rel="noreferrer"> asks client not to send it.
  - DNT: 1 [C], "Do-not-track" tells server:
     - doesn't want any trace/unique ID/cookie that could correlates its visit of different websites
     - this includes tracking cookies, third-party ads tracking, but does not include Google Analytics, user preferences on 
       one site or targetting ads according to one single site preferences
  - Set-Cookie: VAR=VAL;SVAR=VAL;... [S]:
     - Asks client to send Cookie: VAR=VAL[;...] [C] again when visiting a specific path on a specific domain
     - Used to introduce a state: authentication, tracking, etc.
     - One Set-Cookie [S] per cookie, but one Cookie [C] for all cookies
     - VAL are percent-encoded
     - SVAR are:
        - path (récursif) (e.g. "/index.html") et domain (e.g. "www.a.org"):
           - when same as current: first-party cookies, often for authentication or for traffic analytics.
           - when different: third-party cookie
              - often tracking cookies : same domain accross different visited websites to connect different websites 
                someone visits, for advertising purposes
              - needs to trick the browser which otherwise blocks it (can only use cookie from same domain), e.g. hidden 
                iframes.
        - expires|max-age: DATE|NUM secondes before expiration (nothing for end of session). Put to 0 to delete cookie.
        - secure: can only transmit|receive via https.
        - HttpOnly: can't be used via JavaScript (document.cookies) (considered unsecure), can be used e.g. by PHP
     - Zombie cookie :
        - copies in several places.
        - if some absent, reduplicate them 
        - evercookie is an open source implementation
  - Private browsing :
     - a private session erases at the end all the traces (history, cookies, cache) it created.
     - called Incognito in Chrome

Compression:
  - Accept-Encoding: PROGRAM... [C], then Content-encoding: PROGRAM [S]
  - PROGRAM can be: 
      - "identity" (none) 
      - "gzip/deflate": Zlib. Same compression but different header (gzip conserves files info but bigger). 
        However, as a client should ask for gzip, because deflate is handled differently by some servers.
        Other compression methods are way less supported.
      - "bzip2" 
      - "lzma"
      - "shdc": by Google, supported natively by Chrome (seems inactive)
  - server should cache the input/output of compression to avoid doing twice the same compression on same input, because
    compression is long

HTTPS:
  - using HTTP over SSL/TLS over TCP
  - needs to be enable on all website resources, including scripts, all pages, etc., otherwise could attack on specific
    unsecure resources
     - this includes cookies. To have secure cookies, provide the secure attribute, which says it can only be used with HTTPS
  - Strict-Transport-Security: max-age=NUM (seconds from now); includeSubDomains [S]: specify clients it only allows HTTPS 
    connections. Client should resend the request using HTTPS if HTTP was used.
  - initiating connection:
     - Upgrade [C] for HTTPS: should not be used as it leaves beginning of communication unencrypted
     - https:// protocol

Switching protocols:
  - Upgrade: PROTOCOL/VERSION [C] to start a session in HTTP then continue in another protocol:
     - server sends 426 if failed
     - server sends 101 and Upgrade: PROTOCOL/VERSION [S] if success
     - can Upgrade to but not from HTTP/2

Profiling:
  - X-Response-Time: NUM [S]: time taken by server to process answer

REST:
  - X-HTTP-Method-Override: METHOD [C]:
     - tells server that request should be interpreted as if HTTP METHOD has been used. 
	   - goal is to overcome network limitations (firewalls, etc.) protecting client from using methods like PUT, DELETE, etc. 
       on a REST API

Push technologies:
  - allow server to initiate message to client
  - types:
     - short polling with AJAX requests
     - HTTP server push / HTTP streaming (HTTP/1.1): using Transfer-encoding: chunked [S]
     - Comet:
        - Pushlet: leaves HTTP connection open, sending new bits from time to time
        - Long polling: waits for server events to return the reply to client, then ask client to request again. Uses timeouts.
           - BOSH: variation of long polling
     - Server-sent events (SSE)
     - TCP socket used by plugins like Flash or Java: bi-directional
     - Websockets: same idea but standardized

HTTP Tunneling:
  - wrapping another protocol packets in a HTTP payload
  - proxy and endpoints wraps|unwraps request|response
  - CONNECT method:
     - wraps TCP protocol
     - use only first HTTP handshake with proxy, then use TCP connection
     - can be used to access HTTPS using a HTTP proxy (TCP between client-proxy, SSL between proxy-server)

Practices becoming bad with HTTP/2:
  - concatenation:
     - performance impact:
        - lower number of requests
        - but invalidates cache more often
     - HTTP/2:
        - does not have limit on number of parallel requests
        - keep TCP socket always alive
        - so roundtrip performance impact is less important
     - types of concatenation:
        - file plain concatenation
        - sprites
        - inlining, e.g. <link> -> <style>
        - data URIs
  - domain sharding
