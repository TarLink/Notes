
           
   SOLID   
           


SOLID Principles        #Goals are to increase:
                        #  - scalability: how easy to extend a system
                        #  - granularity: decomposing a system into smaller modules
                        #  - orthogonality:
                        #     - modifying a module does not modify others.

Single responsibility   #Une classe ne doit avoir qu'une responsibility. Si ce
                        #n'est pas le cas : la diviser.
                        #Définitions de responsibility : 
                        #  - role jouée par une classe
                        #  - "reason to change"
                        #Related is "loose coupling" / law of Demeter: 
                        #  - lowest possible knowledge/interaction between modules.

Open/Close Principle    #Le code existant (interface) doit être fermée à la
                        #modification, mais ouvert à nouvel ajout par 
                        #inhéritance. Recommande en fait l'utilisation de
                        #l'inhéritance pour extend un système, et non 
                        #modification du code existant.

Liskov substitution /   #Une subclasse peut toujours remplacer sa parente sans
LSP / substitutability  #faire que le programme se comporte de manière
                        #indésirée (cf Design by contract) (mais pas forcément 
                        #l'inverse)
                        #Implique, dans la subclasse :
                        #  - pas de nouvelles exceptions lancées, sauf si 
                        #    celles-ci sont elles-mêmes enfants des exceptions 
                        #    du parent
                        #  - pas plus de préconditions (mais moins possible)
                        #  - au moins les mêmes postconditions (mais plus 
                        #    possible)
                        #  - mêmes invariants
                        #De plus, si A, B, C, D, etc. est une hierarchie de
                        #classes, avec A comme base classe et Z comme dernière
                        #classe, et que Superclasse prend M* comme argument,
                        #alors Subclasse doit :
                        #  - prendre un argument de type entre A et M (argument
                        #    contravariant), sinon Subclasse ne peut pas se
                        #    substituer à Superclasse, car pouvant accepter un
                        #    range d'inputs plus petits
                        #  - retourner une valeur de type entre M et Z (return
                        #    type covariante), sinon pas de substitution, car
                        #    Subclasse peut renvoyer des outputs au-delà du 
                        #    range attendu d'un Superclasse
                        #  - donc par rapport à son parent, être libéral à
                        #    l'input et strict à l'output
                        #Ex de violation : une classe Carré, enfant de 
                        #Rectangle, car ajoute la Précondition "tous côtés 
                        #égaux" absent de Rectangle, qui pourrait par exemple
                        #avoir un SetHorizontalEdges() + SetVerticalEdges()
                        #séparés.

Interface-segregation   #Une interface ne doit pas devenir une God Class, sinon
                        #il faut la diviser en plusieurs interfaces.

Dependency Inversion    #Normalement, les dépendances se font par le haut :
                        #  - les détails de l'implémentation peuvent changer,
                        #    mais doivent rentrer dans l'interface des modules
                        #    supérieurs (ces premiers dépendent de cette 
                        #    dernière)
                        #  - si les modules supérieurs changent, ceux inférieurs
                        #    doivent être changés
                        #Pour éviter cela, on peut ajouter un layer entre les
                        #deux. Le layer spécifie une norme que l'implémentation
                        #doit donner, et l'interface recevoir. Exemple : 
                        #couche TCP/IP.
                        #Il faut donc rajouter une interface entre chaque couche
                        #supérieurs/inférieurs, afin de pouvoir modifier aussi
                        #librement les modules supérieurs.

