
                           
   PROGRAMMING_PARADIGMS   
                           


SUMMARY ==>                       #Abtraction:
                                  #  - low-level (flexible) vs high-level (expressive)
                                  #  - imperative vs declarative
                                  #     - imperative: structured vs non-structured
                                  #     - declarative: functional
                                  #Modularity:
                                  #  - modular vs monolithic
                                  #  - object-oriented
                                  #Domain-specific:
                                  #  - interactivity: none, menu-driven, event-driven
                                  #Performance:
                                  #  - concurrency
                                  #  - array programming


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          ABSTRACTION          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


ABSTRACTION ==>                   #Can be:
                                  #  - 1GL (first-generation programming language): machine-level
                                  #  - 2GL: assembly language
                                  #  - 3GL: low-level, e.g. C, C++, Java, BASIC, Pascal, Fortran, ALGOL, COBOL
                                  #  - 4GL: high-level, e.g. JavaScript, Python, Perl, Ruby, SQL, Bash, PHP, R
                                  #  - 5GL: logic programming, e.g. Prolog
                                  #Lower-level is more flexible, higher-level is more expressive

IMPERATIVE VS DECLARATIVE ==>     #Imperative:
																	#  - manipulate state to get results
																	#  - *how* to get results
																	#  - focus on side effects, control flow, algorithms
																	#  - e.g. ARR.map(val % 2 is 0 ? val : null)
																	#Declarative:
																	#  - define conditions that should be satisfied for the result
																	#  - *what* to get 
																	#     - *how* being abstracted to implementation
																	#  - focus on problem domain
																	#  - e.g. ARR.where(val % 2 is 0)
																	#  - include: query languages (SQL, RegExp), logic programming, configuration management
                                  #Declarative is more abstract:
                                  #  - easier to consume
                                  #  - but harder to build|maintain

STRUCTURED PROGRAMMING ==>        #Which control flows are used by imperative languages
                                  #Non-structured programming:
                                  #  - use branching:
                                  #     - unconditional (goto, call, exit, etc.)
                                  #     - conditional (simple if, etc.)
                                  #  - includes:
                                  #     - early exit (return, break, continue, etc.)
                                  #     - exception|interrupt handling
                                  #     - async (coroutine, promise, etc.)
                                  #Structured programming:
                                  #  - use structures:
                                  #     - blocks (if blocks, switch, etc.)
                                  #     - loops (for, while, etc.)
                                  #     - functions
                                  #  - structures are an abstraction of branching
                                  #Complexity:
                                  #  - non-structured programming can lead to spaghetti code,
                                  #  - but structured programming can lead to too complex state machines

FUNCTIONAL PROGRAMMING ==>        #See functional doc


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          MODULARITY           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


MODULAR PROGRAMMING ==>           #Dividing code into different loosely coupled pieces (modules|packages|components|units):
                                  #  - separate object|functions in separate files|folders
                                  #  - namespacing
                                  #  - encapsulating, abstracting implementation
                                  #Provides code reuse and separation of concerns (see SOLID):
                                  #  - improves maintainability by providing granularity and orthogonality
                                  #  - but higher abtraction can also lead to higher complexity
                                  #Opposite is monolithic design.

OBJECT-ORIENTED PROGRAMMING ==>   #See OOP doc


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:        DOMAIN-SPECIFIC        :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


INTERACTIVITY ==>                 #Can be:
                                  #  - none, e.g. Unix command
                                  #  - menu-driven:
                                  #     - input is constrained to menus|submenus, describing the application state machine
                                  #     - e.g.:
                                  #        - CLI command asking for action among several choices
                                  #        - GUI app where actions can only be done through top bar
                                  #  - event-driven:
                                  #     - any input
                                  #        - including custom events, e.g. when a background task completed
                                  #        - at a low level, always correspond to some IRQ, e.g. device input, network, thread completion
                                  #     - can lead to complex state machine in event handlers:
                                  #        - event handlers should not check for current state
                                  #        - instead, state should modify|toggle event handlers
                                  #        - e.g.: SPA pages, REST routes
                                  #There is a tradeoff between interactivity and simplicity


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          PERFORMANCE          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


CONCURRING PROGRAMMING ==>        #Running several pieces of code at once
                                  #Good for performance but creates synchronization problems
                                  #See concurrency doc

ARRAY PROGRAMMING ==>             #See parallelism doc
