
                           
   PROGRAMMING_PARADIGMS   
                           


Interaction:
  - single execution:
     - e.g. Unix command
  - event-driven: 
     - instead of only one execution, event loop (i.e. new function executed according to events)
     - events might be other than user interaction, e.g.:
        - hardware events, e.g. Bash serie of pipes (wait for file events)
     - advantages:
        - can react to interaction
     - problems:
        - event handlers should not check current state (creates big conditional logic if many state variables)
           - instead, state should modify/enable/disable event handlers
           - e.g.:
              - web app route
  - menu-driven:
     - like event loop except user manually picks event among the list of all events
        - might be done using menus/submenus
     - e.g.:
        - CLI command asking for action among several choices
        - GUI app where actions can only be done through top bar
     - easier to reason with this kind of interaction, but less flexible

Imperative vs declarative:
  - imperative:
     - define steps, manipulate state to get results
     - i.e. *how* to get results
     - focus on state, side effects
     - e.g. ARR.map(val % 2 is 0 ? val : null)
  - declarative:
     - define conditions that should be satisfied for the result
     - i.e. *what* to get 
        - *how* being left|abstracted to implementation
     - e.g. ARR.where(val % 2 is 0)
     - often include:
        - query language (e.g. SQL, RegExp)
        - functional programming
        - less state
     - subtypes:
        - functional: use functions arguments instead of statements, in order to try to minimize side effects
           - purely functional: absolutely no side effects
        - logic: look like mathematical logic

STRUCTURED PROGRAMMING ==>        #Which control flows are used by imperative languages
                                  #Non-structured programming:
                                  #  - use branching:
                                  #     - unconditional (goto, call, exit, etc.)
                                  #     - conditional (simple if, etc.)
                                  #  - includes:
                                  #     - early exit (return, break, continue, etc.)
                                  #     - exception|interrupt handling
                                  #     - async (coroutine, promise, etc.)
                                  #Structured programming:
                                  #  - use structures:
                                  #     - blocks (if blocks, switch, etc.)
                                  #     - loops (for, while, etc.)
                                  #     - functions
                                  #  - structures are an abstraction of branching
                                  #Complexity:
                                  #  - non-structured programming can lead to spaghetti code,
                                  #  - but structured programming can lead to too complex state machines

Modular programming:
  - namespacing:
     - different subroutines, files or current object
     - goals:
        - easier to understand code
        - encapsulation
        - avoiding name conflicts

OOP:
  - bundle data and methods of same concern together in a complex type (class)
  - subtyping (inheritance)
  - class-based vs prototype-based

Functional programming: see functional doc

Concurring programming: see concurrency doc
