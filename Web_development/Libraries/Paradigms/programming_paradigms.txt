
                           
   PROGRAMMING_PARADIGMS   
                           



STRUCTURED PROGRAMMING ==>        #Which control flows are used by imperative languages
                                  #Non-structured programming:
                                  #  - use branching:
                                  #     - unconditional (goto, call, exit, etc.)
                                  #     - conditional (simple if, etc.)
                                  #  - includes:
                                  #     - early exit (return, break, continue, etc.)
                                  #     - exception|interrupt handling
                                  #     - async (coroutine, promise, etc.)
                                  #Structured programming:
                                  #  - use structures:
                                  #     - blocks (if blocks, switch, etc.)
                                  #     - loops (for, while, etc.)
                                  #     - functions
                                  #  - structures are an abstraction of branching
                                  #Complexity:
                                  #  - non-structured programming can lead to spaghetti code,
                                  #  - but structured programming can lead to too complex state machines

MODULAR PROGRAMMING ==>           #Dividing code into different loosely coupled pieces (modules|packages|components|units):
                                  #  - separate object|functions in separate files|folders
                                  #  - namespacing
                                  #  - encapsulating, abstracting implementation
                                  #Provides code reuse and separation of concerns (see SOLID):
                                  #  - improves maintainability by providing granularity and orthogonality
                                  #  - but higher abtraction can also lead to higher complexity
                                  #Opposite is monolithic design.

CONCURRING PROGRAMMING ==>        #Running several pieces of code at once
                                  #Good for performance but creates synchronization problems
                                  #See concurrency doc

INTERACTIVITY ==>                 #Can be:
                                  #  - none, e.g. Unix command
                                  #  - menu-driven:
                                  #     - input is constrained to menus|submenus, describing the application state machine
                                  #     - e.g.:
                                  #        - CLI command asking for action among several choices
                                  #        - GUI app where actions can only be done through top bar
                                  #  - event-driven:
                                  #     - any input
                                  #        - including custom events, e.g. when a background task completed
                                  #        - at a low level, always correspond to some IRQ, e.g. device input, network, thread completion
                                  #     - can lead to complex state machine in event handlers:
                                  #        - event handlers should not check for current state
                                  #        - instead, state should modify|toggle event handlers
                                  #        - e.g.: SPA pages, REST routes
                                  #There is a tradeoff between interactivity and simplicity

FUNCTIONAL PROGRAMMING ==>        #See functional doc

ARRAY PROGRAMMING ==>             #See parallelism doc

ABSTRACTION ==>                   #Can be:
                                  #  - 1GL (first-generation programming language): machine-level
                                  #  - 2GL: assembly language
                                  #  - 3GL: low-level, e.g. C, C++, Java, BASIC, Pascal, Fortran, ALGOL, COBOL
                                  #  - 4GL: high-level, e.g. JavaScript, Python, Perl, Ruby, SQL, Bash, PHP, R
                                  #  - 5GL: logic programming, e.g. Prolog

IMPERATIVE VS DECLARATIVE ==>


Imperative vs declarative:
  - imperative:
     - define steps, manipulate state to get results
     - i.e. *how* to get results
     - focus on state, side effects
     - e.g. ARR.map(val % 2 is 0 ? val : null)
  - declarative:
     - define conditions that should be satisfied for the result
     - i.e. *what* to get 
        - *how* being left|abstracted to implementation
     - e.g. ARR.where(val % 2 is 0)
     - often include:
        - query language (e.g. SQL, RegExp)
        - less state
     - subtypes:
        - functional: use functions arguments instead of statements, in order to try to minimize side effects
           - purely functional: absolutely no side effects
        - logic: look like mathematical logic

OOP:
  - bundle data and methods of same concern together in a complex type (class)
  - subtyping (inheritance)
  - class-based vs prototype-based

