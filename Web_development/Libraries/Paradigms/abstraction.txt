
                 
   ABSTRACTION   
                 



ABSTRACTION ==>                   #Pros for consumer:
                                  #  - make interface simpler, easier to consume, more expressive
                                  #  - minimize maintainance (of interaction with interface)
                                  #Cons for the interface:
                                  #  - less flexible|efficient
                                  #  - increased complexity

LANGUAGE GENERATION ==>           #Can be:
                                  #  - 1GL (first-generation programming language): machine-level
                                  #  - 2GL: assembly language
                                  #  - 3GL: low-level, e.g. C, C++, Java, BASIC, Pascal, Fortran, ALGOL, COBOL
                                  #  - 4GL: high-level, e.g. JavaScript, Python, Perl, Ruby, SQL, Bash, PHP, R
                                  #  - 5GL: logic programming, e.g. Prolog

IMPERATIVE VS DECLARATIVE ==>     #Imperative:
																	#  - manipulate state to get results
																	#  - *how* to get results
																	#  - focus on side effects, control flow, algorithms
																	#  - e.g. ARR.map(val % 2 is 0 ? val : null)
                                  #  - less abstract
																	#Declarative:
																	#  - define conditions that should be satisfied for the result
																	#  - *what* to get 
																	#     - *how* being abstracted to implementation
																	#  - focus on problem domain
																	#  - e.g. ARR.where(val % 2 is 0)
																	#  - include: query languages (SQL, RegExp), logic programming, configuration management
                                  #  - more abstract

STRUCTURED PROGRAMMING ==>        #Which control flows are used by imperative languages
                                  #Non-structured programming:
                                  #  - use branching:
                                  #     - unconditional (goto, call, exit, etc.)
                                  #     - conditional (simple if, etc.)
                                  #  - includes:
                                  #     - early exit (return, break, continue, etc.)
                                  #     - exception|interrupt handling
                                  #     - async (coroutine, promise, etc.)
                                  #Structured programming:
                                  #  - use structures:
                                  #     - blocks (if blocks, switch, etc.)
                                  #     - loops (for, while, etc.)
                                  #     - functions
                                  #  - structures are an abstraction of branching
                                  #Complexity:
                                  #  - non-structured programming can lead to spaghetti code,
                                  #  - but structured programming can lead to too complex state machines

FUNCTIONAL PROGRAMMING ==>        #See functional doc

INTERFACE-SEGREGATION ==>         #Minimizing interface size
                                  #"I" of SOLID principles

DEPENDENCY INVERSION ==>          #Modules should only used other modules through those modules interfaces
                                  #"D" of SOLID principles

ADAPTER PATTERN ==>               #Interface shared by several modules, i.e. abstracting their differences
                                  #Interface can be interacting with the modules through:
                                  #  - composition ("object adapter")
                                  #  - inheritance ("class adapter")
