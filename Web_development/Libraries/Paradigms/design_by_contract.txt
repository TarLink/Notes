
                                  
   PRECONDITIONS_POSTCONDITIONS   
                                  


Design by contract      #Désigne le fait de définir formellement, pour chaque méthode. Principalement :
                        #  - les préconditions :
                        #     - dont types, nombre et signification des arguments
                        #  - les postconditions :
                        #     - dont type, valeur et signification des return values
                        #Mais aussi :
                        #  - les invariants
                        #  - les exceptions pouvant être lancées, et l'exception-safety
                        #  - les side effects :
                        #     - modification d'une variable utilisable par le caller.
                        #     - ou :
                        #       - modification d'une variable passée par référence (postconditions)
                        #       - modification du global state
                        #  - time complexity maximum
                        #Exemple pour une documentation :
                        #  - prototype indiquant arguments et return values
                        #  - explication sur signification des arguments et effets de la fonction
                        #  - préconditions
                        #  - postconditions
                        #  - valeur et signification des return values
                        #Et s'il y a lieu :
                        #  - exceptions lancées
                        #  - side effects
                        #  - time complexity
                        #Ces conditions peuvent être multiples et booléennes.

RULES ==>               #Il faut limiter au maximum le nombre de préconditions et d'exceptions, et garantir le maximum de 
                        #postconditions, invariants et exception-safety.

Precondition            #Désigne une condition requise avant l'exécution correcte d'une fonction. 
                        #En général, conditions requises par les paramètres de la fonction.
                        #Par exemple : type (dont ceux du template) respecte tel concept (CopyConstructible, etc.) ; valeur 
                        #est != 0 ; etc.
Postcondition           #Désigne une condition devant être vraie après l'exécution correcte d'une fonction.
                        #Il s'agit en fait des effets de la fonction, et porte en général sur la valeur d'un argument passé par
                        #valeur, sur la variable de retour, sur la valeur d'une CLASSDT ou sur la nouvelle return value d'un
                        #getter de la classe (exprimant la valeur d'une CLASSDT)
                        #Par exemple : tel argument est == à tel autre argument
Invariant               #Désigne quelque chose qui, si vrai avant le début de l'exécution de la fonction, restera vrai.
                        #Exemple : const qualifier indique qu'une CLASSDT est immuable.
                        #Cela peut avoir changer pendant le cours de la fonction du moment que :
                        #  - cela est rétabli à la fin
                        #  - cela a lieu dans une section critique (thread-safety) 
                        #  - cela est exception-safe (RAII)
                        #Peuvent aussi être à l'échelle de la CLASS (=> toutes les CLASSFK). Par exemple : tel CLASSDT sera 
                        #toujours...
exceptions              #Elles sont en fait lancées au cas où l'une des conditions du contrat ne peut pas être respectée.
                        #Une exception implique que : 
                        #  - la postcondition ne sera pas forcément respectée
                        #  - les invariants ne seront pas forcément respectés. Cependant un bon design essaie d'éviter ce point

OOP ==>                 #Les CLASSFK passent en argument implicite la CLASS, qui peut donc faire l'objet de préconditions
                        #("tel CLASSDT est..."), postconditions ("tel CLASSDT sera...") ou Invariant ("tel CLASSDT restera...")
ACCESS ==>              #Les conditions ne doivent pas porter sur des variables inaccessibles de l'interface (private)

HERITAGE ET LSP ==>     #Selon le principe LSP : une méthode héritée par un enfant (dont constructor) doit avoir :
                        #  - des préconditions, exceptions et time-complexity <= parent
                        #  - des invariants et side-effects == parent
                        #  - des postconditions  >= parent

COMPILE-TIME VS RUN-TIME#Les checks compile-time sont plus limités, mais comprend :
 ==>                    #  - types utilisés, et concepts modelés :
                        #     - check automatique des langages strongly-typed (dont C++)
                        #     - check des types des templates (ex: boost::concept_check).
                        #    Ne concerne pas les types dynamiques, i.e. pointeurs polymorphiques.
                        #  - valeurs et conditions connues compile-time (ex: invariants "const")
                        #On peut :
                        #  - utiliser des static assert pour ces derniers, bloquant la compilation si rupture du contrat
                        #    (préférer cela)
                        #  - lancer des avertissements.
                        #Les runtime checks ont un overhead cost, mais permettent de checker :
                        #  - pointeurs polymorphiques
                        #  - valeurs et conditions connues runtime
                        #On doit lancer des exceptions pour ceux-ci.

IMPLEMENTATIONS ==>     #Via des macros.
                        #Elles peuvent aussi écrire (en commentaire de fin de ligne) le code Doxygen correspondant, car avoir
                        #une macro REQUIRE( ... ) + balise Doxygen est redondant.
