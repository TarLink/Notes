
                        
   DESIGN_BY_CONTRACT   
                        


ROBUSTNESS PRINCIPLE ==>					#Also called "Postel's law"
                        					#Increase interface predictability by:
                        					#  - being liberal in input
                        					#     - benefit: reduces erratic behavior due to wrong input
                        					#     - problems:
                        					#        - harder to implement|maintain
                        					#        - less consistency among different implementations of the same interface
                        					#  - being strict in output
                        					#E.g. with design by contract:
                        					#  - less preconditions, exceptions
                        					#  - more postconditions, invariants

DESIGN BY CONTRACT ==>  					#Increase interface predictability by defining:
                                  #  - input: preconditions 
                                  #  - output: postconditions, exceptions
                                  #  - side effects: invariants, side effects, time complexity
                        					#Can be:
                        					#  - documented
                        					#  - enforced compile-time or runtime

Design by contract      					
                        					#  - les préconditions :
                        					#     - dont types, nombre et signification des arguments
                        					#  - les postconditions :
                        					#     - dont type, valeur et signification des return values
                        					#  - les invariants
                        					#  - les exceptions pouvant être lancées, et l'exception-safety
                        					#  - les side effects :
                        					#     - modification d'une variable utilisable par le caller.
                        					#     - ou :
                        					#       - modification d'une variable passée par référence (postconditions)
                        					#       - modification du global state
                        					#  - time complexity maximum

Precondition            					#Désigne une condition requise avant l'exécution correcte d'une fonction. 
                        					#En général, conditions requises par les paramètres de la fonction.
                        					#Par exemple : type (dont ceux du template) respecte tel concept (CopyConstructible, etc.) ; valeur 
                        					#est != 0 ; etc.
Postcondition           					#Désigne une condition devant être vraie après l'exécution correcte d'une fonction.
                        					#Il s'agit en fait des effets de la fonction, et porte en général sur la valeur d'un argument passé par
                        					#valeur, sur la variable de retour, sur la valeur d'une CLASSDT ou sur la nouvelle return value d'un
                        					#getter de la classe (exprimant la valeur d'une CLASSDT)
                        					#Par exemple : tel argument est == à tel autre argument
Invariant               					#Désigne quelque chose qui, si vrai avant le début de l'exécution de la fonction, restera vrai.
                        					#Exemple : const qualifier indique qu'une CLASSDT est immuable.
                        					#Cela peut avoir changer pendant le cours de la fonction du moment que :
                        					#  - cela est rétabli à la fin
                        					#  - cela a lieu dans une section critique (thread-safety) 
                        					#  - cela est exception-safe
                        					#Peuvent aussi être à l'échelle de la CLASS (=> toutes les CLASSFK). Par exemple : tel CLASSDT sera 
                        					#toujours...
exceptions              					#Elles sont en fait lancées au cas où l'une des conditions du contrat ne peut pas être respectée.
                        					#Une exception implique que : 
                        					#  - la postcondition ne sera pas forcément respectée
                        					#  - les invariants ne seront pas forcément respectés. Cependant un bon design essaie d'éviter ce point

OOP ==>                 					#Les CLASSFK passent en argument implicite la CLASS, qui peut donc faire l'objet de préconditions
                        					#("tel CLASSDT est..."), postconditions ("tel CLASSDT sera...") ou Invariant ("tel CLASSDT restera...")
ACCESS ==>              					#Les conditions ne doivent pas porter sur des variables inaccessibles de l'interface (private)

HERITAGE ET LSP ==>     					#Selon le principe LSP : une méthode héritée par un enfant (dont constructor) doit avoir :
                        					#  - des préconditions, exceptions et time-complexity <= parent
                        					#  - des invariants et side-effects == parent
                        					#  - des postconditions  >= parent

COMPILE-TIME VS RUN-TIME					#Les checks compile-time sont plus limités, mais comprend :
 ==>                    					#  - types utilisés, et concepts modelés :
                        					#     - check automatique des langages strongly-typed (dont C++)
                        					#     - check des types des templates (ex: boost::concept_check).
                        					#    Ne concerne pas les types dynamiques, i.e. pointeurs polymorphiques.
                        					#  - valeurs et conditions connues compile-time (ex: invariants "const")
                        					#On peut :
                        					#  - utiliser des static assert pour ces derniers, bloquant la compilation si rupture du contrat
                        					#    (préférer cela)
                        					#  - lancer des avertissements.
                        					#Les runtime checks ont un overhead cost, mais permettent de checker :
                        					#  - pointeurs polymorphiques
                        					#  - valeurs et conditions connues runtime
                        					#On doit lancer des exceptions pour ceux-ci.

IMPLEMENTATIONS ==>     					#Via des macros.
                        					#Elles peuvent aussi écrire (en commentaire de fin de ligne) le code Doxygen correspondant, car avoir
                        					#une macro REQUIRE( ... ) + balise Doxygen est redondant.
