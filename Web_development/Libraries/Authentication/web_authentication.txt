
                        
   WEB_AUTHENTICATION   
                        


Summary (from best to worst):
  - cookie authentication:
     - advantages over sending credentials in other headers/request_params:
        - can force HTTPS with httpOnly
        - simple:
           - client automatically stores it
           - client automatically sends it
           - with max-age: easy way to communicate expire time to client, or to invalidate
     - disadvantages over sending credentials in other headers/request_params:
        - credentials must be sent as a response HTTP headers (cannot use alternative ways)
        - not crossdomain
  - sending credentials in other headers/request_params
  - HTTP authentication:
     - disadvantages over just sending credentials in headers/request_params (including cookies):
        - browser show prompt on first request
        - basic/digest do not use temp token but actual credentials (username:password)
        - use browser-specific unconditional caching, i.e. must force a request with invalid credentials to invalidate cache

General status codes:
  - 403 (Forbidden)
  - 511 (Network Authentication required): sent by proxy for authentication pb
  - 419 (Authentication timeout)

Cookie Authentication:
  - Set-Cookie [S] + Cookie [C] (see HTTP doc)

HTTP Authentication:
  - Basic:
	   - server (failure or first request):
         - WWW-Authenticate: Basic realm="REALM",... [S]
           401|407 for server|proxy
		     - realm: set of resources sharing credentials
     - client: 
         - shows prompt for username and password
         - [Proxy-]Authorization: Basic BASE64_USERNAME:PASSWORD [C]
         - or use USERNAME:PASSWORD in USERINFO part of URI
  - Digest:
	   - server (failure or first request):
        - 401|407 WWW-Authenticate: Digest VAR="VAL",... [S]
           - realm="REALM": like Basic Authentication
           - qop="auth[, auth-int]": different algorithms let to client (optional)
           - algorithm="MD5[-sess]": same but for different part of algo (optional)
           - nonce="RANDOM_ALNUM": server-side nonce. Prevents building rainbow tables.
           - opaque="RANDOM_ALNUM", domain="DOMAIN": used to pass state information around during the process (optional).
     - client:
        - [Proxy-]Authorization: Digest VAR="VAL",... [C]:
           - retake same VAR="VAL" as response (chooses gop|algorithm too)
           - username="USERNAME"
           - response="HASHED_PASSWORD"
           - uri="URI": must match first request URL
           - cnonce="RANDOM_ALNUM", nc="NUM": (if gop="auth-int"):
               - if Mallory can simulate Bob (not case if SSL), prevents him to build random tables using unique server nonce,
                 then guessing plaintext password from HASHED_PASSWORD
               - cnonce is the client nonce. nc is incrementing at each client request, keeping initial cnonce (allow reusing
                 same cnonce during a whole session)
        - HASHED_PASSWORD: MD5(MD5(HA1):NONCE[:NC:CNONCE:QOP]:MD5(HTTPMETHOD:URI[:MD5(BODY)])):
           - HA1:
              - if algorithm="MD5", MD5(USERNAME:REALM:PASSWORD)
              - if algorithm="MD5-sess", MD5(MD5(USERNAME:REALM:PASSWORD):NONCE:CNONCE)
           - ":NC:CNONCE:QOP": if qop="auth[-int]". Prevents replay
           - ":MD5(BODY)": if qop="auth-int". Provides message integrity of BODY
  - Token-based:
     - server (failure or first request):
        - 401|407 WWW-Authenticate: Bearer VAR="VAL" [S]:
           - realm="REALM": like HTTP Basic Auth. (only one required)
           - scope="SCOPE": sub-realm
           - error[_description|uri]="ERROR" (only for failure)
     - client:
        - [Proxy-]Authorization: Bearer TOKEN [C]
        - or access_token as POST|GET variable

Federated authentication/authorization: 
  - Types:
     - Federated authentication:
        - instead of Alice authenticating to Bob:
           - Alice authenticates to Trent
           - Bob ask Alice to authenticate
           - Alice ask Bob to ask Trent instead
        - Goal: single login (authentication as a service)
        - Roles:
           - End-user / Resource owner (RO) (Alice)
           - Relying party (RP) / client (Bob)
           - OpenID Provider (OP) / Resource Server (RS) (Trent)
     - Federated authorization:
        - same but "authenticating" -> "authorizing Bob to do X"
     - Pseudo-federated authentication:
        - assuming that federated authorization providers check identity, so use federated authorization as federated authentication
  - Providers:
     - OpenID: Federated authentication, token-based
     - Oz: Federated authentication, but wait too new to try
     - OAuth (see doc): Federated authorization, token-based 
     - OpenID Connect: OAuth-based pseudo-federated authentication
