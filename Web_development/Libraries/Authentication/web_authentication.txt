
                        
   WEB_AUTHENTICATION   
                        


Summary (from best to worst):
  - cookie authentication:
     - advantages over sending credentials in other headers/request_params:
        - can force HTTPS with httpOnly
        - simple:
           - client automatically stores it
           - client automatically sends it
           - with max-age: easy way to communicate expire time to client, or to invalidate
     - disadvantages over sending credentials in other headers/request_params:
        - credentials must be sent as a response HTTP headers (cannot use alternative ways)
        - not crossdomain
  - sending credentials in other headers/request_params
  - HTTP authentication:
     - disadvantages over just sending credentials in headers/request_params (including cookies):
        - browser show prompt on first request
        - basic/digest do not use temp token but actual credentials (username:password)
           - if user-picked:
              - might be guessable
              - can trick users to given credentials with phishing
        - use browser-specific unconditional caching, i.e. must force a request with invalid credentials to invalidate cache

Credentials:
  - types:
     - can be:
        - knowledge: 
           - password/passphrase, secret questions, etc.
           - problems:
              - because need to memorized:
                 - incentive to keep entropy low
                 - might be written down
        - possession:
           - security token, key/lock
           - can be disconnected (tells user credentials) or connected (tells computer credentials directly)
           - problems: can be stolen
        - inherence: 
           - biometrics: fingerprint, retina reader, voice recognition
           - problems: hard to implement
     - multifactor authentication (MFA):
        - using different types together
        - 2-factor authentication (2FA): when two types
  - lifetime:
     - long-lived: most convenient, but if not confidential anymore, must revoke
     - long-lived -> one-time token: middle-way
     - one-time tokens: less convenient, but if not confidential anymore, no need to revoke
  - issuer:
     - user-picked: more convenient but less entropy
     - server-picked: less convenient but more entropy
  - scope:
     - shared among websites:
        - often goes along user-picked
        - if not confidential anymore, compromise other websites
        - can prevent problem by persisting only hash
     - unique for specific website

General status codes:
  - 403 (Forbidden):
     - when using HTTP authentication, and user is authenticated but not authorized
     - when using other kind of authentication, and user is not authenticated or not authorized
  - 511 (Network Authentication required): sent by proxy for authentication pb
  - 419 (Authentication timeout)

Cookie Authentication:
  - Set-Cookie [S] + Cookie [C] (see HTTP doc)

HTTP Authentication:
  - Basic:
	   - server (failure or first request):
         - 401|407 WWW|Proxy-Authenticate: Basic VAR="VAL",... [S]
		        - realm="REALM" (mandatory):
               - set of resources sharing credentials
               - specific for any URL which starts with current URL (without filename)
            - charset="CHARSET" (def and only possible value: "UTF-8"): of USERNAME:PASSWORD
     - client: 
         - shows prompt for username and password
         - [Proxy-]Authorization: Basic BASE64(USERNAME:PASSWORD) [C]
            - USERNAME: allowed chars are [:graph:] any Unicode character representing char|digit
            - PASSWORD: also whitespaces, punctuation, symbols
         - or use USERNAME:PASSWORD in USERINFO part of URI
  - Digest:
	   - server (failure or first request):
        - 401|407 WWW|Proxy-Authenticate: Digest VAR="VAL",... [S]
           - realm="REALM": like Basic Authentication
           - qop="auth[, auth-int]": different algorithms let to client (optional)
           - algorithm="MD5[-sess]": same but for different part of algo (optional)
           - nonce="RANDOM_ALNUM": server-side nonce. Prevents building rainbow tables.
           - opaque="RANDOM_ALNUM", domain="DOMAIN": used to pass state information around during the process (optional).
     - client:
        - [Proxy-]Authorization: Digest VAR="VAL",... [C]:
           - retake same VAR="VAL" as response (chooses gop|algorithm too)
           - username="USERNAME"
           - response="HASHED_PASSWORD"
           - uri="URI": must match first request URL
           - cnonce="RANDOM_ALNUM", nc="NUM": (if gop="auth-int"):
               - if Mallory can simulate Bob (not case if SSL), prevents him to build random tables using unique server nonce,
                 then guessing plaintext password from HASHED_PASSWORD
               - cnonce is the client nonce. nc is incrementing at each client request, keeping initial cnonce (allow reusing
                 same cnonce during a whole session)
        - HASHED_PASSWORD: MD5(MD5(HA1):NONCE[:NC:CNONCE:QOP]:MD5(HTTPMETHOD:URI[:MD5(BODY)])):
           - HA1:
              - if algorithm="MD5", MD5(USERNAME:REALM:PASSWORD)
              - if algorithm="MD5-sess", MD5(MD5(USERNAME:REALM:PASSWORD):NONCE:CNONCE)
           - ":NC:CNONCE:QOP": if qop="auth[-int]". Prevents replay
           - ":MD5(BODY)": if qop="auth-int". Provides message integrity of BODY
  - Token-based:
     - server (failure or first request):
        - 401|407 WWW|Proxy-Authenticate: Bearer VAR="VAL" [S]:
           - realm="REALM": like HTTP Basic Auth. (only one required)
           - scope="SCOPE": sub-realm
           - error[_description|uri]="ERROR" (only for failure)
     - client:
        - [Proxy-]Authorization: Bearer TOKEN [C]
        - or access_token as POST|GET variable
  - server can offer several authentication options at once, e.g.:
      WWW|Proxy-Authenticate: Digest ..., Basic ... [S]
      [Proxy-]Authorization: Digest ... [C]

Federated authentication/authorization: 
  - Types:
     - Federated authentication:
        - instead of Alice authenticating to Bob:
           - Alice authenticates to Trent
           - Bob ask Alice to authenticate
           - Alice ask Bob to ask Trent instead
        - Goal: single login (authentication as a service)
        - Roles:
           - End-user / Resource owner (RO) (Alice)
           - Relying party (RP) / client (Bob)
           - OpenID Provider (OP) / Resource Server (RS) (Trent)
     - Federated authorization:
        - same but "authenticating" -> "authorizing Bob to do X"
     - Pseudo-federated authentication:
        - assuming that federated authorization providers check identity, so use federated authorization as federated authentication
  - Providers:
     - OpenID: Federated authentication, token-based
     - Oz: Federated authentication, but wait too new to try
     - OAuth (see doc): Federated authorization, token-based 
     - OpenID Connect: OAuth-based pseudo-federated authentication
