
                
   MOCHA_CHAI   
                



																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         CHAI GENERAL          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


chai			                    #Either:
                              #  - Server-side test: use Node module (test files must fire CHAI.should())
                              #  - Client-side test: use browser script (include <script> chai.js, then fire chai.should())
                              #Version 1.10.0
CHAI.should()		              #Must be fired to extend OBJ prototype with OBJ.should
															#There are two other possible syntaxes:
															#  - CHAI.expect(VAL).to... -> VAL.should...
															#  - CHAI.assert... (other API not as good)
VAL.should		                #Returns SHOULD, an object wrapping VAL: access it with SHOULD._obj
                              #All members returns SHOULD, so can be chained, e.g. VAL.should.exist.and.be.ok
                              #There are two types of members along the chains:
                              #  - methods: assertion on SHOULD._obj, internally using SHOULD.assert()
                              #  - properties: add an internal "flag" along the chain, that will influence next methods
new CHAI.Assertion(VAL[, STR])#Like VAL.should except:
                              #  - VAL can be null|undefined
                              #  - can setup default "internal error message" STR, so:
                              #      new CHAI.Assertion(VAL, STR).should.equal(VAL2)
                              #    is same as:
                              #      new CHAI.Assertion(VAL).should.equal(VAL2, STR)
                              #    but is useful if STR is used for several following assertions

SHOULD.assert( BOOL, STR[()], #Internal assertion function used by all methods.
STR2[()][, VAL[, VAL2]] )	    #Throws ASSERTIONERROR(ERRORMESSAGE) if false, doesn't do anything otherwise.
                              #  - STR is the the positive error message, STR2 the negative one. 
                              #    Usually "expected ... to VERB ..."
                              #    An "internal error message" is prepended: it is the final optional argument of all methods,
                              #    i.e. all assertion functions can take an extra STR "internal error message" (déf: "")
                              #    The "internal error message" is specific to this assertion case (e.g. "player not a
                              #    magician"), the second message is the general assertion problem (e.g. "ID not equal 'mag'").
                              #  - VAL and VAL2 (expected value() and actual value) are used to be included in error message. 
                              #    STR|STR2 can use following format codes: 
                              #      - "#{this}": SHOULD._obj
                              #      - "#{exp}": VAL 
                              #      - "#{act}": VAL2 (déf: SHOULD._obj)
CHAIUTILS.flag(SHOULD,        #Gets|sets a "flag"
VAR_STR[, VAL_STR]))	        #Some flags used by most ASSERTION:
															#  - "object" (see above): underlying VAL. Can also use SHOULD._obj
															#  - "message": internal error message
															#  - "negate" BOOL: flag .not
															#  - "deep" BOOL: flag .deep
															#  - "contains" BOOL: flag .include.*
															#  - "length" BOOL: flag .length.*

CONFIG VAR ==>                #Can be used by Mocha reporters
CHAI.config.showDiff		      #Show diff (déf: true)
CHAI.config.truncateThreshold	#Truncates VAL length (def: 40, 0 to disable)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:        CHAI EXTENSIONS        :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


CHAI.use(FUNC(CHAI,CHAIUTILS))#Fires FUNC(), which should extend SHOULD by using addMethod(), etc.
                              #FUNC are usually plugins MODULE

CHAI.Assertion.addProperty    #Makes SHOULD.VAR fire FUNC2():
(VAR_STR, FUNC2())		        #  - this SHOULD, so can access CHAIUTILS.flag(this,...) and this._obj
                              #  - should:
                              #     - assert preconditions with this..., e.g. this.equal(3) or this._obj.VAR.equal(3)
                              #       Often check right type with SHOULD.be.an.instanceof()
                              #     - set up a flag with CHAIUTILS.flag(this, VAR, VAL), then overwrite/create 
                              #       property/methods that check this.flag()
CHAI.Assertion.addMethod      #Same for SHOULD.FUNC(...). Should:
(FUNC_STR, FUNC2(...))	      #  - also assert preconditions
                              #  - but finish with final this.assert(...)
CHAI.Assertion.               #Same as CHAI.Assertion.addMethod(FUNC); SHOULD.addProperty(FUNC2), except:
addChainableMethod            #  - it cannot be overwritten (case of a, an, include, length)
(STR, FUNC, FUNC2)	          #  - method FUNC() also fire property FUNC2()

CHAI.Assertion.               #Overwrite SHOULD.FUNC(...):
overwriteMethod(FUNC_STR,     #  - FUNC3() should test it is right type first (if not call original property function): 
FUNC2(SUPER)->FUNC3(...))     #      if ( this._obj && this._obj instanceof TYPE ) 
                              #      { ... } else { SUPER.call(this, ...); }
                              #  - CHAIUTILS.transferFlags(this, SHOULD, BOOL): 
                              #     - adds current chain flags to SHOULD (excluding "object" and "message" if false, which is 
                              #       usually wanted)
                              #     - to do:
                              #        - usually when final assertion use SHOULD..., and should be influenced by current flags
                              #        - not when final assertion use SHOULD.assert() (not affected by flags)
                              #        - usually not when checking preconditions
CHAI.Assertion.               
overwriteProperty             
(VARSTR,FUNC2(SUPER)->FUNC3())#Same for SHOULD.VAR


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:        CHAI ASSERTIONS        :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


NULL|UNDEFINED ==>            #With .should assertion style:
                              #  - SHOULD works by extending OBJ, so null|undefined will throw TYPERROR with SHOULD.*
                              #  - can use CHAI.should().[not.]exist(VAL)
                              #With expect(...) assertion style:
                              #  - SHOULD.[be.]null|undefined
                              #  - SHOULD.exist: not null nor undefined

SHOULD.be                     #
SHOULD.have[.been]            #
SHOULD...that|which
[.is|has[.been]]              #
SHOULD...and                  #
SHOULD.with|at|of|same|to	    #Same as SHOULD (doesn't do anything), provided only for BDD-style syntax

SHOULD.not  	                #Negation

SHOULD.equal(VAL)	            #===. Compare OBJ by reference.
SHOULD.deep.equal(VAL)        #===. Compare OBJ by copy (doesn't compare prototype)
SHOULD.[be.]like|jsonOf(VAL) 	##==. Compare OBJ by copy (doesn't compare prototype) (module chai-fuzzy 1.5.0)
                              ##jsonOf first does JSON.parse(JSON.stringify(VAL))

SHOULD.[be.]ok	              #Is not: STR "", NUM 0, BOOL false, null|undefined
SHOULD_ARR|OBJ.[be.]empty		  #Is: STR "", NUM 0, BOOL false, null|undefined, ARR [], OBJ {}
SHOULD.[be.]true|false	      #Is BOOL and true|false

SHOULD.[be.]above|[at.]least|
below|[at.]most(NUM)		      #> >= < <=
SHOULD.[be.]within(NUM, NUM2)	#> and <
SHOULD.[be.]closeTo(NUM, NUM2)#>= NUM-NUM2 and <= NUM+NUM2

SHOULD.[be.a[n]](STR)	        #Checks typeof (STR is case insensitive)
SHULD.[be.an.]instanceof(FUNC)#Checks TYPE (prototype)
SHOULD.[be.]arguments		      #Is arguments object

SHOULD_ARR|OBJ.               #  - ARR: one element === VAL
include|contain(VAL|OBJ2)     #  - OBJ: members are === subset of OBJ
SHOULD_STR.[have.]string(STR2)#STR2 is inside STR
SHOUD_OBJ.containOneLike(VAL) ##One value of a first-level member of OBJ == VAL, by copy (module chai-fuzzy)
SHOULD_ARR.[deep.]include.
members(ARR2)	                #ARR2 is a subset of ARR (use [deep.]equal)

SHOULD_ARR.include.
some|one|any.item|thing|      ##Like SHOULD_ARR.FUNC(...), but passes if any element of ARR passes
something.FUNC(...)	          ##(Node module chai-things 0.2.0)
SHOULD_ARR.all.FUNC(...)		  ##Inverse: all element of ARR should pass

SHOULD_OBJ.[have.][deep.]     #Check property exist (if "ownProperty", non-inherited only).
[ownP|p]roperty(VAR_STR[,VAL])#If VAL, same as SHOULD.*(VAR_STR).that.equal(VAL)
[.that[.is]|with...]		      #If "deep", VAR can contain indexes and OBJ members, e.g. "VAR[UINT].VAR2" or (for an ARR) 
                              #"[UINT][UINT2].VAR"
			                        #It also changes the assertion value from OBJ to OBJ[VAR_STR] for the rest of the chain, e.g. 
                              #  OBJ.should have.property(...).that.is.true.with.property(...).that.is.false
SHOULD.[be.of.]length[(NUM)]	#Same as OBJ.should.have.property("length"[, NUM])
SHOULD_OBJ|ARR.have|contain.  #Contains those keys (use UINT_STR, starting at 0 for ARR):
any|all.keys(STR[_ARR]...)	  #  - "any": at least one of the keys
                              #  - "all" + "contain": all the keys, must can have more
                              #  - "all" + "have": exactly same keys
SHOULD.[itself.]
respondTo(FUNC2_STR)	        #Checks if VAR.[prototype.]FUNC2(...) (not prototype if "itself")

SHOULD_STR.match(REGEXP)	    #
SHOULD_FUNC().throw
([ERROR|REGEXP|STR])	        #
SHOULD.satisfy
(FUNC(VAL)->BOOL)	            #
SHOULD_FUNC().change
(OBJ, "VAR")                  #OBJ.VAR should be different before|after FUNC() called
SHULD_FUNC().increase|decrease
(OBJ, "VAR")                  #OBJ.VAR should increase|decrease before|after FUNC() called

SHOULD_DATE.equal|before|
afterTime|Date(DATE2)	        ##Module chai-datetime 1.4.0. With "Date": same but truncates after day.

CHAI-JQUERY ==>		            ##Only in browser. Should be included. Version 2.0.0
SHOULD_JQ.[have.]attr|prop|
css|data(VAR[, VAL])	        ##Checks with JQ.attr|prop|css|data()
SHOULD_JQ.[have.]class(CLASS)	##
SHOULD_JQ.[have.]id(ID)	      ##
SHOULD_JQ.[have.]value(VAL)	  ##Check with JQ.val()
SHOULD_JQ.match(CSS_SELECTOR)	##Check with JQ.is()
SHOULD_JQ.descendants
(CSS_SELECTOR)	              ##Check with JQ.has()
SHOULD_JQ.[have.]
html|text(STR)	              ##Check match entirely with JQ.html|text()
SHOULD_JQ.contain(STR)	      ##Check match partially with CSS selector :contains(STR)
SHOULD_JQ.[be.]visible|hidden|
selected|checked|enabled|
disabled|empty		            ##Check with CSS selector ":visible", etc.
SHOULD_JQ.exist		            ##Not of length 0

CHAI-AS-PROMISED ==>          ##All return a CHAIPROMISE (module chai-as-promised 5.0.0), a PROMISE with only then() member.
                              ##To extend it, use CHAI-AS-PROMISED.transferPromiseness = FUNC(SHOULD, PROMISE), where
                              ##FUNC() assign SHOULD.NEWFUNC = PROMISE.FUNC.bind(PROMISE) (this is PROMISE not CHAIPROMISE)
                              ##For wd.js, can do it with:
                              ##  CHAI-AS-PROMISED.transferPromiseness = WD.transferPromiseness;
                              ##So BROWSER.should.eventually returns a BROWSER, not a CHAIPROMISE
                              ##Can also use CHAI-AS-PROMISED.transformAsserterArgs = FUNC(ARR)->ARR, which will modify
                              ##resolved VAL before VAL.should.FUNC2(...) is called.
SHOULD_PROMISE.[be.]fulfilled ##PROMISE should be resolved
SHOULD_PROMISE.eventually.    
FUNC2(...)                    ##PROMISE should be resolved and resolve with VAL and VAL.should.FUNC2(...).
SHOULD_PROMISE.become(VAL)    ##Same as SHOULD_PROMISE.eventually.deep.equal(VAL)
SHOULD_PROMISE.[be.]rejected  
SHOULD_PROMISE.[be.]
rejectedWith(VAL)             ##PROMISE should be rejected [with VAL]


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          MOCHA TESTS          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


MOCHA ==>		                  #Can either:
                              #  - server-side test files: use Node.js with command line mocha, or Node module MOCHA
                              #  - client-side test files: use browser
                              #Version 2.2.5

ASSERTIONS ==>	              #Can use several ones, but the best is Chai
describe[.only|skip](STR, 
FUNC())	                      #
it[.only|skip](STR,           #For async, can either:
[,FUNC( [FUNC2([ERROR])] )])  #  - fire FUNC2
                              #  - return PROMISE (useful when using chai-as-promised)
															#If no FUNC, pending.
															#If only, doesn’t run other test suits/test cases
                              #Can have statements in describe() other than it()|before|after[Each](), e.g.:
                              #  ARR.forEach(FUNC(VAL)->it(STR + VAL, FUNC2))
                              #Nested describe() will create indentations.
                              #Using an already defined describe(STR) will get it instead of setting it.
this.skip()                   #Stops a test unit (inside an it())
before|after[Each]            #before|after are fired only once on the current describe() or, if outside, all describe()
(FUNC([FUNC2([ERROR])]))      #before|afterEach are fired once for each it() on the current describe() or, if outside, all
                              #describe()
                              #Child describe()'s before[Each] are fired after their parent, after[Each] before their parent.

GIVEN[.async](VAL...|ARR).    ##GIVEN = require("mocha-testdata")
it(STR,FUNC([FUNC2(),]VAL...))##Data-driven tests
                              ##Create multipe test cases with description "STR <VAL>" (if VAL is OBJ with OBJ.description 
                              ##STR2, use <STR2> instead)
                              ##Can use require() for ARR to put data in a separate file.
				                      ##FUNC2() is only if "async". If FUNC() returns PROMISE, do not use "aync"
                              ##Version 1.1.0

this				                  #Is shared by all it|before|after[Each]() in a given describe()
                              #Child describe() get a shallow copy.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         MOCHA RUNNERS         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


mocha [FILE|DIR...]			      #Runs test files server-side (Node.js)
                              #Def: ./tests/*.js. With DIR, use --recursive
                              #Options can be in a file at ./test/mocha.opts (as is, one per line)
	
-R MODULE		                  #Changes reporters, i.e. how results are being output.
-O VAR=VAL[,...]              #VAR=VAL are options.
                              #MODULE is a FUNC(RUNNER_OBJ, MOCHA), where RUNNER_OBJ:
															#  - RUNNER_OBJ.on("start", FUNC())
															#  - RUNNER_OBJ.on("suite[ end]", FUNC(SUITE_OBJ)), where SUITE_OBJ has members root BOOL, 
                              #    title STR
															#  - RUNNER_OBJ.on("test[ end]", FUNC(TEST_OBJ))
															#  - RUNNER_OBJ.on("pending", FUNC(TEST_OBJ))
															#  - RUNNER_OBJ.on("pass", FUNC(TEST_OBJ)), where TEST_OBJ has members title|fullTitle(), slow(),
                              #    duration NUM, title STR
															#  - RUNNER_OBJ.on("fail", FUNC(TEST_OBJ, ERROR))
															#  - RUNNER_OBJ.on("end", FUNC())
                              #Extra reporters must be installed along mocha, which means in same node_modules (including if
                              #it has been installed globally)
												      #Built-in MODULE:
															#  - "min": only summary
															#  - "dot|nyan|landing|progress": short console output, printing dots|Nyan cat|plane|progress bar
															#  - "spec" (def): prints test suites/cases names and passed status
															#  - "list": same but flatten suites/test cases, and show all execution times
															#  - "tap"
															#  - "doc|html": HTML code (doc has no formatting, html can only be used client-side)
															#  - "json": OBJ_STR:
															#      - stats:
															#          - suites NUM
															#          - tests|passed|failures NUM
                              #          - pending NUM
															#          - start|end DATE_STR, duration NUM
															#       - tests|failures|passes OBJ_ARR:
															#           - [fullT|t]itle STR
															#           - duration NUM
                              #           - err (when error) OBJ:
                              #              - name STR (e.g. "AssertionError")
                              #              - message STR, stack STR
                              #              - actual|expected VAL
                              #              - showDiff BOOL
															#   - "json-stream": OSTREAM emitting events:
															#       - start FUNC(OBJ) with members total NUM
															#       - pass|fail FUNC(OBJ) with members [fullT|t]title, duration
															#       - end FUNC(OBJ) with members suites, tests|passed|failures, pending, start|end, duration
															#    - "json|html-cov": test coverage
															#    - "xunit"
															#    - "markdown"
-G			                      #Use a final summary Growl notification
-c|C			                    #colors|no-colors
-S                            #Sort test files

-t NUM			                  #Test case timeout (def: 2000) (0 for none)
                              #Can also change for a specific test case with this.timeout(NUM); or all test cases of a test
                              #suite (put in describe() this.timeout(NUM), outside of any before())
                              #Can also --disable-timeouts
-s NUM		                    #Test case slow threshold (def: 75). Slow test cases can be highlighted by REPORTER

-g REGEXP	                    #Only run test cases which description matching partially REGEXP
			                        #Can be used with pseudo-tags, e.g. "#..." or "@..." to include|exclude e.g. tests tagged with 
                              #"selenium"
-f STR                        #Same with just string matching
-i			                      #Inverse -g or -f

-w			                      #Runs then watches ./*.EXT (according to --watch-extensions STR,... def "js") for additional runs
-b			                      #Stops at first error
-r MODULE		                  #Like doing require(MODULE) in beginning of FILE (but not var VAR = require(MODULE), so 
                              #requiring must execute an action
-d			                      #Starts node debug FILE...
--compilers EXT:MODULE        #Execute a MODULE first for *.EXT, e.g. coffee:coffee-script/register

--globals VAR...              #Allow some global vars
--ui STR                      #"bdd", "tdd", "qunit", "require", "exports": this doc is about "bdd" (describe(), it(), etc.),
                              #others are not interesting.


new require("mocha")		      #As Node module. Returns MOCHA
MOCHA.addFile(FILE)	          #
MOCHA.files                   #
MOCHA.run(FUNC(STR, NUM))	    #STR is output, NUM number of failed tests
                              #Returns a RUNNER_OBJ
MOCHA.options                 #OBJ, e.g. useColors BOOL. Following methods only change options.
MOCHA.reporter(MODULE_STR)	  #
MOCHA.grep(PATTERN)	          #
MOCHA.fgrep(STR)  	          #
MOCHA.invert()	              #
MOCHA.growl()	                #
MOCHA.globals(VAR_STR_ARR)	  #
MOCHA.ignoreLeaks(BOOL)		    #
MOCHA.checkLeaks(BOOL)        #
MOCHA.useColors(BOOL)         #
MOCHA.useInlineDiffs(BOOL)    #
MOCHA.timeout(NUM)            #
MOCHA.ui(STR)                 #


CLIENT-SIDE TEST ==>          #To use for client-side testing:
                              #  - load libraries, including chai.js (then fire chai.should())
                              #  - load mocha.js, which define MOCHA, same as Node.js module but:
                              #     - must define option ui: "bdd"
                              #     - can use MOCHA.setup(OBJ), which fire MOCHA.VAR(VAL) for each member (should set up 
                              #       options). MOCHA.setup(STR) is same as MOCHA.setup({ ui: STR })
                              #     - can use MOCHA.globals(VAR_STR_ARR) to let test files use global variables WINDOWS.VAR
                              #       Should before use MOCHA.checkLeaks()
															#     - can use -g REGEXP or -f STR by using GET parameter grep REGEXP, or fgrep STR
                              #  - results:
                              #     - can be displayed in <div id="mocha">
                              #     - can be collected using RUNNER_OBJ returned by mocha.run() to listen for events
                              #  - this results in following:
															#      <html>
															#      <head>
															#        <meta charset="utf-8">
															#        <title>Mocha Tests</title>
															#        <link rel="stylesheet" href="mocha.css">
															#      </head>
															#      <body>
															#        <div id="mocha"></div>
															#        <script src="LIBRARY.js"></script>
															#        <script src="chai.js"></script>
															#        <script src="mocha.js"></script>
															#        <script>mocha.setup('bdd')</script>
															#        <script src="TEST_FILE.js"></script>
															#        <script>
                              #          chai.should();
															#          mocha.checkLeaks();
															#          mocha.globals(VAR_STR_ARR);
															#          mocha.run();
															#        </script>
															#      </body>
															#      </html>

SELENIUM ==>                  #See Selenium doc.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:       MOCHA AUTOMATION        :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


GULP-MOCHA(OBJ)		            #Executes Mocha tests (2.1.0)
				                      #OBJ members are MOCHA.VAR(VAL) (ex: reporter: STR, etc.)

mocha-phantomjs FILE|URL	    #Command line (Node module)
														  #Run mocha on HTML file using PhantomJS
															#HTML page should replace mocha.run() by:
                              #  if (window.mochaPhantomJS){mochaPhantomJS.run();}else{mocha.run();}
-R MODULE			                #Reporter. 
                              #Some reporters based on Node.js modules will not work (since it is run in browser), 
                              #e.g. "html-cov"
-C|--no-color			            #
-t NUM				                #Test startup timeout
-A USERAGENT		              #
-c COOKIE_FILE		            #
-h HEADER_VAR=VAL	            #
-s WEBPAGE.SETTINGSVAR=VAL	  #
-v WIDTHxHEIGHT		            #

GULP-MOCHA-PHANTOMJS(OBJ)	    #OBJ:
                              #  - reporter STR 
                              #  - mocha OBJ
                              #  - dump FILE (redirected output)
                              #Client-side page must do (instead of mocha.run()):
                              #  if ( window.mochaPhantomJS ) { mochaPhantomJS.run() } else { mocha.run() }
                              #Version 0.6.1
