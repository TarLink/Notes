
               
   RECOMPOSE   
               


VERSION ==>                       #0.12.0
                                  #HOC library, i.e. creating wrappers for React types: FUNC(RTYPE)->RTYPE2

CURRYING ==>                      #Most functions can be curried

WRAPPERS ==>                      #All functions except in "Factory" and "Info" are RTYPE wrappers, i.e. 
                                  #returns another RTYPE2 (HOC, "High order component")
                                  #As such, works well with RECOMPOSE.compose(...)

RECOMPOSE.compose(...)            #Same as _.compose(...) but with more debug info


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            FACTORY            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/

RECOMPOSE.renderComponent
('TAG'|RTYPE)                     #Similar to REACT.createFactory()

RECOMPOSE.componentFromProp('VAR')#Same as RECOMPOSE.renderComponent() but using PROPS.VAR 'TAG'|RTYPE

RECOMPOSE.toClass(FUNC())->RTYPE  #Transform a stateless function into a RTYPE
                                  #Can specify FUNC.displayName|name|propTypes|contextTypes|defaultProps


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             INFO              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


RECOMPOSE.isClassComponent(RTYPE)
->BOOL                            #

RECOMPOSE.getDisplayName(RTYPE)   #Returns RTYPE.displayName|name or 'Component'
RECOMPOSE.wrapDisplayName
(RTYPE, STR)                      #Returns STR + RECOMPOSE.getDisplayName(RTYPE)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             PROPS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


RECOMPOSE.flattenProp('VAR',RTYPE)
->RTYPE2                          #Make PROPS.VAR.VAR2 -> PROPS.VAR2

RECOMPOSE.renameProp
('VAR', 'VAR2', RTYPE)->RTYPE2    
RECOMPOSE.renameProps
({ 'VAR': 'VAR2' ... }, RTYPE)
->RTYPE2                          #Make PROPS.VAR -> PROPS.VAR2

RECOMPOSE.mapProps
(FUNC(PRPS)->PROPS2,RTYPE)->RTYPE2#Make PROPS -> PROPS2

RECOMPOSE.mapPropsOnChange        #Same as RECOMPOSE.mapProps() except recomputed on change, i.e.:
('VAR'_ARR, FUNC, RTYPE)->RTYPE2  #  - also pass original PROPS (except PROPS.VAR)
                                  #  - recompute PROPS2 if PROPS.VAR changes (shallow comparison in componentWillReceiveProps)
                                  #So 'VAR'_ARR must be the variables used in FUNC

RECOMPOSE.withAttachedProps
(PROPS[(FUNC()->PROPS2)], RTYPE)
->RTYPE2                          #Wraps RTYPE with PROPS (PROPS2 is the one passed to it, and has higher priority)

RECOMPOSE.withReducer             #Wraps RTYPE to add:
('VAR', 'VAR2', RFUNC,            #  - PROPS.VAR: initial value is OBJ
OBJ[(PROPS)], RTYPE)->RTYPE2      #  - PROPS.VAR2(ACTION): does PROPS.VAR = RFUNC(PROPS.VAR, ACTION)

RECOMPOSE.withState               #Wraps RTYPE to add:
('VAR', 'VAR2',                   #  - PROPS.VAR: initial value is OBJ
OBJ[(PROPS)], RTYPE)->RTYPE2      #  - PROPS.VAR2(VAL|FUNC(PROPS.VAR)[, FUNC()]): does PROPS.VAR = VAL|FUNC(PROPS.VAR)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         RCOMP MEMBERS         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/

RECOMPOSE.withContext
(OBJ, FUNC()->OBJ, RTYPE)->RTYPE2 #Wraps RTYPE with childContextTypes OBJ and getChildContext FUNC

RECOMPOSE.defaultProps
(OBJ, RTYPE)->RTYPE2              #Wraps RTYPE with defaultProps OBJ

RECOMPOSE.withProps
(FUNC(FUNC()->PROPS2)->PROPS,RTYP)
->RTYPE2                          #Similar to RECOMPOSE.defaultProps(...)


RECOMPOSE.setStatic
('VAR', VAL, RTYPE)->RTYPE        #Same as RTYPE.VAR = VAL, but returns RTYPE, so can be used in functional programming
RECOMPOSE.setDisplayName
(VAL, RTYPE)->RTYPE               #Same as RECOMPOSE.setStatic('displayName', VAL, RTYPE)
RECOMPOSE.setPropTypes
(VAL, RTYPE)->RTYPE               #Same as RECOMPOSE.setStatic('propTypes', VAL, RTYPE)

RECOMPOSE.hoistStatics            #Wraps FUNC so it copies RTYPE attributes to RTYPE2 
(FUNC(RTYPE)->TYPE2)->FUNC        #except React-specific attributes: contextTypes, defaultProps, displayName, mixins, type, etc.



																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           LIFECYCLE           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


RECOMPOSE.lifecycle               #Wraps RTYPE with:
(FUNC(), FUNC2(), RTYPE)->RTYPE2  #  - FUNC() called during construction
                                  #  - FUNC2() called during componentWillUnmount
                                  #RTYPE2.state is passed as RTYPE.props

RECOMPOSE.doOnReceiveProps        #Wraps RTYPE so that:
(FUNC(PROPS), TYPE)->RTYPE2       #  - FUNC(PROPS) called on componentWillMount and componentWillReceiveProps


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:     SHOULDCOMPONENTUPDATE     :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


RECOMPOSE.shouldUpdate
(FUNC(PREV_PROPS,NEXT_PRPS)->BOOL, 
RTYPE)->RTYPE2                    #Wraps RTYPE with shouldComponentUpdate()->BOOL

RECOMPOSE.pure(RTYPE)->RTYPE2     #Wraps RTYPE with shouldComponentUpdate() doing a shallow comparison on PROPS

RECOMPOSE.onlyUpdateForKeys       
('VAR'_ARR, RTYPE)->RTYPE2        #Wraps RTYPE with shouldComponentUpdate() doing a shallow comparison on any PROPS.VAR

RECOMPOSE.onlyUpdateForPropTypes
(RTYPE)->RTYPE2                   #Wraps RTYPE with shouldComponentUpdate() doing a shallow comparison on any PROPS.VAR from RTYPE.propTypes


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            RENDER             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


RECOMPOSE.nest(RTYPE...)->RTYPE2  #Will render as:
                                  #  <RTYPE PROPS> 
                                  #     <RTYPE2 PROPS>
                                  #       ...
                                  #         PROPS.children

RECOMPOSE.createSink(FUNC(PROPS))
->RTYPE                           #Renders as no HTML but firing FUNC(PROPS) on 'mount' and 'update'

RECOMPOSE.renderNothing()->RTYPE  #Renders as no HTML

RECOMPOSE.branch
(FUNC(PROPS)->BOOL, 
FUNC3(RTYPE)->RTYPE3,   
FUNC4(RTYPE)->RTYPE4,             #Wraps RTYPE so that RTYPE3 is rendered if BOOL true, RTYPE4 otherwise.
RTYPE)->RTYPE2                    #Calculated at construction and componentWillReceiveProps

