
            
   NODEJS   
            



																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         COMMAND LINE          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


PURPOSE ==>                                     #Execute JavaScript code server-side
                                                #Based on Chrome JavaScript engine V8

VERSION ==>                                     #6.3.1 (non-LTS), 4.4.7 (LTS)

ES6 ==>                                         #Support is documented in JavaScript doc

node[js] [[-e] FILE] [FILE_ARGS]                #Command-line
node[js] -p STR [ARGS]                          #nodejs is symlink to node (prefer the later as this is what nvm uses).
                                                #FILE is JavaScript file (def: stdin)
                                                #With -p, evaluates STR, and returns last return value.
-i                                              #Enters REPL even if stdin does not come from a terminal
--v8-options                                    #Prints available v8 options.
-c                                              #Run-dry (syntax check)

#!/usr/bin/env node                             #Shabang to execute a Node file directly with ./FILE

npm                                             #Node packet manager (see doc)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          EVENT QUEUE          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


clear|setTimeout|Interval|Timeout(...)          #Like DOM ones, but calls underlying [un]ref() to keep the program running. 
                                                #But can call ID.unref() on the ID returned (then ID.ref() later too).
process.nextTick(FUNC()[, ...])                 #Similar to setImmediate(...) but uses microtask queue instead of macrotask one (see JavaScript doc)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              NVM              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


nvm                                             #Manage different versions of Node. Version 0.31.4
                                                #Must install via manual Bash script, not npm
nvm install [-s] [VERSION]                      #Install Node, VERSION in ~/.nvm/
                                                #VERSION def is .nvmrc content:
                                                #  - .nvmrc is looked in project root directory, or any parent 
                                                #  - should create /home/ether/.nvmrc for default VERSION
                                                #VERSION can also be:
                                                #  - stable
                                                #  - unstable
                                                #  - iojs: IO.js
                                                #  - system: version used on current system
                                                #  - ALIAS: after nvm alias ALIAS VERSION. Can also nvm unalias ALIAS.
                                                #-s is from source
nvm uninstall [VERSION]                         #
nvm use [VERSION]                               #Make default binary point to this VERSION (by changing $PATH)
nvm current                                     #Show current VERSION
nvm run [VERSION] ...                           #Calls node (non-interactive)
nvm exec VERSION node ...                       #Calls node (interactive)
nvm which [VERSION]                             #
nvm ls [VERSION]                                #Show which versions are installed
nvm ls-remote [VERSION]                         #Show which versions can be installed
nvm version[-remote] VERSION                    #Normalize "VERSION" string
nvm unload|deactivate                           #Undo nvm temporarily|permanently
nvm reinstall-packages [VERSION]                #Redo npm install -g, but with VERSION


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           DEBUGGER            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


node debug ...                                  #Debugging:
                                                #  - must provide FILE
                                                #  - launch in debug mode. Puts a breakpoint in first line and can use:
                                                #     - breakpoints are specified by:
                                                #       - putting breakpoint; in FILE
                                                #       - sb([[FILE, ]LINE_NUM]): by def, current line
                                                #       - sb('FUNC()')
                                                #       - cb(...): clear breakpoints
                                                #     - [un]watch(VAL): watch points
                                                #     - watchers: list watch points
                                                #     - c: continue
                                                #     - n: next
                                                #     - s: step in
                                                #     - o: step out
                                                #     - pause: pause running code
                                                #     - run|restart|kill
                                                #     - repl: open console to execute in current context
                                                #     - bt: call stack
                                                #     - list(NUM): list NUM next lines
                                                #     - scripts: list all FILE

node --debug[-brk][=NUM] ...                    #Launch debugger but in background.
                                                #If -brk, will put breakpoint at first line.
                                                #Can also send SIGUSR1 to exisiting node process to make in same debugging
                                                #state.
                                                #Can then connect to it with node debug -p PID or node debug URL
                                                #(port 5858, or NUM)

node-inspector                                  #Node package (0.12.8). Use node debugger via the Chrome developer tools.
                                                #How:
                                                #  - use node --debug[-brk]
                                                #  - on same machine, node-inspector & (if /usr/bin/node not available, 
                                                #    make a symlink from /usr/bin/node)
                                                #  - on any machine, visit http://HOST:PORT/debug?port=PORT2 (see options)
                                                #Uses 'rc' module for configuration
--web-port PORT                                 #Def: 8080. Port to be listened.
--web-host HOST                                 #Def: 0.0.0.0
--debug-port PORT2                              #Def: 5858. Listening port.
--save-live-edit                                #Live edit change files directly
--hidden '["REGEXP",...]'                       #Files to hide
--no-preload                                    #Faster boot-time
--inject                                        #When using debugger extensions
--stack-trace-limit                             #Def: 50
--ssl-key|cert                                  #FILE

node-debug ...                                  #Part of node-inspector package.
                                                #Same as node --debug-brk ..., followed by node-inspector, then open browser.
                                                #Same arguments with also:
--[no-]debug-brk                                #Stop on first line
--cli                                           #Don't open browser
--nodejs "[...]"                                #Pass options to NodeJS process


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            GLOBAL             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


global                                          #Global object (like WINDOW in a browser)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             ERROR             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


ERROR                                           #Like standard JavaScript, with extra properties
ERROR.stack                                     #
Error.captureStackTrace(OBJ)                    #Adds OBJ.stack
Error.stackTraceLimit                           #Def: 10


NERROR                                          #Node internal error, as opposed to standard JavaScript ERROR
                                                #Often filesystem errors, including permissions
NERROR.syscall                                  #STR
NERROR.errno                                    #UINT
NERROR.code                                     #STR
NERROR.path                                     #STR, for filesystem errors


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            EVENTS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


EventEmitter                                    #Base class of all objects receiving events
                                                #Note that 'EVENT' can be a SYM
EVENTEMITTER.on|removeListener('EVENT', FUNC)
  ->EVENTEMITTER                                # 
EVENTEMITTER.once('EVENT', FUNC)->EVENTEMITTER  #
EVENTEMITTER.prepend[Once]Listener(...)         #Like on[ce](...) but adds to beginning of listeners list, not end
EVENTEMITTER.removeAllListeners(['EVENT'])
  ->EVENTEMITTER                                #
EVENTEMITTER.emit('EVENT'[, ...])->BOOL         #True if there were listeners
                                                #If 'EVENT' is 'error' and there are not listeners, throws instead

EVENTEMITTER.listeners(EVENT)->FUNC_ARR         #
EVENTEMITTER.listenerCount(EVENT)->NUM          #Slightly faster than EVENTEMITTER.listeners(STR).length
EVENTEMITTER.eventNames()->'EVENT'_ARR          #
EVENTEMITTER.setMaxListeners(NUM)->EVENTEMITTER #0 for unlim. Beyond max, does not stops adding listeners, only print warning.
EVENTEMITTER.getMaxListeners()->NUM             #
EVENTEMITTER.defaultMaxListeners                #10
EVENTEMITTER.on                                 #Event when a new event handler is added or removed.
 ("new|removeListener", FUNC(EVENT, FUNC2))     #Added|removed FUNC2 might still [not] be in EVENTEMITTER.listeners(EVENT)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            MODULE             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


MODULE ==>                                      #Can be:
                                                #  - Node JavaScript file: executes it
                                                #  - JSON file: same as module.exports = JSON.parse('JSON')
                                                #  - machine code file:
                                                #     - often "*.node"
                                                #     - loaded by dlopen()
                                                #     - exports available in void init(Handle<Object> exports)
                                                #     - must use libraries: V8, libuv, others
                                                #     - use node-gyp for packaging/compilation
module                                          #Current MODULE, i.e. file being loaded.
                                                #There are builtin modules, which are the chapters of this doc.

node -r STR                                     #Load file STR:
require(STR)                                    #  - 'ID': core module
                                                #  - 'FILE' (absolute or relative)
                                                #  - 'DIR' (absolute or relative):
                                                #     - DIR/package.json, using main 'PATH' (relative to DIR)
                                                #     - DIR/index.EXT
                                                #  - 'MODULE':
                                                #     - i.e. anything that does not start with / or .
                                                #     - tries require('DIR2/MODULE'), with DIR2:
                                                #        - [.../[..]]./node_modules/
                                                #        (all the following should be avoided)
                                                #        - ENVVAR NODE_PATH (colon-separated list)
                                                #        - $HOME/.node_modules
                                                #        - $HOME/.node_libraries
                                                #        - [process.config.variables.node_prefix]/lib/node/ 
                                                #Paths can omit extensions: .js, .json, .node
                                                #If not found, throw ERROR with code "MODULE_NOT_FOUND"
require.resolve(STR)->'ID'                      #How [MODULE.]require(STR) would resolve
require.cache[ID]                               #[MODULE.]require(STR) cache (i.e. modules are only loaded once).
                                                #ID is require.resolve(STR) result
                                                #Builtins are not cached.
                                                #Can delete it to remove cache, or restart current code.
MODULE.require                                  #Reference to require

CIRCULAR DEPENDENCIES ==>                       #If a module require its parent:
                                                #  - it will receive its parent current module.exports, even though its parent is not finished loading
                                                #  - it will not execute its parent, since its parent is already loading

SCOPE ==>                                       #Variables are local to each file, except for MODULE.exports
exports                                         #Return value (by reference if OBJ) when required. Must be assigned sync.
                                                #Can be any type.
MODULE.exports                                  #Reference to exports. 
                                                #Must be used when want to overwrite, i.e. exports = VAL (as opposed to exports.VAR = VAL)
this                                            #Is, according to ENVVAR NODE_MODULE_CONTEXTS:
                                                #  - 0 (def): module.exports
                                                #  - 1: global

require.main                                    #Root file (first to have been loaded), as MODULE
process.mainModule                              #Same but updated if root file changed at runtime
MODULE.parent|children                          #MODULE[_ARR]|null
MODULE.loaded                                   #False for the first time the file is loaded (i.e. sync)
                                                #True for async functions

__filename                                      #Current file absolute path.
MODULE.filename                                 #Reference to __filename
MODULE.id                                       #For core modules, a string like "buffer". For others, module.filename.
__dirname                                       #Current file absolute dirname

CLI ==>                                         #require.main, process.mainModule: undefined
                                                #MODULE.loaded: false
                                                #__filename, __dirname: undefined (but MODULE.filename is '$PWD/repl')
                                                #MODULE.id: 'repl'
                                                #exports is undefined (but not MODULE.exports)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:        STRING_DECODER         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


new StringDecoder([ENCODING_STR])							  #Returns DECODER. Def: "utf8"
                                                #Does BUFFER -> STR translation
DECODER.write|end(BUFFER)->STR                  #Adds to current string. If:
                                                #  - it still contains incomplete chars, returns ''
                                                #  - otherwise, resets and returns current string
DECODER.end()->STR                              #Returns current string, but does not reset.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            BUFFER             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Buffer                                          #Child of Uint8Array (including constructors), with extra methods:
                                                #  - mixes in DATAVIEW flexibility (of changing current type)
                                                #  - better serialization: toString(), toJSON()
                                                #  - can decode STR according to different encodings
                                                #  - can swap bytes, compare bytes
                                                #  - some performance improvements, and some convenience functions
                                                #Don't need to use require("buffer")

BVAL                                            #UINT (like Uint8Array), STR or BUFFER2
ENCODING                                        #Among: ascii, utf8 (def), urf16le|ucs2, base64, hex, binary (actually latin-1)
Buffer.isEncoding('ENCODING')->BOOL             #

new TYPED_ARR(BUFFER)                           #Copy, not reference
                                                #Each single BUFFER BVAL -> a single TYPED_ARR VAL
Buffer.allocUnsafe[Slow](NUM)->BUFFER           #Similar to new TYPED_ARR(NUM)
                                                #Max size is Buffer.kMaxLength (64 bits on 64 bits architecture)
                                                #Unless "Slow", will reuse preallocated buffer from a pool (i.e. faster) if NUM <= Buffer.poolSize (def: 8192) / 2
Buffer.alloc(NUM[, BVAL[, 'ENCODING']])->BUFFER #Like Buffer.allocUnsafeSlow(NUM).fill(BVAL, 'ENCODING') (def: \0), for security reasons
                                                #If node --zero-fill-buffers, will fill with \0 even Buffer.allocUnsafe[Slow]()
Buffer.from(NUM_ARR)->BUFFER                    #Similar to new TYPED_ARR(NUM_ARR)
Buffer.from(ARRBUFFER, ...)->BUFFER             #Similar to new TYPED_ARR(ARRBUFFER, ...)
Buffer.from(STR[, 'ENCODING'])->BUFFER          #
Buffer.from(BUFFER)->BUFFER                     #Copies
Buffer.concat(BUFFER_ARR[, UINT])->BUFFER       #Similar to Array.prototype.concat.call(null, ...) but with BUFFER_ARR
                                                #Providing final length UINT can speed up performance.

Buffer.byteLength(STR|BUFFER|TYPED_ARR|DATAVIEW|
ARRBUFFER[, 'ENCODING'])->NUM                   #Similar to TYPED_ARR.byteLength

Buffer.isBuffer(VAL)->BOOL                      #
BUFFER.equals(BUFFER2)->BOOL                    #
BUFFER.compare(BUFFER2[, 4 NUM])->-1|0|1        #Sort comparaison. NUMs are BUFFER2 start|end and BUFFER start|end
Buffer.compare(BUFFER, BUFFER2)->-1|0|1         #Same as BUFFER.compare(BUFFER2)

BUFFER.toString(['ENCODING'[, ...])->STR        #Like:
                                                #  let decoder = new StringDecoder('ENCODING');
                                                #  decoder.write(BUFFER.slice(...));
                                                #  return decoder.end()
BUFFER.toJSON()                                 #Returns as '{"type": "Buffer", "data": [...]}'

BUFFER.slice(...)->BUFFER                       #Like [TYPED_]ARR, but returns a reference
BUFFER.[last]indexOf(..., 'ENCODING')->NUM      #Like [TYPED_]ARR but:
BUFFER.includes(..., 'ENCODING')->BOOL          #  - VAL is BVAL
BUFFER.fill(...[, 'ENCODING'])                  #  - can use 'ENCODING'

BUFFER.write(STR[, UINT[, UINT2[, 'ENCODING']]])#Writes STR on BUFFER
 ->NUM                                          #UINT is offset (def: 0) and UINT2 is length (def: all)
BUFFER.copy(BUFFER2[, 3 UINT])->UINT4           #Copies bytes from BUFFER at position UINT to BUFFER2 from position UINT2 to UINT3 (def: BUFFER2.length)

BUFFER.readFloat|Double|[U]Int8|16|32]LE|BE     
(UINT[, BOOL])->VAL                             #Similar to DATAVIEW.get|set* but:
BUFFER.writeFloat|Double|[U]Int8|16|32LE|BE     #  - use LE|BE instead of BOOL argument
(VAL, UINT[, BOOL])                             #  - if BOOL true, faster but no validation of UINT buffer overflow
BUFFER.read[U]Int[LE|BE](UINT, UINT2[, BOOL])   
BUFFER.write[U]Int[LE|BE](VAL,UINT,UINT2[,BOOL])#Same but specifies [U]Int size UINT2 (up to 48)

BUFFER.swap16|32|64()->BUFFER                   #Swaps every couple of 1|2|4 bytes. Return value is reference


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            STREAM             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


SVAL                                            #BUFFER or (if setEncoding() called) STR, or null if nothing to read
OBJECT MODE ==>                                 #SVAL is any VAL (except null): 
                                                #  - encoding is ignored
                                                #  - both ISTREAM and OSTREAM must be in objectMode
                                                #  - ISTREAM.read() NUM argument is ignored (always 1)

ISTREAM ==>                                     #Input stream. Actually called Readable
new STREAM.Readable([OBJ])                      #OBJ:
                                                #  - encoding 'ENCODING' (def: null, i.e. uses BUFFER)
                                                #  - objectMode BOOL: see above
                                                #  - highWaterMark NUM: 
                                                #     - buffer size (def: 16kb)
                                                #     - on ISTREAM: data available for read but not read yet
                                                #     - on OSTREAM: data not flushed yet
                                                #     - if buffer full, waits
ISTREAM.on("readable", FUNC())                  #New chunks available, or just before "end"
ISTREAM.on("data", FUNC(SVAL))                  #Each new chunk available. Firing FUNC() consumes that chunk.
                                                #Not fired if ISTREAM is empty
ISTREAM.read([UINT])->SVAL                      #Like on("data") but:
                                                #  - sync: waits until chunk available (i.e. prefer on("data"))
                                                #  - specify (max) chunk size UINT (def: all)
                                                #  - SVAL is null if ISTREAM empty
ISTREAM.on("end", FUNC())                       #When all chunks have been read
ISTREAM.on("close", FUNC())                     #When underlying fd is closed (not all ISTREAM close)
ISTREAM.on("error", FUNC())                     #
ISTREAM.pause|resume()                          #Makes it stop|resume emit "data" events.
ISTREAM.isPaused()															#
ISTREAM.setEncoding('ENCODING')                 #
ISTREAM.pipe(OSTREAM[, { end: BOOL }])->OSTREAM #Same as ISTREAM.on("data", sval => OSTREAM.write(SVAL))
                                                #If BOOL true (def), call OSTREAM.end() on ISTREAM.on('end|error') (except on stdout|stderr)
ISTREAM.unpipe([OSTREAM])                       #Stops pipe() (def: all)
ISTREAM.unshift(SVAL)                           #Put last SVAL read back in ISTREAM

OSTREAM ==>                                     #Output stream. Actually called Writable
STREAM.Writable([OBJ])                          #Constructor for OSTREAM. OBJ members are:
                                                #  - decodeStrings BOOL: if true (def), decodes to BUFFER before calling underlying OSTREAM._write()
                                                #  - objectMode BOOL: see above
                                                #  - highWaterMark NUM: see above
OSTREAM.write(SVAL[, 'ENCODING'[,FUNC()]])->BOOL#Writes chunks.
                                                #FUNC() is fired when buffered + flushed.
                                                #BOOL:
                                                #  - false if data cannot be buffered anymore (i.e. buffer is full)
                                                #  - i.e. should wait for OSTREAM.once('drain') before writing again
OSTREAM.end(SVAL[, 'ENCODING'[, FUNC()]])->BOOL #Same but for final chunk. FUNC is the finish event handler
OSTREAM.setDefaultEncoding('ENCODING')->OSTREAM #
OSTREAM.[un]cork()                              #cork() forces buffering to disk, uncork() flushes
                                                #To do when writing a lot of small I/O, to make them all flush at once.
OSTREAM.on("close", FUNC())                     #Like ISTREAM
OSTREAM.on("finish", FUNC())                    #Fired when end() done
OSTREAM.on("[un]pipe", FUNC(ISTREAM))           #Fired by ISTREAM.[un]pipe()
OSTREAM.on("error", FUNC())                     #

IOSTREAM ==>                                    #Implement both ISTREAM and OSTREAM. Actually called either:
                                                #  - STREAM.Duplex
                                                #  - STREAM.Transform: 
                                                #     - same but where there is a correlation between input and output (ex: crypto, but not HTTP) 
                                                #     - only semantic

INHERITING STREAMS ==>                          #To create STREAM child classes, just inherit them and reimplement functions
                                                #_read(), _write[v](), _transform() or _flush() (see online doc), without calling them directly.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           READLINE            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


createInterface(OBJ)->INTERFACE                 #Creates an INTERFACE object:
                                                #  - read CLI input and pipe it to output
                                                #  - when using stdin and stdout on a terminal, will create a CLI 
                                                #  - if Node prompt is already there, will double output on input
                                                #OBJ:
                                                #  - input ISTREAM
                                                #  - output OSTREAM
                                                #  - completer(STR[, FUNC(ERROR, ARR)])[->ARR]:
                                                #     - used to tab completion
                                                #     - can be sync or async
                                                #     - ARR: [ STR2_ARR, STR ]
                                                #        - STR is original string
                                                #        - STR2_ARR are possible matches. If only one left, autocompletes
                                                #  - historySize NUM (def: 30)
                                                #  - terminal BOOL (def: OSTREAM.isTTY): if tty
INTERFACE.close()                               #Called by ISTREAM.end(), CTRL-C and CTRL-D.
INTERFACE.on("close", FUNC())                   #

INTERFACE.on("line", FUNC(STR))                 #Fired each time a line is read from ISTREAM.
INTERFACE.write(STR[, OBJ])                     #Prints STR on OSTREAM or, if OBJ { ctrl|meta|shift: true, name: STR }, on CTRL-STR
                                                #Be careful as it will be read by ISTREAM, if ISTREAM and OSTREAM point to same thing (e.g. terminal).
INTERFACE.prompt([BOOL])                        #Write in beginning of current OSTREAM line the STR set by INTERFACE.setPrompt(STR) (def: "> ").
                                                #If line was not empty, will place cursor at character number UINT of prompt (def) or, if true, at end of line.
INTERFACE.question(STR, FUNC(STR2))             #Replace current prompt by STR on OSTREAM, and fires FUNC(STR2) on line event instead of normal line event.
INTERFACE.pause|resume()                        #Pause|resume ISTREAM. 
                                                #ISTREAM still accept input but buffers it, and reads it once resumed.
                                                #Also fired by SIGCONT or SIGTSTP (CTRL-Z)
                                                #resume() is also called by write(), prompt() and question()
INTERFACE.on("pause|resume", FUNC())            #
INTERFACE.on("SIGNINT|TSTP|CONT", FUNC())       #

clearScreenDown(OSTREAM)                        #
clearLine(OSTREAM, NUM)                         #Can be 0 (entire line) or -1|1 (to the left|right of cursor)
cursorTo|moveCursor(OSTREAM, NUM, NUM2)         #Move cursor absolutely|relatively
emitKeypressEvents(OSTREAM[, INTERFACE])        #Enable OSTREAM.on('keypress')


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             REPL              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


start([OBJ])->REPLSERVER                        #Creates a REPLSERVER:
                                                #  - INTERFACE made specifically for Node.js command line, e.g. whose line event handler is eval()
                                                #  - this is what is used by node with no FILE.
                                                #If NODE_NO_READLINE envvar is defined to 1, readline is not used.
                                                #OBJ members are:
                                                #  - prompt STR (def: "> ")
                                                #  - input ISTREAM (def: process.stdin)
                                                #  - output OSTREAM (def: process.stdout)
                                                #  - terminal BOOL (def: OSTREAM.isTTY)
                                                #  - eval(STR, OBJ, FILENAME, FUNC(ERROR, STR)): 
                                                #     - function to perform after each line 
                                                #        - if ERROR is new Recoverable(ERROR), keep prompt ongoing (e.g. for multiline input)
                                                #     - def is async. wrapper of eval():
                                                #        - STR is command
                                                #        - OBJ is current context (global object)
                                                #        - STR2 is current module.filename
                                                #  - useColors BOOL (def: same as terminal)
                                                #     - can also use ENVVAR NODE_DISABLE_COLORS=1
                                                #  - useGlobal BOOL (def: false): use current context, and not local one
                                                #  - ignoreUndefined BOOL (def: false): if true, doesn't print output when it is undefined
                                                #  - writer FUNC(VAL): output printing, def. is util.inspect
                                                #  - replMode:
                                                #     - can be:
                                                #        - REPL_MODE_STRICT: "use strict"
                                                #        - REPL_MODE_SLOPPY: inverse
                                                #        - REPL_MODE_MAGIC: first SLOPPY, then STRICT
                                                #     - def is ENVVAR NODE_REPL_MODE 'sloppy|strict|magic' (def: 'magic')
                                                #  - breakEvalOnSigint BOOL: if true (def: false), stops on CTRL-C
REPLSERVER.on("reset", FUNC())                  #When ".clear" is called.
REPLSERVER.on("exit", FUNC())                   #
REPLSERVER.context                              #Global environment, as OBJ
                                                #REPL command ".clear" resets it.


REPL COMMANDS ==>                               #
_                                               #Last expression evaluated
.save FILE                                      #Save all input so far to FILE
.load FILE                                      #Input FILE
.exit                                           
CTRL-D                                          #
.break
CTRL-C                                          #
.help                                           #
REPLSERVER.defineCommand('STR', OBJ|FUNC(...))  #Custom commands called .STR 
                                                #OBJ:
                                                #  - action(...)
                                                #  - help STR

NODE_REPL_HISTORY                               #ENVVAR (def: ~/.node_repl_history)
NODE_REPL_HISTORY_SIZE                          #Def: 1000
NODE_REPL_MODE                                  #Whether to use strict mode:
                                                #  - sloppy: never
                                                #  - magic (def): when 'use strict' specified
                                                #  - strict: always


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             DGRAM             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


createSocket(STR|OBJ[, FUNC(BUFFER, OBJ2)])     #OBJ:
 ->UDPSOCKET                                    #  - type "udp4|6"
                                                #  - reuseAddr BOOL (def: false): make UDPSOCKET.bind() reuse an address already bound
                                                #STR is OBJ.type
                                                #FUNC is 'message' event handler.
UDPSOCKET.address()                             #{ address, port, family }

UDPSOCKET.bind(OBJ[, FUNC()])                   #Start listening. OBJ:
UDPSOCKET.bind(PORT_NUM[, 'ADDR'][, FUNC()])    #  - port PORT_NUM
                                                #  - address 'ADDR' (def: all available)
                                                #FUNC() is 'listening' event handler
                                                #Program will block until UDPSOCKET.close() is called. Can also use UDPSOCKET.[un]ref()
UDPSOCKET.on("listening", FUNC())               #After bind()
UDPSOCKET.on("message", FUNC(BUFFER, OBJ))      #OBJ is like UDPSOCKET.address()
UDPSOCKET.close([FUNC()])                       #FUNC is close event handler
UDPSOCKET.on("close", FUNC())                   #
UDPSOCKET.on("error", FUNC(ERROR))              #

UDPSOCKET.send                                  #Sends to PORT_NUM, address 'ADDR'. 
(BUFFER[_ARR]|STR[_ARR][, UINT, UINT2],         #Payload is first arg, from byte UINT, length UINT2
PORT_NUM, 'ADDR'[, FUNC(ERROR, UINT3)])         #If bind() has not been called, UDPSOCKET gets assigned a random port, and an adress "0.0.0.0"
                                                #When done, fires FUNC: UINT3 is the number of bytes sent.
                                                #Max. BUFFER size is the MTU, which must be found with PMTUD.

UDPSOCKET.setBroadcast(BOOL)                    #
UDPSOCKET.setMulticastLoopback(BOOL)            #
UDPSOCKET.add|dropMembership(STR[, STR2])       #Routing options
UDPSOCKET.set[Multicast]TTL(UINT)               #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              NET              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


createServer([OBJ, ][FUNC()])->TCPSERVER        #FUNC is 'connection' event handler
                                                #OBJ:
                                                #  - allowHalfOpen BOOL: see below
                                                #  - pauseOnConnect BOOL (def: false): if true, calls TCPSOCKET.pause() on 'connection'

TCPSERVER.listen                                #Makes the TCPSERVER:
(PORT_NUM|'PORT'[, 'ADDR'][, UINT][, FUNC()])   #  - listen to PORT_NUM|'PORT':
                                                #     - if 0, random port
                                                #     - can fire 'error' event with ERROR.code "EADDRINUSE" if another process already uses this port.
                                                #  - listen to 'ADDR':
                                                #     - def: INADDR_ANY, i.e. any available IP on the machine will work
                                                #  - UINT: max number of pending connections:
                                                #     - def: 511 
                                                #     - OS limits are determined by sysctl settings like tcp_max_backlog and somaxconn
                                                #  - FUNC is 'listening' event hander
                                                #Can only be called once.
TCPSERVER.listen('PATH'[, UINT][, FUNC()])      #Same but by explictely creating a socket at 'PATH' (should be in /tmp)
TCPSERVER.listen(OBJ[, UINT][, FUNC()])         #Same but for either:
                                                #  - { fd: UINT }: with file descriptor, not on Windows
                                                #  - TCPSERVER|TCPSOCKET
TCPSERVER.listen(OBJ[, FUNC()])                 #Same with OBJ: port, host, path, backlog UINT
TCPSERVER.on("listening", FUNC())               #Fired when listen() is called.
TCPSERVER.listening                             #BOOL
TCPSERVER.close([FUNC()])                       #Stops the server from accepting new connections:
                                                #  - keeps existing ones
                                                #  - when existing ones have stopped, emits "close" event
                                                #FUNC is 'close' event listener
TCPSERVER.on("close", FUNC())                   #Fired on TCPSERVER.close()
TCPSERVER.address()->OBJ                        #Returns { port: UINT, address STR, family: "IPv4|6" }
                                                #After listen() has been called
TCPSERVER.[un]ref()->TCPSERVER                  #The program will block until at least one TCPSERVER is ref'd.
                                                #listen() call ref(), and stop() or stop event handlers call unref()

TCPSERVER.on("connection", FUNC(TCPSOCKET))     #Fired when a TCP connection is initiated.
TCPSERVER.on("error", FUNC(ERROR))              #Fired when connection problem. Will fire TCPSERVER.close()
TCPSERVER.maxConnections                        #Def: null
TCPSERVER.getConnections([FUNC(ERROR, UINT)])   #Number of connections


connect|createConnection(ARGS[, FUNC()])       
  ->TCPSOCKET                                   #Same as new Socket(OBJ) followed by TCPSOCKET.connect(...)
TCPSOCKET                                       #IOSTREAM but:
                                                #  - no readable event, read() or unshift() (but still data event)
                                                #  - nothing about piping
                                                #  - close event handler: FUNC(BOOL): true if close because of error
                                                #  - error event handler: FUNC(ERROR)
new Socket([OBJ])                               #OBJ:
                                                #  - fd: UINT
                                                #  - readable|writable BOOL (def: false): only when fd was used
                                                #  - allowHalfOpen BOOL (def: false): 
                                                #     - if true, when other socket closes connection, doesn't automatically call end()
                                                #     - which means:
                                                #        - can still write to it (but non-readable)
                                                #        - must manually call end()
TCPSOCKET.connect(ARGS[, FUNC()])								#ARGS:
                                                #  - OBJ:
                                                #     - port PORT_NUM|'PORT'
                                                #     - host 'ADDR'
                                                #     - localAddress|localPort
                                                #     - path 'PATH' (only for UNIX sockets, only option then)
                                                #     (see DNS.lookup())
                                                #     - family 4|6|null
                                                #     - hints
                                                #     - lookup (def: DNS.lookup())
																								#  - HOST[, PORT]
																								#  - "PATH"
                                                #FUNC() is 'connect' event handler.
TCPSOCKET.connecting                            #BOOL: true after connect() but before 'connect' event
TCPSOCKET.on                                    #Fired after hostname resoution, but before TCP connection.
("lookup", FUNC(ERROR, 'IP', VAL, 'HOST'))      #VAL is family 4|6|null
TCPSOCKET.on("connect", FUNC())                 #
TCPSOCKET.destroy([ERROR])                      #No more read|write. Only necessary when error happened.
                                                #If ERROR, 'error' event is fired
TCPSOCKET.destroyed                             #BOOL
TCPSOCKET.[un]ref()->TCPSOCKET                  #Like TCPSERVER

TCPSOCKET.setTimeout(UINT[, FUNC()])->TCPSOCKET #Trigger a timeout event after UINT ms of idleness (0 to disable (def)), a single time.
                                                #Event handler can end|destroy()
                                                #FUNC is 'timeout' event handler
TCPSOCKET.on('timeout', FUNC())                 #
TCPSOCKET.setKeepAlive(BOOL, UINT)->TCPSOCKET   #Def: false and 0.
TCPSOCKET.setNoDelay(BOOL)->TCPSOCKET           #If false (def), use buffers:
                                                #  - to reduce amount of requests i.e. send data in chunks 
                                                #  - more efficient when using a lot of small requests, but can delay them
                                                #  - even disabled, underlying IOSTREAM still use buffer to keep up with high demand
TCPSOCKET.bufferSize                            #Currently buffered size. 
                                                #If ever growing, should use pause|resume()
TCPSOCKET.bytesRead|Written                     #So far

TCPSOCKET.address()->OBJ                        #Like TCPSERVER
TCPSOCKET.local|remotePort|Address              #
TCPSOCKET.remoteFamily                          #'IPv4|6'
isIp('ADDR')->0|4|6                             #
isIpv4|6('ADDR')->BOOL                          #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              TLS              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


getCiphers()->STR_ARR                           #All suite of SSL ciphers are [PREFIX-]ALGO[-HASH]
                                                #ALGO: AES128|256, 3DES, DES, Camellia128|256, IDEA, RC4, SEED
                                                #PREFIX:
                                                #  - ECDH[E]-ECDSA|RSA: for AES, DES, RC4
                                                #  - DH[E]-DSS|RSA: for AES, Camellia, SEED
                                                #  - EDH-DSS|RSA: for DES
                                                #  - PSK: for AES, 3DES, RC4
                                                #  - SRP-[DSS|RSA]: for AES, 3DES
                                                #HASH ([-]#ALGO means ALGO with[out] PREFIX SPK|SRP):
                                                #  - sha: -#AES*, Camellia*, RC4, SEED
                                                #  - gcm-sha256: -#AES128
                                                #  - gcm-sha384: -#AES256
                                                #  - sha256: -#AES*
                                                #  - cbc3-sha: -#DES
                                                #  - cbc-sha: IDEA, #AES
                                                #  - md5: RC4 (unless any PREFIX)
                                                #  - ede-cbc-sha: #DES
TLSSOCKET.getEphemeralKeyInfo()->OBJ            #Gets information about cipher's (only [EC]DH) use of perfect forward secrecy:
                                                #  - type '[EC]DH' 
                                                #  - name STR
                                                #  - size NUM

TLSSERVER                                       #Child of TCPSERVER:
                                                #  - since it inherits from TCPSERVER, can accept TCP connections, not only SSL ones.
                                                #  - all TLSSERVER will fire for both SSL and normal TCP connections.
                                                #Authorization:
                                                #  - unless rejectUnauthorized is true:
                                                #     - non-authorized SSL are still accepted (and communication is encrypted) 
                                                #     - but can be checked as non-authorized
                                                #  - certificate check will follow CA chain until CA roots which are known builtin
                                                #  - authorization also checks the domain in certificate === host being connected
createServer(OBJ[, FUNC(TLSSOCKET)])->TLSSERVER #OBJ:
                                                #  - key STR[_ARR]|BUFFER|OBJ_ARR: server private key, in PEM format
                                                #  - cert STR[_ARR]|BUFFER[_ARR]: server certificate, in PEM format
                                                #  - pfx STR|BUFFER: key+cert+ca in PFX or PKCS12 format
                                                #  - requestCert BOOL (def: false): request authentication (with certificate) of other end (i.e. client)
                                                #     - rejectUnauthorized BOOL (def: false): throw error to other end if cannot authentify it
                                                #     - ca STR[_ARR]|BUFFER[_ARR]: 
                                                #        - list of root certificates, in PEM format
                                                #        - by def., well-known root CAs
                                                #        - otherwise, can be used to authorize self-signed certificates
                                                #  - passphrase STR: passphrase used to decrypt the server private key (when a private key is encrypted)
                                                #  - crl STR[_ARR]: CRLs, in PEM format
                                                #  - secureProtocol STR: 
                                                #     - "SSLv2|3|TLSv1_[client|server_]method": forces SSL version for client and|or server
                                                #        - no client|server means both
                                                #     - def: uses the best one accepted by client
                                                #  - honorCipherOrder BOOL: 
                                                #     - if true, server will choose cipher preference, not client
                                                #     - list is designated by ciphers STR:
                                                #        - defaults to "*AES*:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA"
                                                #        - AES are in order: 128 > 256, SHA384 > SHA256, ECDHE > DHE, RSA > ECDSA
                                                #     - def: false, but true recommended
                                                #  - handshakeTimeout (def: 120000, in ms): when timing out, emits tlsClientError
                                                #  - NPNProtocols|ALPNProtocols STR_ARR|BUFFER: list of application protocols that can be used, ordered by priority.
                                                #  - SNICallback('HOST', FUNC(ERROR, OBJ)): 
                                                #     - when client asks for SNI, calls it with requested server 'HOST' 
                                                #        - if success, must call FUNC(null, OBJ2), where OBJ2 is TLSSOCKET.secureContext
                                                #     - can also use TLSSERVER.addContext('HOST', OBJ) with OBJ { key, cert, ca, ... }
                                                #  - sessionIdContext STR: 
                                                #     - STR concatened in front of SSL session ID.
                                                #     - if requestCert is true, it is a MD5 nonce. Otherwise, it is "".
                                                #  - sessionTimeout (def: 300, in sec): expiration for TLS identifiers and session tickets
                                                #  - ticketKeys BUFFER: 48 bytes divided in three 16 bytes parts: prefix, HMAC, AES key
                                                #     - can use TLSSERVER.getTicketKeys()->BUFFER and TLSSERVER.setTicketKeys(BUFFER)
                                                #  - ecdhCurve STR (def: "prime256v1"): for ECDH
                                                #  - dhparam STR|BUFFER: for DH
                                                #FUNC is 'secureConnection' event handler
TLSSERVER.on("secureConnection",FUNC(TLSSOCKET))#Like TCPSERVER.on("connection"), but for SSL.
                                                #Only fired by SSL connections, not normal TCP ones.
TLSSERVER.on
("tlsClientError", FUNC(ERROR, TLSSOCKET))      #See handshakeTimeout
TLSSERVER.on("newSession",FUNC(ID,DATA,FUNC2()))#Fired when client creates new session: ID is the session ID, DATA the shared secret.
                                                #Must fire FUNC2 when done
TLSSERVER.on("resumeSession",                   #Fired when client wants to resume a session. Must call FUNC2() to do so:
FUNC(ID, FUNC2(ERROR, DATA)))                   #  - DATA is the one stored with newSession event
                                                #  - if no new session, ERROR|DATA should be null

connect([PORT_NUM[,'HOST']]OBJ[,FUNC(TLSSOCKT)])#Like TCP.connect(), but for TLS (client connection). OBJ members are:
  ->TLSSOCKET                                   #  - host 'HOST', port PORT_NUM, path 'PATH'
                                                #  - socket TCPSOCKET|IOSTREAM: use an existing TCPSOCKET (host+port can be ommitted then)
                                                #  - pfx, key, passphrase, cert, ca, ciphers, rejectUnauthorized, NPNProtocols, ALPNProtocols, secureProtocol: 
                                                #     - like for createServer(), but for client.
                                                #     - also, rejectUnauthorized is true by def.
                                                #  - servername: for SNI, hostname to choose
                                                #  - checkServerIdentity('HOST', CERT_BUFFER): if throw error, refuse connection
                                                #  - secureContext, session: see constructor
                                                #  - minDHSize NUM (def: 1024)
                                                #FUNC is 'secureConnect' event handler
                                                #Returns a TLSSOCKET.

TLSSOCKET                                       #Child of TCPSOCKET, but for SSL.
                                                #Contains other end's authentication status and certificate, providing requestCert: true has been used.
new TLSSocket(TCPSOCKET, OBJ)                   #OBJ:
                                                #  - secureContext OBJ: returned by TLS.createSecureContext(OBJ) with OBJ: pfx, key, passphrase, cert, ca, crl, ciphers, honorCipherOrder
                                                #  - session BUFFER
                                                #  - requestOCSP BOOL (def: false): 
                                                #     - OCSP is alternative protocol to use CRL
                                                #        - ask to Certificate authority instead of using CRL list
                                                #     - TLSSERVER.on('OCSPRequest', FUNC(BUFFER, BUFFER2, FUNC(ERROR, BUFFER3))): 
                                                #        - BUFFER[2] are primary|issuer DER-encoded certificates
                                                #        - BUFFER3: see just below
                                                #     - TLSSOCKET.on('OCSPResponse', FUNC(BUFFER3))
                                                #  - isServer BOOL
                                                #  - server TCPSERVER
                                                #  - requestCert, rejectUnauthorized, NPNProtocols|ALPNProtocols, SNICallback
TLSSOCKET.on("secureConnect", FUNC())           #Like TCPSOCKET.on("connect"), but for SSL.
TLSSOCKET.getPeerCertificate([BOOL])->OBJ       #OBJ: subject, issuer, valid_to, fingerprint, etc.
                                                #If true, returns full chain, i.e. OBJ.issuer
TLSSOCKET.encrypted                             #Always true. To distinguish from TCPSOCKET.
TLSSOCKET.authorized                            #False if certificate was not signed by CA specified in ca: STR_ARR
                                                #If false, reason might be given in TLSSOCKET.authorizationError STR
TLSSOCKET.getCipher()->OBJ                      #Current SSL cipher used as { name STR, version STR }
TLSSOCKET.getProtocol()->STR                    #Among 'SSLv3|TLSv1[.1|2]|unknown'
TLSSOCKET.npnProtocol|alpnProtocol              #Protocol selected among NPNProtocols|ALPNProtocols (see above)
TLSSOCKET.servername                            #For SNI, chosen 'HOST'
TLSSOCKET.renegotiate(OBJ[, FUNC(ERROR)])       #OBJ: rejectUnauthorized, requestCert
                                                #Automatically done after session expires:
                                                #  - TLS.CLIENT_RENEG_LIMIT (def: 3) times every TLS.CLIENT_RENEG_WINDOW (def: 600, in sec), to avoid DDoS as it takes resources
TLSSOCKET.setMaxSendFragment(NUM)->BOOL         #Def|max: 16384. Min: 512. 
                                                #True on success.
                                                #Smaller: smaller latency but slower.
TLSSOCKET.getSession()->OBJ                     #OBJ: ASN.1 encoded
TLSSOCKET.getTLSTicket()->BUFFER                #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             HTTP              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


STATUS_CODES                                    #{ STATUS_NUM: 'STATUS_NAME', ... }
                                                #Misses 419
METHODS                                         #STR_ARR of HTTP methods, including common ones, WEBDEV and more obscure ones

HTTPSERVER                                      #Child of TCPSERVER
createServer([FUNC()])->HTTPSERVER              #FUNC is 'request' event handler
HTTPSERVER.on("request", FUNC(REQ, RES))        #Fired on client request
HTTPSERVER.on("checkContinue", FUNC(REQ, RES))  #Fired on client request with Expect: 100-continue [C]
                                                #If request is ok, should use RES.writeContinue() to sends a 100 status code to the client.
HTTPSERVER.on                                   #Fired on client request with CONNECT method
("connect", FUNC(REQ, TCPSOCKET, BUFFER))       #Client's body is in BUFFER.
HTTPSERVER.on                                   #Fired on client request with Upgrade [C]
("upgrade", FUNC(REQ, TCPSOCKET, BUFFER))       #Client's body is in BUFFER.
HTTPSERVER.on("clientError",FUNC(ERR,TCPSOCKET))#Fired on connection problem.
                                                #Def: TCPSOCKET.destroy()
HTTPSERVER.maxHeadersCount                      #Maximum number of headers incoming (def: 1000, 0 for unlim)
HTTPSERVER.setTimeout(UINT[, FUNC()])           #Do setTimeout(...) on all underlying TCPSOCKET
HTTPSERVER.timeout                              #Def: 120000 (2 mins)

REQ                                             #ISTREAM, reading the body
REQ.httpVersion[Major|Minor]                    #
REQ.method                                      #"GET|DELETE|..." (not for CLIENTREQUEST's REQ)
REQ.url                                         #STR (not for CLIENTREQUEST's REQ)
REQ.headers                                     #As { VAR: 'VAL'[_ARR] ... }. Normalized: 
                                                #  - 'VAR' lowercase 
                                                #  - duplicates:
                                                #     - common ones are merged as 'VAL'
                                                #     - Set-Cookie: 'VAL'_ARR
                                                #     - others are joined with ','
REQ.rawHeaders                                  #As [ 'VAR', 'VAL', ... ]. Not normalized
REQ.[raw]trailers                               #Same for trailer headers
REQ.statusCode|Message                          #Only for CLIENTREQUEST's REQ
REQ.socket                                      #TCPSOCKET
REQ.setTimeout(UINT[, FUNC()])                  #Calls TCPSOCKET.setTimeout()
REQ.flush()                                     #Send the headers right away, instead of trying to send in same TCP packet as body.
                                                #Useful if headers are given quickly but body retrieval takes time.
REQ.on('aborted', FUNC())                       #Aborted by client

RES                                             #OSTREAM, writing the body:
                                                #  - headers must be set first
                                                #  - write() sends to client
                                                #  - end() finishes
                                                #Automatically create following headers: 
                                                #  - Date [S] (if RES.sendDate true (def))
                                                #  - Connection: keep-alive [S]
                                                #  - Transfer-Encoding: chunked [S]
RES.on("close", FUNC())                         #Fired if closed before end() was called
RES.headersSent                                 #True if headers are sent
RES.finished                                    #True if all sent (i.e. after end())
RES.statusCode|Message                          #If statusMessage not set, use STATUS_CODES[statusCode]
RES.setHeader('VAR', 'VAL'[_ARR])               #'VAL'_ARR: same as doing setHeader() several times.
RES.getHeader('VAR')->'VAL'[_ARR]               #
RES.removeHeader('VAR')                         #
RES.writeHead(STATUS_NUM[, 'STATUS_NAME'][,OBJ])#Sets RES.statusCode|Message|headers (must be done only once)
RES.addTrailers(OBJ)                            #Add trailing header fields, i.e. between write() and end() of the body.
                                                #Do not forget Trailer [C] at beginning of response
RES.setTimeout(UINT[, FUNC()])                  #For the underlying TCPSOCKET.
RES.on("timeout", FUNC())                       #See setTimeout()

CLIENTREQUEST                                   #Outgoing HTTP request (as opposed to incoming)
                                                #OSTREAM (like RES)
                                                #Headers:
                                                #  - Content-length [C]: only compatible with utf8 encoding for write()
                                                #  - Expect: 100-continue [C]:
                                                #     - call end() right away
                                                #     - should set a timeout
                                                #     - and listen to 'continue' event
                                                #  - default:
                                                #     - all: 
                                                #         Host: HOST:PORT [C]
                                                #         Connection: keep-alive [C]
                                                #     - not GET|HEAD:
                                                #         Transfer-Encoding: chunked [C]
request(OBJ[, FUNC(REQ)])->CLIENTREQUEST        #Sends a HTTP request.
                                                #OBJ:
                                                #  - protocol STR (def: 'http:')
                                                #  - host[name] STR (def: "localhost")
                                                #     - prefer hostname
                                                #     - will fire exception if non existing
                                                #  - family 4|6 (def: both)
                                                #  - port PORT_NUM (def: 80)
                                                #  - socketPath STR: incompatible with host[name] and port
                                                #  - localAddress STR
                                                #  - method STR (def: "GET")
                                                #  - path STR (def: "/")
                                                #  - headers OBJ
                                                #  - auth STR: e.g. "auth:password"
                                                #  - agent AGENT|false (def: globalAgent)
																								#  - keepAlive[Msecs]: see AGENT
                                                #  - createConnection(...): see AGENT
                                                #FUNC is 'response' event handler.
get(OBJ[, FUNC(REQ)])                           #Same but use method "GET" and automatically calls OSTREAM.end()
CLIENTREQUEST.on("socket", FUNC(TCPSOCKET))     #Fired when socket is created to send the request.
CLIENTREQUEST.on("response", FUNC(REQ))         #Response of the server. 
                                                #REQ must be read, no matter what.
CLIENTREQUEST.on("continue", FUNC())            #Fired when server responds with Expect: 100-continue [S]
CLIENTREQST.on("checkExpectation",FUNC(REQ,RES))#Fired when server responds with Expect [S], except Expect: 100-continue [S]
CLIENTREQUEST.on
("connect", FUNC(REQ, TCPSOCKET, BUFFER))       #Fired when server responds to a CONNECT request
CLIENTREQUEST.on
("upgrade", FUNC(REQ, TCPSOCKET, BUFFER))       #Fired when server responds with Upgrade [S]
CLIENTREQUEST.abort()                           #
CLIENTREQUEST.on('abort', FUNC())               #Aborted by client, i.e. CLIENTREQUEST.abort()
CLIENTREQUEST.on('aborted', FUNC())             #Aborted by server
CLIENTREQUEST.setTimeout|NoDelay|
SocketKeepAlive(...)                            #Do it on underlying TCPSOCKET.
CLIENTREQUEST.flushHeaders()										#Like REQ.flush()

AGENT                                           #Socket pools manager for CLIENTREQUEST (not REQ|RES)
new AGENT(OBJ)                                  #OBJ is:
                                                #  - maxSockets NUM (def: Infinity): 
                                                #     - max busy + free sockets per host.
                                                #     - increasing just affect pooling, i.e. more memory used but faster 
                                                #     - but does not affect max. number of sockets per host (unlim.)
                                                #  - maxFreeSockets NUM (def: 256): 
                                                #     - max free sockets. 
                                                #     - only relevant if keepAlive true
                                                #  - keepAlive BOOL (def: true): keep free sockets opened for use
                                                #  - keepAliveMsecs NUM (def: 1000)
AGENT.max[Free]Sockets                          #
AGENT.[free]sockets                             #Current TCPSOCKET_ARR
AGENT.requests                                  #Current REQ_ARR, not assigned to sockets yet.
AGENT.destroy()                                 #To do to destroy free sockets if keepAliveMsecs high, to avoid hanging.
AGENT.getName(OBJ)                              #Returns OBJ (host, port, localAddress) as unique ID STR
AGENT.createConnection(...)->TCPSOCKET          #Same as TCP createConnection(), but can be customized


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             HTTPS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


HTTPS ==>                                       #Has exactly same members as HTTP except:
                                                #  - createServer(OBJ[, FUNC]): OBJ is same as TLS.createServer()
                                                #  - all members:
                                                #      - inherit from HTTP, e.g. HTTPSSERVER inherits HTTPSERVER
                                                #      - use TLS* objects instead of TCP*, e.g. TLSSERVER <- TCPSERVER, TLSSOCKET <- TCPSOCKET, etc.
                                                #      - as such, can be used as HTTP server too
                                                #  - to provide TLS OBJ members (same as tls.connect(OBJ), e.g. key, cert, etc.) to connect(...):
                                                #     - use a custom AGENT, and provide AGENT.options


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              URL              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


URL_OBJ                                         #OBJ:
                                                #  - protocol STR|null
                                                #  - slashes BOOL: if AUTHORITY starts with //
                                                #  - auth STR|null
                                                #  - host STR|null
                                                #  - port STR|null
                                                #  - hostname STR|null
                                                #  - pathname 'PATH'|null
                                                #  - path 'PATH?QUERY'|null
                                                #  - search '?QUERY'|QUERY_OBJ|null
                                                #  - query 'QUERY'|null
                                                #  - hash '#HASH'|null
                                                #  - href 'URI'
parse('URI'[, BOOL[, BOOL2]])->URL_OBJ          #BOOL: if true (def: false), URL_OBJ.search is QUERY_OBJ
                                                #BOOL2: if true (def: false), protocol can be ommitted
format(URL_OBJ)->'URI'                          #Trailing/leading characters are unnecessary for:
                                                #  - protocol: :
                                                #  - pathname: /
                                                #  - search: ?
                                                #  - hash: #

resolve('BASE_URI', 'RELATIVE_URI')->'URI'      #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          QUERYSTRING          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


stringify(QUERY_OBJ[, STR[, STR2[, OPTS]]])     #'QUERY' is escaped
  ->'QUERY'                                     #STR is separator (def: '&'), STR2 delimiter (def: '=')
                                                #ARR is serialized as several VARs
                                                #OPTS:
                                                #  - encodeURIComponent(...) (def: escape(...)): customize escaping
parse('QUERY'[, STR[, STR2]][, OPTS])->QUERY_OBJ#Inverse. 
                                                #OPTS:
                                                #  - maxKeys NUM (def: 1000, 0 for unlim)
                                                #  - decodeURIComponent(...) (def: unescape(...)): 
                                                #     - customize escaping
                                                #     - transforms + to spaces (instead of escaping)
                                                #Note: QUERY_OBJ does not inherit from OBJ
[un]escape(STR)                                 #Same as en|decodeURIComponent(), but can be overriden to change stringify|parse() behavior

QS ==>                                         ##See QS module for more features


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              DNS              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


DIFFERENCE ==>                                  #DNS.resolve*|reverse() and DNS.lookup*() are similar but:
																								#  - resolve*|reverse(): use C-Ares, a fast library for DNS resolution, which does DNS query directly.
                                                #  - lookup*(): 
                                                #     - uses getaddrinfo(), which is slower. 
                                                #     - it uses underlying OS, i.e. how DNS resolution would behave on that system (e.g. /etc/hosts)
																								#     - it is used by http.*, tcp.* and udp.* modules.
																								#Resolving manually the host can give better performance.
lookup('HOST'[, OBJ], FUNC(ERROR, 'HOST', STR)) #DNS forward lookup.
                                                #STR4 is family: 4 (IPv4), 6 (IPv6) or null (both).
																								#OBJ:
																								#  - family 4|6|null
																								#  - hints NUM: or'd flags among:
																								#     - DNS.ADDRCONFIG
																								#     - DNS.V4MAPPED: if look for IPv6 but none found, return IPv4 mapped as IPv6
                                                #  - all BOOL: if true (def: false), return all address as STR4_ARR, not only first one
                                                #The ERROR.name can correspond to several DNS.*, like DNS.NOTFOUND, DNS.NODATA, DNS.NOMEM, etc. (see online doc)
lookupService
(IP, PORT, FUNC(ERROR, 'HOST', 'SCHEME'))	      #

resolve('HOST'[, STR2], FUNC(ERROR, VAL_ARR))   #Same but STR2 can any PTR record type: "A" (def), "AAAA", "MX", "TXT", "SRV", "PTR", "NS", "CNAME", "SOA", "NAPTR"
resolveSTR2('HOST', FUNC(ERROR, VAL_ARR))       #Same. STR2 is camelcase.
reverse('IP', FUNC(ERROR, 'HOST'_ARR))          #DNS reverse lookup.

setServers('IP'_ARR)                            #Sets list of servers IP to use for DNS resolution
getServers()->'IP'_ARR                          #List of servers


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           PUNYCODE            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


[ucs2.]de|encode(STR)                           #For a DNS label
toUnicode|ASCII(STR)                            #For a full domain name
version                                         #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              OS               :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


tmpdir()->STR                                   #e.g. "/tmp"
homedir()->STR                                  #e.g. "/home/user"
endianness()->STR                               #"BE" or "LE"
hostname()->STR                                 #e.g. "ether-laptop"
type()->STR                                     #e.g. "Linux"
platform()->STR                                 #e.g. "linux"
release()->STR                                  #e.g. "3.11.0-14-generic"
arch()->STR                                     #e.g. "x64"
uptime()->DOUBLE                                #In seconds
loadavg()->DOUBLE_ARR                           #For last 1, 5 and 15 minutes. Not for Windows.
total|freemem()->NUM                            #RAM
cpus()->OBJ_ARR                                 #OBJ:
                                                #  - model STR
                                                #  - speed UINT (MHz)
                                                #  - times OBJ, ms spent by CPU on each member since uptime: user, sys, idle, nice, irq
networkInterfaces()->OBJ_ARR                    #OBJ:
                                                #  - key is interface name ("lo", "wlan0", etc.)
                                                #  - value is OBJ2_ARR, with OBJ2: 
                                                #     - address STR
                                                #     - netmask STR
                                                #     - family "IPv4|6" 
                                                #     - mac STR
                                                #     - internal BOOL (true if boucle local)
                                                #     - scopeid NUM
userInfo([OBJ])->OBJ2                           #OBJ2:
                                                #  - uid|gid NUM (-1 on Windows)
                                                #  - username 'USER'
                                                #  - homedir 'PATH'
                                                #  - shell 'PATH' (null on Windows)
                                                #OBJ: encoding 'utf8' (def) or 'buffer'
EOL                                             #"\n" or "\r\n"
constants                                       #OBJ: errno.ERROR NUM, signals: SIGNAME NUM


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             PATH              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


PATH ==>                                        #All these functions look at PATH without caring if file exists.
normalize('PATH')->'PATH'                       #Normalize ".", ".." and extra "/"
join('PATH',...)->'PATH2'                       #Concat paths, by adding|removing "/" in-between, and normalize()
resolve('PATH',...)->'PATH2'                    #Like doing several cd 'PATH' from current directory:
                                                #  - can be fictional DIR
                                                #  - 'PATH' can be relative or absolute
                                                #  - 'PATH2' is final DIR, normalized()
relative('PATH', 'PATH2')->'PATH3'              #Show path to go from absolute PATH to absolute PATH2.
isAbsolute('PATH')->BOOL                        #
dirname('PATH')->'DIR'                          #
basename('PATH'[, 'EXT'])->'FILE'               #
extname('PATH')->'EXT'                          #Including '.'

parse('PATH')->PATH_OBJ                         #PATH_OBJ: root STR, dir STR, base STR, ext STR, name STR 
format(PATH_OBJ)->'PATH'                        #Inverse

sep                                             #"/" or "\\"
delimiter                                       #":" or ";"
posix|win32.*                                   #Like PATH, but always behave like if on those platforms


																						 /=+===============================+=\
																						/  :                               :  \
							 														  )==:              FS               :==(
																						\  :_______________________________:  /
																						 \=+===============================+=/


FS-EXTRA                                       ##Replacement for FS, with extra methods.
                                               ##Version 0.16.3
                                               ##Works well with BLUEBIRD.promisifyAll(FS-EXTRA)
WRENCH                                         ##Other filesystem module, but not drop-in replacement of FS.
                                               ##Version 1.5.8 

PATH|FILENAME|DIR                               #STR (to prefer) or BUFFER (less interoperable)
f*                                              #Variant using file descriptior FD_INT
l*                                              #Doesn't deference symlinks

PWD ==>                                         #All relative to process.cwd()
...Sync(...)                                    #All functions have a synchronous variant, without FUNC, except
                                                #[un]watch[File]() and createRead|WriteStream()
                                                #Will throw exceptions instead of using ERROR.

FS-EXTRA.copy(FILE|DIR, FILE|DIR2, FUNC(ERROR))##
WRENCH.copyDirSync[Recursive]                  ##OBJ:
(FILE|DIR, FILE|DIR2[, OBJ][,FUNC(ERROR)])     ##  - forceDelete BOOL: overwrite destination
                                               ##  - excludeHiddenUnix BOOL: copy dotfiles
                                               ##  - preserveFiles BOOL: keep copy when overwriting
                                               ##  - preserveTimestamps BOOL
                                               ##  - inflateSymlinks BOOL: follow symlinks
                                               ##  - filter REGEXP|FUNC(STR)->BOOL: exclude files to copy
                                               ##  - whitelist BOOL: if true, filter works
                                               ##  - include|exclude REGEXP|FUNC(STR)->BOOL
rename(PATH, PATH2, FUNC(ERROR))      			    #
FS-EXTRA.move(FILE|DIR, FILE|DIR2[, OBJ], 
FUNC(ERROR))                                   ##Can use OBJ.clobber true to overwrite.
GULP-RENAME(VAL)                               ##Rename filenames. VAL can be:
                                               ##  - FILENAME_STR (single file)
                                               ##  - OBJ: dirname STR, basename STR, prefix STR, suffix STR, extname STR 
                                               ##    (e.g. ".js")
                                               ##  - FUNC(OBJ)->OBJ, with same OBJ as above
                                               ##Version 1.2.0

[f]truncate(PATH|FD_INT, UINT, FUNC(ERROR))     #

[f|l]chown(PATH|FD_INT, UID, GID, FUNC(ERROR))  #
WRENCH.chownSyncRecursive(DIR, UID, GID)       ##
[f|l]chmod(PATH|FD_INT, UINT, FUNC(ERROR))      #
WRENCH.chmodSyncRecursive(DIR, UINT)           ##

[f]utimes(PATH|FD_INT, ATIME, MTIME, FUNC(ERR)) #Change atime|mtime
access(PATH[, NUM], FUNC(ERROR))							  #Checks if has permission, according to NUM or'd flags:
																								#  - FS.F_OK (def): files exists and its directory list it
																								#  - FS.R|W|X_OK: can be read|written|executed
[f|l]stat(PATH|FD_INT, FUNC(ERROR, FSSTAT))     #FSTAT:
                                                #  - isFile|Directory|Block|CharacterDevice|FIFO|Socket(), (only with lstat()) isSymbolicLink()
                                                #  - dev UINT
                                                #  - ino UINT
                                                #  - mode UINT
                                                #  - nlink UINT
                                                #  - uid|gid UINT
                                                #  - rdev UINT
                                                #  - [blk]size UINT
                                                #  - blocks UINT
                                                #  - a|m|ctime DATE
                                                #  - birthtime DATE: creation time (Windows only)

[sym]link(PATH, PATH2[, STR], FUNC(ERROR))      #STR is 'dir', 'file' (def) or 'junction' (only Windows)
GULP-SYMLINK.relative|absolute                 ##Creates a symlink in DIR (creates it if not existing, overwrite if OBJ.force
(DIR_ARR|FUNC(VINYLOBJ)->VINYLOBJ2[,OBJ])      ##true) with same filename as current file, poiting to that file (with a 
                                               ##relative|absolute path). Version 2.0.1
readlink(PATH[, OBJ], FUNC(ERROR, PATH2))       #PATH must be a symlink
                                                #OBJ: encoding 'ENCODING'
realpath(PATH[, OBJ], FUNC(ERROR, PATH2))       #Like normalize(), but also resolve symlinks, and PATH must exist.
                                                #OBJ: encoding 'ENCODING'

unlink(PATH, FUNC(ERROR))                       #
rmdir(PATH, FUNC(ERROR))                        #
FS-EXTRA.remove(FILE|DIR, FUNC(ERROR))         ##Like rm -rf
WRENCH.rmdirSyncRecursive(FILE|DIR[, BOOL])    ##Same. If true, fails silently.
RIMRAF(DIR|FILE[, FUNC()])		                 ##Same
                                               ##Version 2.2.8
                                               ##Also GULP-RIMRAF([OBJ]):
                                               ##  - Only makes sense after GULP-IGNORE() in the middle of the pipeline 
                                               ##    (otherwise use RIMRAF() directly).
															                 ##  - gulp.src() should use { read: false } if only GULP-IGNORE() then 
                                               ##    GULP-RIMRAF() are used, so it is faster.
															                 ##  - Must use OBJ.force true if not in $PWD
                                               ##  - Version 0.1.0

mkdir(PATH[, MODE_INT], FUNC(ERROR))            #MODE_INT is 0777 by def
FS-EXTRA.ensureFile|Dir(FILE|DIR,FUNC(ERROR))  ##Create file|dir, including parent dirs, if not existing.
FS-EXTRA.mkdirs(DIR, FUNC(ERROR))              ##Like ensureDir()
WRENCH.mkdirSyncRecursive(DIR[, MODE_INT])

readdir(DIR, FUNC(ERROR, 'FILE'_ARR))           #ls: 'FILE' excludes . and ..
WRENCH.readdirSync[Recursive]
(DIR[,FUNC(ERROR, STR2_ARR)])                  ##Same but recursive

open(PATH, STR|NUM[, MODE], FUNC(ERROR, FD_INT))#Open a file and return a file descriptor.
                                                #STR|NUM are flags: "r|w|a[s|x][+]":
                                                #  - r|w|a: read, write (create if not exist, or truncate), 
                                                #    append (create if not exist)
                                                #  - s: for read only. Bypass cache (synchronous mode): has bad performance
                                                #    impact.
                                                #  - x: for write|append only. Don't overwrite file. 
                                                #  - +: Open for read and writing.
                                                #MODE INT is 0666 by def.
close(FD_INT, FUNC(ERROR))                      #
write(FD_INT, BUFFER, INT, INT2, [ INT3,]				#Write INT2 bytes from BUFFER at its position INT to file FD_INT at its position INT3 (def: current). 
FUNC(ERROR, INT4, BUFFER))              		    #INT4 is the number of bytes written.
write(FD_INT, BUFFER|STR[, INT3, ['ENCODING', ]]#
FUNC(ERROR, INT4, BUFFER))              		    #Similar.
read(FD_INT, STR|BUFFER, INT, INT2, INT3, 
FUNC(ERROR, INT4, BUFFER))                      #
f[data]sync(FD_INT, FUNC(ERROR))                #Flushes to disk
                                                #If 'data', does not flush metadata (e.g. mtime)

readFile                                        #Easier way than using open() and read()
(PATH|FD_INT, [OBJ, ]FUNC(ERROR, BUFFER|STR))   #OBJ:
                                                #  - encoding 'ENCODING' (def: null, i.e. returns BUFFER, otherwise returns STR)
                                                #  - flag STR (def: "r")
                                                #Prefer createReadStream(...).pipe(OSTREAM)
FS-EXTRA.readJson(...)                         ##Same as readFile(), but return as OBJ
write|appendFile                                #OBJ has same members but also mode MODE_INT (def: 0666)
(FILENAME|UINT, [STR|BUFFER,] [OBJ,]FUNC(ERROR))#Def flag is "w|a"
FS-EXTRA.outputFile(...)                       ##Same as writeFile(), but calls ensureFile() first
FS-EXTRA.writeJson|outputJson(...)             ##Same as writeFile|outputFile(), but with an OBJ (JSON.stringify'd).
createReadStream(PATH[, OBJ])->ISTREAM          #Preferred over readFile(). 
                                                #Useful with ISTREAM.[.pipe(IOSTREAM)...]pipe(OSTREAM):
                                                #  - transmits to OSTREAM by chunks ("data" events) instead of at once 
                                                #    (readFile())
                                                #  - can use IOSTREAM as modular transforms functions (like Unix commands)
                                                #OBJ has members:
                                                #  - flags STR (def: "r")
                                                #  - encoding 'ENCODING' (def: null)
                                                #  - fd FD_INT (def: null)
                                                #  - mode NUM (def: 0666)
                                                #  - autoClose BOOL (def: true): close the file descriptor on error|end event
                                                #  - start|end UINT: only use from bytes UINT to UINT2
                                                #ISTREAM has extra:
                                                #  - same members as OBJ 
                                                #  - on('open', FUNC(FD_INT))
                                                #  - path PATH
                                                #  - pos UINT
createWriteStream(PATH[, OBJ])->OSTREAM         #OBJ has members flags, defaultEncoding, fd, mode, autoClose, start
                                                #OSTREAM has extra:
                                                #  - same members as OBJ
                                                #  - on('open', FUNC(FD_INT))
                                                #  - path PATH
                                                #  - pos UINT
                                                #  - bytesWritten UINT
new WRENCH.LineReader(FILE)                    ##Returns LINEREADER
LINEREADER.hasNextLine()                       ##
LINEREADER.getNextLine()                       ##Returns FILE line by line
LINEREADER.close()                             ##

mkdtemp('PATH', FUNC(ERROR, 'PATH2'))           #Create temp file at 'PATHrandom', with random:
                                                #  - 6 chars [:alnum:] (36 bits of entropy)
                                                #  - can end with '/'
TEMP.open(PREFIX, FUNC(ERROR, OBJ))            ##Creates temp file with permission 0600 under temp directory.
                                               ##OBJ:
                                               ##  - path STR
                                               ##  - fd NUM
                                               ##PREFIX: 
                                               ##  - OBJ: prefix STR, suffix STR, dir DIR (def: "", "", OS temp dir)
                                               ##  - STR: only PREFIX_STR
                                               ##  - Path will be TMP_DIR/PREFIX-UUID-AFFIX
                                               ##If TEMP.track() called before, it will erase file on process exit.
                                               ##Version 0.8.1
TEMP.mkdir(PREFIX,FUNC(ERROR,PATH))            ##Same with directory
TEMP.createWriteStream()                       ##Same for file as OSTREAM
TEMP.path(PREFIX)                              ##Same for only the path
TEMP.cleanup(FUNC(ERROR,OBJ))                  ##Remove temp files. TEMP.track() must have been called before.
                                               ##OBJ: files|dirs NUM


watch(DIR[, OBJ][, FUNC])->FSWATCHER            #FSWATCHER fires events when file STR changes name or content.
                                                #OBJ:
                                                #  - persistent BOOL: if true (def), calls ref() (meaning program doesn't close until unwatch())
                                                #  - recursive BOOL (def: false)
                                                #  - encoding 'ENCODING' (def: 'utf8')
                                                #FUNC is the FSWATCHER change event handler.
                                                #Unstable. Prefer Chokidar.
FSWATCHER.on
("change", FUNC("change|rename", FILENAME))     #FILENAME is not always provided (e.g. never on MacOSX, and not always on other OS)
FSWATCHER.close()                               #
FSWATCHER.on("error", FUNC(ERROR))              #

[un]watchFile                                   #Uses polling
(FILE[, OBJ], FUNC(PREV_STAT, NEW_STAT))        #OBJ:
                                                #  - persistent BOOL
                                                #  - interval (def: 5000)

CHOKIDAR.watch('FILE|DIR'[, OBJ])              ##Returns WATCHER
                                               ##OBJ:
                                               ##  - persistent BOOL (def: true): like watch()
                                               ##  - ignore REGEXP or FILE|DIR_STR with globbing or FUNC(STR)->BOOL
                                               ##  - ignoreInitial (def: false): ignore initial add event
                                               ##  - followSymlinks (def: true)
                                               ##  - cwd (def: null)
                                               ##  - usePolling BOOL (def: false): if true, slower, but works over networks.
                                               ##    Also use interval NUM (def: 100) and binaryInterval (def: 300) 
                                               ##    (for binary files only)
                                               ##  - depth NUM (def: null): recursion level
                                               ##  - ignorePermissionErrors BOOL (def: false)
                                               ##  - atomic BOOL: fixes problems with editors that rewrites several times
                                               ##FILE|DIR can include blog (uses Minimatch) or be a REGEXP
                                               ##Version 1.0.0-rc3
WATCHER.on("add[Dir]|change|unlink[Dir]",      ##OBJ is FS.stat() object, and might be absent sometimes unless CHOKIDAR.watch()
FUNC(PATH, OBJ))                               ##OBJ.alwaysStat true (def: false)
WATCHER.on("all",FUNC(PATH, OBJ))              ##Check "add[Dir]|change|unlink[Dir]" events.
WATCHER.on("error",FUNC(ERROR))
WATCHER.on("ready",FUNC())
WATCHER.add|unwatch(FILE|DIR[_ARR])
WATCHER.close()                                ##Only if persistent true

constants                                       #Low-level file-system constants, for the current OS


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             ZLIB              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


createGzip|Deflate[Raw]([OBJ])->COMPRESS        #COMPRESS is a IOSTREAM, so should do:
                                                #  ISTREAM.pipe(IOSTREAM).pipe(OSTREAM)
                                                #See HTTP for different formats.
                                                #Raw: same but does not append a zlib header.
                                                #OBJ can be:
                                                #  - [finish]flush, among:
                                                #     - Z_NO_FLUSH (def)
                                                #     - Z_PARTIAL_FLUSH
                                                #     - Z_SYNC_FLUSH
                                                #     - Z_FULL_FLUSH
                                                #     - Z_FINISH
                                                #     - Z_BLOCK
                                                #     - Z_TREES
                                                #  - chunkSize (def: 16*1024)
                                                #  - windowBits (def: 15): from 8 to 15, higher means better compression but 
                                                #    more memory.
                                                #  - dictionary (deflate|inflate only) (def: "")
                                                #OBJ (compression only):
                                                #  - level: higher means better compression but slower, among:
                                                #     - Z_DEFAULT_COMPRESSION (def)
                                                #     - Z_BEST_SPEED
                                                #     - Z_BEST_COMPRESSION
                                                #     - Z_NO_COMPRESSION
                                                #  - memLevel (def: 8): from 1 to 9, higher means better compression but more 
                                                #    memory.
                                                #  - strategy, make compression better, according to type of data, among:
                                                #     - Z_DEFAULT_STRATEGY: almost random data, and small values
                                                #     - Z_FILTERED: in-between 
                                                #     - Z_HUFFMAN_ONLY: less random, and large repeating chunk
                                                #     - Z_RLE: same, but specially for PNG data
                                                #     - Z_FIXED
                                                #Memory required (in bytes) is:
                                                #  - for compression:
                                                #     - 2^windowBits * 4 + 2^memLevel * 512 + chunkSize, i.e. 272K by def
                                                #  - for decompression:
                                                #     - 2^windowBits + chunkSize, i.e. 48K by def
createGunzip|Inflate[Raw]|Unzip([OBJ])->UNCOMPRS#UNCOMPRESS is a IOSTREAM.
                                                #Unzip: autodetect whether Gunzip or Deflate (but not DeflateRaw).
[UN]COMPRESS.flush([NUM, ]FUNC(ERROR))          #Compression uses an internal cache. Flush it.
                                                #Don't call unless necessary, because it impacts performance.
                                                #NUM def is ZLIB.Z_FULL_FLUSH. See above for other values.
[UN]COMPRESS.reset()                            #Stop compressing any data going through.
                                                #Only for Deflate|Inflate
[UN]COMPRESS.params(LEVEL, STRATEGY,FUNC(ERROR))#

gzip|deflate[Raw]
(BUFFER|STR[, OBJ], FUNC(ERROR, BUFFER))        #
gunzip|inflate[Raw]|unzip
(BUFFER[, OBJ], FUNC(ERROR, BUFFER2))           #Convenience methods
*Sync(...)                                      #Same without callback


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              TTY              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


READSTREAM                                      #Child of TCPSOCKET, but without destroy(), connect event nor *address*
                                                #Usually only instantiated by process.stdin
READSTREAM.isRaw                                #BOOL: raw or character device.
READSTREAM.setRawMode(BOOL)                     #

WRITESTREAM                                     #Same but for process.stdout|err for example.
WRITESTREAM.columns|rows                        #UINT
WRITESTREAM.on("resize", FUNC())                #

isatty(FD_INT)                                  #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            PROCESS            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


process                                         #Don't need to use require("process")

on("exit", FUNC(INT))                           #INT is the exit code. process.exitCode is same, except undefined if process.exit() not called explicitely.
                                                #FUNC should only use synchronous functions.
on("beforeExit", FUNC(INT))                     #Fired when programs finishes because no more code, not because explicit return/exception/process.exit()
on("uncaughtException", FUNC(ERROR))						#
on('rejectionHandled, FUNC(PROMISE))            #On PROMISE rejected but handled.
on('unhandledRejection, FUNC(VAL, PROMISE))     #On PROMISE rejected and not handled.
on('warning', FUNC(OBJ))                        #On console.warn(). OBJ: name STR, message STR2, stack STR
                                                #Can also use PROCESS.emitWarning(STR, STR2[, FUNC(ERROR)->ERROR]) or PROCESS.emitWarning(ERROR) to avoid printing on console
exit([UINT])                                    #Exit with exit code UINT (def: 0)
abort()                                         #Aborts: exits + produce a core file.

pid                                             #
kill(PID_INT[, 'SIGNAL'])                       #Sends a signal (def: "SIGTERM").
                                                #If PID_INT, doesn't exit, throw exception (can use SIGNAL_STR 0 to just test process existence).
on('SIGNAL', FUNC())                            #Fires when signal emitted on current process. Special cases:
                                                #  - "SIGUSR1" will start debugger
                                                #  - handling SIGINT or SIGTERM will remove default handler.
                                                #  - cannot handle SIGKILL or SIGSTOP
																								#  - SIGWINCH: when window resized

stdout|err|in                                   #OSTREAM|ISTREAM with extra member:
                                                #  - isTTY BOOL: if true, will be a READ|WRITESTREAM
                                                #And those members for ISTREAM :
                                                #Unless used as a pipe, are blocking (unless other STREAM which are async by
                                                #def).
argv                                            #Command line args as STR_ARR. Doesn't include node options.
                                                #First is "node", second the absolute path of FILE, then the other arguments.
execArgv                                        #Same but only for node options (exclude all STR of argv)
execPath                                        #Absolute path of node executable used.
env                                             #Environment variables, as OBJ
title                                           #Process title displayed in ps. Read/write. Usually short max length.

cwd()->'DIR'                                    #Current directory
chdir('DIR')                                    #

get[e]gid|[e]uid()                              #
set[e]gid|[e]uid(UINT|STR)                      #
getgroups()
setgroups(STR_ARR)                              #Supplementary GIDs.
initgroups(STR, STR2[_ARR])                     #
umask([UINT])                                   #

release.name                                    #'node|io.js'
release.sourceUrl|headersUrl                    #'URL'
release.lts                                     #When LTS
version                                         #
versions                                        #OBJ with members http_parser, node, icu, v8, ares, uv, zlib, modules, openssl
config                                          #Config flags and variables used during compilation, as OBJ
arch                                            #"arm", "ia32" or "x64"
platform                                        #"darwin", "freebsd", "linux", "sunos" or "win32"

memoryUsage()->OBJ                              #OBJ: rss, heapTotal and heapUsed
cpuUsage([OBJ])->OBJ                            #OBJ: user|system NUM (time usage, in microseconds)
                                                #If OBJ passed, is difference.
uptime()                                        #
hrtime([VAL])->VAL                              #Current time as [UINT, UINT2], where UINT is seconds and UINT2 nanoseconds.
                                                #Not real time, but arbitrary one just to compare with another time check.
                                                #If VAL passed, is difference.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:        CHILD_PROCESS          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


spawn(STR[, STR2_ARR], OBJ)                     #Creates, runs and return a CHILDPROCESS, from command line STR, with 
                                                #args STR2_ARR.
                                                #OBJ (should be at least {}) are options among:
                                                #  - cwd STR
                                                #  - env OBJ (def: process.env)
                                                #  - uid|gid UINT
                                                #  - detached BOOL: if true, becomes leader a new process group, i.e. will
                                                #    not exit when parent does. Must not inherit any file descriptor from 
                                                #    parent.
                                                #  - stdio STR_ARR, how parent can access child's file descriptors 
                                                #    (at least first three ones, stdin|out|err, but can continue with
                                                #    fd 3, etc.) among:
                                                #      - "pipe": enable CHILDPROCESS.stdio[FD_INT]|stdin|out|err
                                                #      - "ipc": enable CHILDPROCESS.send()
                                                #        Can only do it for one file descriptor.
                                                #      - "ignore": with nothing
                                                #      - STREAM: use the underlying file descriptor (like doing NUM> FILE)
                                                #      - FD_INT: use parent file descriptor FD_INT (like doing NUM&>FD_INT)
                                                #      - null: "pipe" for stdin|out|err, "ignore" for others.
                                                #    Can use the following shortcuts STR instead:
                                                #      - "ignore": [ "ignore", "ignore", "ignore" ]
                                                #      - "pipe": [ "pipe", "pipe", "pipe" ]
                                                #      - "inherit": [ 0, 1, 2 ]
                                                #  - shell STR|BOOL (def: false)
                                                #Use CHILDPROCESS.ref(), so needs to use unref() if program can exit while
                                                #CHILDPROCESS is running.
spawnSync(...)                                  #Same except:
                                                #  - extra arguments:
                                                #     - input STR: overrides stdio[0]
                                                #     - timeout, killSignal, maxBuffer, encoding: see exec()
                                                #  - waits for completion and returns:
                                                #     - pid UINT
                                                #     - output STR_ARR
                                                #     - stdout|err BUFFER|STR: same as output[1|2]
                                                #     - status NUM
                                                #     - signal STR
                                                #     - error ERROR
fork(STR[, STR2_ARR], OBJ)                      #Same as spawn(), but:
                                                #  - for a file STR. Use: 
                                                #     - execPath STR: def is "node", so STR is a JavaScript node.js file,
                                                #       but could use Bash, Python, etc.
                                                #     - execArgv STR_ARR to pass arguments.
                                                #  - OBJ options are cwd, env, encoding, execPath, execArgv, uid|gid and:
                                                #     - silent BOOL: if true use "pipe" stdio, otherwise "inherit" (def)
                                                #       In all cases, send() is available.
                                                #Sets ENVVAR NODE_CHANNEL_FD, which is a file descriptor that I don't 
                                                #understand how to use.
                                                #Can consume quite a lot of resources.
exec(STR, OBJ, FUNC(ERROR,BUFFER,BUFFER2))      #Same as spawn() but current process becomes CHILDPROCESS (which is returned) and:
                                                #  - STR is command line, including arguments
                                                #  - when terminated, fires FUNC where BUFFER[2] is stdout|err
                                                #  - OBJ have members:
                                                #     - cwd STR
                                                #     - env OBJ
                                                #     - uid|gid UINT
                                                #     - encoding 'ENCODING' (def: "utf8")
                                                #     - timeout UINT (def: 0): if > 0, will send killSignal after UINT ms
                                                #     - killSignal STR (def: "SIGTERM")
                                                #     - maxBuffer UINT (def: 200KB): killSignal if more is used
                                                #     - shell STR (def: "/bin/sh")
execSync(STR[, OBJ])                            #Same but:
                                                #  - extra argument: input STR|BUFFER (overrides stdio[0])
                                                #  - returns BUFFER|STR (result stdout)
execFile('FILE'[, STR2_ARR], OBJ, FUNC(...))    #Same but specifies a 'FILE', and arguments STR2_ARR.
execFileSync(STR[, STR2_ARR][, OBJ])            #
execSync(STR[, OBJ])                           ##Same as native execSync() (module sync-exec 0.5.0) but:
                                               ##  - works on Node 0.10
                                               ##  - returns OBJ2.stdout|stderr|status
execSync.exec|run(STR)                         ##Same as native execSync() (module execSync, 1.0.4) but:
                                               ##  - not maintained, does not work on Node 0.12
                                               ##  - exec()->EXIT_NUM, run()->OBJ.code|stdout

CHILDPROCESS.stdio[FD_INT]                      #I|OSTREAM for file descriptor FD_INT
CHILDPROCESS.stdin|out|err                      #Same for 0|1|2
CHILDPROCESS.pid                                #

PROCESS|CHILDPROCESS.send                       #Communication:
(VAL[, TCPSOCKET|TCPSERVER][, OPTS]             #  - parent use CHILDPROCESS.on("message") and CHILDPROCESS.send(...)
[, FUNC([ERROR])])                              #  - child use PROCESS.on("message") and PROCESS.send(...)
                                                #When sending a TCPSOCKET|TCPSERVER, it will be shared between parent and child:
                                                #  - packets will arrive randomly at both
                                                #  - only one needs to listen
                                                #  - for TCPSERVER, both can listen to 'connection' event
                                                #FUNC is fired after sending, before target received.
                                                #If FUNC specified, no 'error' event emitted.
                                                #OPTS:
                                                #  - keepOpen BOOL (def: false): see TCPSOCKET
CHILDPROCESS.on("message",
FUNC(OBJ[, TCPSOCKET|TCPSERVER]))               #CHILDPROCESS will not exit until disconnect() is called or parent exits.
CHILDPROCESS.disconnect()                       #Flush all communication, then becomes impossible to do send()
                                                #Do it before exiting.
CHILDPROCESS.connected                          #
CHILDPROCESS.on("disconnect", FUNC())           #
CHILDPROCESS.on("error", FUNC(ERROR))           #When CHILDPROCESS could not send(), be kill() or be spawn()
                                                #The exit event might be fired or not after error event.
CHILDPROCESS.on("exit|close", FUNC(UINT,STR))   #UINT is the exit code, STR the terminating signal (or null).
                                                #exit is when process exits, close is when its file descriptors are closed.
                                                #file descriptors don't close if shared by other processes.
CHILDPROCESS.kill([STR])                        #Def: "SIGTERM"


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            CLUSTER            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


GOAL ==>                                        #A single process will only use only one CPU core.
                                                #Using CHILDPROCESS.fork() on the same code to create one child for each CPU
                                                #core.
                                                #Can manage the workers: kill some, manage a pool, etc.
                                                #Work should be done by child processes, master should only manage them.
                                                #Child processes cannot fork() to grandchild processes.
                                                #One common task is to make CHILDPROCESS TCPSERVER.listen(), in which case:
                                                #  - connections will arrive randomly at the child processes listening to
                                                #    the same port.
                                                #    The randomness uses CLUSTER.schedulingPolicy:
                                                #      - CLUSTER.SCHED_RR (def): improved round-robin
                                                #      - CLUSTER.SCHED_NONE: previous version
                                                #    or use ENVVAR NODE_CLUSTER_SCHED_POLICY "rr|none"
                                                #  - be careful:
                                                #     - listen(TCPSERVER|TCPSOCKET): TCPSERVER|TCPSOCKET must have been sent by master
                                                #       to child, or will create problems
                                                #     - listen({ fd: INT }): looks at parent file descriptor
                                                #  - if UDPSOCKET.bind() or TCPSERVER.listen() OBJ.exclusive true (def: false), socket is not shared
fork([OBJ])                                     #Like CHILD_PROCESS.fork(), but returns a WORKER, which gives extra functions.
                                                #Can fork a separate file for children, but if forking the same file, should
                                                #use if ( CLUSTER.isMaster|Worker ) in beginning of code.
                                                #OBJ is env (def: process.env).
                                                #Options are controlled by CLUSTER.settings, that is available for read once
                                                #CLUSTER.setupMaster(OBJ) has been called to change it (only once):
                                                #  - exec STR: the file the child is forked with (def: process.argv[1])
                                                #  - args STR (def: process.argv.slice(2)): to worker
                                                #  - execArgv STR_ARR (def: process.execArgv): to node
                                                #  - silent BOOL: like CHILDPROCESS.fork() (def: false)
                                                #  - uid|gid UINT
                                                #setupMaster() fire 'setup'(OBJ) event
on("fork|online", FUNC(WORKER))                 #Fired when a child process is created|ready to respond.
WORKER.on("online", FUNC())                     #
on("listening", FUNC(WORKER, OBJ))              #Fired when a child process use TCPSERVER.listen(). 
                                                #OBJ has members { address, port, addressType: "[udp]4|6|-1(Unix socket)" }
WORKER.on("listening", FUNC(OBJ))               #

workers                                         #All WORKER in an OBJ, where the key is the WORKER.id
                                                #Only available in parent process.
worker                                          #Current WORKER. Only available in child processes.
WORKER.id                                       #
WORKER.process                                  #The underlying CHILDPROCESS.
                                                #In a WORKER, can use process.* directly

WORKER.send(VAL[,TCPSOCKET|TCPSERVER][, FUNC()])#
WORKER.on
("message", FUNC(OBJ[, TCPSOCKET|TCPSERVER]))   #
on('message', FUNC(WORKER TCPSOCKET|TCPSERVER, 
OBJ))                                           #
WORKER.kill([STR])                              #Calls WORKER.disconnect(), then in:
                                                #  - the parent, sends signal (def: "SIGTERM")
                                                #  - the child processes, exit with error code 0

WORKER.disconnect()                             #If listen() was called, don't accept new connections and emit TCPSERVER.close()
                                                #when no more connections (only server connections, not CLIENTREQUEST, that
                                                #are closed directly).
                                                #Might be useful to use a timeout to kill the WORKER if connections keep on
                                                #living.
disconnect(FUNC())                              #Call disconnect() on all child processes (must be done from parent).
on("disconnect", FUNC(WORKER))                  #Fired when a child process use disconnect()
WORKER.on("disconnect", FUNC())                 #
WORKER.isConnected()                            #
WORKER.isDead()                                 #True if exited of thrown exception
WORKER.exitedAfterDisconnected                  #When WORKER exits, will be false if exited because of an exception, and true
                                                #if because of kill() or disconnect()
on("exit", FUNC(WORKER, UINT, STR))             #Fired when a child process exits.
                                                #UINT is the exit code, STR the signal (null if none).
WORKER.on("exit", FUNC(UINT, STR))              #
WORKER.on("error", FUNC(ERROR))                 #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              VM               :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


VM.createContext([OBJ4])                        #Returns a COBJ, i.e. an OBJ with some hidden properties.
VM.isContext(OBJ)                               #Returns true if COBJ
 
runIn[Debug]Context(STR, COBJ[, OBJ2])          #Like eval() but use context COBJ as unique global environment: 
                                                #  - passed by reference.
                                                #  - does not have any other access to caller otherwise, including current caller local scope
                                                #Also:
                                                #  - use current process:
                                                #     - same file descriptors
                                                #     - throw exception in current process
                                                #     - sould create a new process first if VM used for security reason.
                                                #  - returns synchronous return value from code STR
                                                #     - but can still inspect COBJ passed by reference for async return value, or pass COBJ.FUNC()
                                                #OBJ2:
                                                #  - filename STR, line|columnOffset NUM: for stack trace error message
                                                #  - displayErrors BOOL (def: true): prints to current stderr any stderr from code
                                                #  - timeout NUM: throw error if timeout
                                                #"Debug" runs in V8 debug context
runInNewContext(STR[, OBJ4][, OBJ2])            #Same but automatically use VM.createContext(OBJ4)
runInThisContext(STR[, OBJ2])                   #Same as runInNewContext(STR, global)

new VM.Script(STR[, OBJ2])                      #Returns a SCRIPT, i.e. a compiled version of STR:
                                                #  - can call SCRIPT.run*(...): 
                                                #     - same as VM.run*(STR, ...) but delayed
                                                #     - every SCRIPT.run*(...) can be bound to different COBJ
                                                #  - OBJ2:
                                                #     - does not include: 
                                                #        - timeout in new VM.Script()
                                                #        - filename in SCRIPT.run*(...)
                                                #     - also include:
                                                #        - OBJ2: 
                                                #           - producedCachedData BOOL:
                                                #              - if true, sets cachedData with copy of code as BUFFER
                                                #              - SCRIPT.producedCachedData then shows success|failure
                                                #           - cachedData BUFFER: copy from previous script, to improve load performance
                                                #        - in SCRIPT.runInContext() OBJ: breakOnSigint BOOL


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            CRYPTO             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


setEngine(PATH[, NUM])                          #When using custom OpenSSL or alternative crypto library.
                                                #NUM are or'd flags: ENGINE_METHOD_ALL|RSA|DSA|DH|RAND|ECDH|ECDSA|CIPHERS|
                                                #DIGESTS|STORE|PKEY_[ASN1_]METH|NONE

createHash(STR)                                 #Returns a HASH, i.e. a IOSTREAM generator: write|read to it to get hashes.
                                                #STR is the algo. 
                                                #CRYPTO.getHashes() gives list of supported hashes algos, as STR_ARR:
                                                #includes [EC]DSA, DSS1, MD4|5, RIPEMD, RMD, SHA1|224|256|384|512, Whirlpool
createHmac(STR, BUFFER|STR2)                    #Same but for a HMAC. STR is hash algo. Second argument is the key.
createCipher(STR, BUFFER|STR2)                  #Same but for a CIPHER (sym. cipher). Key must be BUFFER or STR with encoding
                                                #"binary". If there is an IV, it is derived from the key.
                                                #CRYPTO.getCiphers() gives list of supported sym. ciphers (including mode of 
                                                #operation), as STR_ARR: includes AES, Blowfish, Camellia, CAST, DES, DES3, 
                                                #DES-X, IDEA, RC2, RC4, SEED.
createCipheriv(STR, BUFFER|STR2, BUFFER2|STR3)  #Same but IV is specified in third argument, not derived from key.
CIPHER.setAutoPadding(BOOL)                     #If false (def: true), disables padding (PKCS padding).
                                                #Use it for personalized padding, i.e. filling with nulls.
CIPHER.getAuthTag()                             #Returns MAC as BUFFER, for sym. ciphers that produce one ("authenticated
                                                #encryption"), i.e. "GCM" only.
CIPHER.setAAD(BUFFER)                           #Same but for "additional authenticated data" ("GCM" only)
createDecipher[iv](...)
DECIPHER.setAutoPadding(BOOL)                   #Same for decryption.
DECIPHER.setAuthTag(BUFFER)                     #
DECIPHER.setAAD(BUFFER)                         #

createDiffieHellman(ARGS)                       #Creates a DIFFIEHELLMAN (used for asym. encryption with HL algo).
                                                #ARGS can be:
                                                #  - NUM[, NUM2]: prime length NUM and generator NUM2 (def: 2).
                                                #  - STR|BUFFER[, ENCODING][, NUM|STR|BUFFER2[, ENCODING2]]: prime STR|BUFFER 
                                                #    (def ENCODING: "buffer", can also be "binary|base64") and generator 
                                                #    NUM|STR|BUFFER2 (def: 2)
DIFFIEHELLMAN.getPrime([ENCODING])              #
DIFFIEHELLMAN.getGenerator([ENCODING])          #
DIFFIEHELLMAN.generateKeys([ENCODING])          #Creates private and public key, and returns public key.
DIFFIEHELLMAN.getPublic|PrivateKey([ENCODING])  #
DIFFIEHELLMAN.setPublic|PrivateKey(STR|BUFFER,
[ENCODING])                                     #
DIFFIEHELLMAN.computeSecret(STR|BUFFER          #Creates shared secret by using current private key and other part public key
[, ENCODING][, ENCODING2])                      #STR|BUFFER (must have used the same prime and generator)
                                                #ENCODING is other part public key encoding, ENCODING2 shared secret returned.
DIFFIEHELLMAN.verifyError                       #Or'd flags showing warning after initialization among: 
                                                #  - CRYPTO.DH_CHECK_P_NOT_SAFE_PRIME
                                                #  - CRYPTO.DH_CHECK_NOT_PRIME
                                                #  - CRYPTO.DH_UNABLE_TO_CHECK_GENERATOR
                                                #  - CRYPTO.DH_NOT_SUITABLE_GENERATOR
getDiffieHellman(STR)                           #Returns a DIFFIEHELLMAN but:
                                                #  - without setPublic|PrivateKey()
                                                #  - according to STR "modp1|2|5|14|15|16|17|18", i.e. prime is constant, but
                                                #    it is faster

createECDH(STR)														      #Returns ECDH, elliptic curve version of Diffie-Hellman. 
																								#Same as DIFFIEHELLMAN but:
																								#  - last arg FORMAT "[un]compressed|hybrid" (def: "uncompressed") to generateKeys() and getPublicKeys()
																								#  - no getPrime(), getGenerator(), verifyError, setPublicKey()
                                                #STR is algo, from CRYPTO.getCurves() as STR_ARR: includes Oakley, brainpool,
                                                #c2tnb, prime, secp, sect, wap-wsg-idm-ecid-wtls
																								
public|privateEncrypt|Decrypt(STR|OBJ, BUFFER)  #Encrypts/decrypts asym. (RSA) BUFFER, with private|public key STR|OBJ:
																								#  - key STR: PEM format
																								#  - passphrase STR (decoding only)
																								#  - padding: CRYPTO.constants.RSA_NO|PKCS1[_OAEP]_PADDING
																								
createSign(STR)                                 #Same as createDecipher() but for signing algo STR. 
                                                #List can be found with openssl list-public-key-algorithms. 
                                                #Includes RSA, DH, DSA, HMAC and CMAC.
                                                #Unless createCipher(), is only a OSTREAM. To read from it, use 
                                                #SIGN.sign(BUFFER|STR[, ENCODING]), where BUFFER|STR is the private key.
createVerify(STR)                               #Same for verifying algo STR.
                                                #Like createSign(), is only a OSTREAM. To read from it, use 
                                                #VERIFY.verify(STR, STR2|BUFFER[, ENCODING]), where STR is a certificate or
                                                #a RSA|DSA public key in PEM format, and STR2|BUFFER the signature.

Certificate()                                   #Returns CERTIFICATE, used for SPKAC, used to send certificates client-side to 
                                                #the server with the HTML5 <keygen>.
CERTIFICATE.verifySpkac(BUFFER)                 #Returns BOOL
CERTIFICATE.exportChallenge|PublicKey
(STR|BUFFER[, ENCODING])                        #Returns BUFFER

pbkdf2(STR|BUFFER, STR2|BUFFER2, NUM, NUM2,     #Generate a random BUFFER using PBKDF2 with HMAC-SHA1, with first arg being
DIGEST, FUNC(ERROR, BUFFER))                    #the input, second the salt (should be min. 64 bits), NUM the number of 
                                                #iterations (should be min. 1000) and NUM2 the final string length.
pbkdf2Sync(STR|BUFFER, STR2|BUFFER2, NUM, NUM2,
DIGEST)                                         #Same but synchronous (returns BUFFER).
randomBytes(NUM[,CALBACK(EROR,BUFER)])          #Generates random BUFFER of length NUM  
                                                #Is cryptographically secure (e.g. from /dev/random)
                                                #If no FUNC, synchronous (returns BUFFER)

fips                                            #True if Node has been built to be FIPS-compliant

																								
																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            ASSERT             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


ASSERT		                                      #Throws ASSERTIONERROR with message STR (default messages provided) if fails.
                                                #ASSERTIONERROR have members message STR, actual|expected VAL, operator STR
                                                #Prefer using an actual test library.
ASSERT.fail(VAL, VAL2, STR, STR2)		            #Throws ASSERTIONERROR({ message: STR, actual: VAL, expected: VAL2, 
                                                #operator: STR2 })
ASSERT[.ok](BOOL[, STR])		                    #Checks BOOL is true
ASSERT.[not][Deep|Strict]e|Equal(VAL,VAL2[,STR])#  - equal is == 
                                                #  - strictEqual === 
                                                #  - deepEqual for objects (doesn't compare prototypes)
ASSERT.throws|doesNotThrow(FUNC()
[, ERROR|FUNC(ERROR)|REGEXP][, STR])	          #
ASSERT.ifError(ERROR)		                        #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            CONSOLE            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


console.log|info|error|warn(...)                #Use UTIL.inspect() and UTIL.format()
console.dir(VAL[, OBJ])                         #OBJ:
                                                #  - showHidden BOOL: if true, show non-enumerable
                                                #  - depth NUM (def: 2)
                                                #  - colors BOOL (def: false)
console.time[End](STR)                          #Timer start|end
console.trace(STR)                              #Prints error message with current stack trace
console.assert(VAL, ...)                        #Same as ASSERT.ok(VAL, UTIL.format(...))

new Console(OSTREAM[, OSTREAM2])                #Returns CONSOLE, same as console but with different stdout|stderr


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             UTIL              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


inspect(VAL[, OBJ])                             #Print function used by repl. Returns as STR.
                                                #OBJ members are:
                                                #  - showHidden BOOL: if false (def), doesn't show non-enumerable properties
                                                #  - depth NUM (def: 2): max recursion (null for infinite)
                                                #  - maxArrayLength NUM (def: 0) (null for infinite)
                                                #  - breakLength NUM (def: 60) (null for infinite): maxlength to print OBJ in multiline
                                                #  - colors BOOL (def: false)
                                                #  - customInspect BOOL: if true (def), will call VAL.inspect(UINT)
                                                #    (UINT is depth, and it returns STR) if it exists
                                                #  - showProxy BOOL: if true (def: false), dereference PROXY (to their target)
                                                #require("buffer").INSPECT_MAX_BYTES: number of bytes printed for BUFFER 
                                                #(def: 50)
inspect.colors                                  #OBJ with members defining colors. styles points category (e.g. number) to
inspect.styles                                  #color category, and colors point color category to color codes.

format(STR[, STR2...])                          #Printf-like FUNC, STR can contain "%s" (STR), "%d" (NUM) or "%j" (JSON)

debuglog(STR)                                   #Returns FUNC() that works like console.error() except:
                                                #  - appends STR
                                                #  - noop unless envvar NODE_DEBUG "STR2,..." includes STR 

deprecate(FUNC(...), STR)											  #Same as console.log(STR); FUNC(...), but influenced by Node options:
																								#  --no-deprecation: does not console.log()
                                                #  --trace-deprecation: console.trace() instead of console.log()
																								#  --throw-deprecation: throws
																								
inherits(TYPE_FUNC, TYPEPARENT_FUNC)            #Makes TYPE inherits from TYPEPARENT, i.e. executes:
                                                #  TYPE.prototype = Object.create(TYPEPARENT.prototype)
                                                #  TYPE.prototype.constructor = TYPE
                                                #Also creates a TYPE.super_ that points to TYPEPARENT
                                                #Since it does not use OBJ in Object.create(), needs to create own static 
                                                #members with TYPE.prototype.VAR = VAL


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              V8               :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


getHeapStatistics()->OBJ                        #OBJ:
                                                #  - total|used_heap_size[_executable] NUM
                                                #  - total_physical|available_size NUM
                                                #  - heap_size_limit NUM
getHeapSpaceStatistics()->OBJ                   #OBJ:
                                                #  - space_name STR
                                                #  - space_[used|available_]size NUM
                                                #  - physical_space_size NUM
setFlagsFromString('--OPT ...')                 #Additional v8 CLI options
