
             
   EXPRESS   
             


STRUCTURE ==>									#Order of main file:
															#  - APPVAR
															#  - MIDWR (APP.use()) 
															#     - logging middlewares
															#     - utility middlewares
															#  - routing (APP.METHOD|route() (sorted by directories))
															#  - error handling middlewares
															#  - APP.listen()
															#Routing:
															#  - sorted by "branch" (directories/topics):
															#     - all APP.METHOD of one branch call APP.METHOD(..., OBJ.FUNC()) with same OBJ
															#       (required module) but different OBJ.FUNC()
															#     - Data should be specific to each branch if possible.
															#  - Instead of calling APP.METHOD over and over:
															#     - use a function APP.map(OBJ):
															#			   - iterates recursively over it
															#        - calls proper APP.METHOD(DIR, FUNC)
															#        - OBJ:
															#           - METHOD: FUNC
															#           - DIR: OBJ (recursive)
															#     - see https://github.com/visionmedia/express/blob/master/examples/route-map/index.js


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             MAIN              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


CONNECT()											#Returns APP like EXPRESS but only with APP.use|listen() and limited functionalities.
                              #Version 3.0.2

EXPRESS()											#Returns APP (version 4.14.0)
															#Uses DEBUG
															#All methods returns their object, so that be chained.
HTTP[S].createServer(APP)			#APP is a FUNC(REQ, RES) that should be used as the request event handler of HTTP[S].SERVER
APP.listen(...)								#Same as HTTP.createServer(APP).listen(...)

APP.use([PATH, ]							#MIDWR are middleware functions: 
MIDWR([ERROR, ]REQ, RES			  #  - they modify incoming|outcoming REQ|RES
[, NEXT([ERROR])])...)			  #  - they only apply to requests to PATH:
                              #     - excluding query string or hash
                              #     - PATH is "mounted", meaning it is stripped from REQ.url (not REQ.originalUrl)
                              #       Can see current mounting with APP.mountpath
															#     - PATH ("route") is STR (exact match): 
                              #        - can use PARAM (see below)
                              #        - can use globbing
                              #        - "PATH" == "PATH/" unless APPVAR "strict routing" true
															#        - can use APPVAR "case sensitive routing" (def: false) 
															#  - they are usually Node.js modules
															#  - can use several MIDWR(...)... or a MIDWR_ARR. 
															#  - NEXT(...):
															#     - proceed to the next registered MIDWR
															#     - the "end point", i.e. the final middleware (usually delivering the content to the client)
															#       should not call NEXT()
															#     - Can be an end point only on condition, e.g. static MIDWR using NEXT() if it doesn't
															#       find the file, which allow chaining several static MIDWR to use different folders by
															#       order of preference.
															#     - If NEXT(ERROR) or throw ERROR, will call the next APP.use() with four arguments
                              #       ERROR_MIDWR(ERROR, REQ, RES, NEXT(VAL))
                              #        - default ERROR_MIDWR will send 500 status code with response ERROR
                              #        - should be redefined, so that it prints ERROR.stack and send 500 status code with 
                              #          error message using RES.send() if REQ.xhr, or RES.status() + RES.render() otherwise.
                              #     - if no MIDWR has intercepted a request, will send a 404 with small HTML saying 
                              #       "Cannot METHOD PATH"
                              #       To redefine it, put a last APP.use(MIDWR(...)) (but not ERROR_MIDWR)
APP.use([PATH, ]APP2)         #APP2:
                              #  - will be used when requests made to PATH
                              #  - Since PATH is "mounted":
                              #     - APP2 paths will be relative to PATH (if they are not absolute, i.e. starting with '/')
                              #     - so APP2 has no knowledge of APP, but thanks to REQ.originalUrl can rewrite to real URL.
                              #       For example, RES.redirect|location() with relative PATH will use REQ.originalUrl
                              #  - Goal is to create sub-apps, which is why every app should be assigned to module.exports,
                              #    and only use APP.listen() if ( ! module.parent )

APP.METHOD(PATH,MIDWR(...)...)#Like APP.use(...) except:
                              #  - cannot use APP.METHOD(PATH, APP2) nor APP.METHOD(ERROR, ...)
															#  - only when using HTTP METHOD ("all" for any, "get" also catches "head")
                              #  - PATH can be REGEXP (partial match): parenthesis matches are available at REQ.params ARR 
                              #    (empty if no parenthesis)
                              #  - Can by bypass next MIDWR(...)... of current APP.METHOD() by calling NEXT("route").
                              #    Ex. usage: authentication failure.
                              #  - APP.METHOD() is usually used for end points
APP.route(PATH)								#Returns a ROUTE where ROUTE.METHOD(...) is same as APP.METHOD(PATH, ...) and returns ROUTE 
															#(for chaining). Simplify syntax and avoid redundancy.
EXPRESS.Router([OBJ])					#Returns ROUTER, which is a MIDWR dedicated to routing. 
															#Has ROUTER.use|param|route|METHOD(...) like APP functions, but not APPVAR or listen().
															#OBJ: 
															#  - caseSensitive BOOL: like APPVAR "case sensitive routing"
															#  - strict BOOL: like APPVAR "strict routing"

APPVAR												#Like ENVVAR but only for APP. Uses:
															#  - APP.set(VAR, VAL), APP.get(VAR)
															#  - APP.disable[d]|enable[d](VAR): like set|get() but for VAL true|false
APPVAR "x-powered-by"					#Adds response header X-Powered-By: Express (def: true)
APPVAR "env"									#Defines whether it is run in "development" or "production" (some MIDWR behaves accordingly).
                              #Default to ENVVAR NODE_ENV or, if unset, "development".
															#Useful to load different configuration files according to dev|production.

PARAM													#Any part of URL in APP.METHOD() that matches [?]:PARAM_VAR
                              #  - up until next /
                              #  - if ?, optional
REQ.params.PARAM_VAR          #PARAM_VAL
APP.param(PARAM_VAR, 					
MIDWR(..., PARAM_VAL))				#Fires FUNC() each time a route taken includes PARAM_VAR.
APP.param                     #Only use PARAM_VAR if true
(PARAM_VAR, FUNC(VAL)->BOOL)  #Must use EXPRESS-PARAMS.extend(APP)
APP.param(PARAM_VAR, REGEXP)	#Same with REGEXP.test()
															#If REGEXP uses parenthesis groups, REQ.params is an ARR of matches, where first element is the whole REGEXP match.
EXPRESS-PARAMS.extend(APP)    #Must be used to use APP.param(PARAM_VAR, REGEXP|FUNC(VAL)->BOOL)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              REQ              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


REQ														#Same as Node.js but augmented with extra properties


REQ.route.methods.METHOD      #BOOL
REQ.url|originalUrl						#originalUrl doesn't take "mounting" into account.
REQ.protocol									#REQ.url protocol, i.e. "http[s]"
REQ.secure										#Same as REQ.protocol == "https"
REQ.hostname									#REQ.url hostname
REQ.subdomains								#REQ.hostname as STR_ARR:
                              #  - without top NUM subdomains (APPVAR 'subdomain offset', def: 2)
                              #  - top first
REQ.path											#REQ.url 'PATH'
REQ.route.path							  #Original PATH in APP.METHOD|use(...)

REQ.ip												#Client 'ADDR'
REQ.ips                       #'ADDR'_ARR: client + reverse proxies list (furthest to server first)

APPVAR "trust proxy fn"       #Ignore reverse proxies, i.e.:
                              #  - REQ.hostname|ip|protocol uses first address after reverse proxies
                              #     - using X-Forwarded-Host|For|Proto [C]
                              #  - REQ.ips require it to work properly
                              #Is FUNC(...) declaring which addresses are "trusted", i.e. reverse proxies
                              #Uses PROXY-ADDR(...) (see its doc)
                              #Def: nothing is trusted|ignored
APPVAR "trust proxy"          #Same but can also be:
                              #  - true: same as FUNC()->true 
                              #  - NUM: same as FUNC(VAL, NUM2)->NUM2 < NUM 


REQ.query											#GET variables as OBJ
                              #Use QS (see its doc)
                              #Can use QUERYSTRING instead if APPVAR "query parser" is "simple"
REQ.body											#Only defined with BODY-PARSER


REQ.get('VAR')->'VAL'				  #Retrieve header. Case insensitive.
REQ.range(...)->VAL           #Parses Range: TYPE=RANGE,... [C]
                              #See RANGE-PARSER doc for more info
REQ.xhr												#X-Requested-With [C] === 'XMLHttpRequest' (case-insensitive)

REQ.accepts[Charsets|Languages#Returns current headers (if no STR2) or content negotiated headers (if STR2)
|Encodings]([STR2[_ARR],...]) #For Accept[-Charset|Language|Encoding] [C]
->STR[_ARR]		                #Uses ACCEPTS (see its doc)
                              #If undefined: should respond with error code 406 "Not Acceptable"
REQ.is('MIME'[_ARR]...)->BOOL	#Check against Content-Type [C]
                              #MIME can contain TYPE/*, EXT, etc.
REQ.[signedC|c]ookies         
REQ.secret                   ##See COOKIE-PARSER

REQ.fresh|stale               #Returns true|false if:
                              #  - method is GET|HEAD
                              #  - RES.statusCode is 2** or 304
                              #  - If-Modified-Since [C] matches Last-Modified [S] or If-None-Match [C] matches ETag [S], using FRESH(...) (see its doc)
                              #Used by REQ.send(). REQ.sendFile() does not use it directly but uses same logic.
                              #Note:
                              #  - ETag [S] is set by REQ.send[File]()
                              #  - Last-Modified [S] is set by REQ.sendFile()


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              RES              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


RES														#Same as Node.js but augmented with extra properties

RES.status(NUM)->RES					#Sets RES.statusCode
RES.set('VAR','VAL'[ARR])->RES#Like RES.setHeader() but:
RES.set(OBJ)->RES     				#  - can use OBJ
                              #  - returns RES
                              #  - adds "; charset=UTF-8" if missing and Content-Type: text/... [C]
RES.get('VAR')->'VAL'[_ARR]		#Like RES.getHeader()
RES.append('VAR', VAL[_ARR])
 ->RES                        #Like RES.set(), but appends to current value if existing


RES.location(URL)->RES			  #Sets Location: URL [S]
                              #Calls encodeURI()
                              #If URL is 'back', use Referrer [C] (def: '/') as URL
RES.type('MIME')->RES					#Sets Content-Type: MIME [S]
                              #MIME can be '[.]EXT' or 'FILENAME.EXT', in which case it deduces actual MIME
RES.attachment(['FILE'])->RES	#Sets Content-Disposition: attachment[; filename="FILE"] [S] (using CONTENT-DISPOSITION, see its doc)
                              #Sets Content-Type [S] if 'FILE'
RES.links(OBJ)->RES     			#Appends|sets Link [S], where OBJ is { REL: 'URI' }
RES.cookie                    #Sets Set-Cookie: COOKIE [S], using COOKIE('VAR', 'VAL', OPTS) (see its doc)
('VAR', 'VAL'[, OPTS])->RES		#Also:
                              #  - 'VAL' can be OBJ -> 'j:JSON'
                              #  - OPTS: #     - path def '/'
                              #     - maxAge: ms instead of seconds
                              #     - expires def (using OPTS.maxAge)
                              #     - signed BOOL: if true (def: false):
                              #        - 'VAL' -> 's:VAL.HASH', using REQ.secret 'SECRET'
                              #           - uses COOKIE-SIGNATURE (see its doc)
                              #           - usually a middleware (like COOKIE-PARSER) sets REQ.secret and verifies 's:VAL.HASH'
RES.clearCookie('VAR'[, OBJ2])
 ->RES                        #Same as RES.cookie, with OPTS.expires 1970-01-01
															

RES.sendFile('PATH'[, OBJ]		#Uses SEND(REQ, ...) (see its doc), i.e. like RES.end() but:
[, FUNC([ERROR])])						#  - send file content for 'PATH'
                              #  - handles: range requests, [un]conditional caching, Content-Type|Length [S], HEAD
                              #On top of SEND():
                              #  - can add OPTS.headers HEADER_OBJ
                              #  - 'PATH' does not need to be encodeURIComponent'd
                              #  - fires FUNC(ERROR) (or, if undefined, NEXT(ERROR)) instead of sending 4**, 5**
                              #  - fires FUNC(ERROR) (or, if undefined, NEXT()) instead of 301
RES.download
('PATH'[, 'FILE'], FUNC)      #Same as RES.attachment(['FILE']); RES.sendFile('PATH', FUNC);
                              
RES.send([VAL])->RES			    #Similar to sendFile() but:
                              #  - sends content directly, not file content
															#     - VAL can be any JSON value except null:
                              #        - uses JSON.stringify(VAL[, APPNAME "json replacer"][, APPNAME "json spaces"])
                              #     - does not set Last-Modified [S]
                              #  - no range requests
                              #  - does not set Cache-Control [S]
                              #  - different ETag [S]: uses ETAG(..., {weak: BOOL}) (see its doc)
                              #     - BOOL according to APPVAR 'etag' 'weak' (def) or 'strong'
                              #     - i.e. '[W/]"SIZE-MD5HASH"'
                              #     - can customize with APPVAR "etag fn"(STR, 'ENCODING')->'ETAG'
                              #  - if 204, no body
                              #  - never fires NEXT([ERROR])
RES.json(...)->RES						#Same as RES.send(OBJ)
RES.jsonp(...)->RES						#Same as RES.send(OBJ) but for JSONP, i.e. returns FUNC(BODY)
                              #  - 'FUNC' is REQ.query[CALLBACK]
                              #     - CALLBACK is "jsonp callback name" (def: 'callback')
RES.sendStatus(STATU_NUM)->RES#Like RES.status(STATUS_NUM).send(HTTP.STATUS_CODES[NUM])
RES.redirect([NUM, ]'URL')	  #Same RES.location('URL'); RES.sendStatus(NUM); 


RES.format({ MIME|default() })#Fire MIME(REQ, RES, NEXT) according to REQ.accepts('MIME'_ARR)
 ->RES                        #Sets Content-Type [S], Vary: Accept [S] (using VARY, see its doc)
                              #If no match: 
                              #  - default()
                              #  - if no default, NEXT(ERROR) with ERROR: status[Code] 406, types 'MIME'_ARR




EXPRESS.static(DIR[, OBJ])    #Express MIDWR that serves static files using RES.sendFile(). Same as SERVE-STATIC (???)
                              #OBJ:
                              #  - maxAge: see sendFile()
                              #  - redirect BOOL: if true (def), request to DIR redirects to DIR/
                              #  - index FILE: requests to "/" (only) redirects to /FILE (def: "index.html")
                              #  - dotfiles "allow|deny|ignore": "deny" sends 403, "ignore" (def) calls NEXT()
                              #  - setHeader FUNC(): event handler like ONHEADERS
                              #No caching.

TFUNC('PATH'[, OBJ]           #Template function:
[, FUNC(ERROR, STR)])         #  - processes 'PATH', using OBJ locals, then return STR
                              #  - can use CONSOLIDATE (see its doc)
APP.engine('EXT', TFUNC)      #Make APP.render('FILE[.EXT]') use TFUNC (def '.EXT' is APPVAR "view engine" (def: none))
APP.render(...)               #Fires TFUNC(...):
                              #  - 'PATH' should be relative to APPVAR "views" 'DIR'[_ARR] (def: ./views)
                              #     - but is resolved when passed to TFUNC()
                              #  - OBJ: filled with APP.locals OBJ
                              #Use 'PATH'-based cache if OBJ.cache true (def: APPVAR "view cache" (def: true if NODE_ENV === "production"))
                              #Can customize low-level templating logic with APPVAR "view" (see source code)
RES.render(...)               #Same as APP.render(...) except:
                              #  - can use RES.locals
                              #  - def FUNC2 is RES.send(STR)

                      		    


ONHEADERS(RES, FUNC())       ##Fires FUNC() (with RES as this) just before RES starts sending headers. Node module (0.0.0)
