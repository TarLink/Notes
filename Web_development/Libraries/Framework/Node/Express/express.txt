
             
   EXPRESS   
             


STRUCTURE ==>									#Order of main file:
															#  - APPVAR
															#  - MIDWR (APP.use()) 
															#     - logging middlewares
															#     - utility middlewares
															#  - routing (APP.METHOD|route() (sorted by directories))
															#  - error handling middlewares
															#  - APP.listen()
															#Routing:
															#  - sorted by "branch" (directories/topics):
															#     - all APP.METHOD of one branch call APP.METHOD(..., OBJ.FUNC()) with same OBJ
															#       (required module) but different OBJ.FUNC()
															#     - Data should be specific to each branch if possible.
															#  - Instead of calling APP.METHOD over and over:
															#     - use a function APP.map(OBJ):
															#			   - iterates recursively over it
															#        - calls proper APP.METHOD(DIR, FUNC)
															#        - OBJ:
															#           - METHOD: FUNC
															#           - DIR: OBJ (recursive)
															#     - see https://github.com/visionmedia/express/blob/master/examples/route-map/index.js


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             MAIN              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


CONNECT()											#Returns APP like EXPRESS but only with APP.use|listen() and limited functionalities.
                              #Version 3.0.2

EXPRESS()											#Returns APP (version 4.14.0)
															#Uses DEBUG
															#All methods returns their object, so that be chained.
HTTP[S].createServer(APP)			#APP is a FUNC(REQ, RES) that should be used as the request event handler of HTTP[S].SERVER
APP.listen(...)								#Same as HTTP.createServer(APP).listen(...)

APP.use([PATH, ]							#MIDWR are middleware functions: 
MIDWR([ERROR, ]REQ, RES			  #  - they modify incoming|outcoming REQ|RES
[, NEXT([ERROR])])...)			  #  - they only apply to requests to PATH:
                              #     - excluding query string or hash
                              #     - PATH is "mounted", meaning it is stripped from REQ.url (not REQ.originalUrl)
                              #       Can see current mounting with APP.mountpath
															#     - PATH ("route") is STR (exact match): 
                              #        - can use PARAM (see below)
                              #        - can use globbing
                              #        - "PATH" == "PATH/" unless APPVAR "strict routing" true
															#        - can use APPVAR "case sensitive routing" (def: false) 
															#  - they are usually Node.js modules
															#  - can use several MIDWR(...)... or a MIDWR_ARR. 
															#  - NEXT(...):
															#     - proceed to the next registered MIDWR
															#     - the "end point", i.e. the final middleware (usually delivering the content to the client)
															#       should not call NEXT()
															#     - Can be an end point only on condition, e.g. static MIDWR using NEXT() if it doesn't
															#       find the file, which allow chaining several static MIDWR to use different folders by
															#       order of preference.
															#     - If NEXT(ERROR) or throw ERROR, will call the next APP.use() with four arguments
                              #       ERROR_MIDWR(ERROR, REQ, RES, NEXT(VAL))
                              #        - default ERROR_MIDWR will send 500 status code with response ERROR
                              #        - should be redefined, so that it prints ERROR.stack and send 500 status code with 
                              #          error message using RES.send() if REQ.xhr, or RES.status() + RES.render() otherwise.
                              #     - if no MIDWR has intercepted a request, will send a 404 with small HTML saying 
                              #       "Cannot METHOD PATH"
                              #       To redefine it, put a last APP.use(MIDWR(...)) (but not ERROR_MIDWR)
APP.use([PATH, ]APP2)         #APP2:
                              #  - will be used when requests made to PATH
                              #  - Since PATH is "mounted":
                              #     - APP2 paths will be relative to PATH (if they are not absolute, i.e. starting with '/')
                              #     - so APP2 has no knowledge of APP, but thanks to REQ.originalUrl can rewrite to real URL.
                              #       For example, RES.redirect|location() with relative PATH will use REQ.originalUrl
                              #  - Goal is to create sub-apps, which is why every app should be assigned to module.exports,
                              #    and only use APP.listen() if ( ! module.parent )

APP.METHOD(PATH,MIDWR(...)...)#Like APP.use(...) except:
                              #  - cannot use APP.METHOD(PATH, APP2) nor APP.METHOD(ERROR, ...)
															#  - only when using HTTP METHOD ("all" for any, "get" also catches "head")
                              #  - PATH can be REGEXP (partial match): parenthesis matches are available at REQ.params ARR 
                              #    (empty if no parenthesis)
                              #  - Can by bypass next MIDWR(...)... of current APP.METHOD() by calling NEXT("route").
                              #    Ex. usage: authentication failure.
                              #  - APP.METHOD() is usually used for end points
APP.route(PATH)								#Returns a ROUTE where ROUTE.METHOD(...) is same as APP.METHOD(PATH, ...) and returns ROUTE 
															#(for chaining). Simplify syntax and avoid redundancy.
EXPRESS.Router([OBJ])					#Returns ROUTER, which is a MIDWR dedicated to routing. 
															#Has ROUTER.use|param|route|METHOD(...) like APP functions, but not APPVAR or listen().
															#OBJ: 
															#  - caseSensitive BOOL: like APPVAR "case sensitive routing"
															#  - strict BOOL: like APPVAR "strict routing"

APPVAR												#Like ENVVAR but only for APP. Uses:
															#  - APP.set(VAR, VAL), APP.get(VAR)
															#  - APP.disable[d]|enable[d](VAR): like set|get() but for VAL true|false
APPVAR "x-powered-by"					#Adds response header X-Powered-By: Express (def: true)
APPVAR "env"									#Defines whether it is run in "development" or "production" (some MIDWR behaves accordingly).
                              #Default to ENVVAR NODE_ENV or, if unset, "development".
															#Useful to load different configuration files according to dev|production.

PARAM													#Any part of URL in APP.METHOD() that matches [?]:PARAM_VAR
                              #  - up until next /
                              #  - if ?, optional
REQ.params.PARAM_VAR          #PARAM_VAL
APP.param(PARAM_VAR, 					
MIDWR(..., PARAM_VAL))				#Fires FUNC() each time a route taken includes PARAM_VAR.
APP.param                     #Only use PARAM_VAR if true
(PARAM_VAR, FUNC(VAL)->BOOL)  #Must use EXPRESS-PARAMS.extend(APP)
APP.param(PARAM_VAR, REGEXP)	#Same with REGEXP.test()
															#If REGEXP uses parenthesis groups, REQ.params is an ARR of matches, where first element is the whole REGEXP match.
EXPRESS-PARAMS.extend(APP)    #Must be used to use APP.param(PARAM_VAR, REGEXP|FUNC(VAL)->BOOL)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              REQ              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


REQ														#Same as Node.js but augmented with extra properties


REQ.route.methods.METHOD      #BOOL
REQ.url|originalUrl						#originalUrl doesn't take "mounting" into account.
REQ.protocol									#REQ.url protocol, i.e. "http[s]"
REQ.secure										#Same as REQ.protocol == "https"
REQ.hostname									#REQ.url hostname
REQ.subdomains								#REQ.hostname as STR_ARR:
                              #  - without top NUM subdomains (APPVAR 'subdomain offset', def: 2)
                              #  - top first
REQ.path											#REQ.url 'PATH'
REQ.route.path							  #Original PATH in APP.METHOD|use(...)

REQ.ip												#Client 'ADDR'
REQ.ips                       #'ADDR'_ARR: client + reverse proxies list (furthest to server first)

APPVAR "trust proxy fn"       #Ignore reverse proxies, i.e.:
                              #  - REQ.hostname|ip|protocol uses first address after reverse proxies
                              #     - using X-Forwarded-Host|For|Proto [C]
                              #  - REQ.ips require it to work properly
                              #Is FUNC(...) declaring which addresses are "trusted", i.e. reverse proxies
                              #Uses PROXY-ADDR(...) (see its doc)
                              #Def: nothing is trusted|ignored
APPVAR "trust proxy"          #Same but can also be:
                              #  - true: same as FUNC()->true 
                              #  - NUM: same as FUNC(VAL, NUM2)->NUM2 < NUM 


REQ.query											#GET variables as OBJ
                              #Use QS (see its doc)
                              #Can use QUERYSTRING instead if APPVAR "query parser" is "simple"
REQ.body											#Only defined with BODY-PARSER


REQ.get('VAR')->'VAL'				  #Retrieve header. Case insensitive.
REQ.range(NUM[, OPTS])->VAL   #Parses Range: TYPE=RANGE,... [C]
                              #NUM is resource byte size.
                              #Returns OBJ_ARR with OBJ.start|end NUM2 or (if error) -2|-1
                              #See RANGE-PARSER doc for more info
REQ.xhr												#X-Requested-With [C] === 'XMLHttpRequest' (case-insensitive)

REQ.accepts[Charsets|Languages#Returns current headers (if no STR2) or content negotiated headers (if STR2)
|Encodings]([STR2[_ARR],...]) #For Accept[-Charset|Language|Encoding] [C]
->STR[_ARR]		                #Uses ACCEPTS (see its doc)
                              #If undefined: should respond with error code 406 "Not Acceptable"
REQ.is('MIME'[_ARR]...)->BOOL	#Check against Content-Type [C]
                              #MIME can contain TYPE/*, EXT, etc.
REQ.[signedC|c]ookies         
REQ.secret                   ##See COOKIE-PARSER

REQ.fresh|stale               #Returns true|false if:
                              #  - method is GET|HEAD
                              #  - RES.statusCode is 2** or 304
                              #  - If-Modified-Since [C] matches Last-Modified [S] or If-None-Match [C] matches ETag [S], using FRESH(...) (see its doc)
                              #Used by REQ.send()


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              RES              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


RES														#Same as Node.js but augmented with extra properties

RES.status(NUM)->RES					#Sets RES.statusCode
RES.set('VAR','VAL'[ARR])->RES#Like RES.setHeader() but:
RES.set(OBJ)->RES     				#  - can use OBJ
                              #  - returns RES
                              #  - adds "; charset=UTF-8" if missing and Content-Type: text/... [C]
RES.get('VAR')->'VAL'[_ARR]		#Like RES.getHeader()
RES.append('VAR', VAL[_ARR])
 ->RES                        #Like RES.set(), but appends to current value if existing

RES.location(URL)->RES			  #Sets Location: URL [S]
                              #Calls encodeURI()
                              #If URL is 'back', use Referrer [C] (def: '/') as URL
RES.type('MIME')->RES					#Sets Content-Type: MIME [S]
                              #MIME can be '[.]EXT' or 'FILENAME.EXT', in which case it deduces actual MIME
RES.links(OBJ)								#Appends|sets Link [S], where OBJ is { REL: 'URI' }
RES.cookie                    #Sets Set-Cookie: COOKIE [S], using COOKIE('VAR', 'VAL', OPTS) (see its doc)
('VAR', 'VAL'[, OPTS])				#Also:
                              #  - 'VAL' can be OBJ -> 'j:JSON'
                              #  - OPTS: #     - path def '/'
                              #     - maxAge: ms instead of seconds
                              #     - expires def (using OPTS.maxAge)
                              #     - signed BOOL: if true (def: false):
                              #        - 'VAL' -> 's:VAL.HASH', using REQ.secret 'SECRET'
                              #           - uses COOKIE-SIGNATURE (see its doc)
                              #           - usually a middleware (like COOKIE-PARSER) sets REQ.secret and verifies 's:VAL.HASH'
RES.clearCookie('VAR'[, OBJ2])#Same as RES.cookie, with OPTS.expires 1970-01-01
															
                              #???:
                              #     - RES Last-Modified
                              #        - set automatically by RES.sendFile()
                              #     - RES ETag
                              #        - set automatically by RES.send|sendFile()
                              #        - sendFile|download() ETag function is always content-based, 'W/"MD5HASH"'

RES.send([VAL])				        #Similar to RES.end(STR) but also:
															#  - VAL can also be OBJ|ARR|BOOL|NUM:
                              #     - uses JSON.stringify(OBJ[, APPNAME "json replacer"][, APPNAME "json spaces"])
                              #  - sets Content-Type|Length [S], if body and not already set
                              #  - sets ETag [S], using ETAG(..., {weak: BOOL}) (see its doc)
                              #     - BOOL according to APPVAR 'etag' 'weak' (def) or 'strong'
                              #     - i.e. '[W/]"SIZE-MD5HASH"'
                              #     - can customize with APPVAR "etag fn"(STR, 'ENCODING')->'ETAG'
                              #  - if REQ.fresh: 304
                              #  - if 204|304 or HEAD, no body
RES.json(...)									#Same as RES.send(OBJ)
RES.jsonp(...)								#Same as RES.send(OBJ) but for JSONP, i.e. returns FUNC(BODY)
                              #  - 'FUNC' is REQ.query[CALLBACK]
                              #     - CALLBACK is "jsonp callback name" (def: 'callback')
RES.sendStatus(NUM)           #Like RES.status(NUM).send(HTTP.STATUS_CODES[NUM])


SERVE-STATIC



SEND(REQ, 'PATH'[, OPTS])
 ->SENDSTREAM
                              #Returns SENDSTREAM, containing file located at 'PATH'
                              #'PATH':
                              #  - must be encodeURIComponent()'d
                              #  - if wrong, sends 400
                              #  - if contains .., sends 403
                              #  - if cannot find, sends 404
                              #  - if other filesystem error, sends 500
                              #OPTS:
                              #  - acceptRanges BOOL (def: true): handle Range [C] and send Accept-Ranges [S]
                              #  - start|end NUM: only send the file from those offsets
                              #  - cacheControl BOOL (def: true): set Cache-Control [S]???
                              #  - maxAge NUM???
                              #  - dotfiles STR: what to do if 'PATH' contains a file that starts with '.':
                              #     - 'allow': nothing
                              #     - 'deny': sends 403
                              #     - 'ignore' (def): sends 404
                              #  - etag BOOL (def: true): sets ETag [S]
                              #  - root 'DIR': make 'PATH' relative to 'DIR'
                              #  - extensions 'EXT'_ARR or false (def): if 'PATH' cannot be found, try 'PATH.EXT'
                              #  - index 'FILE'[_ARR]|false (def: 'index.html'): if 'PATH' cannot be bound, try DIR('PATH')/'FILE'
                              #     - if 'PATH' is DIR ???
                              #  - lastModified BOOL (def: true): sets Last-Modified [S] according to file mtime
SENDSTREAM.pipe(RES)->RES     #Sends response
SENDSTREAM.on('error',        #Fired when 4**|5** would be sent:
FUNC(HTTPERROR, STATUS_NUM))  #  - unless defined, will RES.sendStatus(STATUS_NUM)
                              #  - also sets Content-Range [S] if 416
                              #HTTPERROR (see its doc) 
SENDSTREAM.on                 #Fired when 'PATH' is DIR but misses last '/'
('directory', FUNC())         #Unless defined, will send 301 with Location: 'PATH/' [S], and body "Redirecting to PATH/"
SENDSTREAM.on
('file', FUNC('PATH', FSSTAT))#When 'PATH' is FILE found, goind to be sent
SENDSTREAM.on('headers', 
FUNC(RES, 'PATH', FSSTAT))    #Before setting response headers
SENDSTREAM.on
('stream', FUNC(???))         #Streaming has started???
SENDSTREAM.on('end', FUNC())  #Streaming has ended???


RES.sendFile(PATH[, OBJ]			#Similar to RES.send(), but: 
[, FUNC([ERROR])])						#  - sends file content instead. 
                              #  - sets Last-Modified
                              #  - when done sending, fires FUNC()
                              #  - does automatically byte serving (Accept-Ranges: "bytes")
                              #     - unless OBJ.acceptRanges false (def: true)
                              #  - sets Cache-Control: public, max-age=OBJ.maxAge (def: 0) if not already set
                              #     - unless OBJ.cacheControl false (def: true)
                              #  - Can set OBJ.root DIR for relative path
EXPRESS.static(DIR[, OBJ])    #Express MIDWR that serves static files using RES.sendFile(). Same as SERVE-STATIC
                              #OBJ:
                              #  - maxAge: see sendFile()
                              #  - redirect BOOL: if true (def), request to DIR redirects to DIR/
                              #  - index FILE: requests to "/" (only) redirects to /FILE (def: "index.html")
                              #  - dotfiles "allow|deny|ignore": "deny" sends 403, "ignore" (def) calls NEXT()
                              #  - setHeader FUNC(): event handler like ONHEADERS
                              #No caching.

APP|RES.render(FILE[, OBJ]    #FILE is looked under APPVAR "views" STR[_ARR] (def: ./views)
[, FUNC2(ERROR, STR2)])       #Then APP|RES.render(...) fires FUNC(...), where FUNC:
                              #  - is registered:
                              #     - by extension, using APP.engine(EXT_STR, FUNC(...)) (def: none)
                              #       EXT_STR does not have the dot.
                              #     - if no extension, call APPVAR "view engine" EXT_STR (def: none)
                              #  - can use CONSOLIDATE for FUNC(...)
                              #OBJ:
                              #  - is automatically filled by APP|RES.locals OBJ
															#  - if OBJ.cache true or APPVAR "view cache", use FILE path-based cache (see CONSOLIDATE)
                              #RES, as opposed to APP, can omit FUNC2(), in which case it will RES.send(STR2)

RES.format(OBJ)								#OBJ has members MIME: FUNC():
															#  - fires FUNC() according to REQ.accepted (content negociation), and sets Content-Type header 
															#    accordingly
															#  - if none works, automatically throw a 406 response ERROR, or fires OBJ.default() if defined
RES.attachment([PATH])				#Sets Content-Disposition: attachment[; filename="PATH"] header, which means RES.send(VAL) will
															#open a download box for client.
                              #If PATH, also sets Content-Type, so PATH must exist
RES.download(PATH[, PATH2]    
[, FUNC([ERROR])])						#Same as RES.attachment([PATH2]), but fires RES.sendFile(...)

RES.redirect([NUM, ]URL|PATH)	#NUM is 302 by def.
															#PATH can be "back", meaning Referer header URL (if none, "/")
                              #Calls encodeURI()

ONHEADERS(RES, FUNC())       ##Fires FUNC() (with RES as this) just before RES starts sending headers. Node module (0.0.0)
