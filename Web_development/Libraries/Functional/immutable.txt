
               
   IMMUTABLE   
               


VERSION ==>                       #3.7.6

GOAL ==>                          #Provide:
                                  #  - IARR|IMAP|ISET: ARR|MAP|SET like JavaScript but immutable (setters create copy)
                                  #  - ISEQ: deferring, pipeline, lazy-evaluation like Lodash chain
                                  #  - ISTACK: like IARR, but optimized for FIFO
                                  #  - ordered IMAP|ISET
                                  #  - IRECORD: IMAP with define set of keys, and default values

ITERABLE VS IITERABLE             
SET VS ISET
MAP VS IMAP
ARR VS IARR                       #JavaScript's vs Immutable's
COLL vs ICOLL                     #Underscore/Lodash's vs Immutable's

IVARR                             #Similar to VARR but using IITERABLE|SET|ARR|MAP
                                  #Each intermediate|final value must be an IITERABLE

METHODS ==>                       #IITERABLE implements all ARR|MAP|SET methods, except:
                                  #  - no length (use size), Array.from(), fill|copyWithin(...)
                                  #  - only on ICOLL|ISEQ:            size
                                  #  - only on IARR|IMAP|ISET|ISTACK: clear()
                                  #  - only on IARR|IMAP|ISET:        delete()
                                  #  - only on IARR|IMAP:             set()
                                  #  - only on IARR|ISTACK:           push|pop|shift|unshift()
                                  #  - only on ISET:                  add()


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         IMMUTABILITY          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


GOAL ==>                          #Setters creates copies:
                                  #  - unless setters did not change anything
                                  #  - efficient: copies are as deep for what changed, shallow otherwise
                                  #  - only for Immutable setters. IITERABLE.VAR = VAL will do nothing and return VAL.
                                  #Uses:
                                  #  - object which should be used but not modified
                                  #  - fast track changes: === instead of deep comparison
                                  #     - i.e. consumer gets new objects instead of keeping references
RETURN VALUE ==>                  #Is the same object, unless specified otherwise


ISET|IARR|IMAP|ISTACK.            #Opts-in|out of immutability, i.e. setters will return same object instead of copy
as[Im]Mutable()                   #To do for performance optimization when many setters are called on same object,
                                  #to avoid too many intermediate copies.
ISET|IARR|IMAP|ISTACK.withMutations
(FUNC(ISET|IARR|IMAP|ISTACK))      #Calls asMutable() then FUNC() then asImmutable()


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             TESTS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


IMMUTABLE.is(VAL, VAL2)           #Like === but:
                                  #  - deep comparison of IITERABLE (but not OBJ), which must still be same type
                                  #  - NaN === NaN
IITERABLE.equals(VAL)             #Same as IMMUTABLE.is(IITERABLE, VAL)

IITERABLE.hashCode()->NUM         #Numeric checksum of IITERABLE deep content (not identity)

TYPE.isTYPE(VAL)                  #E.g. Set.isSet(VAL)
                                  #Notes:
                                  #  - not for ICOLL[.*]
                                  #  - Iterable.isKeyed|Indexed|Associative(VAL): for IITERABLE.KEYED|INDEXED|ISET


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          CONVERSIONS          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


[I]MAP -> [I]ARR|[I]SET           #{ VAR: VAL ... } -> [[KEY, VAL]...] 
[I]ARR|[I]SET -> [I]MAP           #[VAL...] -> { VAL: VAL ... }
... -> ISET                       #Removes duplicates

DEEP ==>                          #Only fromJS|toJS() are deep. Everything else shallow.


IMMUTABLE.fromJS(VAL)             #Returns, using according to VAL:
->ILIST|IMAP|VAL                  #  - ARR: ILIST()
                                  #  - plain OBJ: IMAP()
                                  #  - others: as is
IITERABLE.toJS|toJSON()->ARR|OBJ  #
IITERABL.toArray|Object()->ARR|OBJ#


Set|List|Stack|Seq[.Set|Indexed]
.of(VAL...)->ISET|ILIST|etc.      #Like creating empty, then setting|adding each VAL


IARR|ISTACK(IITERABLE|ARR|SET|MAP)#
IITERABLE.toList|Stack()          #

IMAP(IITERABLE|ARR|SET|MAP|OBJ)   #
IITERABLE.to[Ordered]Map()        #

ISET([IITERABLE|ARR|SET|MAP])     #Use values
IITERABLE.to[Ordered]Set()        #
ISET.fromKeys(IITERABLE|OBJ|MAP)  #Use keys


IITERABLE.toSeq()->ISEQ            #Uses toKeyedSeq|toIndexedSeq|toSetSeq() according to IITERABLE type
IITERABLE.toKeyedSeq()->ISEQ.KEYED #Not from [[KEY, VAL]]
IITERABLE.INDEXED.fromEntrySeq()
->ISEQ.KEYED                       #From [[KEY, VAL]]
IITERABLE.toIndexedSeq()
->ISEQ.INDEXED                     #
IITERABLE.key|value|entrySeq()
->ISEQ.INDEXED                     #Like keys|values|entries() except returns as ISEQ.INDEXED
IITERABLE.toSetSeq()->ISEQ.SET     #



																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           IITERABLE           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


IMMUTABLE.Iterable                #IITERABLE
                                  #Base classe for other data types

IITERABLE.get(...)
IITERABLE.has(...)                #Like _.get|has(...) but using VAR instead of VARR
IITERABLE.getIn(...)              
IITERABLE.hasIn(...)              #Like _.get|has(...) but using IVARR instead of VARR

IITERABLE.includes|contains(...)  #Like _.includes(...), without last arg INT

IITERABLE.keys|values|entries()
->ITERATOR                        #Like ARR.keys|values|entries()

IITERABLE.forEach(...)            #Like _.forEach(...)
IITERABLE.map(...)                #Like _.map(...)
IITERABLE.filter[Not](...)        #Like _.filter|select(...)
IITERABLE.reverse()               #Like ARR.reverse()
IITERABLE.sort(...)               #Like ARR.sort(...)
IITERABLE.sortBy(FUNC, ...)       #Like sort(...) but uses IITERABLE.map(FUNC) for sorting
IITERABLE.groupBy(...)            #Like _.groupBy(...)

IITERABLE.slice(...)              #Like ARR.slice(...)

IITERABLE.skip|take[Last](...)    #Like _.take|drop[Right](...)
IITERABL.skip|dropWhile|Until(...)#Like _.take[Right]While(...)
IITERABLE.butLast|rest()          #Like _.initial|rest()
IITERABLE.first|last()->VAL       #Like _.first|tail()

IITERABLE.concat(VAL|IITERABL2...)#Similar to ARR.concat()
IITERABLE.flatten([BOOL|NUM])     #Like _.flatten() but:
                                  #  - can specify NUM levels of depth
                                  #  - each level of depth must contain other IITERABLE2
IITERABLE.flatMap(...)            #Like map(...) + flatten(true)

IITERABLE.reduce[Right](...)->VAL #Like ARR.reduce[Right](...)
IITERABLE.every|some(...)->BOOL   #Like ARR.every|some(...)
IITERABLE.join(...)->STR          #Like ARR.join(...)

IITERABLE.isEmpty()->BOOL         #Like _.isEmpty()

IITERABLE.count
([FUNC(VAL, KEY, IITERABLE)->BOOL
[, THIS]])->NUM                   #Like _.filter().length
IITERABLE.countBy(...)->NUM       #Like _.countBy()

IITERABLE.find[Last](...[, VAL2])
->VAL                             #Like ARR.find(...), with default VAL2
IITERABLE.find[Last]Entry(...)
->[KEY, VAL]                      #Like find[Last]() but returns [KEY, VAL] not VAL

IITERABLE.min|max
([FUNC(VAL, VAL2)->NUM])->VAL     #Def FUNC: <
IITERABLE.minBy|maxBy
(FUNC2(VAL, KEY, IITERABLE)->VAL),
FUNC(VAL, VAL2)->NUM)->VAL        #Same but map values before

IITERABLE.isSubset|Superset
(IITERABLE2)->BOOL                #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             ICOLL             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


IMMUTABLE.Collection              #ICOLL
                                  #Child of IITERABLE
                                  #Base class for other data types
ICOLL.size                        #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              ISEQ              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


IMMUTABLE.Seq                     #ISEQ
                                  #Child of IITERABLE
                                  #Like ICOLL but deferred, pipelined, lazy-evaluated (like Lodash chain)
ISEQ.size                         #
ISEQ.cacheResult()                #Do not defer (but still pipelined, lazy-evaluated)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          IARR/ISTACK          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


IMMUTABLE.Iterable.Indexed        #IITERABLE.INDEXED
                                  #Child of IITERABLE
IMMUTABLE.Seq|Collection.Indexed  #ISEQ|ICOLL.INDEXED
                                  #Child of IITERABLE.INDEXED and ICOLL|ISEQ
IMMUTABLE.List                    #IARR
                                  #Child of ICOLL.INDEXED
                                  #Immutable ARR
IMMUTABLE.Stack                   #ISTACK
                                  #Child of ICOLL.INDEXED
                                  #Immutable FIFO


IINDEXED.interpose(VAL)           #Adds VAL between each element
IINDEXED.splice(...)              #Like ARR.splice(...)

IINDEXED.zip(...)                 #Like _.zip(...)
IINDEXD.zipWith(FUNC(VAL...)->VAL, 
IITERABLE2[_ARR]...)              #Similar to _.zipWith(...)
IINDEXED.interleave(IITERABLE2...)#Like zip() + flatten()

IINDEXED.[last]indexOf(...)->NUM  #Like ARR.[last]indexOf(...)
IINDEXED.find[Last]Index(...)->NUM#Like ARR.find[Last]Index(...)


IMMUTABLE.Range(...)->COLLINDEXED #Like _.range(...)
IMMUTABLE.Repeat(VAL[, NUM])
->COLLINDEXED                     #Repeats VAL NUM times (def: infinite)


IARR.delete|remove(NUM)           #
IARR.deleteIn|removeIn(IVARR)     #
IARR|ISTACK.clear()               #
IARR.setSize(NUM)                 #Truncates or fills with undefined

IARR.push(...)                    #Like ARR.push(...)
IARR.pop()                        #Like ARR.pop()
IARR|ISTACK.unshift(...)          #Like ARR.unshift(...)
IARR|ISTACK.shift()               #Like ARR.shift()
ISTACK.unshiftAll
(IITERABLE|ARR|SET|MAP)           #Similar to ISTACK.unshift()


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              IMAP             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


IMMUTABLE.Iterable.Keyed          #IITERABLE.KEYED
                                  #Child of IITERABLE
IMMUTABLE.Seq|Collection.Keyed    #ISEQ|ICOLL.KEYED
                                  #Child of IITERABLE.KEYED and ICOLL|ISEQ
IMMUTABLE.Map                     #IMAP
                                  #Child of ICOLL.KEYED
                                  #Immutable MAP

IKEYED.[last]keyOf(...)->'KEY'    #
IKEYED.find[Last]Key(...)->'KEY'  #Like ARR.[last]indexOf|find[Last]Key(...) but with 'KEY'

IKEYED.mapKeys(...)               #Like _.mapKeys()
IKEYED.mapEntries
(FUNC([KEY,VAL], NUM, IKEYED)
->[KEY, VAL][, THIS])             #Like mapKeys(...) but settings both key and value

IKEYED.flip()                     #Like _.invert()

IMAP.delete|remove('KEY')         #
IMAP.deleteIn|removeIn(IVARR)     #
IMAP.clear()                      #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           IARR/IMAP           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/



IARR|IMAP.set('VAR', VAL)         #
IARR|IMAP.setIn(IVARR, VAL)       #Like MAP.set()

IARR|IMAP.update
('VAR', [VAL2, ]FUNC(VAL)->VAL)   #
IARR|IMAP.updateIn
(IVARR, [VAL2, ]FUNC(VAL)->VAL)   #
IARR|IMAP.update
(FUNC(IARR|IMAP)->IARR|IMAP)      #Like set[In]() but with a function

IARR|IMAP.merge[Deep]
(IITERABLE|ARR|MAP|SET|OBJ)       #
IARR|IMAP.merge[Deep]In
(IVARR, IITERABLE|ARR|MAP|SET|OBJ)#Like _.extend|merge()

IARR|IMAP.merge[Deep]With
(FUNC(VAL, VAL2, 'KEY')->VAL,VAL2)#Like merge[Deep]() but with custom merge function


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              ISET             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


IMMUTABLE.Iterable.Set            #IITERABLE.SET
                                  #Child of IITERABLE
                                  #Iterates over VALUE, VALUE
IMMUTABLE.Seq|Collection.Set      #ISEQ|ICOLL.SET
                                  #Child of IITERABLE.ISET and ICOLL|ISEQ
IMMUTABLE.Set                     #ISET
                                  #Child of ICOLL.ISET
                                  #Immutable SET

ISET.add(VAL)                     #
ISET.delete|remove(VAL)           #
ISET.clear()                      #

ISET.subtract
(IITERABLE|ARR|SET|MAP)           #Like _.difference()
ISET.union|merge
(IITERABLE|ARR|SET|MAP)           #Like _.union()
ISET.intersect
(IITERABLE|ARR|SET|MAP)           #Like _.intersection()


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            ORDERED            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


IMMUTABLE.OrderedMap|OrderedSet   #Child of IMAP|ISET
                                  #Makes it iterate in the same order as items were set|added.
Iterable.isOrdered(VAL)->BOOL     #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            RECORD             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/

                                             
IMMUTABL.Record(OBJ[, 'NAME'])    #Child of IMAP
->IRECORD_TYPE                    #Like IMAP except:
new IRECORD_TYPE(OBJ2)->IRECORD   #  - only keys present in OBJ can be set (otherwise silently not set)
                                  #  - OBJ are default values
                                  #  - IRECORD.VAR = VAL throws error
