
             
   LO-DASH   
             



TODO: changelog, going through all func again, Underscore aliases, check diff with Underscore, sort everything

VERSION ==>                       #Version 2.4.2
                                  #Is a Node module or a client-side script
                                  #Can also require only a specific category, e.g. "lodash/array" or "lodash/array/chunk"

lodash [MODE...]                  #Command line to create builds ./lodash[.min].js (must npm install -g lodash-cli)
                                  #MODE... can be:
                                  #  - one of:
                                  #     - compat (déf): supports old browsers
                                  #     - modern: only browsers supporting EcmaScript 5 (IE >=9)
                                  #  - plus any of:
                                  #     - strict: EcmaScript5 strict mode
                                  #     - modularize: put it in several files, for either a category or a single function to
                                  #       include
                                  #       Also available as Node module "lodash-node" (all functions) or "lodash.FUNC" 
                                  #       (a single function)
-d|p                              #Only creates [non-]minified version
-m [FILE]                         #Generates a source map
-o FILE                           #Uses a different DIR/FILE output
-c                                #Prints to stdout instead
-s                                #Silent mode
category=CAT...                   #Include only part of it, among "array", "chain", "collection", "date", "function", "lang",
                                  #"object", "number", "string", "utility"
include=FUNC...                   #
minus|plus=FUNC|CAT...            #Other ways to include|exclude
exports=EXP...                    #Among "amd", "commonjs", "es", "global", "iojs", "node", "npm", "none", "umd"
                                  #"es" and "npm": only with modularize
                                  #"amd": can use moduleId=MODULE_NAME

grunt-lodash                      #Grunt plugin (0.4.0):
                                  #  - TARGET dest
                                  #  - options:
                                  #     - modifier: "modern", etc.
                                  #     - modularize BOOL
                                  #     - category|include|minus|plus|exports STR_ARR
                                  #     - template|settings|moduleId STR
                                  #     - flags|shortFlags STR_ARR: other command line flags


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             MAIN              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__                                #Based on Underscore: is actually an improved superset, some names are changed but aliases
                                  #maintain compatibility, and new methods are added.
                                  #Often require("lodash") is assigned to _, but since Node REPL uses it for last results,
                                  #can assign to __ instead (but can use _ if not in REPL)
__.noConflict()                   #Reverts _ to its previous value, and returns LODASH

COLL                              #Means either ARR|OBJ|STR, to iterate over the values (chars for STR)
                                  #OBJ should not have a property length.
                                  #For OBJ, only own enumerable properties are being iterated.
RCOLL|ROBJ|RARR|RSTR              #Same but iterates from right to left
COLL_ELEM                         #Element of a COLL, i.e. VAL, single element OBJ or single char STR
LFUNC                             #FUNC(VAL, KEY, COLL)->VAL2 fired for each element, that can be instead (if COLL is OBJ_ARR):
                                  #  - STR: same as FUNC(OBJ2) { return OBJ2[STR] }
                                  #  - OBJ3: same as FUNC(OBJ2) { return true if OBJ2 contains OBJ3 }
                                  #Can always be followed by THIS argument: if LFUNC is STR, must return BOOL and THIS is
                                  #defined, means OBJ2[STR] === THIS

__(VAL)                           #Returns a LCHAIN:
                                  #  - OBJ wrapping VAL: get VAL with LCHAIN.value()
                                  #  - LCHAIN.FUNC(...) calls __|ARR|STR.FUNC(VAL, ...)->LCHAIN2
                                  #  - does not return LCHAIN2 if FUNC() returns non-OBJ, unless LCHAIN.chain() fired before
                                  #    or __.chain(VAL) used instead of __(VAL)
                                  #LCHAIN performance:
                                  #  - deffered: only fires LCHAIN functions when:
                                  #     - value() called (returns non-LCHAIN)
                                  #     - commit() called (returns LCHAIN)
                                  #     - returning non-OBJ
                                  #  - pipelined, i.e. chaining reuse same variable (no temp variables), so is faster
                                  #  - lazy evaluated, i.e. each element goes through the whole LCHAIN instead of all element 
                                  #    going through each step. E.g. if finished by __.take(NUM) will be much faster because
                                  #    stops processing after NUM elements.
__.toString()                     #Same as __.value().toString()
__.tap(COLL, LFUNC)               #Fires LFUNC (which can modify each VAL, but should not return it) then returns COLL
__.thru(COLL, LFUNC)              #Fires LFUNC which can modify VAL by returning it
__.plant(VAL)                     #Changes initial VAL from __(VAL), cloning LCHAIN
__.reverse()                      #Changes initial ARR from __(ARR) to __(ARR.reverse())


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          COLLECTION           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__.size(COLL)                     #Returns ARR.length, STR.length or Object.keys(OBJ).length (own enumerable properties)

__.find[Last]([R]COLL, LFUNC)     #Returns the first COLL_ELEM that returns true with LFUNC(), or undefined if none if found
                                  #(for ARR|STR, prefer using __.findIndex())
__.findWhere(OBJ_ARR, OBJ2)       #Returns first OBJ containing OBJ2
__.range([INT, ]INT2[, INT3])     #Like {INT..INT2..INT3} in Bash. INT is 0 by déf, INT3 is 1.

__.forEach[Right]([R]COLL, LFUNC) #Returns COLL
                                  #If LFUNC() returns false, stops the iteration.
                                  #Similar to ARR.forEach()

__.at|pullAt(COLL, KEY[_ARR]...)  #Excludes any VAL not with KEY[_ARR] from COLL, and returns as VAL_ARR
                                  #pullAt removes elements from COLL too, and only works on ARR
__.where(OBJ_ARR, OBJ2)           #Excludes any OBJ not containing OBJ2 from OBJ_ARR
__.without|pull(ARR, VAL...)      #Excludes any VAL... from ARR
                                  #pull removes elements from ARR too.
__.filter|reject(COLL, LFUNC)     #Excludes any VAL where LFUNC() returns false|true
                                  #Similar to native ARR.filter()
__.remove(ARR, LFUNC)             #Same as __.filter() but removes elements from ARR

__.pluck(OBJ)                     #Keeps only values and return them as array.
__.pluck(OBJ_ARR, KEY_STR)        #Keeps only { KEY: VAL } from each OBJ, then returns OBJ_ARR as ARR (with undefined or VAL)
__.sample(COLL[, NUM])            #Keeps NUM random elements, in a random order.
                                  #If no NUM, like 1 but returns a single COLL_ELEM (not a COLL)

__.groupBy(COLL, LFUNC)           #If LFUNC(VAL)->VAL2, returns an OBJ with the VAL2 as keys and VAL_ARR as values.
__.countBy(COLL, LFUNC)           #Same as groupBy() but use VAL_ARR.length NUM instead of VAL_ARR
__.indexBy(COOL, LFUNC)           #Same as groupBy() but use VAL_ARR[-1] VAL instead of VAL_ARR

__.map(COLL, LFUNC)               #Does __.toArray(), then transform each VAL with LFUNC() return value
                                  #Similar to native ARR.map()
__.invoke(OBJ_ARR, FUNC[_STR]     
[, ...])                          #Each OBJ = FUNC|OBJ["FUNC"]([...]), with OBJ as this
__.reduce[Right]([R]COLL, LFUNC   #Fires LFUNC(VAL2, VAL, KEY, COLL) on each VAL, where VAL2 is the return of the last LFUNC()
[, VAL3])                         #reduce() return value is the last LFUNC() return value
                                  #The first VAL2 is VAL3 or (if not provided), the first VAL of COLL.
                                  #Similar to native ARR.reduce[Right]()
__.transform(...)                 #Same as __.reduce(), ex¢ept:
                                  #  - LFUNC() must not return value, but manipulate VAL
                                  #  - can stop the iterations by returning false in LFUNC
                                  #  - Déf VAL3 is [] or {} depending on COLL
__.shuffle(COLL)                  #Shuffles COLL, after applying __.toArray()
                                  #Based on Math.random
__.sortBy(COLL, LFUNC)            #Sorts COLL according to LFUNC return value.
__.sortByAll(COLL, LFUNC[_ARR]...)#Same but use several LFUNC in priority order.
__.sortByOrder(..., BOOL_ARR)     #Same as __.sortByAll(...) but specifies asc|desc with BOOL true|false

__.contains(COLL, VAL[, INT])     #Returns true if VAL is a value of COLL, from index INT (déf: 0, can be negative)
__.every(COLL, LFUNC)             #LFUNC() must return true and every() will return true if LFUNC() returned only true
                                  #Similar to ARR.every()
__.some(COLL, LFUNC)              #Same but returns true if LFUNC() returned at least once true
                                  #Similar to ARR.some()

__.partition(COLL, LFUNC)         #Returns [ ARR, ARR2 ], where ARR has the VALs where LFUNC returned true, ARR2 false


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             ARRAY             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__.flatten(ARR[, BOOL])           #Erase 1 (if BOOL true) or all levels of depth (if BOOL false (déf)).
__.flattenDeep(ARR)               #Same as __.flatten(ARR, true)
__.pairs(OBJ)                     #Transforms to [ [ KEY, VAL ]... ]
__.zipObject(ARR_ARR)             #Inverse.
__.zipObject(ARR[,ARR2])          #Here ARR are the keys and ARR2 the values (déf: [])
__.zip(ARR...)                    #Returns ARR... as ARR_ARR, where ARR numéro NUM has the element numéro NUM of each ARR...
__.chunk(ARR[, NUM])              #Returns as ARR_ARR, where each sublevel has NUM (def: 1) elements (except maybe the last 
                                  #one)

__.slice(ARR, ...)                #Like ARR.slice(...) but crossbrowser
__.fill(ARR, VAL[, NUM[, NUM2]])  #Fills ARR with VAL (from NUM to NUM2)
__.take[Right]([R]ARR[, NUM])     #Returns NUM first|last elements (déf: 1)
__.take[Right]While([R]ARR, LFUNC)#Returns elements until LFUNC returns false.
__.first|last([R]ARR)             #Same as __.take([R]ARR, 1)
__.drop*(...)                     #Same as __.take, but excludes instead of includes
__.initial|rest([R]ARR)           #Same as __.drop([R]ARR, 1)

__.[lastI|i]ndexOf([R]ARR, VAL    
[, BOOL|NUM])                     #Like ARR.[lastI|i]ndexOf(VAL, NUM) except that if BOOL true and ARR is sorted, it is faster.
__.sorted[Last]Index              #Returns index where VAL would be inside sorted ARR (must be sorted).
(ARR, VAL[, LFUNC])               #If LFUNC, do __.map(ARR, LFUNC) first (result ARR must be sorted).
                                  #If several possible positions, choose first|last one.
__.find[Last]Index([R]ARR, LFUNC) #Same as __.find[Last]() but for the first KEY as NUM, or -1 if none is found

__.compact(ARR)                   #Excludes any false, null, 0 or "" from ARR
__.difference(ARR, ARR2...)       #Excludes any VAL of ARR2... from ARR

__.uniq(ARR[, BOOL][, LFUNC])     #Returns ARR without duplicates. If ARR is sorted, use BOOL true to make it faster.
                                  #If LFUNC, do __.map(ARR, LFUNC) first (result ARR must be sorted).
__.intersection(ARR...)           #Returns an ARR2 with values present in all ARR..., without duplicates
__.union(ARR...)                  #Same for values present in any ARR...
__.xor(ARR...)                    #Same for values present in only one ARR...


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            OBJECT             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__.keys[In](OBJ)                  #Like Object.keys() (own [and inherited] enumerable keys), except that if not OBJ, 
                                  #returns [] instead of throwing an error
__.values[In](OBJ)                #Same for values
__.functions(OBJ)                 #Same as __.keys(), but only for FUNC members, and the return ARR is sorted.

__.get(OBJ, VAL[, VAL2])          #Returns OBJ[VAL], but VAL can be "VAR.VAR2..." or [ "VAR", "VAR2", ... ]
                                  #VAL2 is default value.
__.result(...)                    #Like OBJ.get(...), except that if returns a FUNC, returns FUNC() instead
__.set(OBJ, VAL, VAL2)            #Assigns __.get(OBJ, VAL) = VAL2
__.has(OBJ, VAL)                  #Checks if __.get(OBJ, VAL) exists

__.invert(OBJ[, BOOL])            #Invert keys and values, and only keep own enumerable properties.
                                  #If multiple keys per same values, keep only last one if BOOL false (def), or create ARR.

__.assign(OBJ, OBJ2...[, FUNC     #Assign own enumerable properties of OBJ2... to OBJ, then return OBJ
[, THIS]])                        #If FUNC, values being assigned are filtered first by FUNC.call(THIS, OLD_VAL, NEW_VAL)->VAL
__.merge(...)                     #Same as __.assign() but if both OBJ.KEY: OBJ3 and OBJ2.KEY: OBJ4 exists, recursively
                                  #__.assign(OBJ3, OBJ4)
__.defaults(OBJ, OBJ2...)         #Same as __.assign(), except it doesn't assign if OLD_VAL !== undefined
MERGEDEFAULTS(...)               ##Same for __.merge(). Is Node module "merge-defaults"
__.create(OBJ[, OBJ2])            #Like Object.create(), except OBJ2 is simpler: {VAR: VAL} instead of 
                                  #{VAR: {value: VAL, enumerable: true, configurable: true, writable: true}}
                                  #Which means returns OBJ2, where OBJ2.__proto__ pointe vers OBJ
__.mixin(OBJ, OBJ2[,{chain:BOOL}])#Same as __.assign(), except:
                                  #  - doesn't return OBJ, but modify it directly
                                  #  - only copy OBJ2.FUNC members
                                  #  - if BOOL true (déf) and OBJ is __, OBJ2.FUNC can be chained (they will take current
                                  #    chain value as first arg), e.g. __(VAL).FUNC(...) will call OBJ2.FUNC(VAL,...)

__.omit|pick(OBJ, LFUNC)          #Same as __.filter|reject() but:
                                  #  - returns as __.clone(OBJ, false)
                                  #  - LFUNC cannot be OBJ, and can be STR[_ARR]..., meaning the properties names to exclude.
__.find[Last]Key([R]OBJ, LFUNC)   #Same as __.find[Last](...) but for the first KEY_STR, or undefined if none is found

__.forOwn|In[Right]([R]OBJ, LFUNC)#Same as __.forEach[Right](...) but only for OBJ and more efficient for it
                                  #If In, also iterated over inherited enumerable properties.
__.transform(OBJ|ARR, LFUNC       #Interates over own enumerable properties and return OBJ2|ARR2 (def: {} or []).
[, OBJ2|ARR2])                    #LFUNC can return false to stop iteration
__.mapValues|Keys(OBJ, LFUNC)     #Same as __.map(...) but LFUNC() must not return the OBJ but only its value|key 
                                  #(the key|value is kept)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             LANG              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__.toArray(COLL)                  #For:
                                  #  - ARR: does nothing
                                  #  - OBJ: transform to VAL_ARR
                                  #  - STR: transform to STR_ARR (of characters)
__.clone(OBJ[,BOOL][,FUNC[,THIS]])#Returns OBJ by copy (only keep own enumerable properties)
                                  #Nested OBJ are by copy if BOOL true, by reference otherwise (déf: false)
                                  #If FUNC, values being assigned are filtered first by FUNC.call(THIS, NEW_VAL)->VAL
                                  #(excludes if undefined)
__.cloneDeep(OBJ[, ...])          #Same as __.clone(OBJ, true, ...)
__.toPlainObject(OBJ)             #Make enumerable inherited properties become own inherited.

__.isEqual(OBJ, OBJ2              #Deep comparison of own enumerable properties.
[, FUNC(VAL, VAL2)[, THIS]])      #Uses either === or FUNC
__.isMatch(...)                   #Same but only checks if OBJ includes OBJ2

__.isBoolean(VAL)
__.isNumber(VAL)                  #NaN is a NUM
__.isString(VAL)
__.isObject(VAL)
__.isPlainObject(VAL)             
__.isArray(VAL)                   #Like Array.isArray()
__.isTypedArray(VAL)
__.isFunction(VAL)
__.isNative(VAL)                  #Native FUNC
__.isDate(VAL)
__.isRegExp(VAL)
__.isError(VAL)
__.isArguments(VAL)               #True if "arguments"
__.isElement(VAL)                 #Is a DOM ELEMENT

__.isFinite(VAL)                  #Same as isFinite(VAL), except it doesn't returns true for BOOL or ""
__.isNaN(VAL)                     #Same as isNaN(VAL), except it doesn't returns true for undefined and non-NUM
__.isNull(VAL)
__.isUndefined(VAL)
__.isEmpty(VAL)                   #True if Object.keys(OBJ)|ARR|STR.length == 0


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           FUNCTIONS           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__.bind(FUNC[, THIS[, ...]])      #Like FUNC.bind(THIS, ...)
__.partial[Right](FUNC[, ...])    #Like FUNC.bind(null, ...)
                                  #If Right, ... are appended, not prepended.
__.bindKey(OBJ, "FUNC"[, ...])    #Like OBJ.FUNC.bind(OBJ, ...), except that it refers to FUNC as "FUNC", which means 
                                  #if OBJ.FUNC is reassigned, the bound function will refer to the new assigned function.
__.bindAll(OBJ[, "FUNC"...])      #Replace OBJ[.FUNC] by __.bind(FUNC, OBJ) so it is possible to pass OBJ.FUNC as arguments
                                  #without doing OBJ.FUNC.bind(OBJ)
__.wrap(FUNC(...),FUNC2(FUNC,...))#Returns FUNC2.partial( FUNC )
__.createCallback(LFUNC[, NUM])   #Like FUNC.bind(OBJ), except:
                                  #  - Only accepts max NUM arguments
                                  #  - can be LFUNC (i.e. STR or OBJ too)
__.negate(FUNC->BOOL)             #Returns FUNC, but inverse return value

__.ary(FUNC, NUM)                 #Returns FUNC, but can only take max NUM arguments (erased otherwise).
__.flow[Right](FUNC...)           #Returns FUNC(FUNC2(etc.)) (flowRight) or FUNC2(FUNC(etc.)) (flow)
__.curry[Right](FUNC[, NUM])      #Returns FUNC, but makes it possible to fire with only first arguments, in which case it
                                  #returns a bound function, e.g: can be fired with f(1,2,3) or:
                                  #  - curry:      f(1)(2)(3) or f(1,2)(3)
                                  #  - curryRight: f(3)(2)(1) or f(2,3)(1)
                                  #Can also call with _.curry[Right].placeholder (def: __), i.e. not known yet:
                                  #  - curry:      f(__,2)(1,3)
                                  #  - curryRight: f(2,__)(1,3)
                                  #NUM means only consider first NUM arguments (other are ignored)
__.rearg(FUNC, NUM[_ARR]...)      #Returns FUNC, but with different argument position (NUM starting at 0), 
                                  #e.g. [ 1, 0 ] to inverse two arguments positions.
__.restParam(FUNC[, NUM])         #Make argument number NUM (def: last one) variadic, i.e. an ARR
__.spread(FUNC)                   #Returns FUNC, but must call FUNC(ARGS_ARR) instead of FUNC(ARGS...)
 
__.before(NUM, FUNC)              #Returns FUNC that fire only the first NUM times, after wards it just returns last result.
__.once(FUNC)                     #Same as __.before(1, FUNC)
__.after(NUM, FUNC)               #Returns FUNC that doesn't fire the first NUM-1 times.
                                  #Goal is to invoke in a loop of NUM items so it fires at last iteration, but without 
                                  #having to check if it's the last iteration.
__.times(NUM, FUNC[, THIS])       #Fires FUNC(INDEX) NUM times, and returns ARR concatenating all return values 

__.debounce(FUNC, NUM[, OBJ])     #Returns FUNC that invoked accordingly:
                                  #  - fires at beginning if OBJ.leading true (déf: false)
                                  #  - wait for NUM milliseconds. If invoked again, restart the waiting time (but doesn't fire)
                                  #    Expanded time cannot be more than OBJ.maxWait (déf: Infinity, needs to be > NUM)
                                  #  - fires at end if OBJ.trailing true (déf: true)
__.throttle(FUNC, NUM[, OBJ])     #Same except:
                                  #  - If invoked during the wait, doesn't restart waiting time (is just ignored)
                                  #  - OBJ.leading is true by déf
__.delay(FUNC, NUM[, ...])        #Same as setTimeout(FUNC[.bind(null, ...)], NUM)
__.defer(FUNC[, ...])             #Same as __.delay(FUNC, 0, ...)

__.memoize(FUNC[, FUNC2])         #Returns FUNC with a FUNC.cache OBJ
                                  #Each time FUNC(...) is fired: 
                                  #  - FUNC.cache[FUNC2(...)] = FUNC(...) 
                                  #  - or cache is used if existing (FUNC() is not performed)
                                  #Déf FUNC2 caches according to first argument: 
                                  #  - return KEY_STR + FIRST_ARG, 
                                  #  - where KEY_STR is new Date() as UINT_STR, when lodash was loaded

__.property(STR)                  #Returns function(OBJ) { return OBJ[STR]; }
__.constant(VAL)                  #Returns function() { return VAL; }
__.identity(VAL)                  #Returns VAL
__.noop()                         #Does nothing


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            STRING             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__.starts|endsWith(STR,STR2[,NUM])#NUM (def: 0|end)

__.camelCase(STR)                 #aBcDe
__.capitalize(STR)                #Abcde
__.kebabCase(STR)                 #a-bc-de
__.snakeCase(STR)                 #a_bc_de
__.startCase(STR)                 #A Bc De

__.repeat(STR, NUM)               #Concatenates STR NUM times
__.pad[Left|Right](STR,NUM[,STR2])#Adds STR2 (def: " ") on left and|or right of STR, so that it is of Unicode length STR
__.trim[Left|Right](STR[, STR2])  #STR2 (def: whitespaces)
__.trunc(STR[, NUM][, STR2]       #Truncates STR at max NUM (def: 30) length chars, adding ellipsis STR2 (def: "…")
[, REGEXP|STR3])                  #If REGEXP|STR3 defining words, make sure only full words are output.
__.trunc(STR[, OBJ])              #Same using OBJ.length|omission|separator
__.words(STR[, REGEXP])           #Splits as STR_ARR. REGEXP is not the delimited, but the words (def: a word only contains
                                  #[[:alnum:]], and a uppercase means a new word)

__.[un]escape(STR)                #HTML escape: & < > " ' to ampersand sequences
__.escapeRegExp(STR)              #RegExp escape: \ / ^ $ . | ? * + ( ) [ ] { }
__.deburr(STR)                    #Replaces accents by letter without accent

__.parseInt(STR[, NUM])           #Same as native, but crossbrowser

__.template(STR[, OBJ[, OBJ2]])   #Returns a FUNC(OBJ3) that interpolate following sequences, using OBJ3 as context 
                                  #(current context also used):
                                  #  <%= EXPR %> 
                                  #  ${EXPR}     -> VAL
                                  #  <%- EXPR %> -> __.escape(VAL)
                                  #  <% EXPR %>  -> executes EXPR, then returns ""
                                  #                 Inside EXPR, executing %>...<% or print(STR) concatenates "..." to 
                                  #                 return value, without stopping EXPR
                                  #                 "..." can contain other templates, recursively interpreted after insertion
                                  #                 Ex:
                                  #                    __.template('<% [a,b].forEach(function(c){ %> <%= c %> <% }) %>', 
                                  #                    {a:1,b:2});      // " 1  2 "
                                  #If OBJ is provided, returns FUNC(OBJ) result directly.
                                  #OBJ2 (def: from __.templateSettings) are options:
                                  #  - interpolate REGEXP: to replace <% %>, must be /...(...).../g
                                  #    For mustache-like: /{{([\s\S]+?)}}/g
                                  #  - escape|evaluate REGEXP: same for <%- %> and <% %>
                                  #    Default interpolations are /<%-([\s\S]+?)%>/g, etc.
                                  #  - imports OBJ: merged (with lower priority) into OBJ3
                                  #  - sourceURL STR: source of the template (like source maps: show original file in debugger)
TEMPLATE(STR[, OBJ[, OBJ2]])      #Node module "template"
                                  #Same but process templates recursively, and OBJ2 options have also:
                                  #  - delims STR_ARR, e.g. [ '{{', '}}' ]
TEMPLATE.read(...)                #Same but STR is a filename
TEMPLATE.copy(STR, STR2[, OBJ     #Like TEMPLATE.read(), but copy to file STR2 instead of returning value.
[,OBJ2]])                         #Can use OBJ2.process: false to disable processing (so only copy file).

lodash template="GLOB_FILES"      #lodash-cli (see above). GLOB_FILES are Lodash templates files (e.g. containing <%= EXPR %>)
                                  #Creates files which when required load: { FILENAME: FUNC(OBJ3) ... }
settings="OBJ2"                   #Same OBJ2 as __.template()


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             MATH              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__.add(NUM, NUM2)                 #Returns NUM + NUM2
__.sum(COLL[, LFUNC])             #Like __.reduce() with default LFUNC __.add()
__.min|max(COLL[, LFUNC])         #Returns the COLL_ELEM that returns the min|max value with LFUNC() (def: __.identity)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            NUMBER             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__.range(NUM[, NUM2], NUM3)       #NUM >= NUM2 (def: 0) && NUM < NUM3
__.random([INT][, INT2][, BOOL])  #INT is min (déf: 0), INT2 max excluded (déf: 1), BOOL floating point (déf: false)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             DATE              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__.now()                          #Same as (new Date()).getTime()


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           UTILITIES           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__.uniqueId([STR])                #Returns STR + NUM, where NUM is incrementing (relative to __)
