
             
   LO-DASH   
             



VERSION ==>                       #Version 2.4.2
                                  #Is a Node module or a client-side script

lodash [MODE...]                  #Command line to create minified builds ./lodash.min.js (must npm install -g lodash-cli)
                                  #MODE... can be:
                                  #  - one of:
                                  #     - modern: browsers supporting EcmaScript 5
                                  #     - mobile
                                  #     - compat (déf): normal
                                  #     - legacy: old browsers
                                  #     - backbone: for use with Backbone.js
                                  #  - plus any of:
                                  #     - strict: EcmaScript5 strict mode
                                  #     - underscore: make it 100% compatible with Underscore (when using as replacement)
                                  #     - modularize: put it in several files, for either a category or a single function to
                                  #       include
                                  #       Also available as Node module "lodash-node" (all functions) or "lodash.FUNC" 
                                  #       (a single function)
-d                                #Create non-minified version instead ./lodash.js
-p [FILE]                         #Generates a source map
-o FILE                           #Uses a different DIR/FILE output
-c                                #Prints to stdout instead
-s                                #Silent mode
category=CAT...                   #Include only part of it, among "arrays", "chaining", "collections", "functions", "objects"
                                  #and "utilities"
include=FUNC...                   #
minus|plus=FUNC|CAT...            #Other ways to include|exclude
exports=EXP...                    #Among "amd", "commonjs", "global", "node", "npm" and "none"

grunt-lodash                      #Grunt plugin:
                                  #  - TARGET dest
                                  #  - options:
                                  #     - modifier: "backbone", "modern", etc.
                                  #     - modularize BOOL
                                  #     - category|include|minus|plus|exports STR_ARR
                                  #     - flags STR_ARR: other command line flags


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             MAIN              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__                                #Based on Underscore: is actually an improved superset, some names are changed but aliases
                                  #maintain compatibility, and new methods are added.
                                  #Often require("lodash") is assigned to _, but since Node REPL uses it for last results,
                                  #can assign to __ instead (but can use _ if not in REPL)
__.noConflict()                   #Reverts _ to its previous value, and returns LODASH

COLL                              #Means either ARR|OBJ|STR, to iterate over the values (chars for STR)
                                  #OBJ should not have a property length.
                                  #For OBJ, only own enumerable properties are being iterated.
RCOLL|ROBJ|RARR                   #Same but iterates from right to left
COLL_ELEM                         #Element of a COLL, i.e. VAL, single element OBJ or single char STR
LFUNC                             #FUNC(VAL, KEY, COLL)->VAL2 fired for each element, that can be instead (if COLL is OBJ_ARR):
                                  #  - STR: same as FUNC(OBJ2) { return OBJ2[STR] }
                                  #  - OBJ3: same as FUNC(OBJ2) { return true if OBJ2 contains OBJ3 }
                                  #Can always be followed by this argument.

__(VAL)                           #Returns a LCHAIN, i.e. an OBJ wrapping VAL, so that one can do LCHAIN.FUNC(...), where 
                                  #FUNC is any __.FUNC or ARR.FUNC (if VAL is ARR)
                                  #Only available if __.FUNC() have a first required|significant argument.
                                  #If LCHAIN.FUNC() returns an OBJ, wrap return value in another LCHAIN2.
                                  #Otherwise (if native type), returns value as is, unless LCHAIN.chain() has been fired before
                                  #or __.chain(VAL) used instead of __(VAL)
                                  #Can get underlying VAL with LCHAIN.valueOf()
__.tap(VAL,FUNC(VAL))             #Returns VAL, after firing FUNC, which does not return but is expected to modify VAL
                                  #To be used in a chain to change the currently processed chain.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          COLLECTIONS          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__.toArray(COLL)                  #For:
                                  #  - ARR: does nothing
                                  #  - OBJ: transform to VAL_ARR
                                  #  - STR: transform to STR_ARR (of characters)
__.flatten(ARR[, BOOL][, LFUNC])  #Erase 1 (if BOOL true) or all levels of depth (if BOOL false (déf)).
                                  #If LFUNC, do __.map(ARR, LFUNC) first.
__.pairs(OBJ)                     #Transforms to [ [ KEY, VAL ]... ]
__.zipObject(ARR_ARR)             #Inverse.
__.zipObject(ARR[,ARR2])          #Here ARR are the keys and ARR2 the values (déf: [])
__.zip(ARR...)                    #Returns ARR... as ARR_ARR, where ARR numéro NUM has the element numéro NUM of each ARR...

__.size(COLL)                     #Returns ARR.length, STR.length or Object.keys(OBJ).length (own enumerable properties)
__.first|last([R]ARR[, LFUNC|NUM])#Returns NUM first elements (déf: 1), or first until LFUNC() returns false
__.initial|rest([R]ARR            #Same as __.first|last(), except NUM is number of elements excluded (not included), and
[, LFUNC|NUM])                    #LFUNC() stops when returning true.
__.[lastI|i]ndexOf([R]ARR, VAL    
[, BOOL|NUM])                     #Like ARR.[lastI|i]ndexOf(VAL, NUM) except that if BOOL true and ARR is sorted, it is faster.
__.sortedIndex(ARR, VAL[, LFUNC]) #Returns index where VAL would be inside sorted ARR (must be sorted).
                                  #If LFUNC, do __.map(ARR, LFUNC) first (result ARR must be sorted).
__.find[Last]([R]COLL, LFUNC)     #Returns the first COLL_ELEM that returns true with LFUNC(), or undefined if none if found
                                  #(for ARR|STR, prefer using __.findIndex())
__.find[Last]Key([R]COLL, LFUNC)  #Same but for the first KEY_STR, or undefined if none is found
__.find[Last]Index([R]ARR, LFUNC) #Same but for the first KEY as NUM, or -1 if none is found
__.range([INT, ]INT2[, INT3])     #Like {INT..INT2..INT3} in Bash. INT is 0 by déf, INT3 is 1.
__.min|max(COLL, LFUNC)           #Returns the COLL_ELEM that returns the min|max value with LFUNC()

__.forEach[Right]([R]COLL, LFUNC) #Returns COLL
                                  #If LFUNC() returns false, stops the iteration.
                                  #Similar to ARR.forEach()
__.forOwn|In[Right]([R]OBJ, LFUNC)#Same but only for OBJ and more efficient for it
                                  #If In, also iterated over inherited enumerable properties.

__.at(COLL, KEY[_ARR]...)         #Excludes any VAL not with KEY[_ARR] from COLL, and returns as VAL_ARR
__.where(OBJ_ARR, OBJ2)           #Excludes any OBJ not containing OBJ2 from OBJ_ARR
__.compact(ARR)                   #Excludes any false, null, 0 or "" from ARR
__.difference(ARR, ARR2...)       #Excludes any VAL of ARR2... from ARR
__.pull|without(ARR, VAL...)      #Excludes any VAL... from ARR
                                  #pull removes elements from ARR too.
__.filter|reject(COLL, LFUNC)     #Excludes any VAL where LFUNC() returns false|true
                                  #Similar to native ARR.filter()
__.omit|pick(OBJ, LFUNC)          #Same but:
                                  #  - returns as __.clone(OBJ, false)
                                  #  - LFUNC cannot be OBJ, and can be STR[_ARR]..., meaning the properties names to exclude.
__.remove(ARR, LFUNC)             #Same as __.filter() but removes elements from ARR

__.pluck(OBJ)                     #Keeps only values and return them as array.
__.pluck(OBJ_ARR, KEY_STR)        #Keeps only { KEY: VAL } from each OBJ, then returns OBJ_ARR as ARR (with undefined or VAL)
__.sample(COLL[, NUM])            #Keeps NUM random elements, in a random order.
                                  #If no NUM, like 1 but returns a single COLL_ELEM (not a COLL)

__.groupBy(COLL, LFUNC)           #If LFUNC(VAL)->VAL2, returns an OBJ with the VAL2 as keys and VAL_ARR as values.
__.countBy(COLL, LFUNC)           #Same as groupBy() but use VAL_ARR.length NUM instead of VAL_ARR
__.indexBy(COOL, LFUNC)           #Same as groupBy() but use VAL_ARR[-1] VAL instead of VAL_ARR

__.map(COLL, LFUNC)               #Does __.toArray(), then transform each VAL with LFUNC() return value
                                  #Similar to native ARR.map()
__.mapValues(OBJ, LFUNC)          #Same but doesn't do __.toArray()
__.invoke(OBJ_ARR, FUNC[_STR]     
[, ...])                          #Each OBJ = FUNC|OBJ["FUNC"]([...]), with OBJ as this
__.reduce[Right]([R]COLL, LFUNC   #Fires LFUNC(VAL2, VAL, KEY, COLL) on each VAL, where VAL2 is the return of the last LFUNC()
[, VAL3])                         #reduce() return value is the last LFUNC() return value
                                  #The first VAL2 is VAL3 or (if not provided), the first VAL of COLL.
                                  #Similar to native ARR.reduce[Right]()
__.transform(...)                 #Same as __.reduce(), ex¢ept:
                                  #  - LFUNC() must not return value, but manipulate VAL
                                  #  - can stop the iterations by returning false in LFUNC
                                  #  - Déf VAL3 is [] or {} depending on COLL
__.shuffle(COLL)                  #Shuffles COLL, after applying __.toArray()
                                  #Based on Math.random
__.sortBy(COLL, LFUNC)            #Sorts COLL according to LFUNC return value.
                                  #LFUNC can be STR_ARR, meaning each STR will be used in order of priority to sort.
__.uniq(ARR[, BOOL][, LFUNC])     #Returns ARR without duplicates. If ARR is sorted, use BOOL true to make it faster.
                                  #If LFUNC, do __.map(ARR, LFUNC) first (result ARR must be sorted).
__.intersection(ARR...)           #Returns an ARR2 with values present in all ARR..., without duplicates
__.union(ARR...)                  #Same for values present in any ARR...
__.xor(ARR...)                    #Same for values present in only one ARR...

__.contains(COLL, VAL[, INT])     #Returns true if VAL is a value of COLL, from index INT (déf: 0, can be negative)
__.every(COLL, LFUNC)             #LFUNC() must return true and every() will return true if LFUNC() returned only true
                                  #Similar to ARR.every()
__.some(COLL, LFUNC)              #Same but returns true if LFUNC() returned at least once true
                                  #Similar to ARR.some()



																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            OBJECTS            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__.keys(OBJ)                      #Like Object.keys() (own enumerable keys), except that if not OBJ, returns [] instead of 
                                  #throwing an error
__.values(OBJ)                    #Same for values
__.functions(OBJ)                 #Same as __.keys(), but only for FUNC members, and the return ARR is sorted.
__.has(OBJ, STR)                  #Same as OBJ.hasOwnProperty(STR)
__.result(OBJ, STR)               #Like OBJ.STR, except that if it is a FUNC, it returns FUNC()

__.assign(OBJ, OBJ2...[, FUNC     #Assign own enumerable properties of OBJ2... to OBJ, then return OBJ
[,this]])                         #If FUNC, values being assigned are filtered first by FUNC.call(this, OLD_VAL, NEW_VAL)->VAL
__.merge(...)                     #Same as __.assign() but if both OBJ.KEY: OBJ3 and OBJ2.KEY: OBJ4 exists, recursively
                                  #__.assign(OBJ3, OBJ4)
__.defaults(OBJ, OBJ2...)         #Same as __.assign(), except it doesn't assign if OLD_VAL !== undefined
MERGEDEFAULTS(...)               ##Same for __.merge(). Is Node module "merge-defaults"
__.create(OBJ[, OBJ2])            #Like Object.create(), except OBJ2 is simpler: {VAR: VAL} instead of 
                                  #{VAR: {value: VAL, enumerable: true, configurable: true, writable: true}}
                                  #Which means returns OBJ2, where OBJ2.__proto__ pointe vers OBJ
__.mixin(OBJ, OBJ2[,{chain:BOOL}])#Same as __.assign(), except:
                                  #  - doesn't return OBJ, but modify it directly
                                  #  - only copy OBJ2.FUNC members
                                  #  - if BOOL true (déf) and OBJ is __, OBJ2.FUNC can be chained (they will take current
                                  #    chain value as first arg), e.g. __(VAL).FUNC(...) will call OBJ2.FUNC(VAL,...)
__.clone(OBJ[,BOOL][,FUNC[,this]])#Returns OBJ by copy (only keep own enumerable properties)
                                  #Nested OBJ are by copy if BOOL true, by reference otherwise (déf: false)
                                  #If FUNC, values being assigned are filtered first by FUNC.call(this, NEW_VAL)->VAL
                                  #(excludes if undefined)
__.cloneDeep(OBJ[, FUNC[, this]]) #Same as __.clone(OBJ, true, ...)

__.isEqual(OBJ, OBJ2              #Deep comparison of own enumerable properties.
[, FUNC(VAL,VAL2)[, this]])       #Uses either === or FUNC

__.invert(OBJ)                    #Invert keys and values, and only keep own enumerable properties.

__.isBoolean(VAL)
__.isNumber(VAL)                  #NaN is a NUM
__.isString(VAL)
__.isObject(VAL)
__.isPlainObject(VAL)             
__.isArray(VAL)                   #Like Array.isArray()
__.isFunction(VAL)
__.isDate(VAL)
__.isRegExp(VAL)
__.isArguments(VAL)               #True if "arguments"
__.isElement(VAL)                 #Is a DOM ELEMENT

__.isFinite(VAL)                  #Same as isFinite(VAL), except it doesn't returns true for BOOL or ""
__.isNaN(VAL)                     #Same as isNaN(VAL), except it doesn't returns true for undefined and non-NUM
__.isNull(VAL)
__.isUndefined(VAL)
__.isEmpty(VAL)                   #True if Object.keys(OBJ)|ARR|STR.length == 0


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           FUNCTIONS           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__.bind(FUNC[, THIS[, ...]])      #Like FUNC.bind(THIS, ...)
__.partial[Right](FUNC[, ...])    #Like FUNC.bind(null, ...)
                                  #If Right, ... are appended, not prepended.
__.bindKey(OBJ, "FUNC"[, ...])    #Like OBJ.FUNC.bind(OBJ, ...), except that it refers to FUNC as "FUNC", which means 
                                  #if OBJ.FUNC is reassigned, the bound function will refer to the new assigned function.
__.bindAll(OBJ[, "FUNC"...])      #Replace OBJ[.FUNC] by __.bind(FUNC, OBJ) so it is possible to pass OBJ.FUNC as arguments
                                  #without doing OBJ.FUNC.bind(OBJ)
__.wrap(FUNC(...),FUNC2(FUNC,...))#Returns FUNC2.partial( FUNC )
__.createCallback(LFUNC[, NUM])   #Like FUNC.bind(OBJ), except:
                                  #  - Only accepts max NUM arguments
                                  #  - can be LFUNC (i.e. STR or OBJ too)

__.compose(FUNC...)               #Returns FUNC(FUNC2(etc.))
__.curry(FUNC)                    #Returns FUNC, but makes it possible to fire with only first arguments, in which case it
                                  #returns a bound function, e.g:
                                  #  var f = __.curry(function(a,b,c){})
                                  #Can be fired with f(1,2,3) or f(1)(2)(3)

__.once(FUNC)                     #Returns FUNC that fire only the first time, the next time it just returns first time result.
__.after(NUM, FUNC)               #Returns FUNC that doesn't fire the first NUM-1 times.
                                  #Goal is to invoke in a loop of NUM items so it fires at last iteration, but without 
                                  #having to check if it's the last iteration.
__.times(NUM, FUNC[, THIS])       #Fires FUNC(INDEX) NUM times, and returns ARR concatenating all return values 

__.debounce(FUNC, NUM[, OBJ])     #Returns FUNC that invoked accordingly:
                                  #  - fires at beginning if OBJ.leading true (déf: false)
                                  #  - wait for NUM milliseconds. If invoked again, restart the waiting time (but doesn't fire)
                                  #    Expanded time cannot be more than OBJ.maxWait (déf: Infinity, needs to be > NUM)
                                  #  - fires at end if OBJ.trailing true (déf: true)
__.throttle(FUNC, NUM[, OBJ])     #Same except:
                                  #  - If invoked during the wait, doesn't restart waiting time (is just ignored)
                                  #  - OBJ.leading is true by déf
__.delay(FUNC, NUM[, ...])        #Same as setTimeout(FUNC[.bind(null, ...)], NUM)
__.defer(FUNC[, ...])             #Same as __.delay(FUNC, 0, ...)

__.memoize(FUNC[, FUNC2])         #Returns FUNC with a FUNC.cache OBJ
                                  #Each time FUNC(...) is fired: 
                                  #  - FUNC.cache[FUNC2(...)] = FUNC(...) 
                                  #  - or cache is used if existing (FUNC() is not performed)
                                  #Déf FUNC2 caches according to first argument: 
                                  #  - return KEY_STR + FIRST_ARG, 
                                  #  - where KEY_STR is new Date() as UINT_STR, when lodash was loaded

__.property(STR)                  #Returns function(OBJ) { return OBJ[STR]; }
__.constant(VAL)                  #Returns function() { return VAL; }
__.identity(VAL)                  #Returns VAL
__.noop()                         #Does nothing

																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           UTILITIES           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


__.template(STR[, OBJ[, OBJ2]])   #Returns a FUNC(OBJ3) that interpolate following sequences, using OBJ3 as context 
                                  #(current context also used):
                                  #  <%= EXPR %> 
                                  #  ${EXPR}     -> VAL
                                  #  <%- EXPR %> -> __.escape(VAL)
                                  #  <% EXPR %>  -> executes EXPR, then returns ""
                                  #                 Inside EXPR, executing %>...<% or print(STR) concatenates "..." to 
                                  #                 return value, without stopping EXPR
                                  #                 "..." can contain other templates, recursively interpreted after insertion
                                  #                 Ex:
                                  #                    __.template('<% [a,b].forEach(function(c){ %> <%= c %> <% }) %>', 
                                  #                    {a:1,b:2});      // " 1  2 "
                                  #If OBJ is provided, returns FUNC(OBJ) result directly.
                                  #OBJ2 are options:
                                  #  - interpolate REGEXP: to replace <% %>, must be /...(...).../g
                                  #    For mustache-like: /{{([\s\S]+?)}}/g
                                  #  - escape|evaluate REGEXP: same for <%- %> and <% %>
                                  #    Default interpolations are /<%-([\s\S]+?)%>/g, etc.
                                  #Default settings are in __.templateSettings
TEMPLATE(STR[, OBJ[, OBJ2]])      #Node module "template"
                                  #Same but process templates recursively, and OBJ2 options have also:
                                  #  - delims STR_ARR, e.g. [ '{{', '}}' ]
TEMPLATE.read(...)                #Same but STR is a filename
TEMPLATE.copy(STR, STR2[, OBJ     #Like TEMPLATE.read(), but copy to file STR2 instead of returning value.
[,OBJ2]])                         #Can use OBJ2.process: false to disable processing (so only copy file).

__.[un]escape(STR)                #HTML escape: & < > " ' to ampersand sequences

__.random([INT][, INT2][, BOOL])  #INT is min (déf: 0), INT2 max excluded (déf: 1), BOOL floating point (déf: false)
__.uniqueId([STR])                #Returns STR + NUM, where NUM is incrementing (relative to __)
