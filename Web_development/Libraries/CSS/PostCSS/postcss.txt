
             
   POSTCSS   
             


VERSION ==>                       #5.0.19
                                  #CSS parser/stringifier, with good plugins support, allowing easy CSS processing.

CSS PARSERS COMPARISONS ==>       #PostCSS has more audience and is better fit for processing plugins.
                                  #One might want to also check gonzales-pe and reworkcss/css parsers.

SUMMARY ==>                       #  - parsing/stringifier of CSS
                                  #  - use plugins middleware and can customize parsing/stringifier to support new syntax
                                  #  - reporting is done separately


CONFIG ==>                        #Can be:  
                                  #  - postcss --config CONF_FILE
CONF_FILE                         #JSON or Node module exporting CONF_OBJ 
CONF_OBJ.OPT                      #Like postcss --OPT


postcss [FILE|DIR...]             #Def: stdin
                                  #Version 2.5.1
--output FILE                     #Def: stdout
--dir DIR                         #
--replace                         #Replace input file

--watch                           #

--[no-]map [FILE]                 #Sourcemaps (def: inline)
--[no-]map.inline                 #Inline sourcemaps (def: true)
--[no-]map.annotation 'FILE'      #Sourcemap output
--[no-]map.prev 'FILE'            #Sourcemaps from a previous compilation step, e.g. Sess/Less
                                  #Def: automatically detects it
--[no-]map.sourcesContent         #Sets sourcemap origin (def: true)



             
   PLUGINS   
             



																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            PLUGINS            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


CONF_OBJ.plugin                   
postcss --PLUGIN.option           #PLUGIN_OPTS

postcss 
--use PLUGIN ...                  #
--local-plugins                   #Require PLUGIN from $PWD, as opposed to DIR where PostCSS is installed

POSTCSS.plugin                    #PLUGIN() is middleware called during PROCESSOR.process():
('PLUGIN', PLUGINFUNC(PLUGIN_OPTS)#  - ROOT can be modified. It can also be replaced by assigning RESULT.root      
->PLUGIN(ROOT,RESULT))->PLUGINFUNC#  - RESULT can get extra messages.
                                  #  - PLUGIN() must return PROMISE if async 
PLUGINFUNC(PLUGIN_OPTS)->PLUGIN   #
PLUGINFUNC.postcss                #PLUGIN (from PLUGINFUNC()) created right away

POSTCSS([VAL_ARR])->PROCESSOR     
PROCESSOR.use(VAL)->PROCESSOR     #VAL can be:
                                  #  - any FUNC(ROOT, RESULT), including PLUGIN
                                  #  - { postcss(ROOT, RESULT) ... }: use OBJ.postcss
                                  #  - PLUGINFUNC: use PLUGINFUNC.postcss
                                  #  - PROCESSOR2: use PROCESSOR2.plugins
@use PLUGIN([PLUGN_OPT: VAL,...])##Loads Plugin from CSS, for a given files
@use PLUGIN PLUGIN_OPTS          ##Use POSTCSS-USE PLUGIN (2.0.2) with PLUGIN_OPTS:
                                 ##  - modules VAL[_ARR]: plugins to whitelist (mandatory)
                                 ##    Can be '*'

PROCESSOR.plugins                 #PLUGIN_ARR
PLUGIN.postcssPlugin              #'PLUGIN'
PLUGIN.postcssVersion             #PostCSS version


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            CUSTOM             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


postcss --parser MODULE           #Resolving to PARSER
CONF_OBJ.parser                   #PARSER
PARSER('CSS', CONF_OBJ)->ROOT     #PARSER does the 'CSS'->ROOT conversion, which helps using PostCSS with something different
                                  #than standard CSS (e.g. Sass/Less)

postcss --stringifier MODULE      #Resolving to STRINGIFIER
CONF_OBJ.stringifier              #STRINGIFIER
NODE.toString(STRINGIFIER)        #
STRINGIFIER                       #STRINGIFIER does the ROOT->final output conversion (formatter)
(ROOT,FUNC(STR,NOD[,'start|end']))#Must call each successive NODE with FUNC, and provide corresponding output STR.

postcss --syntax MODULE           #Resolving to SYNTAX
CONF_OBJ.syntax                   #SYNTAX
SYNTAX                            #Is { parser: PARSER, stringifier: STRINGIFIER }



                
   PROCESSING   
                


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          PROCESSING           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


POSTCSS.parse('CSS', OBJ)->ROOT   #OBJ:
                                  #  - from 'FILE'
                                  #  - map: inline BOOL, annotation 'FILE'|BOOL, prev 'FILE'|BOOL, sourcesContent BOOL

PROCESSOR.process                 #CONF_OBJ also has:
('CSS'|ROOT|RESULT, CONF_OBJ)     #  - from|to 'FILE'
->PROMISE(RESULT)                 #  - map: same as POSTCSS.parse()
                                  #When using synchronous plugins, can use PROMISE.result RESULT instead
                                  #Note: processing is only fired when PROMISE.then|catch() or RESULT.FUNC() is called
PLUGINFUNC.process(VAL, CONF_OBJ) #Same as POSTCSS([PLUGINFUNC(CONF_OBJ)]).process(VAL, CONF_OBJ)

RESULT.root                       #ROOT
RESULT.toString()                 
RESULT.css|content                #Same as RESULT.root.toString()

RESULT.warn('REASON', OBJ)        #Same as OBJ.node.warn('REASON', OBJ), but node is optional.
RESULT.warnings()->WARNING_ARR    #
RESULT.messages                   #CSSSYNTAXERR|WARNING_ARR

RESULT.map                        #Similar to INPUT.map
RESULT.processor                  #PROCESSOR
RESULT.opts                       #OBJ passed to PROCESSOR.process() or to ROOT.toResult()


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             NODE              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


NODE                              #
NODE_PROPS                        #Plain OBJ with attributes specific to a NODE|CONTAINER subtype, e.g. name|params for ATRULE
NODE.type                         #'root|atrule|rule|decl|comment'

NODE.toString()->'CSS'            #
NODE.raws                         #OBJ:
                                  #  (RULE|DECLARATION|ATRULE|COMMENT)
                                  #  - before STR: whitespaces and browser hacks before NODE, before/* for a COMMENT
                                  #  (ROOT|RULE|COMMENT)
                                  #  - after STR: whitespaces and browser hacks after NODE, after */ for a COMMENT
                                  #  (ROOT|RULE)
                                  #  - semicolon BOOL: true if last child has it
                                  #  (RULE|DECLARATION)
                                  #  - between STR: anything in-between
                                  #  (ATRULE)
                                  #  - afterName STR: whitespaces between @RULE and VAL
                                  #  (DECLARATION)
                                  #  - important STR
NODE.raw('VAR')                   #Similar to NODE.raws.VAR, except fill in default
NODE.source                       #Location from input file (for sourcemaps) as OBJ:
                                  #  - input INPUT
                                  #  - start|end: line|column NUM
                                  #Will be null when creating new NODE from scratch. Should then take a NODE with source and
                                  #either copy its NODE.source or clone it.

NODE.root()->ROOT                 #
NODE.parent                       #NODE|undefined
NODE.prev|next()->NODE|undefined  #Siblings
                                  #Fires exception for ROOT

NODE.moveTo(CONTAINER)            #
NODE.moveBefore|After(NODE2)      #
NODE.remove()                     #
NODE.replaceWith(NODE2...)        #
NODE.clone([OBJ])->NODE2          #OBJ is assigned to NODE2
NODE.cloneBefore|After([OBJ])     #Clone then inserts before|after

NODE.error('REASON'[, OBJ])       #OBJ:
->CSSSYNTAXERR                    #  - plugin 'PLUGIN' (def: set automatically)
                                  #  - word STR: highlight this word
                                  #  - index NUM: highlight this character
NODE.warn(RESULT, 'REASON'[, OBJ])#Same OBJ as NODE.error()
                                  #Adds a WARNING to RESULT.messages


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           CONTAINER           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


CONTAINER                         #NODE that contain other NODE
CONTAINER.nodes                   #NODE_ARR
CONTAINER.first|last              #NODE
CONTAINER.index(NODE)->NUM|-1     #

CONTAINER.every|some(FUNC)        #Same as CONTAINER.nodes.every|some(FUNC)
CONTAINER.each(FUNC)              #Same as CONTAINER.nodes.each(FUNC) except:
                                  #  - can return false to stop iteration
                                  #  - safe if mutation children during iteration
CONTAINER.walk(FUNC(NODE, NUM))   #Like CONTAINER.each() but iterates over descendants
CONTAINER.walkDecls|              #Like CONTAINER.walk() but:
AtRules|Rules|Comments            #  - filters only DECLARATION|ATRULE|RULE|COMMENT
([STR|REGEXP, ]FUNC(NODE, NUM))   #  - filters according to STR|REGEXP:
                                  #     - used to match DECLARATION.prop, ATRULE.name or RULE selector
                                  #     - not used for COMMENT
CONTAINER.replaceValues           #Replace children DECLARATION values.
(STR|REGEXP[, OBJ], STR2[(...)])  #STR2(...) gets same arguments as STR.replace(...)
                                  #OBJ:
                                  #  - props 'PROP'_ARR: only for those properties
                                  #  - fast 'STR': does indexOf(STR) before performing REGEXP.test(), just can be performance
                                  #    boost

CONTAINER.prepend|append          #NODE_VAL can be:
(NODE_VAL[_ARR]...)               #  - NODE
                                  #  - NODE_PROPS
                                  #  - 'CSS' (slower)
CONTAINER.insertBefore|After
(NODE|NUM, NODE_VAL)              #
CONTAINER.removeChild(NODE|NUM)   #
CONTAINER.removeAll()             #

																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             NODES             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


POSTCSS.root|atRule|rule|decl|
comment([NODE_PROPS])->ROOT|
ATRULE|RULE|DECLARATION|COMMENT   #Creates new NODE of that type

ROOT                              #CSS file, as CONTAINER
ROOT.toResult(OBJ)->RESULT        #OBJ: same as POSTCSS.parse()

ATRULE                            #'@RULE VAL... [{ ... }]', as CONTAINER
                                  #{ ... } are children
ATRULE.name                       #'RULE'
ATRULE.params                     #'VAL...'

RULE                              #'SELECTORS { ... }', as CONTAINER
                                  #{ ... } are children
RULE.selector                     #'SELECTORS'. See POSTCSS-SELECTOR-PARSER to parse this.
RULE.selectors                    #'SELECTOR'_ARR

DECLARATION                       #'PROP: VAL', as NODE
DECLARATION.prop                  #'PROP'
DECLARATION.value                 #'VAL'
DECLARATION.important             #BOOL

COMMENT                           #'/* COMMENT */', as NODE
COMMENT.text                      #'COMMENT'


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           SELECTORS           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


POSTCSS-SELECTOR-PARSER           
(FUNC(S_ROOT))->PROCESSOR        ##Does selector parsing (1.3.3)
PROCESOR.process('CSS')->PROCESOR##
PROCESSOR.result                 ##'CSS'


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         SELECTOR NODE         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


S_NODE                           ##Like NODE but for selectors

S_NODE.type                      ##'attribute|class|combinator|comment|id|nesting|pseudo|root|selector|string|tag|universal'
S_NODE.parent|toString|next|prev|
replaceWith|remove|clone(...)    ##Like NODE
S_NODE.spaces.before|after       ##Like NODE.raws.before|after

S_NODE.source                    ##Like NODE, but without OBJ.input, and not on S_ROOT|SELECTOR
S_NODE.sourceIndex               ##Place NUM inside CSS file. Not on S_ROOT|SELECTOR



																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:      SELECTOR CONTAINER       :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


S_CONTAINER                      ##Like CONTAINER but for selectors, i.e. contains S_NODE

S_CONTAINR.nodes|first|last|index##Like CONTAINER
S_CONTAINER.every|some|each|walk|
prepend|append|insertBefore|After|
removeChild|removeAll(...)       ##Like CONTAINER, except arguments can only be S_NODE
S_CONTAINER.map|reduce|filter|sort
(...)                            ##Like CONTAINER.nodes.map|reduce|filter|sort(...)

S_CONTAINER.walkAttributes|
Classes|Combinators|Comments|
Ids|Nesting|Pseudos|Tags|
Universals(...)                  ##Like CONTAINER.walk*(...)

S_CONTAINR.split(FUNC(NOD)->BOOL)##Returns S_CONTAINER.nodes as S_NODE_ARR_ARR: the subgroups are decided by returning true
                                 ##(this terminates current subgroup and start new one)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:        SELECTOR NODES         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/

POSTCSS-SELECTOR-PARSER.
attribute|className|combinator|
comment|id|nesting|pseudo|root|
selector|string|tag|universal
([S_NODE_PROPS])->S_NODE         ##Creates new S_NODE of that type

S_ROOT                           ##S_CONTAINER representing SELECTORS. Parent of SELECTOR

S_SELECTOR                       ##S_CONTAINER representing SELECTOR. 
                                 ##Parent of S_CLASS|ID|TAG|UNIVERSAL|ATTR|COMBINATOR|COMMENT|PSEUDO

S_COMBINATOR                     ##S_NODE representing space > + ~
S_COMBINATOR.value               ##' |>|+|~'

S_PSEUDO                         ##S_CONTAINER representing :[:]PSEUDO[(...)]
                                 ##Parent of ...
S_PSEUDO.value                   ##':[:]PSEUDO'

S_CLASS|ID|TAG|UNIVERSAL|NESTING ##S_NODE representing .CLASS #ID TAG * &
S_CLASS|ID|TAG|UNIVERSAL|NESTING
.value                           ##'CLASS|ID|TAG|*|&'

S_ATTR                           ##S_NODE representing [ATTR] or [ATTRopVAL]
S_ATTR.attribute                 ##'ATTR'
S_ATTR.operator                  ##'op' or undefined
S_ATTR.value                     ##'VAL' or undefined

S_COMMENT                        ##S_NODE representing /* COMMENT */
S_COMMENT.value                  ##'/* COMMENT */'

S_STRING                         ##S_NODE representing any STR
S_NODE.value                     ##STR


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           UTILITIES           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


PROCESSOR.version                 #STR

POSTCSS.vendor                    #VENDOR
VENDOR.prefix('PROP')             #Returns prefix, e.g. '-moz-'
VENDOR.unprefixed('PROP')         #Returns without prefix

POSTCSS.list                      #LIST, which [de]compose space|comma-separated PROP VAL
LIST.space('VAL  ...')->VAL_ARR   #
LIST.comma('VAL, ...')->VAL_ARR   #




               
   REPORTING   
               



																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             INPUT             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


INPUT                             #CSS input source
INPUT.file                        #'FILE'. Requires OBJ.from to be defined
INPUT.id                          #Automatic 'ID'
INPUT.from                        #INPUT.file or, if unset, INPUT.id
INPUT.origin(LINE, COL)           #Returns position in original input source as OBJ: file STR, line|column NUM
INPUT.map                         #Sourcemap (using mozilla source-map module)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:        WARNINGS/ERRORS        :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/



CSSSYNTAXERR                      #Error message. Child of ERROR
CSSSYNTAXERR.message              #'[PLUGIN:]FILE:LINE:COL: REASON'
CSSSYNTAXERR.plugin               #'PLUGIN'
CSSSYNTAXERR.file                 #'FILE'. Requires OBJ.from to be defined
CSSSYNTAXERR.line|column          #NUM
                                  #Can use previous sourcemap (see --map.prev)
CSSSYNTAXERR.reason               #'REASON'
CSSSYNTAXERR.input                #INPUT
CSSSYNTAXERR.source               #'CSS' of the source
CSSYNTAXERR.showSourceCode([BOOL])#Returns STR showing source code that failed
                                  #BOOL is color output (def: process.stdout.isTTY and process.env.NODE_DISABLE_COLORS)
                                  #Empty if map.inline true and map.sourceContent false

WARNING                           #Warning message
WARNING.toString()->STR           #Like CSSSYNTAXERR.message
WARNING.plugin|file|line|column   #Like CSSSYNTAXERR
WARNING.text                      #Like CSSSYNTAXERR.reason
WARNING.node                      #NODE
WARNING.type                      #'warning'


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           REPORTING           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


POSTCSS-REPORTER(PLUGIN_OPTS)    ##PLUGIN (1.3.3) that prints RESULT.messages using console.log()
                                 ##Must be last PLUGIN
                                 ##PLUGIN_OPTS:
                                 ##  - formatter({ messages OBJ_ARR, source 'CSS' })->STR: custom formatter
                                 ##  - sortByPosition BOOL (def: true): sort messages by lines/columns
                                 ##  - positionless 'first' (def), 'last' or 'any': where to sort message without lines/columns
                                 ##  - noIcon BOOL (def: false): does not show icon in logs
                                 ##  - noPlugin BOOL (def: false): does not show 'PLUGIN' in logs
                                 ##  - plugins 'PLUGIN'_ARR: filter by plugin
                                 ##  - throwError BOOL (def: false): throws error if warning found
                                 ##  - clearMessages BOOL (def: false): initialize RESULT.messages afterwards
                                 ##Can also use PLUGIN({ messages OBJ_ARR, source 'CSS' })->STR
