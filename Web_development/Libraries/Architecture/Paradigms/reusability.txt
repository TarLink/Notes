
                 
   REUSABILITY   
                 



REUSING ==>                       #Difference between reusing:
                                  #  - when adding new features, i.e. easier
                                  #  - after features were added, i.e. goal is to increase modularity
                                  #Reusability is encouraging the first one (although it might help second one too)

OPEN/CLOSE PRINCIPLE ==>          #Interfaces should encourage being extended, as opposed to being modified.
                                  #I.e. limit|simplify the parts that need modification|addition in order to extend
                                  #"O" of SOLID principles


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         POLYMORPHISM          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


POLYMORPHISM ==>                  #Using a single function for several types (for code reuse)
                                  #Can use: 
                                  #  - subtyping (including subclassing), typecasting, overloading, generic programming
                                  #  - composition, aggregation, association: not polymorphism, but related

TYPE REUSABILITY ==>              #A type can reuse another type behavior by:
                                  #  - reusing that type (simpler, more object-oriented):
                                  #     - from tighter to looser relationship (i.e. simpler to more modular) (see OOP doc): 
                                  #        - inheritance, coercion, composition, aggregation, association
                                  #  - reusing its related functions, i.e. making it more generic (more abstract, more algorithm-oriented):
                                  #     - overloading: simpler (reimplement whole function)
                                  #     - generic: more abstract (only reimplement concepts)


SUBTYPING ==>                     #Also called "inclusion polymorphism"
                                  #Concept:
                                  #  - extending base type by reimplementing its full interface
                                  #  - child-parent relationship
                                  #  - geared towards general concepts, i.e. usually OOP objects (except static members)
                                  #Name resolution (dispatch): usually dynamic, but can be static with CRTP
                                  #Can use multiple base types: 
                                  #  - called "multiple inheritance" with inheritance
                                  #  - conflicts are resolved by:
                                  #     - calling only last base type (i.e. overriding)
                                  #     - calling each base type (called "multicast delegate" with prototype-based inheritance)

SUBCLASSING/INHERITANCE ==>       #Also called "nominal subtyping" (as opposed to "structural subtyping")
                                  #Subtyping where child ("subclass") explicitely references its parent ("supercass"):
                                  #  - inherits parent's interface:
                                  #     - abstract methods: methods that only get their definition (not implementation) inherited
                                  #     - abstract class: class with only abstract methods
                                  #  - type identity conforms to parent's
                                  #Can be:
                                  #  - class-based: class (i.e. static, compile-time) vs instances (i.e dynamic, runtime)
                                  #  - prototype-based: types are instances, either by copy ("concatenating") or by reference
                                  #Some types might be non-subclassable, e.g. builtin types in some languages
TEMPLATE METHOD ==>               #Alternative to reimplementing methods in full:
                                  #  - only variant parts are separated into other methods, meant to be reimplemented
                                  #  - provides better code reuse

TYPECASTING ==>                   #Also called "coercion polymorphism"
                                  #Concept: extending base type by initializing|constructing another one
                                  #Name resolution (dispatch): usually dynamic

OVERLOADING ==>                   #Also called "ad-hoc polymorphism"
                                  #Concept: extending function by defining new implementation for argument types
                                  #Name resolution (dispatch): static is "overloading", dynamic is "multimethods"|"multiple dispatch"

GENERIC PROGRAMMING ==>           #Also called "parametric polymorphism"
                                  #Concept:
                                  #  - extending function by defining new argument types implementing "contract" (used by the function)
                                  #  - types are "generic", i.e. "any" + "traits" (contracts)
                                  #  - more abstract, i.e. harder to build generic type, but easier to extend
                                  #Can implement several contracts using:
                                  #  - mixins
                                  #  - traits, like mixins but:
                                  #     - usually only methods, no attributes
                                  #     - can be composed instead of just overriding, e.g. addition, substraction or allowing aliasing if name conflict
                                  #Name resolution (dispatch): static is "templates", dynamic is "mixins"|"traits"
                                  #Type definition:
                                  #  - predicative (as opposed to impredicative): can define with generic types, but must assign with non-generic types
                                  #  - rank-n (1 is "prenext"): can define with a generic type, that takes itself another generic type, etc. (n times)
                                  #     - e.g. FUNC(any_database of any_collection of any_item)
