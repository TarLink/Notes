
                
   MODULARITY   
                



MODULARITY ==>                    #Dividing into different modules 
                                  #Aims at orthogonality/separation of concern:
                                  #  - between modules: granularity, loose coupling
                                  #  - inside each module: high cohesion, single responsibility
                                  #Pros:
                                  #  - lower complexity on smaller part:
                                  #     - easier to maintain
                                  #     - easier to scale
                                  #     - easier to extend
                                  #  - improves code reuse
                                  #Cons:
                                  #  - higher overall complexity
                                  #  - less efficient

MODULAR PROGRAMMING ==>           #Features of a language allowing modularity, e.g. Python packages


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          GRANULARITY          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


GRANULARITY ==>                   #Dividing code into different pieces (modules|packages|components|units)
                                  #Can be: blocks, functions, namespaces, files, directories
                                  #Opposite is monolithic design.

STRUCTURED PROGRAMMING ==>        #Which control flows are used by imperative languages
                                  #Non-structured programming:
                                  #  - use branching:
                                  #     - unconditional (goto, call, exit, etc.)
                                  #     - conditional (simple if, etc.)
                                  #  - includes:
                                  #     - early exit (return, break, continue, etc.)
                                  #     - exception|interrupt handling
                                  #     - async (coroutine, promise, etc.)
                                  #Structured programming:
                                  #  - use structures:
                                  #     - blocks (if blocks, switch, etc.)
                                  #     - loops (for, while, etc.)
                                  #     - functions
                                  #Structures are an abstraction of branching, aiming at grouping code together, i.e. more granularity


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           COUPLING            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


LOOSE|LOW COUPLING ==>            #Also called "law of Demeter", "principle of least knowledge"
                                  #Minimizing knowledge|contract between modules
                                  #I.e. inheritance < composition < aggregation < association

CHAIN OF RESPONSABILITY PATTERN   #Decoupling modules with different purpose but same input:
  ==>                             #  - by defining shared interface to process that input, e.g. MODULE.process(INPUT)
																	#Sequence order can be maintained by (from simplest to most flexible):
																	#  - container (e.g. array order)
																	#  - items, i.e. each module point to:
																	#     - 1 next module
																	#     - 0-1 next module, i.e. can stop sequence
																	#     - 0|1-n next modules ("dispatcher")
																	#Modules can be excluded from the sequence, according to input properties (e.g. its type)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           COHESION            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


COHESION ==>                      #How related are the parts of a module
                                  #Cohesion reason is: technical < time < data < purpose, i.e. (from lowest to highest):
                                  #  - coincidental: none
                                  #  - logical: same technical nature (e.g. controllers, views)
                                  #  - temporal: happen together at a given time (e.g. init)
                                  #  - procedural: happen always after another
                                  #  - communicational/informational: same data
                                  #  - sequential: procedural + communicational, i.e. pipeline of input/output
                                  #  - functional: same purpose

OBJECT-ORIENTED PROGRAMMING ==>   #See types doc


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          SIMPLICITY           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


SINGLE RESPONSIBILITY ==>         #A module must have a single responsibility (i.e. "reason to change")
                                  #"S" of SOLID principles
