
                     
   OBJECT_ORIENTED   
                     



OBJECT ==>                        #Complex type coupling data and methods of same concern
                                  #Provides modularity: coherence, namespacing
                                  #Can also provide abstraction: "encapsulation", i.e. exposing a limited set of an object
                                  #Type definition can be:
                                  #  - class-based: separate definition and instances
                                  #  - prototype-based: only instances

METHODS ==>                       #Functions of an object
                                  #Can use "this", first implicit argument for convenience

SUBCLASSING ==>                   #OOP is often associated with subclassing (see polymorphism doc) but does not have to be, so not documented here


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         RELATIONSHIPS         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


RELATIONSHIPS ==>                 #Relationship between objects, from more to less coupled:
                                  #  - inheritance: "is a", i.e. at least similar as parent
                                  #  - coercion: "is like a"
                                  #  - composition: "owns a":
                                  #     - exclusivity: only one owner
                                  #     - ownership: destroyed when owner is
                                  #     - containment|container: owning several objects of similar|same type
                                  #  - aggregation|consultation: "has a", i.e. exclusivity but no ownership
                                  #  - association: "uses a", i.e. no exclusivity nor ownership
                                  #Prefer looser relationships, as it provides modularity. 
                                  #E.g. "composition over inheritance": only inheritance if behavorial subtyping, i.e. child is conceptually a subset:
                                  #  - only adds to its parent: subtitutable (see below), does not encapsulate parent's interface
                                  #  - same domain
                                  #Recursion: referring to itself, directly or indirectly

LISKOV SUBSTITUTION PRINCIPLE ==> #Also called LSP, substitutability, "inheritance semantics":
                                  #A parent should be substitutable by its child, i.e. the child:
                                  #  - does not add preconditions, exceptions, time complexity
                                  #  - does not remove postconditions, side effects
                                  #  - keep invariants, side effects
                                  #As such children should tend towards looser input, stricter output
                                  #When a parent takes as argument and returns a polymorphic TYPE, the child:
                                  #  - must take a contravariant TYPE as argument, i.e. TYPE or a parent of it, so it only removes preconditions
                                  #  - must return a covariant TYPE, i.e. TYPE or a child of it, so it only adds postconditions
                                  #"L" of SOLID principles


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:        INITIALIZATION         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


FACTORY METHOD ==>                #Function returning new instances of a type.
                                  #I.e. abstraction of a type initializer:
                                  #  - actual type initializers might be encapsulated (i.e. private)
                                  #  - pros: more flexibility, e.g.:
                                  #     - can instrument (e.g. pooling)
                                  #     - return different types
                                  #  - cons: more complexity, e.g.:
                                  #     - must replicate exception safety
ABSTRACT FACTORY ==>              #Factory method that is an abstract method.
                                  #I.e. children are meant to be reimplement it, e.g. specifying which instances to create
NAMED CONSTRUCTOR ==>             #Factory method that is a static method on the class itself

PROTOTYPE ==>                     #A prototype is an object that is initialized by cloning.
                                  #Usually done through a factory method, which it registers itself to
                                  #Goal: more dynamic|flexible but more complex
BUILDER ==>                       #Initializing serialized objects:
                                  #  - a "reader" and "writer" deserialize|serialize an object
                                  #  - a "builder" initializes the deserialized object
                                  #     - it can be an abstract factory
                                  #Goal: separating object representation from initialization

SINGLETON ==>                     #Pattern for objects that need to be unique.
                                  #When retrieving the object:
                                  #  - the first time, is initialized and returned
                                  #     - i.e. is lazy initialized
                                  #  - afterwards, is only returned
                                  #Often requires global scope:
                                  #  - must be thread-safe
