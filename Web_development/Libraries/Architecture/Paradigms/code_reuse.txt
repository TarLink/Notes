
                
   CODE_REUSE   
                


OPEN/CLOSE PRINCIPLE ==>          #Interfaces should encourage being extended, as opposed to being modified.
                                  #I.e. limit|simplify the parts that need modification|addition in order to extend
                                  #"O" of SOLID principles


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         POLYMORPHISM          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


POLYMORPHISM ==>                  #Using a single function for several types (for code reuse)
                                  #Can use: 
                                  #  - subtyping (including subclassing), typecasting, overloading, generic programming
                                  #  - composition, aggregation, association: not polymorphism, but related

CODE REUSE FOR A TYPE ==>         #A type can reuse another type behavior by:
                                  #  - reusing that type (simpler, more object-oriented):
                                  #     - from tighter to looser relationship (i.e. simpler to more modular) (see OOP doc): 
                                  #        - inheritance, coercion, composition, aggregation, association
                                  #  - reusing its function, i.e. making it more generic (more abstract, more algorithm-oriented):
                                  #     - overloading: simpler (reimplement whole function)
                                  #     - generic: more abstract (only reimplement concepts)


SUBTYPING ==>                     #Also called "inclusion polymorphism"
                                  #Concept:
                                  #  - extending base type by reimplementing its full interface
                                  #  - child-parent relationship
                                  #  - geared towards general concepts, i.e. usually OOP objects (except static members)
                                  #Name resolution (dispatch): usually dynamic, but can be static with CRTP
                                  #Can use multiple base types: 
                                  #  - called "multiple inheritance" with inheritance
                                  #  - conflicts are resolved by:
                                  #     - calling only last base type (i.e. overriding)
                                  #     - calling each base type (called "multicast delegate" with prototype-based inheritance)

SUBCLASSING/INHERITANCE ==>       #Also called "nominal subtyping" (as opposed to "structural subtyping")
                                  #Subtyping where child ("subclass") explicitely references its parent ("supercass"):
                                  #  - inherits parent's interface:
                                  #     - abstract methods: methods that only get their definition (not implementation) inherited
                                  #     - abstract class: class with only abstract methods
                                  #  - type identity conforms to parent's
                                  #Can be:
                                  #  - class-based: class (i.e. static, compile-time) vs instances (i.e dynamic, runtime)
                                  #  - prototype-based: types are instances, either by copy ("concatenating") or by reference
                                  #Some types might be non-subclassable, e.g. builtin types in some languages

TYPECASTING ==>                   #Also called "coercion polymorphism"
                                  #Concept: extending base type by initializing|constructing another one
                                  #Name resolution (dispatch): usually dynamic

OVERLOADING ==>                   #Also called "ad-hoc polymorphism"
                                  #Concept: extending function by defining new implementation for argument types
                                  #Name resolution (dispatch): static is "overloading", dynamic is "multimethods"|"multiple dispatch"

GENERIC PROGRAMMING ==>           #Also called "parametric polymorphism"
                                  #Concept:
                                  #  - extending function by defining new argument types implementing "contract" (used by the function)
                                  #  - types are "generic", i.e. "any" + "traits" (contracts)
                                  #  - more abstract, i.e. harder to build generic type, but easier to extend
                                  #Can implement several contracts using:
                                  #  - mixins
                                  #  - traits, like mixins but:
                                  #     - usually only methods, no attributes
                                  #     - can be composed instead of just overriding, e.g. addition, substraction or allowing aliasing if name conflict
                                  #Name resolution (dispatch): static is "templates", dynamic is "mixins"|"traits"
                                  #Type definition:
                                  #  - predicative (as opposed to impredicative): can define with generic types, but must assign with non-generic types
                                  #  - rank-n (1 is "prenext"): can define with a generic type, that takes itself another generic type, etc. (n times)
                                  #     - e.g. FUNC(any_database of any_collection of any_item)





Command pattern:
   - decouple:
        - input processing: done by "command" object:
              - combination of a processor ("receiver") and processor's input
              - represent an invocation not fired yet. Does not do processing itself ("receiver" does)
        - processing invocation: done by "invoker":
            - takes command object as input
            - fires command through a parameterless interface (e.g. command.execute())
   - the "client" is the consumer of the pattern (creates commands, invoke them)

Chain of responsability:
   - one input is being processed sequentially by several objects which all implement same processing interface (e.g. obj.process(input))
       - sequence order can be:
           - maintained by a container (e.g. array order)
           - each processor point to to the next one.
           - same but might not point to next one (stopping the chain)
           - each processor point to 0-n others, making processors "dispatchers"
       - input can have a "type" so processors know whether to process or not
   - goal: decoupling several parts of processing of same input from each other
