
                 
   ABSTRACTION   
                 



ABSTRACTION ==>                   #Pros for consumer:
                                  #  - make interface easier: simpler, more expressive
                                  #  - minimize maintainance
                                  #Cons for the interface:
                                  #  - increased complexity
                                  #  - less flexible|efficient

LANGUAGE GENERATION ==>           #Can be:
                                  #  - 1GL (first-generation programming language): machine-level
                                  #  - 2GL: assembly language
                                  #  - 3GL: low-level, e.g. C, C++, Java, BASIC, Pascal, Fortran, ALGOL, COBOL
                                  #  - 4GL: high-level, e.g. JavaScript, Python, Perl, Ruby, SQL, Bash, PHP, R
                                  #  - 5GL: logic programming, e.g. Prolog

IMPERATIVE VS DECLARATIVE ==>     #Imperative:
																	#  - manipulate state to get results
																	#  - *how* to get results
																	#  - focus on side effects, control flow, algorithms
																	#  - e.g. ARR.map(val % 2 is 0 ? val : null)
                                  #  - less abstract
																	#Declarative:
																	#  - define conditions that should be satisfied for the result
																	#  - *what* to get 
																	#     - *how* being abstracted to implementation
																	#  - focus on problem domain
																	#  - e.g. ARR.where(val % 2 is 0)
																	#  - include: query languages (SQL, RegExp), logic programming, configuration management
                                  #  - more abstract

FUNCTIONAL PROGRAMMING ==>        #See functional doc

INTERFACE-SEGREGATION ==>         #Also called "information hiding" or (for OOP) "encapsulation"
                                  #Minimizing interface size
                                  #"I" of SOLID principles

DEPENDENCY INVERSION ==>          #Modules should only used other modules through those modules interfaces
                                  #"D" of SOLID principles

ABSTRACTION INVERSION ==>         #Antipattern: abtraction that:
                                  #  - hides information useful to consumers, leading to consumers to reimplement it using abstracted interface
                                  #  - is unnecessarily high-level (complex, slow)

ADAPTER ==>                       #Interface shared by several modules, i.e. abstracting their differences
                                  #Interface can be interacting with the modules through composition ("object adapter") or inheritance ("class adapter")

COMMAND PATTERN ==>               #Decouple:
                                  #  - input processing (i.e. actual function): "receiver"
                                  #  - input binding (i.e. providing input): "command", i.e. "receiver" + input
                                  #  - invocation (i.e. firing function): "invoker", which triggers a "command" (with no additional input)
                                  #Goal: abstracting function input away from consumer, i.e. less flexible but simpler
