
                  
   REQUIREMENTS   
                  


Requirements:
  - determining needs of client
  - Should:
     - respond to client needs
        - imply all stakeholders: not only people using and benefiting, but also regulating or trying to misuse (enemies)
     - be measurable and testable
     - be documented and traceable

Can be:
  - functional (design): what software does
     - quality
     - quantity/number
     - pertinence
     - cohesion
  - non-functional, quality attributes (architecture): how software does it
     - execution qualities: runtime
     - evolution qualities: development-time

Techniques to be sure we have the right requirements:
     - Interviews:
        - personal
        - in teams: JRD (Joint Requirements Development) sessions
     - User story:
        - desired functionalities written in natural language, i.e. "In order to BENEFIT as a ROLE, I want FUNCTION"
        - a group of user stories of same theme is called an "epic story"
        - should be written as much as possible by end users, as opposed to developers
        - should be INVEST:
           - Independent: from other user stories. If some are tight together, put them as one user story
           - Negotiable: can always be changed until start of coding
           - Valuable: for the end user
           - Estimable: put resources needed on it (time, price, material, etc.)
           - Small: not more than a few person-days
           - Testable: tested by one or several "acceptance tests"
     - ATDD (Acceptance test-driven development): 
        - an acceptance test is a test in natural language to check that a requirement is fulfilled.
          Acceptance tests must cover the requirement, not less, not more.
        - Acceptance tests should be written with sentences with user story (As a, In order to, I want to) followed by 
          several scenarios (title, given/and (precondition), when (action), then (result))
     - Prototypes:
        - Should specify which requirement to implement with the prototype, and which ones to save for the actual project.
        - Can enter a review/enhance loop with the customer
        - Scope:
           - horizontal: the whole thing, good for validating interface to customers
           - vertical: a specific function, good for refining engineering of that part.
        - Evolution:
           - close-ended/throwaway/rapid: not included in final product. Importance is speed of creation.
             Can use GUI builder without implementing the backend for example.
           - evolutionary/breadboard: first step of final product. Importance is possibility to build on it.
        - Can put in black&white parts of the UI that still need graphical design
        - Pretotype: like prototype, but even faster (nothing work just look like it does).
          Focus is on end user feedback on core functionalities.
     - use case: formal diagram or text of all interactions and actors possible in the system

Specification:
  - Response to requirements by provider: overview of the systems with all details, but from end-user point of view.
  - Goal is to make a consensus between end-user and developer, and is also used to know what to test.
  - Form:
     - UI, with comments
     - Textual documentation


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          CATEGORIES           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


EXECUTION QUALITIES
Performance
  (speed): latency, throughput
  (efficiency): resource consumption
Flexibility
  (interactivity): different kind of inputs
  (adaptability): different contexts
  (modifiability/customizability): new features added by user
  (evolvability): new features added over time (with no developer time)
Usability-related
  (accessibility)
  (easiness/learnability)
  (usability)
  (design)
Security
Legality
  (compliance)
  (licensing)
Marketability
  (certification)
Cost/price
Environmental|human sustainability
Privacy
Transparency/accountability/inspectability/traceability

MIX EXECUTION/EVOLUTION QUALITIES
Robustness

stability?
  (quality): preventing fault
    (testability)
    (configuration management)
  (availability): preventing total fault
    (resilience)
  (reliability): preventing frequent fault
  (compatibility): preventing fault, over versions
  (durability): preventing fault, in time

Damage control?
  (recoverability): minimizing fault's damage
    (backups)
  (safety): minimizing fault's damage
  (fault tolerance): minimizing fault's damage

?
  (reporting): alerting for fault
  (debuggability): finding fault

EVOLUTION QUALITIES
Operability
  (deployability/installability)
  (seamlessness/integratibility)
  (administratibility)
  (interoperability/portability)
  (interchangeability / switching cost)
  (supportability)
Maintainability-related
  (maintainability): ease to keep on offering same features, and fix bugs
  (extensibility): ease to offer new features
    (abstraction)
      (functional programming)
    (modularity)
      (object oriented)
      (reusability)
      (orthogonality)
  (scalability): ease to increase|decrease demand
