
                  
   REQUIREMENTS   
                  


Requirements:
  - should be INVEST:
     - Independent: from other user stories. If some are tight together, put them as one user story
     - Negotiable: can always be changed until start of coding
     - Valuable: respond to stakeholders needs
        - imply all stakeholders, i.e. people: using, misusing (enemies), regulating
        - should be specified as much as possible by end users, as opposed to developers
     - Estimable: put resources needed on it (time, price, material, etc.)
     - Small: 
        - not more than a few person-days
        - when specifying, should cover the requirement, not less nor more
     - Testable: 
        - tested by one or several "acceptance tests"
        - documented, traceable
  - i.e.: valuable, granular (small, independent), easy to plan (can be estimated, tested, changed)

Can be:
  - functional (design): what software does
     - execution needs:
        - quality
        - quantity|number (i.e. flexibility)
        - pertinence (i.e. respond precisely to the requirement)
        - cohesion (with rest of system)
  - non-functional, quality attributes (architecture): how software does it
     - execution qualities: runtime, e.g. UX
     - evolution qualities: development-time, e.g. maintainability

Steps:
  - Interviews:
     - personal
     - in teams: JRD (Joint Requirements Development) sessions

Specifiying requirements:
  - user story:
     - functionalities in natural language, i.e. "In order to BENEFIT as a ROLE, I want FUNCTION"
     - "epic story": group of user stories with same theme
  - ATDD (Acceptance test-driven development):
     - test of requirement in natural language, i.e. several scenarios: title, given/and (precondition), when (action), then (result)
  - use case: 
     - formal diagram or text of all interactions and actors possible in the system
  - prototypes:
     - Should specify which requirement to implement with the prototype, and which ones to save for the actual project.
     - Can enter a review/enhance loop with the customer
     - Scope:
        - horizontal: the whole thing, good for validating interface to customers
        - vertical: a specific function, good for refining engineering of that part.
     - Evolution:
        - close-ended/throwaway/rapid: not included in final product. Importance is speed of creation.
          Can use GUI builder without implementing the backend for example.
        - evolutionary/breadboard: first step of final product. Importance is possibility to build on it.
     - Can put in black&white parts of the UI that still need graphical design
     - Pretotype: like prototype, but even faster (nothing work just look like it does).
       Focus is on end user feedback on core functionalities.
  - specification:
     - Response to requirements by provider: overview of the systems with all details, but from end-user point of view.
     - Goal is to make a consensus between end-user and developer, and is also used to know what to test.
     - Form:
        - UI, with comments
        - Textual documentation


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          CATEGORIES           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


When categorizing: make it orthogonal, i.e. one can change without changing others


UX
  (accessibility)
  (easiness/learnability)
  (usability)
  (design)
  (performance)
    (speed): latency, throughput
    (efficiency): resource consumption
Flexibility
  (interactivity): different kind of inputs
  (adaptability): different contexts
  (modifiability/customizability): new features added by user
  (evolvability): new features added over time (with no developer time)
Robustness
  (stability)
    (quality): preventing fault
      (testability)
      (configuration management)
    (security): preventing malign fault
    (availability): preventing total fault
      (resilience)
    (reliability): preventing frequent fault
    (compatibility): preventing fault, over versions
    (durability): preventing fault, in time
  (damage control?)
    (recoverability): minimizing fault's damage
    (safety): minimizing fault's damage
    (fault tolerance): minimizing fault's damage
  (problem visibility?)
    (reporting): alerting for fault
    (debuggability): finding fault
Maintainability-related
  (maintainability): ease to keep on offering same features, and fix bugs
  (extensibility): ease to offer new features
  (scalability): ease to increase|decrease demand
Operability
  (deployability/installability)
  (seamlessness/integratibility)
  (administratibility)
  (interoperability/portability)
  (interchangeability / switching cost)
  (supportability)
Social impact
  (legality)
    (compliance)
    (licensing)
  (privacy)
  (environmental|human sustainability)
  (transparency/accountability/inspectability/traceability)
Marketability
  (certification)
  (cost)
