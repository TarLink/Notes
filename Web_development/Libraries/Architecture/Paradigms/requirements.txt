
                  
   REQUIREMENTS   
                  


Requirements:
  - qualities:
     - should be INVEST:
        - Independent: from other user stories. If some are tight together, put them as one user story
        - Negotiable: can always be changed until start of coding
        - Valuable: respond to stakeholders needs
           - imply all stakeholders, i.e. people: using, misusing (enemies), regulating
        - Estimable: put resources needed on it (time, price, material, etc.)
        - Small: 
           - not more than a few person-days
           - when specifying, should cover the requirement, not less nor more
        - Testable: 
           - tested by one or several "acceptance tests"
           - documented, traceable
     - i.e.: valuable, granular (small, independent), easy to plan (can be estimated, tested, changed)
  - "what to do" vs "how to do"
     - "what to do" (requirements) should be specified by stakeholders, not developers
     - "how to do" (architecture, design) should be specified by developers, not stakeholders
  - high-level first:
     - high-level need:
        - guess actual need, i.e. why do you need to do this?
        - first formulated "need" is usually not the real need but a possible answer to it (formulated by stakeholders)
     - lower-level needs (requirements): to fulfill high-level need
     - implementation: e.g. do not show prototype until requirements are understood

Can be:
  - functional (design): what software does
     - execution needs:
        - quality
        - quantity|number (i.e. flexibility)
        - pertinence (i.e. respond precisely to the requirement)
        - cohesion (with rest of system)
  - non-functional, quality attributes (architecture): how software does it
     - execution qualities: runtime, e.g. UX
     - evolution qualities: development-time, e.g. maintainability

Steps:
  - Interviews:
     - personal
     - in teams: JRD (Joint Requirements Development) sessions

Specification (from most generic to most explicit):
  - requirements only:
     - user story:
        - functionalities in natural language, i.e. "In order to BENEFIT as a ROLE, I want FUNCTION"
        - "epic story": group of user stories with same theme
     - ATDD (Acceptance test-driven development):
        - test of requirement in natural language, i.e. several scenarios: title, given/and (precondition), when (action), then (result)
     - use case: 
        - all interactions|actors in formal diagram or prose
  - requirements + solution:

     - specification:
        - requirements + solution in details
           - solution detailed enough to be used as a test of requirements
   
     - prototypes:
        - Should specify which requirement to implement with the prototype, and which ones to save for the actual project.
        - Can enter a review/enhance loop with the customer
        - Scope:
           - horizontal: the whole thing, good for validating interface to customers
           - vertical: a specific function, good for refining engineering of that part.
        - Evolution:
           - close-ended/throwaway/rapid: not included in final product. Importance is speed of creation.
             Can use GUI builder without implementing the backend for example.
           - evolutionary/breadboard: first step of final product. Importance is possibility to build on it.
        - Can put in black&white parts of the UI that still need graphical design
        - Pretotype: like prototype, but even faster (nothing work just look like it does).
          Focus is on end user feedback on core functionalities.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          CATEGORIES           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


When categorizing: make it orthogonal, i.e. one can change without changing others


UX
  (accessibility)
  (easiness/learnability)
  (usability)
  (design)
  (performance)
    (speed): latency, throughput
    (efficiency): resource consumption
Flexibility
  (interactivity): different kind of inputs
  (adaptability): different contexts
  (modifiability/customizability): new features added by user
  (evolvability): new features added over time (with no developer time)
Robustness
  (stability)
    (quality): preventing fault
      (testability)
      (configuration management)
    (security): preventing malign fault
    (availability): preventing total fault
      (resilience)
    (reliability): preventing frequent fault
    (compatibility): preventing fault, over versions
    (durability): preventing fault, in time
  (damage control?)
    (recoverability): minimizing fault's damage
    (safety): minimizing fault's damage
    (fault tolerance): minimizing fault's damage
  (problem visibility?)
    (reporting): alerting for fault
    (debuggability): finding fault
Maintainability-related
  (maintainability): ease to keep on offering same features, and fix bugs
  (extensibility): ease to offer new features
  (scalability): ease to increase|decrease demand
Operability
  (deployability/installability)
  (seamlessness/integratibility)
  (administratibility)
  (interoperability/portability)
  (interchangeability / switching cost)
  (supportability)
Social impact
  (legality)
    (compliance)
    (licensing)
  (privacy)
  (environmental|human sustainability)
  (transparency/accountability/inspectability/traceability)
Marketability
  (certification)
  (cost)
