
                
   TECHNIQUES   
                
                        

CRTP ==>                					#Curiously Recuring Template Pattern :
                        					#  - Une template BASE classe a une "pseudo-virtual" fonction INTERFACE qui appelle static_cast<BASE*>(this)->FONC()
                        					#  - Les classes dérivées remplissent le template de BASE avec leur propre type, et implémente FONC
                        					#  - Les fonctions peuvent ensuite prendre un BASE<T> en argument, et invoquer BASE.INTERFACE(), qui invoquera la FONC correspondant à l'instantiation de T.
                        					#Utilité :
                        					#  - comme une virtual fonction, mais compile-time:
                        					#    - pas de possibilité de spécifier la classe dérivée seulement runtime.
                        					#    - plus léger qu'une virtual fonction (pas de runtime cost)
                        					#  - programmation générique me semble avoir que des avantages par rapport à cette technique, si ce n'est qu'ici on impose d'instantier avec un enfant de BASE,
                        					#    alors qu'en programmation générique, il faut faire un checke plus minitieux de l'instantiation.

MOVE UN OBJET NON       					#Cf boost::move (pour les threads).
COPIABLE                					#Un smart pointer "move_t" prend un objet T par référence.
                        					#Eventuellement un helper "move()" instantie celui-ci.
                        					#Une fonction "move-aware" s'overloade avec un argument move_t, qui alors passe par référence l'objet, et détruit l'ancienne référence.

RESSOURCE MANAGER       					#Plutôt que d'utiliser une classe centrale manageant un ensemble de classes :
DECENTRALISE ==>        					#  - extraire les data détenues par la classe centrale, et les passer par pointeur à toutes les classes, partageant les mêmes data :
                        					#      - par exemple, deux constructors possibles :
                        					#         - un crée une nouvelle série, avec création de data
                        					#         - un copy constructor copie ces data par addresse
                        					#      - on peut ensuite rajouter des arguments distinguant chaque instance
                        					#  - implémenter les méthodes dépendant de ces data localement dans chaque classe
                        					#Cela n'est cependant pas à 100% décentralisé : les différentes classes partagent des shared data.
                        					#Exemple:
                        					#  class Classe
                        					#  {
                        					#     TYPE ClasseId;
                        					#     unsigned int* RefNumber;
                        					#   public:
                        					#     Classe( TYPE Id ) : ClasseId( Id ), RefNumber( new unsigned int( 1 ) ) {};
                        					#     Classe( TYPE Id, Classe& ClasseToCopy ) : ClasseId( Id ), RefNumber( ClasseToCopy.RefNumber ) 
                        					#     { (*RefNumber)++; }
                        					#  };

FRIEND CLASS CORE       					#Utiliser friend pour renforcer l'encapsulation.
ACCESS ==>              					#Une classe PARENT définit des CLASSFK_PUB de l'interface publique.
                        					#Le client doit définir un ENFANT des CLASSFK_PRIV appelées par CLASSFK_PUB, mais voudraient qu'elles soit absentes de l'interface publique.
                        					#Solution : utiliser un proxy CORE_ACCESS que l'on met en friend dans ENFANT, qui définit des static CLASSFK appelés par PARENT et appelant CLASSFK_PRIV :
                        					#
                        					#  class Parent
                        					#  {
                        					#   public:
                        					#     void Classfk_pub( void );
                        					#  };
                        					#  class Enfant : public Parent
                        					#  {
                        					#   private:
                        					#     void Classfk_priv( void ) const
                        					#     { std::cout << "Cache\n"; }
                        					#     friend class Core_access;
                        					#  };
                        					#  class Core_access
                        					#  {
                        					#   public:
                        					#     template <class T>
                        					#     static void Classfk_proxy( T const& Var )
                        					#     { Var.Classfk_priv(); }   
                        					#  };
                        					#  void Parent::Classfk_pub( void )
                        					#  { Core_access::Classfk_proxy(*static_cast<Enfant*>( this )); }
                        					#
                        					#Ex : boost::serialization::access, boost::iterator::core_access

SPACE-TIME TRADEOFF ==> 					#Appelé aussi time-memory tradeoff.  
                        					#Situation où l'on peut réduire temps d'exécution en utilisant de la mémoire (vive ou morte, peu importe). Le choix est souvent une question de design.
                        					#Exemples :
                        					#  - lookup table :
                        					#     - aucune (pas de mémoire utilisée)
                        					#     - lookup table (plus rapide)
                        					#     - lookup table construite au fur-et-à-mesure (entre les deux)
                        					#  - compression ou non
                        					#  - precalculated rendering en graphics (ex: precalculated alpha, ou precalculated shadows)
                        					#  - loop unrolling
                        					#  - time-memory tradeoff attacks (brithday attacks, meet-in-the-middle)
