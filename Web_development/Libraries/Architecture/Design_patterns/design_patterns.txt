
                     
   DESIGN PATTERNS   
                     


DESIGN PATTERNS ==>               #Usual|recommeded way of solving architectural problems:
                                  #  - creational: initializing objects
                                  #  - structural: object structure: inheritance, composition, wrapper, etc.
                                  #  - behavioral: communication between objects
                                  #"Gang of four" list (see it their respective docs):
                                  #  - creational: factory method, abstract factory, prototype, builder, object pool, singleton
                                  #  - structural: composite, wrapper, adapter, facade, bridge, proxy, flyweight, private class data
                                  #  - behavioral: chain of responsibility, command, interpreter, iterator, mediator, memento, null object, observer, state, strategy, template method, visitor
                

FACTORY METHOD ==>                #Function returning new instances of a type.
                                  #I.e. abstraction of a type initializer:
                                  #  - actual type initializers might be encapsulated (i.e. private)
                                  #  - pros: more flexibility, e.g.:
                                  #     - can instrument (e.g. pooling)
                                  #     - return different types
                                  #  - cons: more complexity, e.g.:
                                  #     - must replicate exception safety
ABSTRACT FACTORY ==>              #Factory method that is an abstract method.
                                  #I.e. children are meant to be reimplement it, e.g. specifying which instances to create
NAMED CONSTRUCTOR ==>             #Factory method that is a static method on the class itself

PROTOTYPE ==>                     #A prototype is an object that is initialized by cloning.
                                  #Usually done through a factory method, which it registers itself to
BUILDER ==>                       #Initializing serialized objects:
                                  #  - a "reader" and "writer" deserialize|serialize an object
                                  #  - a "builder" initializes the deserialized object
                                  #     - it can be an abstract factory
                                  #Goal: separating object representation from initialization

OBJECT POOL ==>                   #Efficient initialization (when it is costly):
                                  #  - pool creates objects in advance
                                  #  - new objects are taken from the pool
                                  #  - destroyed objects are returned to the pool for reuse
                                  #There can be a pool size limit

SINGLETON ==>                     #Pattern for objects that need to be unique.
                                  #When retrieving the object:
                                  #  - the first time, is initialized and returned
                                  #     - i.e. is lazy initialized
                                  #  - afterwards, is only returned
                                  #Often requires global scope:
                                  #  - must be thread-safe


FORWARDING VS DELEGATION ==>      #One interface ("sender") using another one ("receiver")
                                  #Can pass sender itself as argument:
                                  #  - forwarding: does not pass sender (i.e. same as wrapping), i.e. less coupled
                                  #  - delegating: pass sender, i.e. more coupled
                                  #     - e.g. binding "this" in OOP

WRAPPER ==>                       #Interface abstracting another interface:
                                  #  - can modify interface (not behavior) in order to provide:
                                  #     - compatibility (adapter):
                                  #        - i.e. abstract difference from another interface
                                  #        - the other interface can be interacted with through:
                                  #           - composition ("object adapter")
                                  #           - inheritance ("class adapter")
                                  #     - simplicity (facade):
                                  #        - i.e. abstract between heterogeneous modules
                                  #     - abstraction (bridge):
                                  #        - i.e. abstract between different modules|implementations of similar purpose
                                  #  - can modify behavior (not interface) ("proxy"):
                                  #     - decorator / smart proxy: adds functionalities
                                  #     - remote proxy: translate different address spaces
                                  #     - protective|access proxy: authorization purpose
                                  #     - lazy load proxy: lazy initialization purpose
                                  #Can be "thin" or "thick" according to how much modification is done

FLYWEIGHT ==>                     #If several objects share information, sharing that information among them, instead of instantiating in each object.
                                  #Pros: more efficient. Cons: less granularity
                                  #Information can be shared as: 
                                  #  - references stored|shared in each object
                                  #  - function arguments

PRIVATE CLASS DATA ==>            #Encapsulating a class variable with a thin proxy for getting|setting it

HELPER/UTILITY ==>                #Module that is not linked to the core business logic
                                  #Helpers are stateful (e.g. object instances), utility are stateless|pure

PASSING RUNNING CODE ==>          #Can pass running code (as opposed to data) to an interface by:
                                  #  - modifying interface code directly: no abstraction, and only possible if access to interface code
                                  #  - passing functions as arguments ("callbacks"): simpler
                                  #  - event|hooks: 
                                  #     - more abstract
                                  #        - can abstract functional control (debounce, delay, once, etc.) into the event handling system
                                  #     - more flexible, i.e. dynamic (add|remove) 
EVENTS/HOOKS ==>                  #Decouple:
                                  #  - subject: [un]register callback for a specific event
                                  #  - observer: notify subjects about an event (so callbacks are fired)
                                  #Also called "observer" pattern
