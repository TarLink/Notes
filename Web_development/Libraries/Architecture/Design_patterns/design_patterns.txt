
                     
   DESIGN PATTERNS   
                     


CREATIONAL PATTERNS ==> 					#Création de classes et d'objets.

FACTORY METHOD ==>                #Creational pattern: function returning new instances of a class.
                                  #I.e. abstraction of a class initializer:
                                  #  - actual class initializers might be encapsulated (i.e. private)
                                  #  - pros: more flexibility, e.g. can instrument (e.g. pooling) or return different kinds of classes
                                  #  - cons: more complexity, e.g. must replicate exception safety
ABSTRACT FACTORY ==>              #Creational pattern: factory method that is an abstract method.
                                  #I.e. children are meant to be reimplement it, i.e. specifying which instances to create
PROTOTYPE ==>                     #Creational pattern: a prototype is an object that:
                                  #  - registers itself to a factory method
                                  #  - is created only through that factory method, which uses the object's clone() method

OBJECT POOL             					#Singleton class qui maintient un nombre d'instances d'un objet réutilisable, et coûteux en ressources à instancier.
                        					#Pour instancier, cette objet, il faut demander au Pool qui enlève un objet du Pool, et le retourne. 
                        					#Cet objet revient dans le pool après utilisation. Si le Pool n'a pas d'objet de disponible, il en crée un, dans la limite d'une limite maximale.
BUILDER                 					#Une classe Reader parse le contenu d'un fichier conf ou tout autre fichier, et en fonction du parsing, 
                                  #une seconde classe Builder initialise un objet complexe composition). 
                        					#Cette seconde classe Builder peut être une base classe pour des classes enfants spécialisées.
SINGLETON               					#Classe ne pouvant être instantiée qu'une fois, avec une portée globale, et ne devant pas être initialisée dès le début, mais seulement quand on a besoin d'elle.
                        					#Il faut :
                        					#  - Une classe non statique qui comprend:
                        					#     - un pointeur vers une instantiation static d'elle-même (au début NULL)
                        					#     - un constructor protected, non accessible par le client
                        					#     - une méthode static GetInstance(), initialisant le pointeur s'il est == NULL (premier accès), puis dans tous les cas retournant ce pointeur
                        					#Si multi-threading, penser à faire lock (du coup, problème de parallélisme)

                        					#Object-creation patterns (utilise la délégation) :

STRUCTURAL DESIGN       					#Classe et object composition/organisation.
PATTERNS ==>            					#Structural class-creation patterns (inheritance) :

ADAPTER                 					#Une classe qui englobe une autre pour que son interface corresponde à une autre, soit en ne rajoutant pas de fonctionnalités (wrapper) ou si (modifier).
                        					#Exemple : reverse_iterator, ou wrapper d'une bibliothèque dans un autre langage.
BRIDGE                  					#Si le choix de l'instantiation d'une interface dépend de plusieurs paramètres (par exemple OS + compilateur + etc. ), plutôt que de faire une interface parent,
                        					#divisée en plusieurs interfaces pour chaque OS, chacun divisé en plusieurs implémentations de compilateur, faire deux interfaces soeurs, une pour l'OS, une pour
                        					#le compilo, avec leur propre implémentation, et collaborant entre elles.
COMPOSITE               					#Composition/Agrégation, par opposition à l'inhéritance pour construire un design. Utile si les objets contiennent des composants qui peuvent :
                        					#  - être utilisés seuls
                        					#  - accueillir d'autres primitifs ("leaves") en leur sein, et être donc des objets composés à leur tour.
                        					#  - les composants, bien que différents, sont tous pensés comme "au même niveau"
                        					#Les primitifs (pouvant devenir objets composés) comme les objets composés dérivent tous d'une base classe Component, qui définie des fonctions addChild(), removeChild()
DECORATOR               					#Un objet doit avoir des méthodes fondamentales, mais aussi ajouter une multitude de méthodes optionnelles.
                        					#  - Les méthodes fondamentales sont implémentées dans une classe Core
                        					#  - Les méthodes optionnelles sont implémentées dans des classes toutes enfants d'une classe Decorator
                        					#  - Decorator et Core sont enfant d'une classe Interface
                        					#  - Les enfants de Decorator sont des Adaptors qui prennent un Interface* en constructor, le garde en CLASSDT, et rajoute une couche de méthodes propres. 
                        					#    Decorator implémente cela, ses enfants se contentent de rajouter leurs méthodes.
                        					#  - cela donne des instantiations comme : 
                        					#      - Interface* MonObjet = new Decorator2(new Decorator1(new Core))
FACADE                  					#Un ensemble d'interfaces, où on ne peut pas utiliser utiliser une interface commune par inhéritance car :
                        					#  - interfaces trop différentes
                        					#  - interfaces doivent être appelées successivement
                        					#On utilise donc une interface commune Facade, mais sans inhéritance :
                        					#  - ou elle définie plusieurs fonctions renvoyant aux fonctions différentes des interfaces différentes
                        					#  - ou elle appelle via une fonction l'ensemble des interfaces successives
FLYWEIGHT               					#Si on doit instancier un grand nombre de petits objets, pour éviter le coût, diviser entre une classe Factory qui contient les parties invariables de cet objet, et
                        					#une classe Flyweight, instantiée avec comme argument les parties variables de l'objet, et instantiée via une fonction Create() de Factory.
                        					#Factory peut maintenir un Pool et faire la gestion de tous les Flyweight créés.
PRIVATE CLASS DATA      					#Déclarer des CLASSDT private, pour être sûr qu'ils ne soient accédés que via des getters et des setters, même par les classes enfants.
PROXY                   					#Classe utilisée comme intermédiaire pour accéder à une classe Master. Elle :
                        					#  - instantie l'objet quand on lui demande et, si singleton, si déjà créé, renvoie Master&
                        					#  - se souvient de Master&
                        					#  - "forward" les demandes du client vers Master
                        					#Intérêts :
                        					#  - "virtual proxy" : s'assurer qu'il s'agit d'un Singleton, car Master est lourd à instantier
                        					#  - "remote proxy" : différents "adress spaces" entre le Master et le Client, besoin de traduire
                        					#  - "protective proxy" : Master est secure-sensible, Proxy ckecke les droits d'accès
                        					#  - "smart proxy" : Proxy ajoute des fonctionnalités en plus :
                        					#      - smart pointer comptant le nombre de références restantes pour supprimer la mémoire quand il y en a 0
                        					#      - checker que Master n'est pas locked (par exemple Multithreading)
                        					#Si le client peut utiliser Master avec sans Proxy, faire une classe Interface parent de Master et Proxy, et travailler avec Interface (sauf cas où Proxy est exigé)
                        					#Utilisation des overloadable operators ->, *, etc. peut être intéressante

                        					#Structural object-creation patters (composition)

BEHAVIORAL DESIGN       
PATTERNS ==>            					#Communication entre objets :

OBSERVER                					#Event handling :
                        					#  - "subjects" [un]register callbacks for a specific event
                        					#  - "observer" notify subjects about an event -> fire the callbacks
TEMPLATE METHOD         					#(Rien à voir avec les template < >)
                        					#CLASSFK publique (interface utilisée par l'user) d'une superclasse appelant une série de CLASSFK protected, dont certains sont invariants (non redéfinis par les
                        					#subclasses) et d'autres variants (virtual, redéfinis par les subclasses).
                        					#Intérêt : pas besoin de réimplémenter l'ensemble d'une virtual CLASSFK pour chaque objet, mais seulement les parties qui varient.
                        					#Transparent pour l'user, qui utilise seulement la CLASSFK publique.

AUTRES ==>              					#
NAMED CONSTRUCTOR IDIOM 					#Les constructors d'une class ne sont pas public, et il faut utiliser une static fonction create() pour instantier.
                        					#Permet des contrôles supplémentaires, par exemple si on veut éviter que la classe soit créée via des new, si on veut un singleton, etc.
