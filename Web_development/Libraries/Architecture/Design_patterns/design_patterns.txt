
                     
   DESIGN PATTERNS   
                     


CREATIONAL PATTERNS ==> #Création de classes et d'objets.

FACTORY METHOD          #Static method d'une superclasse qui renvoie des
                        #instantiations de ses subclasses. La subclasse 
                        #renvoyée et son instantiation peut dépendre des 
                        #arguments passée à la static method.
                        #En général, les constructors de la superclasse et
                        #des subclasses ne sont pas publiques.
                        #Permet de bien maîtriser l'instantiation de ces
                        #classes à travers une factory class.
                        #Permet aussi de ne pas recréer une instance déjà
                        #créée, mais de renvoyer une référence / pointeur
                        #vers celle déjà créée.
                        #Peut être associé à un object pool.
                        #Problème : si la construction Create() doit appeler une
                        #méthode de destruction Delete() :
                        #  - cela impose au caller de faire Delete
                        #  - cela est exception-unsafe (ou oblige un lourd
                        #    try catch block faisant Delete si exception entre
                        #    Create et Delete originalement prévu)
ABSTRACT FACTORY        #Superclasse ayant un ensemble de factory methods, pas
                        #forcément static, pour un ensemble, une famille 
                        #d'objets différents à créer.
                        #Chaque ensemble d'objet, et sa factory method associé,
                        #est redéfini par chaque subclasse. Le client 
                        #n'instantie qu'une subclasse en fonction de ses 
                        #besoins (par exemple en fonction de l'OS), et utilise
                        #les fonctions de création d'objets de la subclasse.
PROTOTYPE               #  - SUPERCLASSE :
                        #Une superclasse contient un container avec une 
                        #instantiation (prototype) de chacune de ses subclasses.
                        #Elle remplit celle-ci via une méthode 
                        #addPrototype(objet), qui copie un objet en prototype.
                        #Chaque subclasse (et donc chaque prototype) a une 
                        #méthode clone() qui renvoie une copie (par valeur) 
                        #d'elle-même.
                        #Pour obtenir une instantiation de la subclasse, il faut
                        #appeler une static méthod de la superclasse, 
                        #findAndClone(objet), qui appelle un clone() dans son 
                        #container à prototypes (si objet se trouve dedans).
                        #  - ENREGISTREMENT DES PROTOTYPES :
                        #Chaque SUBCLASSE appelle dès l'ouverture un 
                        #addPrototype() d'elle-même, via un constructor private
                        #qui appelle addPrototype(this), et est appelé par
                        #une static SUBCLASSE présent comme CLASSDT de 
                        #SUBCLASSE :
                        #  - class SUBCLASSE
                        #    {
                        #      private:
                        #        static SUBCLASSE SUBCLASSE_VAR;
                        #      SUBCLASSE() { addPrototype(this); }
                        #    };
                        #Un deuxième constructor protected est lui appelé par 
                        #clone().
                        #  - AUTRES : 
                        #SUBCLASSE peut aussi avoir comme CLASSDT un id (pour 
                        #les clones) et le nombre de clones créés (pour le
                        #prototype)
OBJECT POOL             #Singleton class qui maintient un nombre d'instances 
                        #d'un objet réutilisable, et coûteux en ressources à
                        #instancier.
                        #Pour instancier, cette objet, il faut demander au Pool
                        #qui enlève un objet du Pool, et le retourne. Cet objet
                        #revient dans le pool après utilisation. Si le Pool n'a
                        #pas d'objet de disponible, il en crée un, dans la
                        #limite d'une limite maximale.
BUILDER                 #Une classe Reader parse le contenu d'un fichier conf
                        #ou tout autre fichier, et en fonction du parsing, une
                        #seconde classe Builder initialise un objet complexe
                        #(composition). Cette seconde classe Builder peut être
                        #une base classe pour des classes enfants spécialisées.
SINGLETON               #Classe ne pouvant être instantiée qu'une fois, avec une
                        #portée globale, et ne devant pas être initialisée dès
                        #le début, mais seulement quand on a besoin d'elle.
                        #Il faut :
                        #  - Une classe non statique qui comprend :
                        #     - un pointeur vers une instantiation static 
                        #       d'elle-même (au début NULL)
                        #     - un constructor protected, non accessible par le
                        #       client
                        #     - une méthode static GetInstance(), initialisant
                        #       le pointeur s'il est == NULL (premier accès),
                        #       puis dans tous les cas retournant ce pointeur
                        #Si multi-threading, penser à faire lock (du coup,
                        #problème de parallélisme)

                        #Object-creation patterns (utilise la délégation) :

STRUCTURAL DESIGN       #Classe et object composition/organisation.
PATTERNS ==>            #Structural class-creation patterns (inheritance) :

ADAPTER                 #Une classe qui englobe une autre pour que son interface
                        #corresponde à une autre, soit en ne rajoutant pas de
                        #fonctionnalités (wrapper) ou si (modifier).
                        #Exemple : reverse_iterator, ou wrapper d'une 
                        #bibliothèque dans un autre langage.
BRIDGE                  #Si le choix de l'instantiation d'une interface dépend
                        #de plusieurs paramètres (par exemple OS + compilateur
                        # + etc. ), plutôt que de faire une interface parent,
                        #divisée en plusieurs interfaces pour chaque OS, chacun
                        #divisé en plusieurs implémentations de compilateur,
                        #faire deux interfaces soeurs, une pour l'OS, une pour
                        #le compilo, avec leur propre implémentation, et
                        #collaborant entre elles.
COMPOSITE               #Composition/Agrégation, par opposition à l'inhéritance
                        #pour construire un design. Utile si les objets
                        #contiennent des composants qui peuvent :
                        #  - être utilisés seuls
                        #  - accueillir d'autres primitifs ("leaves") en leur 
                        #    sein, et être donc des objets composés à leur tour.
                        #  - les composants, bien que différents, sont tous 
                        #    pensés comme "au même niveau"
                        #Les primitifs (pouvant devenir objets composés) comme 
                        #les objets composés dérivent tous d'une base classe 
                        #Component, qui définie des fonctions addChild(),
                        #removeChild()
DECORATOR               #Un objet doit avoir des méthodes fondamentales, mais
                        #aussi ajouter une multitude de méthodes optionnelles.
                        #  - Les méthodes fondamentales sont implémentées dans 
                        #    une classe Core
                        #  - Les méthodes optionnelles sont implémentées dans
                        #    des classes toutes enfants d'une classe Decorator
                        #  - Decorator et Core sont enfant d'une classe 
                        #    Interface
                        #  - Les enfants de Decorator sont des Adaptors qui
                        #    prennent un Interface* en constructor, le garde 
                        #    en CLASSDT, et rajoute une couche de méthodes
                        #    propres. Decorator implémente cela, ses enfants se
                        #    contentent de rajouter leurs méthodes.
                        #  - cela donne des instantiations comme : 
                        #      - Interface* MonObjet = new Decorator2(new 
                        #        Decorator1(new Core))
FACADE                  #Un ensemble d'interfaces, où on ne peut pas utiliser
                        #utiliser une interface commune par inhéritance car :
                        #  - interfaces trop différentes
                        #  - interfaces doivent être appelées successivement
                        #On utilise donc une interface commune Facade, mais
                        #sans inhéritance :
                        #  - ou elle définie plusieurs fonctions renvoyant aux
                        #    fonctions différentes des interfaces différentes
                        #  - ou elle appelle via une fonction l'ensemble des
                        #    interfaces successives
FLYWEIGHT               #Si on doit instancier un grand nombre de petits objets,
                        #pour éviter le coût, diviser entre une classe Factory
                        #qui contient les parties invariables de cet objet, et
                        #une classe Flyweight, instantiée avec comme argument
                        #les parties variables de l'objet, et instantiée via
                        #une fonction Create() de Factory.
                        #Factory peut maintenir un Pool et faire la gestion de
                        #tous les Flyweight créés.
PRIVATE CLASS DATA      #Déclarer des CLASSDT private, pour être sûr qu'ils ne
                        #soient accédés que via des getters et des setters, 
                        #même par les classes enfants.
PROXY                   #Classe utilisée comme intermédiaire pour accéder à une
                        #classe Master. Elle :
                        #  - instantie l'objet quand on lui demande et, si
                        #    singleton, si déjà créé, renvoie Master&
                        #  - se souvient de Master&
                        #  - "forward" les demandes du client vers Master
                        #Intérêts :
                        #  - "virtual proxy" : s'assurer qu'il s'agit d'un
                        #     Singleton, car Master est lourd à instantier
                        #  - "remote proxy" : différents "adress spaces" entre
                        #     le Master et le Client, besoin de traduire
                        #  - "protective proxy" : Master est secure-sensible,
                        #     Proxy ckecke les droits d'accès
                        #  - "smart proxy" : Proxy ajoute des fonctionnalités
                        #     en plus :
                        #      - smart pointer comptant le nombre de références
                        #        restantes pour supprimer la mémoire quand il
                        #        y en a 0
                        #      - checker que Master n'est pas locked (par 
                        #        exemple Multithreading)
                        #Si le client peut utiliser Master avec sans Proxy,
                        #faire une classe Interface parent de Master et Proxy,
                        #et travailler avec Interface (sauf cas où Proxy est
                        #exigé)
                        #Utilisation des overloadable operators ->, *, etc.
                        #peut être intéressante

                        #Structural object-creation patters (composition)

BEHAVIORAL DESIGN       
PATTERNS ==>            #Communication entre objets :

CHAIN OF RESPONSIBILITY #
COMMAND                 #
INTERPRETER             #
ITERATOR                #
MEDIATOR                #
MEMENTO                 #
NULL OBJECT             #
OBSERVER                #Event handling :
                        #  - "subjects" [un]register callbacks for a specific event
                        #  - "observer" notify subjects about an event -> fire the callbacks
STATE                   #
STRATEGY                #
TEMPLATE METHOD         #(Rien à voir avec les template < >)
                        #CLASSFK publique (interface utilisée par l'user) d'une 
                        #superclasse appelant une série de CLASSFK protected,
                        #dont certains sont invariants (non redéfinis par les
                        #subclasses) et d'autres variants (virtual, redéfinis
                        #par les subclasses).
                        #Intérêt : pas besoin de réimplémenter l'ensemble d'une
                        #virtual CLASSFK pour chaque objet, mais seulement les
                        #parties qui varient.
                        #Transparent pour l'user, qui utilise seulement la 
                        #CLASSFK publique.
VISITOR                 #

AUTRES ==>              #
NAMED CONSTRUCTOR IDIOM #Les constructors d'une class ne sont pas public, et il
                        #faut utiliser une static fonction create() pour 
                        #instantier.
                        #Permet des contrôles supplémentaires, par exemple si
                        #on veut éviter que la classe soit créée via des new,
                        #si on veut un singleton, etc.
