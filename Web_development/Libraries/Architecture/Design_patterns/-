
                     
   DESIGN PATTERNS   
                     


DESIGN PATTERNS ==>               #Usual|recommeded way of solving architectural problems:
                                  #  - creational: initializing objects
                                  #  - structural: object structure: inheritance, composition, wrapper, etc.
                                  #  - behavioral: communication between objects
                                  #"Gang of four" list (see it their respective docs):
                                  #  - creational: factory method, abstract factory, prototype, builder, object pool, singleton
                                  #  - structural: composite, wrapper, adapter, facade, bridge, proxy, flyweight, private class data
                                  #  - behavioral: chain of responsibility, command, interpreter, iterator, mediator, memento, null object, observer, state, strategy, template method, visitor
                

FACTORY METHOD ==>                #Creational pattern: function returning new instances of a type.
                                  #I.e. abstraction of a type initializer:
                                  #  - actual type initializers might be encapsulated (i.e. private)
                                  #  - pros: more flexibility, e.g.:
                                  #     - can instrument (e.g. pooling)
                                  #     - return different types
                                  #  - cons: more complexity, e.g.:
                                  #     - must replicate exception safety
ABSTRACT FACTORY ==>              #Creational pattern: factory method that is an abstract method.
                                  #I.e. children are meant to be reimplement it, e.g. specifying which instances to create

PROTOTYPE ==>                     #Creational pattern: a prototype is an object that is initialized by cloning.
                                  #Usually done through a factory method, which it registers itself to
BUILDER ==>                       #Creational pattern: initializing serialized objects:
                                  #  - a "reader" and "writer" deserialize|serialize an object
                                  #  - a "builder" initializes the deserialized object
                                  #     - it can be an abstract factory
                                  #Goal: separating object representation from initialization

OBJECT POOL ==>                   #Creational pattern:
                                  #  - pool creates objects in advance
                                  #  - new objects are taken from the pool
                                  #  - destroyed objects are returned to the pool for reuse
                                  #There can be a pool size limit
                                  #Goal: efficiency (when initialization is costly)

SINGLETON ==>                     #Creational pattern for objects that need to be unique.
                                  #When retrieving the object:
                                  #  - the first time, is initialized and returned
                                  #     - i.e. is lazy initialized
                                  #  - afterwards, is only returned
                                  #Often requires global scope:
                                  #  - must be thread-safe


WRAPPER ==>                       #Structural design patterns: interface abstracting another interface:
                                  #  - can modify interface (not behavior) in order to provide:
                                  #     - compatibility (adapter):
                                  #        - i.e. abstract difference from another interface
                                  #        - the other interface can be interacted with through:
                                  #           - composition ("object adapter")
                                  #           - inheritance ("class adapter")
                                  #     - simplicity (facade):
                                  #        - i.e. abstract between heterogeneous modules
                                  #     - abstraction (bridge):
                                  #        - i.e. abstract between different modules|implementations of similar purpose
                                  #  - can modify behavior (not interface) ("proxy"):
                                  #     - decorator / smart proxy: adds functionalities
                                  #     - remote proxy: translate different address spaces
                                  #     - protective|access proxy: authorization purpose
                                  #     - lazy load proxy: lazy initialization purpose
                                  #Can be "thin" or "thick" according to how much modification is done

FLYWEIGHT ==>                     #If several objects share information, sharing that information among them, instead of instantiating in each object.
                                  #Pros: more efficient. Cons: less granularity
                                  #Information can be shared as: 
                                  #  - references stored|shared in each object
                                  #  - function arguments

PRIVATE CLASS DATA ==>            #Encapsulating a class variable with a thin proxy for getting|setting it

HELPER/UTILITY ==>                #Module that is not linked to the core business logic
                                  #Helpers are stateful (e.g. object instances), utility are stateless|pure

FORWARDING VS DELEGATION ==>      #One interface ("sender") using another one ("receiver")
                                  #Can pass sender itself as argument:
                                  #  - forwarding: does not pass sender (i.e. same as wrapping)
                                  #  - delegating: pass sender

OBSERVER                					#Event handling :
                        					#  - "subjects" [un]register callbacks for a specific event
                        					#  - "observer" notify subjects about an event -> fire the callbacks

TEMPLATE METHOD         					#(Rien à voir avec les template < >)
                        					#CLASSFK publique (interface utilisée par l'user) d'une superclasse appelant une série de CLASSFK protected, dont certains sont invariants (non redéfinis par les
                        					#subclasses) et d'autres variants (virtual, redéfinis par les subclasses).
                        					#Intérêt : pas besoin de réimplémenter l'ensemble d'une virtual CLASSFK pour chaque objet, mais seulement les parties qui varient.
                        					#Transparent pour l'user, qui utilise seulement la CLASSFK publique.

NAMED CONSTRUCTOR IDIOM 					#Les constructors d'une class ne sont pas public, et il faut utiliser une static fonction create() pour instantier.
                        					#Permet des contrôles supplémentaires, par exemple si on veut éviter que la classe soit créée via des new, si on veut un singleton, etc.
