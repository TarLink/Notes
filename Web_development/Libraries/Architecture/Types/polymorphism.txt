
                  
   POLYMORPHISM   
                  


Polymorphism:
  - can be:
     - 1: subtypes (subtype|inclusion polymorphism)
     - 2: function overloading (ad-hoc polymorphism)
     - 3: generic programming (parametric polymorphism)
  - types are thought as:
     - 1: trees (i.e. type hierarchy) of general concepts
        - concepts -> usually OOP objects (except static members) but not required
     - 2: separate concepts
     - 3: traits combined with each other, i.e. accent on traits and algorithm
  - relationship between types:
     - 1: 
        - "subtyping", i.e. child-parent relationship: child reimplements parent's whole interface
        - subclassing|inheritance is special case when child references its parent:
           - inherits parent interface:
              - abstract methods: methods that only get their definition (not implementation) inherited
              - abstract class: class with only abstract methods
           - type identity conforms to parent's
           - some types might be non-subclassable, e.g. builtin types in some languages
     - 2|3: only relationship is that types implement part of each other interfaces
  - extending:
     - 1: defining parent's or new members
     - 2: defining functions with new argument types
     - 3: defining new types implementing "contracts" (members used by interface)
        - more abstract, i.e. harder to build generic type, but easier to extend
  - combining types:
     - "and":
        - 1: multiple inheritance
        - 2: none
        - 3: 
           - mixins
           - traits, like mixins but:
              - usually only methods, no attributes
              - can be composed instead of just overriding, e.g. addition, substraction or allowing aliasing if name conflict.
     - "or":
        - 1|2: type coercion ("coercion polymorphism"), i.e. making it possible for types to coerce to each other
        - 3: useless because implicit type
  - name resolution (dispatch):
     - 1: usually dynamic, but can be static with CRTP
     - 2: static is "overloading", dynamic is "multimethods"|"multiple dispatch"
     - 3: static is "templates", dynamic is "mixins"|"traits"
  - type definition:
     - 3:
        - predicative (as opposed to impredicative): can define with generic types ("any"), but must assign with non-generic types
        - rank-n (1 is "prenext"): can define with a generic type, that takes itself another generic type, etc. (n times)
           - e.g. FUNC(any_database of any_collection of any_item)

Subclassing:
  - class: "type" (i.e. readonly, compile-time) where prototypes are instances (i.e dynamic, runtime)
  - prototype:
     - multicast delegate: several parents, calls each parent's method
     - prototype can be either a reference or ("concatenating") a deep copy

Design patterns:
  - command pattern:
      - decouple:
           - input processing: done by "command" object:
                 - combination of a processor ("receiver") and processor's input
                 - represent an invocation not fired yet. Does not do processing itself ("receiver" does)
           - processing invocation: done by "invoker":
               - takes command object as input
               - fires command through a parameterless interface (e.g. command.execute())
      - the "client" is the consumer of the pattern (creates commands, invoke them)
  - chain of responsability:
      - one input is being processed sequentially by several objects which all implement same processing interface (e.g. obj.process(input))
          - sequence order can be:
              - maintained by a container (e.g. array order)
              - each processor point to to the next one.
              - same but might not point to next one (stopping the chain)
              - each processor point to 0-n others, making processors "dispatchers"
          - input can have a "type" so processors know whether to process or not
      - goal: decoupling several parts of processing of same input from each other

Operators:
  - functions with syntactic sugar
  - arity: unary, binary, ternary, etc.
  - can be confusing when overloading introduces different meaning/concept for same operator
  - for syntax reason, need to establish implicit operator priority order
