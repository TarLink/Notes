
                  
   POLYMORPHISM   
                  


Polymorphism:
        - subtypes (subtype/inclusion polymorphism, 1) vs generic programming (parametric polymorphism, 3) vs function overloading (ad-hoc polymorphism, 2)
        - default implementation:
             - 1: ancestor method (unless abstract method)
                   - abstract class/type: class with only abstract methods that cannot be instantiated
             - 2/3: none
         - arity/arguments:
             - 1: "this" (first implicit argument), less typing
             - 2/3: any argument, more flexible
                  - 1 can use 2 to achieve it
         - type manifest:
             - 1/2: explicit type
             - 3: no explicit type, "any" type
                   - predicative vs impredicative polymorphism: "any" type cannot/can resolve to another "any" type
                   - polymorphism rank:
                        - rank-1 ("prenex"): a function/type can take "any" type
                        - rank-2: a function/type can take any rank-1 function/type
                        - rank-3: etc.
                        - rank-n: infinite
         - specific implementations:
             - 1/2: redefine method, simpler
             - 1: subtyping:
                   - subclassing/inheritance: 
                        - special case, introducing inheritance of parent's members/implementation and type identity
                        - subtyping does not always imply subclassing, i.e. can only be about conforming to parent's interface with no inheritance
             - 2: overloading
             - 3: redefine members used by method ("contract"), more flexible (contracts can overlap)
                  - 3 can use 2 to redefine contract but might be antipattern (original contract not delegating implementation enough to members)
         - non-extendable implementations:
             - 1: non-subclassable types, e.g. builtin types in some languages
             - 2: none
             - 3: non-extendable types, e.g. non-user code
         - philosophy encourages thinking of types as:
             - 1: separate trees of general concepts, i.e. accent on type hierarchy, more children-oriented
             - 2: separate concepts
             - 3: traits combined with each other, i.e. accent on traits and algorithm, more parents-oriented
        - multiple types "or":
            - 1/2: type coercion ("coercion polymorphism")
            - 3: useless because implicit type
        - multiple types "and":
             - 1: multiple inheritance
                   - collisions: as 1 encourages bigger children and less parent types, more problematic than 3
                   - sometimes not possible.
                   - can use 3 to solve
             - 2: none
             - 3: 
                  - mixins
                  - traits, like mixins but:
                      - usually only methods, no attributes
                      - can be composed instead of just overriding, e.g. addition, substraction or allowing aliasing if name conflict.
         - compile-time vs run-time:
               - 1/2/3:
                  - compile-time: "static dispatch", usually using name mangling (type information concatenated to function name)
                  - run-time: "dynamic dispatch", usually using virtual table (hash of function pointers, resolved at runtime)
              - usually 1 is run-time and 2/3 compile-time
                  - 1 can be compile-time using CRTP
         - implementation of polymorphism:
              - 1: "dynamic dispatch",inheritance
              - 2: function overloading (compile-time), multimethods / multiple dispatch (runtime)
              - 3: templates (compile-time), duck typing (runtime)
         - encapsulation:
              - 1: private methods
              - 2/3: modular programming, i.e. limiting module scope (e.g. exports)
         - namespacing:
              - 1: implicit, i.e. easier
                    - static methods: only keep namespacing of 1, not polymorphism
              - 3: explicit

OOP:
  - objects:
       - obj.a + obj.func(): putting related methods and data in same namespace
       - obj.obj2: composition/aggregation/association
       - obj extends obj2: inheritance (subtype polymorphism with subclassing)

Combination:
  - generic data types: mix of 1 with 3: class where methods are generic, i.e. use "this" members following contracts
  - bounded quantification: mix of 3 with 1: generic function where type must conform with a given class
       - CRTP (curiously recurring template pattern) / F-bounded quantification: 
            - subtyping from a generic data type using subtype as generic type
            - goal: compile-time subtype polymorphism
            - ex: class A <T> { a() { use T } }
                     class B extends A<B>
                     class C extends A<C>
            - each subtype's parent will be different types unless derived themselves from a grandparent
            - ex: above A<B> and A<C> (thus B and C) are not siblings unless A <T> had a parent AA (not using CRTP)
    
Members:
   - recursive: can include itself directly or indirectly
   - types:
       - inheritance: "is a" (i.e. members through inheritance)
       - composition: "has a" (child cannot have two parents) and owns (child has same creation/destruction as parent)
            - containment/container: several children of similar/same type
            - "composition over inheritance": 
                - inheritance should only be used when it is ok all inherited members becomes part of child:
                     - are aimed at being part of child's public interface, i.e. does not break encapsulation
                     - behavorial subtyping, i.e. child is conceptually a subset:
                           -  subtitutability (Liskov substitution principle, "inheritance semantics"): child can be used where parent is without altering semantics, i.e. no more preconditions,  no less postconditions, same invariants (including exceptions)
                           -  same domain
                     - subset override covers all inherited members. Otherwise there are several possible groups of childs, which will create complicated/duplicated graph
                - should think of inherited attributes as aspects instead, added as members
       - aggregation: relation is "has a", but does not own
       - association: "is related to" but is not a member, e.g. message communication or call each others methods

Module/object organization:
  - single responsibility principle:
       - each module/object should:
            - do only one thing and do it well
            - have only "one reason to change"
       - high cohesion:
            - how much parts of a module/objects are inter-related
            - often negatively corrolated with loose coupling).
            - reasons of cohesion (from worst to best):
                 - coincidental: none
                 - logical: same technical nature (e.g. controllers, views)
                 - temporal: happen together at a given time (e.g. init)
                 - procedural: happen always after another
                 - communicational/informational: same data
                 - sequential: procedural + communicational, i.e. pipeline of input/output
                 - functional: same purpose
  - modular programming:
       - separating code into different blobs, e.g. files, libraries/packages, directories/modules, etc.
       - each module might also introduce encapsulation, i.e. only exporting public interface
   - open/closed source:
        - focus on making code easy to extend ("open for extension") than to modify ("close for modification")
             - encouraging reusing existing code (e.g. using inheritance, composition, aggregation, association) than modifying existing one


Subtype polymorphisme: prototype vs class:
  - class are a "type" (i.e. readonly, compile-time) where prototypes are instances (i.e dynamic, runtime)
  - prototype subtypes:
       - multicast delegate: several parents, calls each parent's method
       - prototype can be either a reference or ("concatenating") a deep copy

Design patterns:
  - command pattern:
      - decouple:
           - input processing: done by "command" object:
                 - combination of a processor ("receiver") and processor's input
                 - represent an invocation not fired yet. Does not do processing itself ("receiver" does)
           - processing invocation: done by "invoker":
               - takes command object as input
               - fires command through a parameterless interface (e.g. command.execute())
      - the "client" is the consumer of the pattern (creates commands, invoke them)
  - chain of responsability:
      - one input is being processed sequentially by several objects which all implement same processing interface (e.g. obj.process(input))
          - sequence order can be:
              - maintained by a container (e.g. array order)
              - each processor point to to the next one.
              - same but might not point to next one (stopping the chain)
              - each processor point to 0-n others, making processors "dispatchers"
          - input can have a "type" so processors know whether to process or not
      - goal: decoupling several parts of processing of same input from each other

Operators:
  - functions with syntactic sugar
  - arity: unary, binary, ternary, etc.
  - can be confusing when overloading introduces different meaning/concept for same operator
  - for syntax reason, need to establish implicit operator priority order
