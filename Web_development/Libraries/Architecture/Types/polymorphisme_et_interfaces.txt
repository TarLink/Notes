
                                 
   POLYMORPHISME ET INTERFACES   
                                 

TYPES DE POLYMORPHISME  #Les quatre types de polymorphisme sont :
 ==>                    #  - "coercion" : type overloading (dont cast explicite ou non)
                        #  - overloading de fonctions (parfois pas considéré)
                        #  - templates (programmation générique)
                        #  - "subtype polymorphism" : utilisation de classes interfaces comme argument

STATIC VS DYNAMIC ==>   #Les trois premiers doivent être résolus en compile-time, tandis que les virtual functions en runtime.

DIFFERENTES METHODES ==>#Les différentes méthodes pour implémenter le polymorphisme :

SUBTYPE                 #Une classe abstraite (interface) CLASS1, héritée par plusieurs classes enfants, CLASS2, CLASS3, etc.
POLYMORPHISME ==>       #CLASS1 a une CLASSFK abstraite, et chaque enfant implémente sa propre CLASSFK.
                        #Les fonctions prennent l'interface en argument :
                        #  - TYPE FONC_VAR(CLASS1& CLASS1_VAR)
                        #et invoque les virtual CLASSFK :
                        #  - { CLASS1_VAR.CLASSFK(); }
                        #En invoquant la fonction avec une classe enfant, ce sera la CLASSFK de l'enfant et non de l'interface
                        #qui sera invoquée :
                        #  - CLASS2 CLASS2_VAR;
                        #    FONC_VAR(CLASS2_VAR);
                        #Cependant les fonctions doivent prendre l'interface en argument par référence : en effet, par valeur,
                        #cela fait perdre le polymorphisme, et cela ne fonctionne pas.
                        #On peut alors aussi utiliser un pointeur de classe :
                        #  - TYPE FONC_VAR(CLASS1* CLASS1_ADR)
                        #    { CLASS1_ADR->CLASSFK(); }
                        #et :
                        #  - CLASS2* CLASS2_ADR = new CLASS2;
                        #    FONC_VAR(CLASS2_ADR);
                        #Or, plusieurs fonctions de bibliothèques exigent que leur argument soit copy-constructible ou 
                        #assignable, ce qui empêche l'utilisation de référence et oblige la solution du pointeur de classe. 
                        #C'est notamment le cas des constructors de containers.
                        #Exemple de cas où l'utilisation de pointeurs de classe est obligatoire :
                        #  - std::vector <CLASS*> VECTOR;
                        #    VECTOR.push_back(CLASS2_ADR);
                        #    VECTOR[0].CLASSFK();

CLASSES A COMPOSITION   #La composition utilise le subtype polymorphisme de ses membres.
==>                     #La composition permet une souplesse quant aux containers et leur contenu, construits runtime.
    
PROGRAMMATION GENERIQUE #Cf doc.
 ==>                    #Les templates sont plus libres que les interfaces : en effet ils n'exigent pas que l'argument soit un
                        #enfant d'une classe interface, mais seulement qu'il implémente certaines CLASSFK() ou CLASSDT.
                        #Cependant, ils sont compile-time.
                        #Les templates sont en fait du simple metaprogramming :
                        #  - le compilateur recherche l'ensemble des instantiations d'un template
                        #  - s'il y en a pas, la fonction/classe à template est oubliée
                        #  - sinon, pour chaque instantiation, les T, U, etc. sont remplacés par le type de l'instantiation,
                        #    et un mangled_name spécifique à cette instantiation du template est donné

OPEN/CLOSE PRINCIPLE ==>          #Interfaces should encourage being extended, as opposed to being modified.
                                  #E.g. by using polymorphism
                                  #"O" of SOLID principles
