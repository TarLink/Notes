
           
   TYPES   
           


TYPE CHECKING ==>                 #Type checking (type conformity between argument and parameter) can be done:
                                  #  - compile-time ("static")
                        					#     - safer
                        					#     - faster: not done runtime, and more optimizations
                        					#     - usually compiled languages
                                  #  - runtime ("dynamic")
                        					#     - more flexible (can create types runtime, simpler metaprogramming)
                        					#     - no compile-time required
                        					#     - usually scripted languages

SCOPE ==>                         #Context: current position in the program:
                                  #  - lexical: position in source code (compile-time)
                                  #  - execution|runtime|calling: position in call stack
                                  #Scope: 
                                  #  - associating identifier with an environment (set of available variables)
                                  #  - depends on where it is:
                                  #     - defined ("static|lexical")
                                  #        - i.e. according to lexical context
                                  #     - used ("dynamic")
                                  #        - i.e. according to execution context
                                  #        - e.g. where a function is fired
                                  #Name binding|resolution:
                                  #  - associating identifier with a value
                                  #  - can be performed:
                                  #     - compile-time (static|early)
                                  #     - runtime (dynamic|late)
                                  #Name masking

STATIC VS DYNAMIC SCOPE 					#  - static/lexical scope:
 ==>                    					#     - le callee n'hérite pas de l'environment du caller
                        					#     - donc une variable locale est définie que dans sa fonction
                        					#     - sépare les environments des fonctions les uns des autres, donc plus simple à réfléchir
                        					#     - block-scope vs function-scope : le premier limite l'environment pour tout block, non seulement 
                        					#       fonction
                        					#  - dynamic scope:
                        					#     - le callee hérite d'une *copie* de l'environment du caller
                        					#     - donc une variable locale est copiée aussi dans les fonctions appelées
                        					#        - copie -> le callee ne peut pas modifier variable du caller
                        					#     - plus de possibilité et flexibilité

                        					#      - duck typing : précisément lorsque l'on exécute VAR.FONC runtime, exécute FONC quel que soit 
                        					#        type de VAR (recherche seulement un symbole "FONC" dans VAR).

WEAK VS STRONG TYPED    
LANGAGE ==>             					#Un strongly typed langage n'autorise pas ou peu de typecast implicite.

TYPE INFERENCE VS       					#Le second indique qu'il faut expliciter le type de
MANIFEST TYPING ==>     					#chaque variable dans le code source. Le premier peut
                        					#le deviner lors du compile-time ou du runtime.

TYPE SAFETY ==>         					#Degré avec lequel un langage évite les erreurs compile time et runtime liés aux types : inclue le 
                        					#type checking, les type punnings, memory safety, etc.

MEMORY SAFETY ==>       					#Check de problème comme array overflow, déréférencement de mauvais pointeurs, etc.

TYPE PUNNING ==>        					#Typecaster une variable de manière bizarre pour faire un hack dessus. 
                        					#Ex : récupérer le bit de sign d'un float 32 bits.

NOMINATIVE VS           					#Dans un langage de type nominatif, un type est désigné
STRUCTURAL ==>          					#par un mot/nom ; mais dans un langage de type 
                        					#structural, il est désigné par la structure.

TABLEAU ==>             					#

+-----------------------------+                                                 
|           LANGAGE           |                                                
+-----------------------------+------------+----------+----------+-------------+
|            ASM x86          |   aucun    |  strong  |  unsafe  |  structural |
|             PHP             |  dynamic   |   weak   |   safe   |   aucun     |
|           JavaScript        |  dynamic   |   weak   |   safe   |    duck     |
|            Python           |  dynamic   |  strong  |   safe   |    duck     |
|             Ruby            |  dynamic   |  strong  |   safe   |    duck     |
|             Perl            |  dynamic   |   weak   |   safe   |  nominatif  |
|              C              |   static   |   weak   |  unsafe  |  nominatif  |
|             BASIC           |   static   |   weak   |   safe   |  nominatif  |
|             C++             |   static   |  strong  |  unsafe  |  nominatif  |
|              C#             |   static   |  strong  |  milieu  |  nominatif  |
|             Java            |   static   |  strong  |   safe   |  nominatif  |
|            FORTRAN          |   static   |  strong  |   safe   |  nominatif  |
|            Pascal           |   static   |  strong  |   safe   |  nominatif  |
+-----------------------------+------------+----------+----------+-------------+

OOP:
  - bundle data and methods of same concern together in a complex type (class)
  - subtyping (inheritance)
  - class-based vs prototype-based
