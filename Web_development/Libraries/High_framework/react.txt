
           
   REACT   
           


TO CHECK: https://github.com/facebook/react/wiki/Complementary-Tools ???

REACT
REACTDOM                          #Two packages (versions 0.14.2). Must require both.
REACTDOMSERVER                    #Subpackage of REACTDOM, for using in the server

DEVELOPMENT MODE ==>              #Checks NODE_ENV !== 'production'.
                                  #React uses envify in release files, which replaces NODE_ENV by 'development|production'


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            THEORY             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


PRINCIPLE ==>                     #Data flow:
                                  #  - 'state' is state own by current RCOMP, 'props' is state owned by a parent
                                  #     - when changing it, current RCOMP and all children get 'updated' (if only props !=),
                                  #       'unmounted|mounted' (if CTYPE different according to DOM order / keys)
                                  #     - should have as many RCOMP without 'state' as possible, and concentrate them into few parents
                                  #     - reduce amount of 'state': not computed|duplicated from other 'state|props', 
                                  #       not complex (e.g. not RELEM)
                                  #  - children are owned by the RCOMP that create them:
                                  #     - i.e. in RCOMP.render() -> <RCOMP2>...</RCOMP2>, ... will be 'updated' when current RCOMP is, 
                                  #       but not when RCOMP2 is, except if cloned in RCOMP2.render()
                                  #        - will still be correctly 'mounted|unmounted'
                                  #  - communicating with parent: passing a FUNC as props

GOOD PRACTICES ==>                #  - when passing props down, should explicitely pass props that are consumed, 
                                  #    e.g. deconstructing then spreading:
                                  #      var [ VAR, OBJ... ] = this.props;
                                  #      // Use VAR
                                  #      return <ELEM [VAR={VAR}] {...OBJ}>

BAD PRACTICES ==>                 #  - reaching to HTML elements instead of using RELEM/RCOMP abstraction:
                                  #     - e.g. using REF, REACTDOM.findDOMNode()
                                  #  - using RCOMP other than as 'this' in RCOMP methods:
                                  #     - e.g. using REACTDOM.render() return value
                                  #  - shortcircuiting data flow:
                                  #     - RCOMP.forceUpdate()


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          TERMINOLOGY          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


REACT.Component                   #Base RTYPE
RTYPE                             #RELEM's type
RDOM                              #Builtin RTYPE representing an HTML 'TAG'

RELEM                             #Abstracted ELEM (non-instantiated), i.e. RTYPE + props
RNODE                             #VAL[_ARR...]
                                  #  - VAL can be:
                                  #     - RELEM
                                  #     - STR|NUM: text node. Cannot use HTML entities, but can use raw|escaped Unicode.
                                  #     - null|undefined|true|false: no node (but present in props.children as null)
                                  #  - can be ARR, or ARR_ARR, etc. (will be flattened)

RCOMP                             #Instantiated RELEM. Is not an ELEM.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             RTYPE             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


REACT.createClass(OBJ)            #Creates and returns a RTYPE
                                  #Bind all OBJ.FUNC's this to current RCOMP
                                  #OBJ is merged into RCOMP's prototype
STATELESS COMPONENT ==>           #Can use a FUNC()->RELEM as RTYPE (like specifying only OBJ.render())
                                  #REF is null, so:
                                  #  - cannot use findDOMNode()
                                  #  - cannot use props.ref

ES6 CLASSES ==>                   #Can create ES6 class derived from REACT.Component as an alternative to REACT.createClass()
                                  #Differences:
                                  #  - different syntax:
                                  #     - getInitialState() -> setting this.state in constructor
                                  #     - propTypes|defaultProps OBJ -> static properties
                                  #  - less functionalities:
                                  #     - no 'this' binding
                                  #     - cannot use mixins
                                  #     - cannot use RCOMP.replaceState|isMounted()

RCOMP.displayName                 #JSX tag name, used for debugging.
                                  #Deduced from assigned variable if using JSX transformer.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             RELEM             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


REACT.createElement               #Creates and returns a RELEM
('TAG'|RTYPE[, OBJ][, RNODE...])  #OBJ|RNODE... are RCOMP.props|children.
                                  #'TAG':
                                  #  - use corresponding RDOM
                                  #  - RCOMP.props|children -> HTML attributes|children
REACT.createFactory('TAG'|RTYPE)  #Similar to REACT.createElement.bind(null, 'TAG'|RTYPE)
REACT.DOM.TAG(...)                #Same as REACT.createElement('TAG', ...)
REACT.cloneElement                #Creates and returns a RELEM2, cloned from RELEM.
(RELEM[, OBJ][, RNODE...])        #OBJ are shallow merged, RNODE... children are replaced.

RELEM.type                        #'TAG'|RTYPE
REACT.isValidElement(VAL)         #True if RELEM


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            RENDER             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


REACTDOM.render                   #Instantiate RELEM, and replace ELEM's children with it.
(RELEM, ELEM[, FUNC()]            #Returns RELEM's REF
                                  #Will replace old RELEM with new RELEM2. If:
                                  #  - RELEM === RELEM2 (i.e. same reference): nothing happens
                                  #  - RELEM == RELEM2 (i.e. same RTYPE|'TAG'):
                                  #     - 'update' RELEM
                                  #     - also done on RCOMP.setState|forceUpdate():
                                  #        - does not fire componentWillReceiveProps() nor (forceUpdate() only),
                                  #          shouldComponentUpdate()
                                  #        - unless called while an 'update' is already ongoing
                                  #  - RELEM != RELEM2: 'unmount' RELEM, 'mount' RELEM2
                                  #Calls FUNC() after all events done.
REACTDOMSERVER.renderToString     #Returns RELEM as 'HTML'
(RELEM)                           #Since 'HTML' contains React information, fires client-side REACTDOM.render() will be faster.
REACTDOMSERVR.renderToStaticMarkup
(RELEM)                           #Same but does not set React-specific HTML attributes like 'data-react-id'

MOUNT ==>                         #Fires RCOMP2 (in order):
                                  #  - componentWillMount()
                                  #  - render()
                                  #  - componentDidMount()
UPDATE ==>                        #Does:
                                  #  - not create new RCOMP (only updates it)
                                  #  - replace RCOMP's props with RCOMP2's
                                  #  - fires RCOMP (in order):
                                  #     - componentWillReceiveProps(OBJ): 
                                  #        - before assigning props (this.props is still old one)
                                  #        - OBJ is next props
                                  #        - often used to call setState() according to props
                                  #     - shouldComponentUpdate(OBJ2, OBJ3)->BOOL: 
                                  #        - return false to stop here
                                  #        - OBJ2|OBJ3 is next props|state
                                  #           - note that current props|state might already have changed 
                                  #             if OBJ2|3 was deeply changed, e.g.:
                                  #            this.setState({ VAR: { VAR2: this.state.VAR.VAR2 + VAL } })
                                  #     - componentWillUpdate()
                                  #        - cannot use setState()
                                  #     - render()
                                  #     - componentDidUpdate()
UNMOUNT ==>                       #Fires RCOMP:
                                  #  - componentWillUnmount()

RCOMP.render()                    #Does the actual DOM manipulation.
                                  #Must return RCOMP's RELEM (or null|false):
                                  #  - calls REACTDOM.render() on children:
                                  #     - order:
                                  #        - start with ancestor for componentWill*(), shouldComponentUpdate(), render()
                                  #        - start with descendant for componentDid*()
                                  #     - compare children old RELEM with new RELEM2 according to DOM order
                                  #        - problem:
                                  #           - in lists of similar items, modifications might recreate all items
                                  #             (e.g. prepending, since it compares by DOM order)
                                  #           - this is bad for performance, but also does not retain state in those items
                                  #        - solution: 
                                  #           - can use HTML attribute 'key', which will then be used for comparison
                                  #           - should then be unique ID among siblings
                                  #     - if children are not newly created in render() (e.g. use props.children reference),
                                  #       old RELEM === new RELEM2, so nothing will happen for that child
                                  #        - i.e. RCOMP 'owns' the children it creates in render(), but not the children passed to it
                                  #  - if RDOM, will update DOM, but in an efficient way:
                                  #     - does not update if same
                                  #     - only add|remove attributes if only attributes changed
                                  #  - should not modify state nor read global state nor be async
                                  #    (use componentDidMount|Update() for that)
                                  #Cannot return RELEM_ARR, so each RCOMP has only one root node.
RCOMP.forceUpdate()               #Forces 'update'
                                  #Useful when render() depends on state that changed but did not trigger a new render(), e.g.:
                                  #  - RCOMP.state.OBJ.VAR changed, but no setState() was called
                                  #  - DOM element change that cannot be caught with onEvent
REACTDOM.unmountComponentAtNode   #Inverse of REACTDOM.render(): remove ELEM children (firing 'unmount') then returns true.
(ELEM)                            #If no RCOMP was mounted, does nothing and returns false.

RCOMP.isMounted()                 #To use in async operation to make sure RCOMP still exists.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:       PROPS/STATE BASE        :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


RCOMP.props                       #HTML attributes as OBJ.
                                  #Readonly (non-configurable, non-writable) shallowly (but should be considered deeply readonly)
                                  #'Owned' by a parent, i.e. props change when the parent passing them re-rendered children with different props.
RELEM.props                       #As opposed to RCOMP, props.key|ref are not on RELEM.props.* but on RELEM.*
RCOMP.getDefaultProps()->OBJ      #Called once per RTYPE (not per RCOMP), 
                                  #then the result OBJ is shallowingly assigned to each new RCOMP.props
RCOMP.setProps|replaceProps(...)  #To avoid. Prefer calling REACTDOM.render() on same node again.


RCOMP.state                       #State OBJ
                                  #'Owned' by RCOMP
                                  #Should never be written to, use setState() instead
                                  #Might be null if not getInitialState()
RCOMP.getInitialState()->OBJ      #Initial RCOMP.state
                                  #Called before componentWillMount()
RCOMP.setState(OBJ[(OBJ2, OBJ3)]  #Shallow merges into RCOMP.state
[, FUNC()])                       #OBJ2|OBJ3 is current state|props
                                  #Might be performed async or not. FUNC() performed afterwards.
                                  #Fires 'update'
RCOMP.replaceState(...)           #Same but sets instead of merging


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:       PROPS/STATE EXTRA       :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


RCOMP.props.children              #CHILDREN
                                  #Opaque structure to be manipulated only through React.Children RCHILDREN, 
                                  #where RNODE will be individual elements (not ARR)
RCHILDREN.count(CHILDREN)         #
RCHILDREN.map|forEach
(CHILDREN, FUNC(RNODE)[, THIS])   #
RCHILDREN.toArray(CHILDREN)       #Returns RNODE_ARR
RCHILDREN.only(CHILDREN)          #Returns RNODE if CHILDREN contains only one child, and it is a RELEM
                                  #Otherwise throws (if in 'development mode')


RCOMP.propTypes                   #OBJ.VAR PROP_RULE:
                                  #  - if RTYPE.props.VAR does not satisfy PROP_RULE during createElement(), it will throw error:
                                  #     - only once for a given RTYPE + VAR + PROP_RULE
                                  #     - only in 'development mode'
                                  #  - use PTYPES.oneOfType|customProp for multiple validations
                                  #PROP_RULE is FUNC(OBJ, 'VAR', 'RTYPE')[->ERROR]
                                  #List of builtin PROP_RULE:
React.PropTypes                   #PTYPES
PTYPES.array|bool|func|           
number|object|string|node|element #Checks type: 'node' is RNODE[_ARR], 'element' RELEM
PTYPES.instanceOf(TYPE)           #
PTYPES.oneOf(VAL_ARR)             #
PTYPES.oneOfType(PROP_RULE_ARR)   #
PTYPES.arrayOf(PROP_RULE)         #
PTYPES.objectOf(PROP_RULE)        #Object values
PTYPES.shape({VAR: PROP_RULE ...})#
PROP_RULE.isRequired              #E.g. PTYPES.bool.isRequired


RCOMP.mixins                      #OBJ_ARR, where OBJ gets merged into RCOMP.
                                  #If property conflict:
                                  #  - if lifecycle RCOMP.FUNC (e.g. componentWillUpdate, etc.), surcharges instead of
                                  #    overriding it (i.e. called before non-mixin one)
                                  #  - otherwise, throws error


RCOMP.statics                     #OBJ assigned to RTYPE during createClass(), i.e. static methods.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             REFS              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


REF                               #Instantiation of a RELEM:
                                  #  - if based on RTYPE, RCOMP
                                  #  - if based on 'TAG', ELEM
                                  #  - if stateless component, null

RCOMP.props.ref                   #On createElement():
                                  #  - FUNC(REF): 
                                  #     - on mounting, called once with REF
                                  #     - on updating, first called with null (to let handler clean previous
                                  #       reference), then called with new REF
                                  #     - when unmounting, called once with null
                                  #  - 'REF': same as FUNC(REF) { this.refs['REF'] = REF; }

REACTDOM.findDOMNode(RCOMP)       #Returns corresponding ELEM
                                  #If RCOMP not mounted, throws exception


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             RDOM              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


RDOM ==>                          #Builtin RTYPE mimicking usual HTML.
                                  #Differences are below.

ALLOWED HTML TAGS|ATTRIBUTES ==>  #Whitelisted:
                                  #  - but should cover most standard HTML
                                  #  - custom HTML tags are allowed
                                  #  - custom HTML attributes are allowed if HTML tag name contains '-' or HTML attribute
                                  #    is="..." present

HTML ATTRIBUTES ==>               #  - camelcased, except data-*, aria-*
                                  #  - class -> className, html -> htmlFor
                                  #  - style OBJ.cssProp VAL (camelcased, except vendor prefix which are titleized)
                                  #  - boolean attributes: must only use BOOL as value
                                  #  - new ones:
                                  #     - dangerouslySetInnerHtml="JSON", with OBJ.__html STR: set innerHTML
                                  #     - ref|key: see below

DOM EVENTS ==>                    #  - onEvent(REVENT), with REVENT being like EVENT but:
                                  #     - better crossbrowser behavior
                                  #     - more performant (use only one global event listener, then redistribute)
                                  #     - extra properties:
                                  #        - nativeEvent EVENT
                                  #        - isDefaultPrevented|PropagationStopped(): like jQuery
                                  #     - no stopImmediatePropagation()
                                  #     - is deleted after function ends, so async can only use it with:
                                  #        - copying to local variable
                                  #        - or calling REVENT.persist()

FORM CONTROLS ==>                 #Value:
                                  #  - <textarea> children   -> <textarea value>
                                  #  - <option selected>     -> <select value> (STR[_ARR])
                                  #  - <input value|checked> -> same
                                  #HTML attributes:
                                  #  - onChange: 
                                  #     - should be used. Like onInput, but with React's behavior for 'value'
                                  #     - for checkboxes|radio buttons, do not call REVENT.preventDefault(),
                                  #       or control will be updated in model but not in UI
                                  #  - value|checked: 
                                  #     - sets default value
                                  #     - makes control read-only: can only updated with new render(), usually
                                  #       with this.setState() in onChange event handler
                                  #     - not updated on UI interaction but:
                                  #        - JavaScript value|checked is
                                  #        - if it triggers a new render() with new value|checked, it gets updated like this
                                  #     - good practice. Is how two-way data binding is done.
                                  #  - defaultValue|Checked: only sets default value


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              JSX              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


<...>                             #Like HTML but inside JavaScript:
                                  #  - translated as REACT.createElement(...) by transformers (e.g. Babel)
                                  #  - tag name:
                                  #     - convention is to use Capitalized custom CTYPE
                                  #     - can use <CTYPE.VAR[...]>
                                  #  - can use {...}:
                                  #     - instead of a node, e.g. <TAG>{RNODE}</TAG>
                                  #        - replaced by createElement() RNODE
                                  #     - HTML attribute VAR={VAL}:
                                  #        - replaced by createElement() OBJ { VAR: VAL }
                                  #        - can spread an OBJ: {...OBJ}
                                  #  - boolean attributes:
                                  #     - must use {BOOL} instead of "BOOL"
                                  #     - nothing -> true
                                  #  - OBJ attributes (e.g. "style"): ATTR="{ ... }"
                                  #  - JavaScript comments can be used
                                  #     - however, where they might be interpreted as text node, must be wrapped in {...}
                                  #  - must close tags, including as self-closing tags
