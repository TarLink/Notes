
           
   REACT   
           


REACT
REACTDOM                          #Two packages (versions 0.14.2). Must require both.
REACTDOMSERVER                    #Subpackage of REACTDOM, for using in the server

REACT.Component                   #Base RTYPE
RTYPE                             #RELEM's type
RDOM                              #Builtin RTYPE representing an HTML 'TAG'
RELEM                             #Abstracted ELEM (non-instantiated)
RCOMP                             #Abstracted ELEM (instantiated)
RNODE                             #VAL[_ARR...]
                                  #  - VAL can be:
                                  #     - RELEM
                                  #     - STR|NUM: text node. Cannot use HTML entities, but can use raw|escaped Unicode.
                                  #     - null|undefined|true|false: no node (but present in props.children as null)
                                  #  - can be ARR, or ARR_ARR, etc. (will be flattened)
REF                               #Instantiation of a RELEM:
                                  #  - if based on RTYPE, RCOMP
                                  #  - if based on 'TAG', ELEM
                                  #  - if stateless component, null

PRODUCTION MODE ==>               #Checks NODE_ENV !== 'production'.
                                  #React uses envify in release files, which replaces NODE_ENV by 'development|production'
                                  #If production:
                                  #  - does not throw nor logs:
                                  #     - with RTYPE_CONF.propTypes
                                  #     - with RCHILDREN.only()

RDOM ==>                          #Builtin RTYPE mimicing usual HTML.
                                  #Allowed HTML tags|attributes are whitelisted:
                                  #  - but should cover most standard HTML.
                                  #  - custom HTML tags are allowed
                                  #  - custom HTML attributes are allowed if HTML tag name contains '-' or HTML attribute
                                  #    'is="..."' present
                                  #Some differences:
                                  #  - HTML attributes:
                                  #     - camelcased, except data-*, aria-*
                                  #     - class -> className, html -> htmlFor
                                  #     - style="{ CSS_PROP: VAL, ... }"
                                  #     - new ones:
                                  #        - dangerouslySetInnerHtml="JSON", with OBJ.__html STR: set innerHTML
                                  #        - ref|key: see below
                                  #     - boolean attributes: must only use BOOL as value
                                  #  - onEvent(REVENT), with REVENT being like EVENT but:
                                  #     - better crossbrowser behavior
                                  #     - more performant (use only one global event listener, then redistribute)
                                  #     - extra properties:
                                  #        - nativeEvent EVENT
                                  #        - isDefaultPrevented|PropagationStopped(): like jQuery
                                  #     - no stopImmediatePropagation()
                                  #     - is deleted after function ends, so async can only use it with:
                                  #        - copying to local variable
                                  #        - or calling REVENT.persist()
                                  #  - form controls:
                                  #     - onChange is actually like onInput


REACT.createClass(OBJ)            #Creates and returns a RTYPE
                                  #Bind all OBJ.FUNC's this to current RCOMP
                                  #OBJ is merged into RCOMP
STATELESS COMPONENT ==>           #Can use a FUNC()->RELEM as RTYPE:
                                  #  - differences???
                                  #     - cannot use findDOMNode()

REACT.createElement               #Creates and returns a RELEM
('TAG'|RTYPE[, OBJ][, RNODE...])  #OBJ|RNODE...:
                                  #  - with 'TAG', will become HTML attributes|children
                                  #  - with RTYPE, become RCOMP.props|children
                                  #'TAG': will use corresponding RDOM
REACT.createFactory('TAG'|RTYPE)  #Similar to REACT.createElement.bind(null, 'TAG'|RTYPE)
REACT.DOM.TAG(...)                #Same as REACT.createElement('TAG', ...)
REACT.cloneElement                #Creates and returns a RELEM2, cloned from RELEM.
(RELEM[, OBJ][, RNODE...])        #OBJ are shallow merged, RNODE... children are replaced.

REACTDOM.render                   #Instantiate RELEM, and replace ELEM's children with it.
(RELEM, ELEM[, FUNC()]            #Returns RELEM's REF (avoid using it)
                                  #Will replace old RELEM with new RELEM2. If:
                                  #  - RELEM === RELEM2 (i.e. same reference): nothing happens
                                  #  - RELEM == RELEM2 (i.e. same RTYPE|'TAG'):
                                  #     - does not create new RCOMP, instead only:
                                  #        - replace RCOMP's props with RCOMP2's
                                  #        - fires 'update', i.e. RCOMP (in order):
                                  #           - componentWillReceiveProps(OBJ): 
                                  #              - before assigning props (this.props is still old one)
                                  #              - OBJ is next props
                                  #              - often used to call setState() according to props
                                  #           - shouldComponentUpdate()->BOOL: return false to stop here
                                  #           - componentWillUpdate()
                                  #              - cannot use setState()
                                  #           - render()
                                  #           - componentDidUpdate()
                                  #     - also done when RCOMP.setState|forceUpdate():
                                  #        - does not fire componentWillReceiveProps()
                                  #        - forceUpdate() also does not fire shouldComponentUpdate()
                                  #        - unless called while an 'update' is already ongoing
                                  #  - RELEM != RELEM2:
                                  #     - 'unmount' RELEM, i.e. fires RCOMP:
                                  #        - componentWillUnmount()
                                  #     - 'mount' RELEM2, i.e. fires RCOMP2:
                                  #        - componentWillMount()
                                  #        - render()
                                  #        - componentDidMount()
                                  #Calls FUNC() after all events done.
RCOMP.render()                    #Does the actual DOM manipulation.
                                  #Must return RCOMP's RELEM:
                                  #  - calls REACTDOM.render() on children:
                                  #     - starting with descendants
                                  #     - compare children old RELEM with new RELEM2 according to DOM order
                                  #        - problem:
                                  #           - in lists of similar items, modifications might recreate all items
                                  #             (e.g. prepending, since it compares by DOM order)
                                  #           - this is bad for performance, but also does not retain state in those items
                                  #        - solution: 
                                  #           - can use HTML attribute 'key', which will then be used for comparison
                                  #           - should then be unique ID among siblings
                                  #     - if children are not newly created in render() (e.g. use props.children reference),
                                  #       old RELEM === new RELEM2, so nothing will happen for that child
                                  #        - i.e. RCOMP 'owns' the children it creates in render(), but not the children passed to it
                                  #  - if RDOM, will update DOM, but in an efficient way:
                                  #     - does not update if same
                                  #     - only add|remove attributes if only attributes changed
                                  #  - should not modify state nor read global state nor be async
                                  #    (use componentDidMount|Update() for that)
                                  #Can also return null|false
RCOMP.forceUpdate()               #Forces 'update' (see above) (to avoid)
                                  #Useful when render() depends on state that changed but did not trigger a new render(), e.g.:
                                  #  - RCOMP.state.OBJ.VAR changed, but no setState() was called
                                  #  - DOM element change that cannot be caught with onEvent
RCOMP.isMounted()                 #To use in async operation to make sure RCOMP still exists.
REACTDOM.unmountComponentAtNode   #Inverse of REACTDOM.render(): remove ELEM children (firing 'unmount') then returns true.
(ELEM)                            #If no RCOMP was mounted, does nothing and returns false.

REACTDOMSERVER.renderToString     #Returns RELEM as 'HTML'
(RELEM)                           #Since 'HTML' contains React information, fires client-side REACTDOM.render() will be faster.
REACTDOMSERVR.renderToStaticMarkup
(RELEM)                           #Same but does not set React-specific HTML attributes like 'data-react-id'

RELEM.type                        #'TAG'|RTYPE

RCOMP.displayName                 #JSX tag name, used for debugging.
                                  #Deduced from assigned variable if using JSX transformer.

RCOMP.props                       #HTML attributes as OBJ.
                                  #Readonly (non-configurable, non-writable)
                                  #'Owned' by a parent, i.e. props change when the parent passing them re-rendered children with different props.
RCOMP.getDefaultProps()->OBJ      #Called once per RTYPE (not per RCOMP), 
                                  #then the result OBJ is shallowingly assigned to each new RCOMP.props
RCOMP.setProps|replaceProps(...)  #To avoid. Prefer calling REACTDOM.render() on same node again.

RCOMP.state                       #State OBJ
                                  #'Owned' by RCOMP
                                  #Should never be written to, use setState() instead
RCOMP.getInitialState()->OBJ      #Initial RCOMP.state
                                  #Called before componentWillMount()
RCOMP.setState(OBJ[(OBJ2, OBJ3)]  #Shallow merges into RCOMP.state
[, FUNC()])                       #OBJ2|OBJ3 is current state|props
                                  #Might be performed async or not. FUNC() performed afterwards.
RCOMP.replaceState(...)           #Same but sets instead of merging

RCOMP.refs.REF                    #REF to RCOMP or its children, using HTML attribute ref="REF"
                                  #  - setup by render()???

RCOMP.props.children              #CHILDREN, i.e. RNODE[_ARR] (ARR only if length > 1)
                                  #Should only be manipulated through React.Children RCHILDREN, where RNODE will be individual
                                  #elements (not ARR)
RCHILDREN.map|forEach
(CHILDREN, FUNC(RNODE)[, THIS])   #
RCHILDREN.count(CHILDREN)         #
RCHILDREN.toArray(CHILDREN)       #Returns RNODE_ARR
RCHILDREN.only(CHILDREN)          #Returns RNODE if CHILDREN contains only one child, and it is a RELEM

RCOMP.mixins                      #OBJ_ARR, where OBJ gets merged into RCOMP.
                                  #If property conflict:
                                  #  - if lifecycle RCOMP.FUNC (e.g. componentWillUpdate, etc.), surcharges instead of
                                  #    overriding it (i.e. called before non-mixin one)
                                  #  - otherwise, throws error

RCOMP.statics                     #OBJ assigned to RTYPE during createClass(), i.e. static methods.


REACT.isValidElement(VAL)         #True if RELEM
REACTDOM.findDOMNode(RCOMP)       #Returns corresponding ELEM (to avoid)
                                  #If RCOMP not mounted, throws exception

TWO-WAY DATA BINDING ==>          #Works by passing FUNC as RTYPE.props


ES6 CLASSES ==>                   #Can create ES6 class derived from REACT.Component as an alternative to REACT.createClass(). 
                                  #Differences:
                                  #  - getInitialState() -> setting this.state in constructor
                                  #  - propTypes|defaultProps OBJ -> static properties
                                  #  - no 'this' binding
                                  #  - cannot use RCOMP.replaceState|isMounted()
                                  #  - cannot use mixins


RCOMP.propTypes                   #OBJ.VAR PROP_RULE:
                                  #  - if RTYPE.props.VAR does not satisfy PROP_RULE during createElement(), it will throw error:
                                  #     - only once for a given RTYPE + VAR + PROP_RULE
                                  #  - use PTYPES.oneOfType|customProp for multiple validations
                                  #PROP_RULE is FUNC(OBJ, 'VAR', 'RTYPE')[->ERROR]
                                  #List of builtin PROP_RULE:
React.PropTypes                   #PTYPES
PTYPES.array|bool|func|           
number|object|string|node|element #Checks type: 'node' is RNODE[_ARR], 'element' RELEM
PTYPES.instanceOf(TYPE)           #
PTYPES.oneOf(VAL_ARR)             #
PTYPES.oneOfType(PROP_RULE_ARR)   #
PTYPES.arrayOf(PROP_RULE)         #
PTYPES.objectOf(PROP_RULE)        #Object values
PTYPES.shape({VAR: PROP_RULE ...})#
PROP_RULE.isRequired              #E.g. PTYPES.bool.isRequired

PRINCIPLE ==>                     #Data flow:
                                  #  - 'state' is state own by current RCOMP, 'props' is state owned by a parent
                                  #     - when changing it, current RCOMP and all children get 'updated' (if only props !=),
                                  #       'unmounted|mounted' (if CTYPE different according to DOM order / keys)
                                  #     - should have as many RCOMP without 'state' as possible, and concentrate them into few parents
                                  #     - reduce amount of 'state': not computed|duplicated from other 'state|props', 
                                  #       not complex (e.g. not RELEM)
                                  #  - children are owned by the RCOMP that create them:
                                  #     - i.e. in render() -> <RCOMP2>...</RCOMP2>, ... will be 'updated' when current RCOMP is, 
                                  #       but not when RCOMP2 is, except if clone
                                  #        - will still be correctly 'mounted|unmounted'

GOOD PRACTICES ==>                #When passing props down:
                                  #  - should explicitely pass props that are consumed, e.g. deconstructing then spreading:
                                  #      var [ VAR, OBJ... ] = this.props;
                                  #      // Use VAR
                                  #      return <ELEM [VAR={VAR}] {...OBJ}>


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              JSX              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


<...>                             #Like HTML but inside JavaScript:
                                  #  - translated as REACT.createElement(...) by transformers (e.g. Babel)
                                  #  - tag name:
                                  #     - convention is to use Capitalized custom CTYPE
                                  #     - can use <CTYPE.VAR[...]>
                                  #  - can use {...}:
                                  #     - instead of a node, e.g. <TAG>{RNODE}</TAG>
                                  #        - replaced by createElement() RNODE
                                  #     - HTML attribute VAR={VAL}:
                                  #        - replaced by createElement() OBJ { VAR: VAL }
                                  #        - can spread an OBJ: {...OBJ}
                                  #  - boolean attributes:
                                  #     - must use {BOOL} instead of "BOOL"
                                  #     - nothing translates to true
                                  #  - JavaScript comments can be used
                                  #     - however, where they might be interpreted as text node, must be wrapped in {...}
