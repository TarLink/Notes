
                         
   BACKBONE-RELATIONAL   
                         


VERSION ==>                       #0.9.0

Backbone.Relational               #BREL
Backbone.RelationalModel          #RMODEL_CTOR. Child of MODEL_CTOR

RMODEL.relations                  #REL_ARR:
                                  #  - key "VAR", relatedModel RMODEL2 (def: RMODEL), type "HasOne|HasMany":
                                  #     - means RMODEL.VAR contains RMODEL2.id (or any RMODEL.idAttribute):
                                  #        - can populate:
                                  #           - automatically fetched at construction if REL.autoFetch true|OBJ (def: false)
                                  #             (OBJ is passed to RMODEL.getAsync())
                                  #        - RMODEL.set() will update RMODEL2:
                                  #           - can use OBJ.add|merge|remove like COLL.set() if "HasMany"
                                  #        - fires event change:VAR(RMODEL2, COLL|???) when RMODEL2 changes
                                  #     - if Backbone.HasMany, means RMODEL.VAR is an ARR
                                  #        - must specify collectionType COLL2
                                  #        - REL.collectionKey "VAR3"???
                                  #        - fires events add|remove:VAR(RMODEL2, COLL2) when ARR gets new|less elements
                                  #  - reverseRelation REL2:
                                  #     - inverse, i.e. means RMODEL2.VAR2 contains RMODEL.id (or any RMODEL.idAttribute)
                                  #     - type def will be the inverse, relatedModel def will RMODEL
                                  #     - REL2.type cannot be "HasMany" if RMODEL.type "HasMany"
                                  #       To support many-to-many must use a third REMODEL3 (join table)
                                  #     - when RMODEL[2].VAR[2] is updated, the other RMODEL[2].VAR[2] is as well
                                  #     - also has attributes:
                                  #        - includeInJSON BOOL|"VAR"[_ARR]: includes RMODEL2.VAR in RMODEL.toJSON()
                                  #          (if true (def): all VAR, false: none)
                                  #        - can be on REL too???
                                  #     - collectionOptions OBJ: passed to new COLL_CTOR() OBJ
                                  #  - createModels BOOL: if true (def), can instantiate with RMODEL2 instead of RMODEL2.id
                                  #    (only instantiate or also set???)
                                  #  - keySource "VAR3": means will use RMODEL2.VAR2 in RMODEL.toJSON(), but RMODEL2.VAR3
                                  #    otherwise
                                  #  - keyDestination "VAR3" (def: same as keySource if specified): means will use 
                                  #    RMODEL.VAR3 in RMODEL.toJSON(), but RMODEL.VAR3 otherwise
                                  #  - parse BOOL: if true (def: false), use MODEL.parse() when setting RMODEL2
                                  #  - subModelTypes { STR: RMODEL3 ... }:
                                  #     - means RMODEL instances with RMODEL.ATTR STR will be RMODEL3 instances instead, where
                                  #       RMODEL3 is a child of RMODEL
                                  #     - ATTR is REL.subModelTypeAttribute (def: "type")
                                  #     - used for OO-relational model (single relation, but different possible types with
                                  #       different attributes)
                                  #RMODEL[2|3] and COLL can be STR:
                                  #  - they are resolved compared to WINDOW
                                  #  - can add scope to compare with thanks to STORE.add|RemoveModelScope(OBJ)
RMODEL.getAsync("VAR"[, OBJ])     #Populates and returns RMODEL.VAR, returning a jQuery PROMISE (or DEFERRED???)
                                  #Calls underlyingly RMODEL.fetch(OBJ)
                                  #Only fetches not populated yet, unless OBJ.refresh true
                                  #Will either:
                                  #  - do one request per RMODEL2
                                  #  - do single request if RMODEL.collectionType COLL, and COLL.url specified
                                  #     - can specify COLL.url(RMODEL_ARR)->URL to differentiate URL when whole COLL of just
                                  #       few RMODELs??? 
RMODEL.getIdsToFetch("VAR"[,BOOL])#Same as RMODEL.getAsync("VAR", { refresh: BOOL }), except only returns RMODEL.VAR ids,
                                  #and is sync.
RMODEL.getRelations()             #Returns { VAR: REL2 ... }
RMODEL.getRelation("VAR")         #Returns REL2

RMODEL_CTOR.setup()               #To call from CoffeeScript when using (call it just afterwards):
                                  #  class RMODEL_CTOR extends RMODEL_CTOR2
                                  #Instead of:
                                  #  var RMODEL_CTOR = RMODEL_CTOR2.extend(...)
RMODEL_CTOR.build(...)            #Like new RMODEL_CTOR(...), but taking subModelTypes into account.
RMODEL_CTOR.findModel             #Calls BREL.store.find(RMODEL_CTOR, ATTR_OBJ|id|cid), which basically calls 
(ATTR_OBJ|id|cid)                 #COLL.get(id|cid|ATTR_OBJ.id)
                                  #Can override it.
RMODEL_CTOR.findOrCreate          #Like findModel() but:
(ATTR_OBJ|id|cid[, OBJ2])         #  - if not found and OBJ2.create true (def), creates it with RMODEL_CTOR.build(...)
                                  #  - updates with RMODEL.set(...) if found and OBJ2.merge true (def)
                                  #  - MODEL.parse() is used if OBJ2.parse true (def: false), with this not pointing to MODEL
RMODEL_CTOR.find(...)             #Same with OBJ2.create false

BREL.store                        #STORE. Cache populated RMODEL2
STORE.unregister
(RMODEL[_CTOR]|COLL)
STORE.reset()                     #Removing from cache makes relations not usable anymore.
