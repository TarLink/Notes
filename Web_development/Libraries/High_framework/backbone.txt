
              
   BACKBONE   
              


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             CORE              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


VERSION ==>                       #1.2.0

Backbone                          #Global object
                                  #Can be unset and returned by Backbone.noConflict()

DEPENDENCIES ==>                  #Must load first:
                                  #  - Underscore or Lo-dash
                                  #  - jQuery, set to Backbone.$ (can be overriden)
                                  #Some methods are also mixed in:
                                  #  - MODEL: keys|values|pairs|invert|pick|omit|chain|isEmpty()
                                  #  - COLL: forEach|map|reduce[Right]|find|filter|reject|every|some|contains|invoke|max|min|
                                  #    sortBy|groupBy|shuffle|toArray|size|first|initial|rest|last|without|indexOf|lastIndexOf|
                                  #    isEmpty|chain|difference|sample|partition|countBy|indexBy()

IN SHORT ==>                      #  - EVENT: like EventEmitter in Node
                                  #  - MODEL: an augmented OBJ (or database row server-side)
                                  #  - COLL: MODEL_ARR (or database table server-side)
                                  #  - ROUTER: callbacks fired when URL changes
                                  #  - VIEW: DOM element, setting up event handlers


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            EVENTS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Backbone.Events                   #EVENTS.
                                  #Makes an OBJ event listener by mixing in, i.e. _.extend(OBJ, EVENTS)
                                  #All methods below return EVENTS
                                  #Most Backbone-native events can be prevented by using OBJ.silent true in the function 
                                  #firing them, e.g. MODEL.set(..., { silent: true })

EVENTS.on|once(EVENT_STR,
FUNC(...)[, THIS])                
EVENTS.on|once                    #EVENT_STR can be: 
({ EVENT_STR: FUNC(...) }         #  - a space-delimited list.
[, THIS])                         #  - "all": pass actual EVENT_STR as first arg
EVENTS.off                        #If:
([EVENT_STR[, FUNC[, THIS]]])     #  - EVENT_STR|FUNC null: means any
                                  #  - THIS: if defined, means only when THIS was used in on()
EVENTS.trigger(EVENT_STR[, ...])  #

EVENTS.listenTo[Once](EVENTS2,...)
EVENTS.stopListening              #Like EVENTS2.on|once|off(..., EVENTS), but semantically indicates that EVENTS "eavesdrops" 
([EVENTS2, ]...)                  #on another EVENTS2


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            GENERAL            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


G*                                #Means MODEL|COLLECTION|ROUTER|HISTORY|VIEW
                                  #Describe the object system used by main Backbone objects
                                  #Only the constructor changes, so is described below.
Backbone.G*                       #Root G*_CONSTRUCTOR, camelcase, e.g. Backbone.Collection
G*_CONSTRUCTOR.extend
(G*_ATTR[, G*_CONST_ATTR])        #Returns a G*_CONSTRUCTOR2, inheriting G*_CONSTRUCTOR's G*_ATTR and G*_CONST_ATTR
new G*_CONSTRUCTOR(...)           #Returns a G*:
                                  #  - G*_ATTR is mixed in every G*
                                  #  - G*_CONST_ATTR is mixed in G*_CONSTRUCTOR, i.e. G*.constructor
G*_ATTR.initialize(...)           #Called when new G*_CONSTRUCTOR(...) is called
G*_ATTR.constructor()             #Called instead of new G*_CONSTRUCTOR(...), so must, like in a normal constructor:
                                  #  - modify this
                                  #  - call parent G*_CONSTRUCTOR2: G*_CONSTRUCTOR2.apply( this, arguments );
                                  #Only for very special cases.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            MODELS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/



new MODEL_CONSTRUCTOR             #Returns a MODEL, i.e. an "augmented OBJ" (client-side) or a database row (server-side):
(OBJ[, OBJ2])                     #  - For readwrite variables, use MODEL_ATTR.defaults OBJ3|FUNC()->OBJ3
                                  #    (OBJ3 is reference, FUNC() OBJ3 per value) instead of MODEL_ATTR
                                  #  - ATTR_OBJ == MODEL.attributes == OBJ + MODEL_ATTR
                                  #  - OBJ2 is passed to initial MODEL.set()
MODEL.clone()                     #

MODEL.get|escape("VAR")         
MODEL.set("VAR", VAL[, OBJ])    
MODEL.set({ VAR: VAL }[, OBJ])    #Manipulates ATTR_OBJ. "VAR" should not include spaces.
MODEL.unset("VAR"[, OBJ])         #escape() returns as HTML-escaped STR
MODEL.clear([OBJ])                #set|unset|clear() fires events change(MODEL, OBJ) and change:VAR(MODEL, VAL, OBJ)
MODEL.has("VAR")                  #unless no value was changed.

MODEL.changedAttributes([OBJ])    #Returns the part of ATTR_OBJ modified by the last MODEL.set(), or false if it did not 
                                  #change anything.
                                  #Use OBJ not to return any attributes that match same key+val.
                                  #Internaly use MODEL.changed, which is like MODEL.attributes but keep only track of changes.
MODEL.hasChanged()                #Returns true if MODEL.changedAttributes() empty
MODEL.previousAttributes()        #Returns ATTR_OBJ before the modification by the last MODEL.set().
                                  #Only available in "change[:VAR]" event handlers.
MODEL.previous(VAR_STR)           #Same as MODEL.previousAttributes().VAR

MODEL.id                          #MODEL ID.
                                  #Equal to ATTR_OBJ[MODEL_ATTR.idAttribute (def: "id")]
                                  #Should be defined server-side (by MODEL.save()), not client-side (by new MODEL())
MODEL.cid                         #Unique ID assigned by Backbone, useful when MODEL.id not available (e.g. not saved on
                                  #server yet).
                                  #By def., an incremented number prepended by "c" (or MODEL_ATTR.cidPrefix STR)
MODEL.isNew()                     #Returns true if MODEL.id undefined

MODEL.toJSON([OBJ])               #JSON.stringify() takes MODEL.toJSON() instead of MODEL as input.
                                  #Should return MODEL as OBJ2 (not "OBJ2")
                                  #Can be overriden.
                                  #By def., returns ATTR_OBJ copy.
Backbone.ajax(OBJ)                #Hardlink to $.ajax(OBJ). Can be overriden.
                                  #Conventions:
                                  #  - return value is XHR_RET (JQXHR with jQuery)
                                  #  - XHR_VAL is the first argument passed to OBJ.success|error() callbacks
                                  #    (with jQuery: the return value for success, the JQXHR for error)
Backbone|MODEL.sync               #Calls and returns Backbone.ajax(OBJ), with OBJ also having:
(METHOD_STR, MODEL[, OBJ])        #  - type STR: according to METHOD_STR:
                                  #     - "create": POST   
                                  #     - "read"  : GET    
                                  #     - "update": PUT    
                                  #     - "patch" : PATCH  
                                  #     - "delete": DELETE 
                                  #  - url STR:
                                  #     - OBJ.url if defined
                                  #     - or "/COLL_NAME[/ID]":
                                  #        - "/COLL_NAME" is COLL_ATTR.url STR|FUNC()->STR or (if MODEL outside of a COLL) 
                                  #           MODEL_ATTR.urlRoot STR|FUNC()->STR
                                  #        - /ID is "/" + MODEL.id, not defined if MODEL.isNew()
                                  #  - dataType "json"
                                  #  - emulateHTTP|JSON BOOL: see below
                                  #  (not for GET nor DELETE)
                                  #  - contentType "application/json"
                                  #  - data STR: JSON.stringify(MODEL.toJSON(OBJ))
                                  #  - success|error(...): MODEL.fetch|save|destroy wrapped it to take as arguments
                                  #    (MODEL, XHR_VAL, OBJ).
                                  #    Can use OBJ.context to define this in the wrapped callback
                                  #For older servers, if: 
                                  #  - Backbone.emulateHTTP true, use only GET|POST + HTTP-Method-Override METHOD header
                                  #  - Backbone.emulateHTTP + Backbone.emulateJSON true, use also _method METHOD query param
                                  #  - Backbone.emulateJSON true, send as "application/x-www-form-urlencoded" instead of
                                  #    "application/json"
                                  #Can be overriden globally, or only for a MODEL by overriding MODEL_ATTR.sync()
                                  #Events:
                                  #  - request(MODEL, XHR_RET, OBJ): when request start
                                  #  - sync|error(MODEL, XHR_VAL, OBJ): when request succeeded|errored, only with 
                                  #    MODEL.fetch|save|destroy()
MODEL.fetch([OBJ])                #Calls and returns MODEL.sync("read", MODEL[, OBJ]), then do MODEL.set(XHR_VAL)
MODEL.save(...)                   #Calls MODEL.set(...), then calls/returns Backbone.sync("create|update|patch", MODEL[, OBJ]):
                                  #  - "create": if MODEL.isNew()
                                  #  - "update": if not MODEL.isNew() and OBJ.patch false
                                  #  - "patch": if not MODEL.isNew() and OBJ.patch true
                                  #    As opposed to "create|update", only send attributes specified by ... (not whole ATTROBJ)
                                  #then call MODEL.set(XHR_VAL)
                                  #If OBJ.wait true, only does the second MODEL.set()
MODEL.destroy([OBJ])              #Calls and returns Backbone.sync("delete", MODEL[, OBJ])
                                  #Does nothing and returns false if MODEL.isNew()
                                  #Fire COLL.remove(MODEL) + destroy(MODEL, COLL, OBJ) event right away.
                                  #If OBJ.wait true, does COLL.remove() + destroy() event after Backbone.sync() successfully 
                                  #answered.

MODEL_ATTR.validate(ATTR_OBJ, OBJ)#Can be user-defined. Must return ERROR[_STR] if problem, nothing otherwise.
                                  #Called by MODEL.save() and (if OBJ.validate true) by MODEL.set|fetch()
                                  #OBJ is MODEL.save|set|fetch() OBJ
                                  #If problem:
                                  #  - stops operation by returning false 
                                  #  - fire invalid(MODEL, ERROR[_STR], OBJ)
                                  #  - sets MODEL.validationError ERROR[_STR]
MODEL.isValid()                   #Runs MODEL.validate() then returns BOOL.
MODEL_ATTR.parse(VAL[, OBJ])->VAL #Can be defined to modify XHR_VAL when calling MODEL.fetch|save([OBJ]) and 
                                  #(if OBJ2.parse true) new MODEL_CONSTRUCTOR(A_OBJ, OBJ2)
                                  #Modifies the XHR_VAL used by MODEL.set(...) by those methods, but not the one used in the
                                  #success callback.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          COLLECTIONS          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


new COLL_CONSTRUCTOR              #Represent a MODEL_ARR:
([COLL_ELEM[_ARR][, OBJ]])        #  - COLL_ELEM means either:
                                  #     - MODEL
                                  #     - ATTR_OBJ: calling new MODEL_CONSTRUCTOR(ATTR_OBJ[, OBJ]), where MODEL_CONSTRUCTOR is
                                  #       COLL_ATTR.model (def: Backbone.Model)
                                  #  - OBJ is:
                                  #      - merged with COLL_ATTR
                                  #      - default OBJ passed to most COLL function (e.g. COLL.add() OBJ.merge)
                                  #      - passed to new MODEL_CONSTRUCTOR() OBJ2
                                  #  - any MODEL event bubbles up to its collection, e.g. "destroy", "change:VAR", "invalid"
COLL.clone()                      #
COLL.models                       #Internal MODEL_ARR
MODEL.collection                  #COLL
                                  #Can be also be set with new MODEL_CONSTRUCTOR(A_OBJ, OBJ2) OBJ2.collection (usually useless)

COLL.set(COLL_ELEM[_ARR][, OBJ])  #Compare each current element to COLL_ELEM[_ARR] and:
                                  #  - if current element same as COLL_ELEM[_ARR]:
                                  #     - if OBJ.merge false, does nothing
                                  #     - if OBJ.merge true (def), merges it.
                                  #  - if current element but not in COLL_ELEM[ARR]:
                                  #     - if OBJ.remove true (def): removes it.
                                  #       Fires event remove(MODEL, COLL, OBJ), where OBJ.index NUM is the element index.
                                  #  - if COLL_ELEM[ARR] but not in current elements:
                                  #     - if OBJ.add true (def): adds it at position OBJ.at NUM (def: end)
                                  #       Fires event add(MODEL, COLL, OBJ)
                                  #  - if MODEL have been removed or added, fires event update(COLL, OBJ)
                                  #Compare COLL_ELEM according to COLL_ATTR.modelId(ATTR_OBJ)->VAL (def: return MODEL.id)
                                  #Returns new MODEL_ARR.
                                  #All COLL_ELEM[_ARR] must have MODEL.id if OBJ.remove|merge true
COLL.reset([...])                 #Removes all models, then (if ...) calls and returns COLL.add(...).
                                  #Similar to COLL.set() with OBJ.remove true, OBJ.add true and OBJ.merge true except:
                                  #  - for big difference, faster
                                  #  - replaces instead of merging
                                  #  - different events: only fire event reset(COLL, OBJ), with OBJ.previousModels MODEL_ARR
                                  #    set
COLL.add(...)                     #Same as COLL.set(...) with different default OBJ.remove false
COLL.push|unshift(...)            #Same as COLL.add(...) but with OBJ.at COLL.length|0
COLL.remove                       #Removes and returns COLL_ELEM[_ARR] or VAL (i.e. MODEL.id|cid)
(COLL_ELEM[_ARR]|VAL[,OBJ])       #Fires same event "remove" as COLL.set()
COLL.pop|shift([OBJ])             #Same but for the last|first MODEL

COLL.get(VAL)                     #Returns a MODEL, where VAL can be the MODEL.id, MODEL.cid or MODEL itself
                                  #Returns undefined if none found.
COLL.at(NUM)                      #Returns a MODEL. Error if out-of-bound.
COLL.slice(NUM[, NUM2])           #Same as ARR.slice(...) (including that it returns copy), but for COLL
COLL.length                       #
COLL.findWhere(...)               #Same as COLL.where(...)[0]

COLL_ATTR.comparator(...)         #Is a LFUNC or FUNC(VAL, VAL2)->-1|0|1
                                  #If defined:
                                  #  - keep the collection sorted accordingly when models are changed, unless using 
                                  #    OBJ.sort false (to COLL.add(), etc.)
                                  #  - can manually sort with COLL.sort(). Only useful after OBJ.sort false has been used.
                                  #  - each time it is sorted (automatically or with COLL.sort()) and order changed, fire 
                                  #    event sort(COLL, OBJ)

COLL.toJSON(...)                  #Same as for MODEL (def: concanates all MODEL.toJSON(...))
COLL.sync(...)                    #Same as for MODEL.
COLL.fetch([OBJ])                 #Same as for MODEL but:
                                  #  - calls and returns COLL.sync("read", COLL[, OBJ]), then do COLL.set(XHR_VAL[, OBJ]) or
                                  #    (if OBJ.reset true) COLL.reset(XHR_VAL[, OBJ]).
                                  #    Prefer OBJ.reset true during initial page load.
                                  #  - events request|sync|error fired too, but first arg is COLL not MODEL
COLL.create(COLL_ELEM[, OBJ])     #COLL.add(COLL_ELEM[, OBJ]) then MODEL.save() (or the other way around if OBJ.wait true)
                                  #OBJ.success() is proxied like for COLL.fetch()
COLL.parse(COLL_ELEM[_ARR][, OBJ])#Called on COLL.set(COLL_ELEM[_ARR], OBJ) when OBJ.parse true (def: false, except within
                                  #COLL.fetch()), to modify the input COLL_ELEM[_ARR].
                                  #If COLL.set() OBJ.parse true, will also call MODEL.parse() when a MODEL is updated 
                                  #(with OBJ.merge true)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            ROUTING            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


new ROUTER_CONSTRUCTOR([OBJ])     #Functions fired when R_PATH changes:
                                  #  - setup by:
                                  #     - ROUTER_ATTR.routes { R_PATH: "ROUTE" }|FUNC()->{ R_PATH: "ROUTE" }
                                  #     - ROUTER.route(R_PATH_STR|REGEXP[, "ROUTE"][, R_FUNC])
                                  #  - R_PATH: 
                                  #     - can have:
                                  #        - ":R_VAR": up to next /
                                  #        - "*R_VAR": same up to end
                                  #        - "(...)": optional
                                  #     - no leading slash
                                  #  - when R_PATH changes and matches (checked by HISTORY):
                                  #     - fires ROUTER_ATTR.ROUTE([R_VAR...]) or (if defined) R_FUNC([R_VAR...])
                                  #        - can proxy calls to those functions (e.g. modify/add arguments) by reassigning
                                  #          ROUTER_ATTR.execute(FUNC, ARR, "ROUTE"). By def, only does:
                                  #            if ( FUNC ) FUNC.apply( this, ARR );
                                  #          If execute() returns exactly false, do not fire events.
                                  #     - fires events:
                                  #        - on ROUTER:  "route:ROUTE"([R_VAR...])
                                  #        - on ROUTER:  route("ROUTE", R_VAR_ARR)
                                  #        - on HISTORY: route(ROUTER, "ROUTE", R_VAR_ARR)

Backbone.history                  #Default HISTORY
HISTORY.start([OBJ])              #Call HISTORY.loadUrl() which triggers R_FUNC() of matching R_PATH:
                                  #  - when (in priority order) (only when R_PATH changed):
                                  #     - if OBJ.pushState BOOL true (def: false) and HTML5 History API supported,
                                  #       WINDOW "popstate" event, triggered by using HTML5 History 
                                  #       (done by HISTORY.navigate())
                                  #     - if OBJ.hashChange true (def), WINDOW "hashchange" event.
                                  #     - otherwise, poll every OBJ.interval ms (def: 50)
                                  #  - right away unless OBJ.silent true. Returns true if R_PATH matched.
                                  #R_PATH:
                                  #  - is HISTORY.getFragment()
                                  #  - if OBJ.pushState true, path (without leading slash nor hash), otherwise hash part.
                                  #Set HISTORY.started to true
                                  #OBJ.root (def: "/") should be app root path.
                                  #To do when DOM ready, and after ROUTER setup.
HISTORY.stop()                    #
HISTORY|ROUTER.navigate           #Modify current R_PATH.
(R_PATH[,OBJ])                    #Only triggers RFUNC if R_PATH changed and if OBJ.trigger true (def: false)
                                  #If OBJ.replace false (def) and using HTML5 history, replace history entry instead of adding
                                  #a new one
                                  #Returns true if matched a R_PATH.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             VIEWS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


new VIEW_CONSTRUCTOR([OBJ])       #Creates/queries a DOM element(s) and setup event listeners.
                                  #OBJ is merged into VIEW_ATTR for el|id|tagName|className|model|collection|attributes|events
VIEW_ATTR.remove()                #Remove element from DOM and its event handlers

VIEW_ATTR.el                      #ELEM|JQ|SELECTOR describing the DOM element(s).
                                  #If not specified create one according to VIEW_ATTR.id|tagName|className|attributes
                                  #VAL|FUNC()->VAL (def: empty <div>)
                                  #To change runtime, do VIEW_ATTR.setElement(ELEM|JQ|SELECTOR)
                                  #After initialisation, VIEW_ATTR.el will be ELEM, and VIEW_ATTR.$el JQ
VIEW_ATTR.events                  #OBJ|FUNC()->OBJ, where OBJ is { "EVENT[ SELECTOR]": "FUNC"|FUNC() }: 
                                  #  - VFUNC is FUNC or VIEW_ATTR["FUNC"]
                                  #  - fires VFUNC(...) on "EVENT". SELECTOR is within VIEW_ATTR.$el children
                                  #Setup/reset by VIEW_ATTR.delegateEvents(), removed by VIEW_ATTR.undelegateEvents()

VIEW_ATTR.cid                     #Unique ID assigned automatically
VIEW_ATTR.$(SELECTOR)             #Shortcut to VIEW_ATTR.$el.find(SELECTOR)

CONVENTIONS ==>                   #The following are not used by Backbone, but are conventions for the application code
VIEW_ATTR.model|collection        #MODEL|COLL
VIEW_ATTR.render()                #Handler of linked MODELs "change" event, e.g. put in initialize():
                                  #  this.listenTo( this.model, "change", this.render );
                                  #Should return this.
                                  #Good idea to also put handler of linked MODELs "destroy" event, e.g. in initialize():
                                  #  this.listenTo( this.model, "destroy", this.OTHER_FUNC );
VIEW_ATTR.template(OBJ[, OBJ2])   #Template function, e.g.:
                                  #  template: HANDLEBARS.compile( "<div>{{VAR}}</div>" )
                                  #Typically fired in VIEW_ATTR.render(), with result assigned via VIEW_ATTR.$el.html()
                                  #Should load HTML_STR from a separate file instead of putting HTML_STR in JavaScript.
