
              
   BACKBONE   
              


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             CORE              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


VERSION ==>                       #1.1.2

Backbone                          #Global object
                                  #Can be unset and returned by Backbone.noConflict()

DEPENDENCIES ==>                  #Must load first:
                                  #  - Underscore or Lo-dash
                                  #  - jQuery, set to Backbone.$ (can be overriden)
                                  #Some methods are also mixed in:
                                  #  - MODEL: keys|values|pairs|invert|pick|omit()
                                  #  - COLL: forEach|each|map|collect|reduce|foldl|inject|reduceRight|foldr|find|detect| 
                                  #    filter|select|reject|every|all|some|any|contains|include|invoke|max|min|sortBy|groupBy|
                                  #    shuffle|toArray|size|first|head|take|initial|rest|tail|last|without|indexOf|lastIndexOf|
                                  #    isEmpty|chain|pluck|where()


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            EVENTS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Backbone.Events                   #EVENTS.
                                  #Makes an OBJ event listener by mixing in, i.e. _.extend(OBJ, EVENTS)
                                  #All methods below return EVENTS
                                  #Most Backbone-native events can be prevented by using OBJ.silent true in the function 
                                  #firing them, e.g. MODEL.set(..., { silent: true })

EVENTS.on|once(EVENT_STR,
FUNC(...)[, THIS])                
EVENTS.on|once                    #EVENT_STR can be: 
({ EVENT_STR: FUNC(...) }         #  - a space-delimited list.
[, THIS])                         #  - "all": pass actual EVENT_STR as first arg
EVENTS.off                        #If:
([EVENT_STR[, FUNC[, THIS]]])     #  - EVENT_STR|FUNC null: means any
                                  #  - THIS: if defined, means only when THIS was used in on()
EVENTS.trigger(EVENT_STR[, ...])  #

EVENTS.listenTo[Once](EVENTS2,...)
EVENTS.stopListening              #Like EVENTS2.on|once|off(..., EVENTS), but semantically indicates that EVENTS "eavesdrops" 
([EVENTS2, ]...)                  #on another EVENTS2


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            MODELS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Backbone.Model                    #Root MODEL_CONSTRUCTOR

MODEL_CONSTRUCTOR.extend
(MODEL_ATTR[, CONST_ATTR])        #Returns a MODEL_CONSTRUCTOR2, inheriting MODEL_CONSTRUCTOR's MODEL_ATTR and CONST_ATTR
new MODEL_CONSTRUCTOR             #Returns a MODEL:
(ATTR_OBJ[, OBJ])                 #  - MODEL_ATTR is mixed in every MODEL.
                                  #    Usually for functions and readonly variables. 
                                  #    For readwrite variables, use MODEL_ATTR.defaults OBJ|FUNC()->OBJ
                                  #    (OBJ is reference, FUNC() OBJ per value)
                                  #  - MODEL.attributes = ATTR_OBJ
                                  #  - CONST_ATTR is mixed in MODEL_CONSTRUCTOR, i.e. MODEL.constructor
MODEL_ATTR.initialize(...)        #Called when new MODEL_CONSTRUCTOR(...) is called
MODEL_ATTR.constructor()          #Called instead of new MODEL_CONSTRUCTOR(...), so must, like in a normal constructor:
                                  #  - modify this
                                  #  - call parent MODEL_CONSTRUCTOR2: MODEL_CONSTRUCTOR2.apply( this, arguments );
MODEL.clone()                     #

MODEL.get|escape(VAR_STR)         
MODEL.set(VAR_STR, VAL[, OBJ])    
MODEL.set({ VAR: VAL }[, OBJ])    #Manipulates ATTR_OBJ. "VAR" should not include spaces.
MODEL.unset(VAR_STR[, OBJ])       #escape() returns as HTML-escaped STR
MODEL.clear([OBJ])                #set|unset|clear() fires events change(MODEL, OBJ) and change:VAR(MODEL, VAL, OBJ)
MODEL.has(VAR_STR)                #unless no value was changed.

MODEL.changedAttributes([OBJ])    #Returns the part of ATTR_OBJ modified by the last MODEL.set(), or false if it did not 
                                  #change anything.
                                  #Use OBJ not to return any attributes that match same key+val.
                                  #Internaly use MODEL.changed, which is like MODEL.attributes but keep only track of changes.
MODEL.hasChanged()                #Returns true if MODEL.changedAttributes() empty
MODEL.previousAttributes()        #Returns ATTR_OBJ before the modification by the last MODEL.set().
                                  #Only available in "change[:VAR]" event handlers.
MODEL.previous(VAR_STR)           #Same as MODEL.previousAttributes().VAR

MODEL.id                          #MODEL ID.
                                  #Equal to ATTR_OBJ[MODEL_ATTR.idAttribute (def: "id")]
                                  #Should be defined server-side (by MODEL.save()), not client-side (by new MODEL())
MODEL.cid                         #Unique ID assigned by Backbone, useful when MODEL.id not available (e.g. not saved on
                                  #server yet).
                                  #By def., an incremented number prepended by "c"
MODEL.isNew()                     #Returns true if MODEL.id undefined

MODEL.toJSON([OBJ])               #JSON.stringify() takes MODEL.toJSON() instead of MODEL as input.
                                  #Should return MODEL as OBJ (not OBJ_STR)
                                  #Can be overriden.
                                  #By def., returns ATTR_OBJ copy.
Backbone.ajax(OBJ)                #Hardlink to $.ajax(OBJ). Can be overriden.
                                  #Conventions:
                                  #  - return value is XHR_RET (JQXHR with jQuery)
                                  #  - XHR_VAL is the first argument passed to OBJ.success|error() callbacks
                                  #    (with jQuery: the return value for success, the JQXHR for error)
Backbone|MODEL.sync               #Calls and returns Backbone.ajax(OBJ), with OBJ also having:
(METHOD_STR, MODEL[, OBJ])        #  - type STR: according to METHOD_STR:
                                  #     - "create": POST   
                                  #     - "read"  : GET    
                                  #     - "update": PUT    
                                  #     - "patch" : PATCH  
                                  #     - "delete": DELETE 
                                  #  - url STR:
                                  #     - OBJ.url if defined
                                  #     - or "/COLL_NAME[/ID]":
                                  #        - "/COLL_NAME" is COLL_ATTR.url STR|FUNC()->STR or (if MODEL outside of a COLL) 
                                  #           MODEL_ATTR.urlRoot STR|FUNC()->STR
                                  #        - /ID is "/" + MODEL.id, not defined if MODEL.isNew()
                                  #  - dataType "json"
                                  #  - emulateHTTP|JSON BOOL: see below
                                  #  (not for GET nor DELETE)
                                  #  - contentType "application/json"
                                  #  - data STR: JSON.stringify(MODEL.toJSON(OBJ))
                                  #  - success|error(...): MODEL.fetch|save|destroy wrapped it to take as arguments
                                  #    (MODEL, XHR_VAL, OBJ).
                                  #    Can use OBJ.context to define this in the wrapped callback
                                  #For older servers, if: 
                                  #  - Backbone.emulateHTTP true, use only GET|POST + HTTP-Method-Override METHOD header
                                  #  - Backbone.emulateHTTP + Backbone.emulateJSON true, use also _method METHOD query param
                                  #  - Backbone.emulateJSON true, send as "application/x-www-form-urlencoded" instead of
                                  #    "application/json"
                                  #Can be overriden globally, or only for a MODEL by overriding MODEL_ATTR.sync()
                                  #Events:
                                  #  - request(MODEL, XHR_RET, OBJ): when request start
                                  #  - sync|error(MODEL, XHR_VAL, OBJ): when request succeeded|errored, only with 
                                  #    MODEL.fetch|save|destroy()
MODEL.fetch([OBJ])                #Calls and returns MODEL.sync("read", MODEL[, OBJ]), then do MODEL.set(XHR_VAL)
MODEL.save(...)                   #Calls MODEL.set(...), then calls/returns Backbone.sync("create|update|patch", MODEL[, OBJ]):
                                  #  - "create": if MODEL.isNew()
                                  #  - "update": if not MODEL.isNew() and OBJ.patch false
                                  #  - "patch": if not MODEL.isNew() and OBJ.patch true
                                  #    As opposed to "create|update", only send attributes specified by ... (not whole ATTROBJ)
                                  #then call MODEL.set(XHR_VAL)
                                  #If OBJ.wait true, only does the second MODEL.set()
MODEL.destroy([OBJ])              #Calls and returns Backbone.sync("delete", MODEL[, OBJ])
                                  #Does nothing and returns false if MODEL.isNew()
                                  #Fire COLL.remove(MODEL) + destroy(MODEL, COLL, OBJ) event right away.
                                  #If OBJ.wait true, does COLL.remove() + destroy() event after Backbone.sync() successfully 
                                  #answered.

MODEL_ATTR.validate(ATTR_OBJ, OBJ)#Can be user-defined. Must return ERROR[_STR] if problem, nothing otherwise.
                                  #Called by MODEL.save() and (if OBJ.validate true) by MODEL.set|fetch()
                                  #OBJ is MODEL.save|set|fetch() OBJ
                                  #If problem:
                                  #  - stops operation by returning false 
                                  #  - fire invalid(MODEL, ERROR[_STR], OBJ)
                                  #  - sets MODEL.validationError ERROR[_STR]
MODEL.isValid()                   #Runs MODEL.validate() then returns BOOL.
MODEL_ATTR.parse(VAL[, OBJ])->VAL #Can be defined to modify XHR_VAL when calling MODEL.fetch|save([OBJ])
                                  #Modifies the XHR_VAL used by MODEL.set(...) by those methods, but not the one used in the
                                  #success callback.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          COLLECTIONS          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Backbone.Collection               #Root COLL_CONSTRUCTOR

COLL_CONSTRUCTOR.extend           #Like MODEL except:
(COLL_ATTR[, CONST_ATTR])         #  - represent an array of MODEL, so use MODEL[_ARR] instead of ATTR_OBJ
new COLL_CONSTRUCTOR              #  - no COLL_ATTR.defaults
([COLL_ELEM[_ARR][, OBJ]])        #  - new COLL_CONSTRUCTOR() OBJ:
COLL_ATTR.initialize(...)         #      - can specify COLL_ATTR "known" attributes, i.e. model() and comparator
COLL_ATTR.constructor()           #      - specifies default OBJ passed to most COLL function (e.g. COLL.add() OBJ.merge)
COLL.clone()                      #      - is passed to new MODEL_CONSTRUCTOR() OBJ
                                  #  - any MODEL event bubble up to their collection, e.g. "destroy", "change:VAR", "invalid"

COLL_ELEM                         #Means MODEL|ATTR_OBJ:
                                  #  - if ATTR_OBJ, call new MODEL_CONSTRUCTOR(ATTR_OBJ[, OBJ])
                                  #  - MODEL_CONSTRUCTOR is COLL_ATTR.model() (def: Backbone.Model)
COLL.models                       #Internal MODEL_ARR
MODEL.collection                  #COLL

COLL.set(COLL_ELEM[_ARR][, OBJ])  #Compare each current element to COLL_ELEM[_ARR] (according to their MODEL.id) and:
                                  #  - if current element same as COLL_ELEM[_ARR]:
                                  #     - if OBJ.merge false, does nothing
                                  #     - if OBJ.merge true (def), merges it.
                                  #  - if current element but not in COLL_ELEM[ARR]:
                                  #     - if OBJ.remove true (def): removes it.
                                  #       Fires event remove(MODEL, COLL, OBJ), where OBJ.index NUM is the element index.
                                  #  - if COLL_ELEM[ARR] but not in current elements:
                                  #     - if OBJ.add true (def): adds it at position OBJ.at NUM (def: end)
                                  #       Fires event add(MODEL, COLL, OBJ)
                                  #Returns new MODEL_ARR.
                                  #All COLL_ELEM[_ARR] must have MODEL.id if OBJ.remove|merge true
COLL.reset([...])                 #Removes all models, then (if ...) calls and returns COLL.add(...).
                                  #Similar to COLL.set() with OBJ.remove true, OBJ.add true and OBJ.merge true except:
                                  #  - for big difference, faster
                                  #  - replaces instead of merging
                                  #  - different events: only fire event reset(COLL, OBJ), with OBJ.previousModels MODEL_ARR
                                  #    set
COLL.add(...)                     #Same as COLL.set(...) with different default OBJ.remove false
COLL.push|unshift(...)            #Same as COLL.add(...) but with OBJ.at COLL.length|0
COLL.remove                       #Removes and returns COLL_ELEM[_ARR] or VAL (i.e. MODEL.id|cid)
(COLL_ELEM[_ARR]|VAL[,OBJ])       #Fires same event "remove" as COLL.set()
COLL.pop|shift([OBJ])             #Same but for the last|first MODEL

COLL.get(VAL)                     #Returns a MODEL, where VAL can be the MODEL.id, MODEL.cid or MODEL itself
                                  #Returns undefined if none found.
COLL.at(NUM)                      #Returns a MODEL. Error if out-of-bound.
COLL.slice(NUM[, NUM2])           #Same as ARR.slice(...) (including that it returns copy), but for COLL
COLL.length                       #
COLL.findWhere(...)               #Same as COLL.where(...)[0]

COLL_ATTR.comparator(...)         #Is a LFUNC or FUNC(VAL, VAL2)->-1|0|1
                                  #If defined:
                                  #  - keep the collection sorted accordingly when models are changed, unless using 
                                  #    OBJ.sort false (to COLL.add(), etc.)
                                  #  - can manually sort with COLL.sort(). Only useful after OBJ.sort false has been used.
                                  #  - each time it is sorted (automatically or with COLL.sort()), fire event sort(COLL, OBJ)

COLL.toJSON(...)                  #Same as for MODEL (def: concanates all MODEL.toJSON(...))
COLL.sync(...)                    #Same as for MODEL.
COLL.fetch([OBJ])                 #Same as for MODEL but:
                                  #  - calls and returns COLL.sync("read", COLL[, OBJ]), then do COLL.set(XHR_VAL[, OBJ]) or
                                  #    (if OBJ.reset true) COLL.reset(XHR_VAL[, OBJ]).
                                  #    Prefer OBJ.reset true during initial page load.
                                  #  - events request|sync|error fired too, but first arg is COLL not MODEL
COLL.create(COLL_ELEM[, OBJ])     #COLL.add(COLL_ELEM[, OBJ]) then MODEL.save() (or the other way around if OBJ.wait true)
                                  #OBJ.success() is proxied like for COLL.fetch()
COLL.parse(COLL_ELEM[_ARR][, OBJ])#Called on COLL.set(COLL_ELEM[_ARR], OBJ) when OBJ.parse true (def: false, except within
                                  #COLL.fetch()), to modify the input COLL_ELEM[_ARR].
                                  #If COLL.set() OBJ.parse true, will also call MODEL.parse() when a MODEL is updated 
                                  #(with OBJ.merge true)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            ROUTING            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/



Backbone.Router                   #Root ROUTER_CONSTRUCTOR

ROUTER_CONSTRUCTOR.extend         #Like COLL except for routing, i.e. firing functions when R_PATH changes:
(ROUTER_ATTR[, CONST_ATTR])       #  - setup by:
new ROUTER_CONSTRUCTOR([OBJ])     #     - ROUTER_ATTR.routes { R_PATH: "ROUTE" }|FUNC()->{ R_PATH: "ROUTE" }
ROUTER_ATTR.initialize(...)       #     - ROUTER.route(R_PATH_STR|REGEXP[, "ROUTE"][, R_FUNC])
ROUTER_ATTR.constructor()         #  - R_PATH: 
                                  #     - can have:
                                  #        - ":R_VAR": up to next /
                                  #        - "*R_VAR": same up to end
                                  #        - "(...)": optional
                                  #     - no leading slash
                                  #  - when R_PATH changes and matches (checked by HISTORY):
                                  #     - fires ROUTER_ATTR.ROUTE([R_VAR...]) or (if defined) R_FUNC([R_VAR...])
                                  #        - can proxy calls to those functions (e.g. modify/add arguments) by reassigning
                                  #          ROUTER_ATTR.execute(FUNC, ARR). By def, only does:
                                  #            if ( FUNC ) FUNC.apply( this, ARR );
                                  #          If execute() returns exactly false, do not fire events.
                                  #     - fires events:
                                  #        - on ROUTER:  "route:ROUTE"([R_VAR...])
                                  #        - on ROUTER:  route(ROUTE, R_VAR_ARR)
                                  #        - on HISTORY: route(ROUTER, ROUTE, R_VAR_ARR)

Backbone.history                  #HISTORY. Instance of Backbone.History.

HISTORY.start([OBJ])              #Call HISTORY.loadUrl() which triggers R_FUNC() of matching R_PATH:
                                  #  - when (in priority order):
                                  #     - if OBJ.pushState BOOL true (def: false) and HTML 5 History API supported,
                                  #       window "popstate" event, triggered by using HTML5 History 
                                  #       (done by HISTORY.navigate())
                                  #     - if OBJ.hashChange true (def), window "hashchange" event.
                                  #     - otherwise, poll every OBJ.interval ms (def: 50)
                                  #  - right away unless OBJ.silent true. Returns true if R_PATH matched.
                                  #R_PATH:
                                  #  - is HISTORY.getFragment()
                                  #  - if OBJ.pushState true, path (without leading slash nor hash), otherwise hash part.
                                  #Set HISTORY.started to true
                                  #OBJ.root (def: "/") should be app root path.
                                  #To do when DOM ready, and after ROUTER setup.
HISTORY.stop()                    #
HISTORY|ROUTER.navigate           #Modify current R_PATH.
(R_PATH[,OBJ])                    #Only triggers RFUNC if R_PATH changed and if OBJ.trigger true (def: false)
                                  #If OBJ.replace false (def) and using HTML5 history, replace history entry instead of adding
                                  #a new one
                                  #Returns true if matched a R_PATH.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             VIEWS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


