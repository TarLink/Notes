
              
   BACKBONE   
              


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             CORE              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


VERSION ==>                       #1.1.2

Backbone                          #Global object
                                  #Can be unset and returned by Backbone.noConflict()

DEPENDENCIES ==>                  #Must load first:
                                  #  - Underscore or Lo-dash
                                  #  - jQuery, set to Backbone.$ (can be overriden)
                                  #Some methods are also mixed in:
                                  #  - MODEL: keys|values|pairs|invert|pick|omit()
                                  #  - COLL: forEach|each|map|collect|reduce|foldl|inject|reduceRight|foldr|find|detect| 
                                  #    filter|select|reject|every|all|some|any|contains|include|invoke|max|min|sortBy|groupBy|
                                  #    shuffle|toArray|size|first|head|take|initial|rest|tail|last|without|indexOf|lastIndexOf|
                                  #    isEmpty|chain|pluck|where()


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            EVENTS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Backbone.Events                   #EVENTS.
                                  #Makes an OBJ event listener by mixing in, i.e. _.extend(OBJ, EVENTS)
                                  #All methods below return EVENTS
                                  #Most Backbone-native events can be prevented by using OBJ.silent true in the function 
                                  #firing them, e.g. MODEL.set(..., { silent: true })

EVENTS.on|once(EVENT_STR,
FUNC(...)[, THIS])                
EVENTS.on|once                    #EVENT_STR can be: 
({ EVENT_STR: FUNC(...) }         #  - a space-delimited list.
[, THIS])                         #  - "all": pass actual EVENT_STR as first arg
EVENTS.off                        #If:
([EVENT_STR[, FUNC[, THIS]]])     #  - EVENT_STR|FUNC null: means any
                                  #  - THIS: if defined, means only when THIS was used in on()
EVENTS.trigger(EVENT_STR[, ...])  #

EVENTS.listenTo[Once](EVENTS2,...)
EVENTS.stopListening              #Like EVENTS2.on|once|off(..., EVENTS), but semantically indicates that EVENTS "eavesdrops" 
([EVENTS2, ]...)                  #on another EVENTS2

CHECK LIST OF EVENTS???

																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            MODELS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Backbone.Model                    #Root MODEL_CONSTRUCTOR

MODEL_CONSTRUCTOR.extend
(MODEL_ATTR[, CONST_ATTR])        #Returns a MODEL_CONSTRUCTOR2, inheriting MODEL_CONSTRUCTOR's MODEL_ATTR and CONST_ATTR
new MODEL_CONSTRUCTOR             #Returns a MODEL:
(ATTR_OBJ[, OBJ])                 #  - MODEL_ATTR is mixed in every MODEL.
                                  #    Usually for functions and readonly variables. 
                                  #    For readwrite variables, use MODEL_ATTR.defaults OBJ|FUNC()->OBJ
                                  #    (OBJ is reference, FUNC() OBJ per value)
                                  #  - MODEL.attributes = ATTR_OBJ
                                  #  - CONST_ATTR is mixed in MODEL_CONSTRUCTOR, i.e. MODEL.constructor
MODEL_ATTR.initialize(...)        #Called when new MODEL_CONSTRUCTOR(...) is called
MODEL_ATTR.constructor()          #Called instead of new MODEL_CONSTRUCTOR(...), so must, like in a normal constructor:
                                  #  - modify this
                                  #  - call parent MODEL_CONSTRUCTOR2: MODEL_CONSTRUCTOR2.apply( this, arguments );
MODEL.clone()                     #

MODEL.get|escape(VAR_STR)         
MODEL.set(VAR_STR, VAL[, OBJ])    
MODEL.set({ VAR: VAL }[, OBJ])    
MODEL.unset(VAR_STR[, OBJ])       #Manipulates ATTR_OBJ.         
MODEL.clear([OBJ])                #escape() returns as HTML-escaped STR
MODEL.has(VAR_STR)                #set|unset|clear() fires events change(MODEL, OBJ) and change:VAR(MODEL, VAL, OBJ)
                                  #unless no value was changed.

MODEL.id                          #MODEL ID.
                                  #Equal to ATTR_OBJ[MODEL_ATTR.idAttribute (def: "id")]
                                  #Should be defined server-side (by MODEL.save()), not client-side (by new MODEL())
MODEL.cid                         #Unique ID assigned by Backbone, useful when MODEL.id not available (e.g. not saved on
                                  #server yet).
                                  #By def., an incremented number prepended by "c"
MODEL.isNew()                     #Returns true if MODEL.id undefined

MODEL.changedAttributes([OBJ])    #Returns the part of ATTR_OBJ modified by the last MODEL.set(), or false if it did not 
                                  #change anything.
                                  #Internaly used MODEL.changed, which is like MODEL.attributes but keep only track of changes.
                                  #Use OBJ to temporarily remove from MODEL.changed any attributes that match same key+val.
MODEL.hasChanged()                #Returns true if MODEL.changedAttributes() empty

MODEL.toJSON([OBJ])               #JSON.stringify() takes MODEL.toJSON() instead of MODEL as input.
                                  #Can be overriden.
                                  #By def., returns ATTR_OBJ copy
Backbone.ajax(OBJ)                #Hardlink to $.ajax(OBJ). Can be overriden.
Backbone|MODEL.sync               #Calls and returns Backbone.ajax(OBJ), with OBJ also having:
(METHOD_STR, MODEL[, OBJ])        #  - type STR: according to METHOD_STR:
                                  #     - "create": POST   
                                  #     - "read"  : GET    
                                  #     - "update": PUT    
                                  #     - "patch" : PATCH  
                                  #     - "delete": DELETE 
                                  #  - url STR:
                                  #     - OBJ.url if defined
                                  #     - or "/COLL_NAME[/ID]":
                                  #        - "/COLL_NAME" is COLL_ATTR.url STR|FUNC()->STR or (if MODEL outside of a COLL) 
                                  #           MODEL_ATTR.urlRoot STR|FUNC()->STR
                                  #        - /ID is "/" + MODEL.id, not defined if MODEL.isNew()
                                  #  - dataType "json"
                                  #  - emulateHTTP|JSON BOOL: see below
                                  #  (not for GET nor DELETE)
                                  #  - contentType "application/json"
                                  #  - data STR: JSON.stringify(MODEL.toJSON(OBJ))
                                  #  - success|error(...): MODEL.fetch|save|destroy wrapped it to take as arguments
                                  #    (MODEL, VAL, OBJ):
                                  #     - VAL is the first argument of the actual OBJ.success|error passed to Backbone.ajax()
                                  #       (i.e. with jQuery: the return value for success, the JQXHR for error)
                                  #     - Can use OBJ.context to define this in the wrapped callback
                                  #For older servers, if: 
                                  #  - Backbone.emulateHTTP true, use only GET|POST + HTTP-Method-Override METHOD header
                                  #  - Backbone.emulateHTTP + Backbone.emulateJSON true, use also _method METHOD query param
                                  #  - Backbone.emulateJSON true, send as "application/x-www-form-urlencoded" instead of
                                  #    "application/json"
                                  #Can be overriden globally, or only for a MODEL by overriding MODEL_ATTR.sync()
MODEL.fetch([OBJ])                #Calls and returns MODEL.sync("read", MODEL[, OBJ]), then do MODEL.set(VAL)
MODEL.save(...)                   #Calls MODEL.set(...), then calls/returns Backbone.sync("create|update|patch", MODEL[, OBJ]):
                                  #  - "create": if MODEL.isNew()
                                  #  - "update": if not MODEL.isNew() and OBJ.patch false
                                  #  - "patch": if not MODEL.isNew() and OBJ.patch true
                                  #    As opposed to "create|update", only send attributes specified by ... (not whole ATTROBJ)
                                  #then call MODEL.set(...) again with the success VAL.
                                  #If OBJ.wait true, only does the second MODEL.set(...)
MODEL.destroy([OBJ])              #Calls and returns Backbone.sync("delete", MODEL[, OBJ])
                                  #Does nothing and returns false if MODEL.isNew()
                                  #Fire COLL.remove(MODEL) + destroy(MODEL, COLL, OBJ) event right away.
                                  #If OBJ.wait true, does COLL.remove() + destroy() event after Backbone.sync() successfully 
                                  #answered.

MODEL_ATTR.validate(ATTR_OBJ, OBJ)#Can be user-defined. Must return ERROR[_STR] if problem, nothing otherwise.
                                  #Called by MODEL.save() and (if OBJ.validate true) by MODEL.set|fetch()
                                  #OBJ is MODEL.save|set|fetch() OBJ
                                  #If problem, stops operation by returning false and sets MODEL.validationError ERROR[_STR]
MODEL.isValid()                   #Runs MODEL.validate() then returns BOOL.
MODEL_ATTR.parse(VAL[, OBJ])->VAL #Can be defined to modify success VAL of Backbone.ajax() when calling MODEL.fetch|save([OBJ])
                                  #Modifies the VAL used by MODEL.set(...) by those methods, but not the one used in the
                                  #success callback.
                                  #If CONST_OBJ.parse true, called also on MODEL.set(...)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          COLLECTIONS          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Backbone.Collection.extend        #Returns a COLL, i.e. an array of MODEL:
(COLL_ATTR[, CONST_ATTR])         #  - COLL_ATTR is mixed in COLL
                                  #  - CONST_ATTR is mixed in COLL.constructor
new Backbone.Collection
(ATTR_OBJ_ARR, ...)               #Like Backbone.Collection.extend(...) but add some initial objects.
COLL_ATTR.initialize(???)         #Called at creation
COLL.clone()                      #

COLL_ATTR.model(ATTR_OBJ[, OBJ])  #Allows COLL.add|create|reset|set() to use ATTR_OBJ instead of MODEL as argument
                                  #Must return a MODEL
                                  #Is usually a MODEL_CONSTRUCTOR
COLL.models                       #Internal MODEL_ARR
MODEL.collection                  #COLL
                                  #Those MODEL events bubble up to their collection: "destroy"

COLL.add(MODEL[_ARR][, OBJ])      #Adds and returns MODEL[_ARR].
                                  #Does not add duplicates (according to MODEL.id), but merge them if OBJ.merge true
                                  #Adds at OBJ.at NUM (def: end)
COLL.push(...)                    #Differences???
COLL.unshift(...)                 #Like COLL.add(...) but at beginning
COLL.remove(MODEL[_ARR][, OBJ])   #Removes and returns MODEL[_ARR]
COLL.pop|shift([OBJ])             #Same but for the last|first MODEL
COLL.reset([...])                 #Removes all models, then (if ...) call COLL.add(...)
COLL.set(...)                     #Differences???
COLL.get(VAL)                     #Returns a MODEL, where VAL can be the MODEL.id, MODEL.cid or MODEL itself
COLL.at(NUM)                      #Returns a MODEL
COLL.slice(NUM[, NUM2])           #Same as ARR.slice(...) (including that it returns copy), but for COLL
COLL.length                       #

COLL.sort()                       #Use MODEL.id
COLL_ATTR.comparator(...)         #Is a LFUNC or FUNC(VAL, VAL2)->-1|0|1
                                  #If defined:
                                  #  - keep the collection sorted accordingly when models are changed, unless using 
                                  #    OBJ.sort false (to COLL.add(), etc.)
                                  #  - used by COLL.sort()
COLL.findWhere(...)               #Same as COLL.where(...).at(0)

COLL.toJSON(...)                  #
COLL.sync(...)                    #
COLL.parse(...)                   #Same as for MODEL.
COLL.fetch(...)                   #Same as for MODEL. Also:
                                  #  - can take same OBJ as COLL.add()
                                  #  - can pass OBJ to COLL.sync() OBJ (same for MODEL.fetch()???)
                                  #  - prefer COLL.reset() during initial page load
COLL.create(MODEL[, OBJ])         #MODEL.save() then COLL.add(MODEL)
