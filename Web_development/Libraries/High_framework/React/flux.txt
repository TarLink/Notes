
          
   FLUX   
          


VERSION ==>                       #2.1.1

DEVELOPMENT MODE ==>              #Like React

FLOW ==>                          #Setup:
                                  #  - STORE = new FluxStore(DISPATCHER) (calls DISPATCHER.register())
                                  #  - STORE.addListener(SFUNC)
                                  #Trigger:
                                  #  - DISPATCHER.dispatch(VAL)
                                  #  - fires STORE.__onDispatch(VAL)
                                  #     - fires SFUNC() if change


new Dispatcher()                  #DISPATCHER
DISPATCHER.register(FUNC)         #Register a DFUNC. Returns DFUNC_ID
DISPATCHER.unregister(DFUNC_ID)   #
DISPATCHER.dispatch(VAL)          #Fires each DFUNC(VAL)
                                  #Cannot be done if on-going DISPATCHER.dispatch()
DISPATCHER.isDispatching()->BOOL  #
DISPATCHER.waitFor(DFUNC_ID_ARR)  #To be fired while DISPATCHER.isDispatching(), i.e. in a DFUNC2.
                                  #Fire those DFUNC right away (unless already fired), to make sure they are fired first.


new FluxStore(DISPATCHER)         #STORE
                                  #Calls DISPATCHER.register(STORE.__onDispatch(VAL))
STORE.__onDispatch(VAL)           #

STORE.addListener(SFUNC())        #Returns OBJ: remove()
STORE.__emitChange()              #Fires SFUNC(), providing called within STORE.__onDispatch(), itself called through DISPATCHER.
STORE.hasChanged()->BOOL          #Has __emitChange() been called by last __onDispatch()

STORE.getDispatcher()->DISPATCHER #
STORE.getDispatchToken()->DFUNC_ID#


new FluxReduceStore(DISPATCHER)   #REDUCESTORE, child of STORE, with a state object.
REDUCESTORE.getInitialState()     #Called at construction, must be overriden.
REDUCESTORE.getState()            #OBJ
REDUCESTORE.__onDispatch(VAL)     #Overriden to call REDUCESTORE.reduce(STATE, VAL)->STATE2
                                  #  - STATE2 is new STATE, and cannot be undefined
                                  #  - calls __emitChange() if STATE changed
                                  #     - checked using REDUCESTORE.areEqual(STATE, STATE2) (def: ===)


new FluxMapStore(DISPATCHER)      #MAPSTORE, child of REDUCESTORE, with a IMMUTABLE-MAP state object.
MAPSTORE.getInitialState()        #Overriden to return IMMUTABLE-MAP (from Immutable.js)
MAPSTORE.get|has('VAR')           #Same as MAPSTORE.getState().get|has('VAR')
MAPSTORE.at('VAR')                #Same as MAPSTORE.get('VAR'), except throws if !MAPSTORE.has('VAR')
MAPSTORE.getAll(STR_ARR           #Returns IMMUTABLE-MAP2 (def: new one) with only the key/values from MAPSTORE.getState()
[, IMMUTABLE-MAP2])               #specified by keys STR_ARR


new FluxStoreGroup                #Return FLUXSTOREGROUP
(STORE_ARR, FUNC())               #All STORE must have the same DISPATCHER
                                  #When DISPATCHER.dispatch() is called, fires FUNC() when all STORE.__onDispatch(VAL) have been called.
FLUXSTOREGROUP.release()          #Cleanup


FluxContainer.create(CTYPE[, OBJ])#Return FTYPE, i.e. child of CTYPE where:
                                  #  - 'change':
                                  #     - FTYPE.state = Ftype.calculateState(PREV_STATE[, PROPS])->NEW_STATE:
                                  #     - PROPS is defined only if OBJ.withProps true
                                  #  - 'change' is performed:
                                  #     - at initialization (PREV_STATE is null)
                                  #     - on componentWillReceiveProps:
                                  #        - if OBJ.withProps true 
                                  #        - unless OBJ.pure true (def) and PREV_PROPS != NEXT_PROPS (shallow comparison)
                                  #     - on STORE changes:
                                  #        - STORE_ARR = Ftype.getStores(), where all STORE must have same DISPATCHER
                                  #        - each time all STORE.__onDispatch(VAL) have been called, if a STORE.hasChanged()
                                  #  - do so by monkey-patching (calling original function first) componentDidMount, 
                                  #    componentWillReceiveProps, componentDidUnmount
                                  #  - if OBJ.pure true (def), replace shouldComponentUpdate with PURERENDERMIXIN
