
                         
   BACKBONE/MARIONETTE   
                         


VERSION ==>                       #Backbone 1.2.0
                                  #Marionette 2.4.1 (depends on Backbone 1.1.2, must be loaded before)
                                  #Marionette has the chapters starting with M*

Backbone                          #Global object
                                  #Can be unset and returned by Backbone.noConflict()
Mn|[Backbone.]Marionette          #MARIONETTE

DEPENDENCIES ==>                  #Must load first:
                                  #  - Underscore (depends on 1.6.0) or Lodash
                                  #  - jQuery, set to Backbone.$ (can be overriden)
                                  #Some methods are also mixed in:
                                  #  - MODEL: 
                                  #     - main: chain()
                                  #     - basic: keys|values()
                                  #     - type checking: isEmpty()
                                  #     - filtering: pick|omit()
                                  #     - processing: pairs|invert()
                                  #  - COLL: 
                                  #     - main: chain()
                                  #     - basic: size|toArray()
                                  #     - type checking: isEmpty()
                                  #     - finding: find|[lastI|i]ndexOf()
                                  #     - testing: every|some|contains
                                  #     - filtering: filter|reject|first|initial|rest|last|sample|without|difference()
                                  #     - processing: forEach|map|reduce[Right]|invoke|groupBy|countBy|indexBy|partition()
                                  #     - sorting: sortBy|shuffle()
                                  #     - math: max|min()

IN SHORT ==>                      #Backbone:
                                  #Marionette:
                                  #  - G*: basic object, allowing OO with extend|initialize()
                                  #     - MOBJECT: also MOBJECT.options, specified at instantiation
                                  #  - EVENTS: like EventEmitter in Node
                                  #     - MEVENT: also fire MOBJECT.onMEVENT(...)
                                  #     - RADIO: global (augmented) EVENTS
                                  #  - MAPPLICATION/MMODULE: global/local objects where the app is assigned, loaded in order
                                  #  - MODEL: an augmented OBJ (or database row server-side), with events, synced server-side
                                  #     - COLL: MODEL_ARR (or database table server-side). Can be auto-sorted.
                                  #  - ROUTER: callbacks fired when URL changes
                                  #     - MAPPROUTER: dissocie appRoutes (routing) from handlers (controller)
                                  #  - VIEW: DOM element, setting up event handlers
                                  #     - MVIEW: listening to MODEL|COLLECTION events, firing MEVENT, dissociate MVIEW.ui from
                                  #       MVIEW.behaviors (event triggering/handling)
                                  #        - MITEMVIEW: render() which gets simple template SELECTOR, can add templateHelpers
                                  #           - MCOLLVIEW: MITEMVIEW_ARR, updating with changes. Can have empty MVIEW.
                                  #             Can listen to children MEVENT. Can auto-sort and filter.
                                  #           - MCOMPVIEW: MITEMVIEW + MCOLLVIEW
                                  #           - MLAYOUTVIEW: MITEMVIEW with regions, i.e. containers of other MVIEW

VAL[()]                           #Means VAL|FUNC()->VAL


CHROME EXTENSIONS ==>             #  - Backbone Debugger 0.3.0: show VIEW, MODEL, COLLECTION, ROUTER attributes|events
                                  #  - Marionette Inspector 0.5.6: show Marionette types attributes|events



																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            MOBJECT            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


OBJ..VAR                          #Means either OBJ.options[VAR] or OBJ[VAR]
MEVENT(...)                       #Means either fire event MEVENT(...) or (if available) calls MOBJECT.onMEVENT(...), where 
                                  #MEVENT has different case: "aa:bb:cc" -> "AaBbCc"

MARIONETTE.Object                 #MOBJECT: is a G* with some extra methods
                                  #Main Marionette objects are MOBJECT: MAPPLICATION, MAPPROUTER, MVIEW, MBEHAVIOR, MREGION
MOBJECT.options                   #Is OBJ[()], which can be overriden by new MOBJECT_CTOR([OBJ])
                                  #Exceptions:
                                  #  - MAPPROUTER can only use MOBJECT_CTOR to define it
                                  #  - MVIEW can use new MOBJECT_CTOR([OBJ[()]])
MOBJECT.getOption("VAR")          #Returns OBJ..VAR
MOBJECT.mergeOptions
(OBJ, STR[_ARR])                  #Adds each OBJ[STR] to MOBJECT[STR]
MOBJECT.triggerMethod        
("MEVENT"[, ...])                 #Fires MEVENT(...)
MOBJECT.destroy()                 #Calls stopListening() and fires MEVENT [before:]destroy()
MOBJECT.[un]bindEntityEvents      #OBJ is { EVENT: FUNC|"FUNC ..." ... }
(EVENTS, OBJ[()])                 #Make events fired on EVENTS fire on MOBJECT too, by calling each
                                  #MOBJECT.listenTo(EVENTS, "EVENT", FUNC|EVENTS.FUNC)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:     MAPPLICATION/MMODULE      :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


MARIONETTE.Module                 #MMODULE: set of objects getting initialized/stopped and attached to MMODULE together.
                                  #Is a G* but not a MOBJECT
new MMODULE_CTOR
("MODULE", MAPPLICATION, OBJ)     #MMODULE.moduleName|app|options gets arguments
MMODULE.start(OBJ)|stop()         #Fires MEVENT [before:]start(OBJ)|stop()
                                  #Calls all children MMODULE2.start(OBJ)|stop unless MMODULE2.startWithParent false,
                                  #starting with descendants.
                                  #Idempotent operation.

MARIONETTE.Application            #MAPPLICATION: global/main object
MAPPLICATION.module("MODULE")     #Retrieve registered MMODULE
MAPPLICATION.module               #Register new MMODULE_CTOR("MODULE", MAPPLICATION, OBJ) then fires:
("MODULE", OBJ[, ...])            #  - OBJ|MMODULE.define(MMODULE, MAPPLICATION, BACKBONE, MARIONETTE, JQ, __, ...)
                                  #    Called at each MAPPLICATION.module("MODULE", OBJ), cannot be inherited.
                                  #  - OBJ|MMODULE.initialize("MODULE", MAPPLICATION, OBJ)
                                  #    Called only once, can be inherited.
                                  #Can use "MODULE.SUBMODULE...": will create MMODULE.submodules chain
                                  #MMODULE_CTOR: can redefine with OBJ.moduleClass
                                  #OBJ can be:
                                  #  - FUNC instead of { define FUNC }
                                  #  - MMODULE_CTOR instead of { moduleClass MMODULE_CTOR }
MMODULE|MAPPLICATION.submodules   #{ "MODULE": MMODULE ... } children
MAPPLICATION.start([OBJ])         #Trigger each MMODULE.start([OBJ]), including the ones define afterwards, as soon as 
                                  #they are defined.
                                  #Fires MEVENT [before:]start(OBJ)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:        BACKBONE.WREQR         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Backbone.Wreqr.radio              #RADIO
                                  #Like EVENTS but also add:
                                  #  - CHANNEL: namespaces
                                  #  - REQRES|commands: 
                                  #     - only one callback by event, so means several emitters, few listeners
                                  #       (as opposed to EVENTS)
                                  #     - REQRES returns value, "commands" buffer calls
                                  #Used as a global app-wide event register/handler.
                                  #Version 1.3.2

RADIO.channel("CHANNEL")          #Returns WCHANNEL
RADIO.*.FUNC("CHANNEL", ...)      #Same as WREQR.radio.channel("CHANNEL").*.FUNC(...)
WCHANNEL.channelName              #
WCHANNEL.reset()                  #Remove all WCHANNEL.vent|commands|reqres handlers

WCHANNEL.vent                     #EVENTS

WCHANNEL.reqres                   #REQRES. Similar to EVENTS but sync
REQRES.setHandler
("HDLR", FUNC[, THIS])
REQRES.setHandlers                #Register an event listener
({ "HDLR": FUNC|WOBJ })           #WOBJ: callback FUNC()[, context THIS]
REQRES.getHandler("HDLR")         #Returns FUNC
REQRES.hasHandler("HDLR")         #
REQRES.removeHandler("HDLR")      #
REQRES.removeAllHandlers()        #
REQRES.request("HDLR", ...)       #Fires event listener FUNC(...) synchronously and return value

WCHANNEL.commands                 #Same as WCHANNEL.reqres but:
                                  #  - if event listener missing, buffers calls until it is declared 
                                  #  - use execute() instead of request(), which does not return value


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          MAPPROUTER           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


MARIONETTE.AppRouter              #MAPPROUTER
                                  #Child of ROUTER, which uses MAPPROUTER..appRoutes instead of ROUTER.routes, same but use:
                                  #  - MAPPROUTER..controller.ROUTE(...) instead of ROUTER.ROUTE(...)
                                  #    Goal: separate MAPPROUTER..controller OBJ (logic) from MAPPROUTER (routing)
                                  #  - MAPPROUTER.appRoute(...) instead of ROUTER.route(...) (cannot use last arg R_FUNC)
                                  #  - MAPPROUTER.onRoute("ROUTE", R_PATH, R_VAR_ARR) instead of 
                                  #    EVENT route("ROUTE", R_VAR_ARR).
                                  #    Based on MAPPROUTER..appRoutes


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            MVIEW              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/
 

MARIONETTE.View                   #Child of VIEW
                                  #Fires MEVENT dom:refresh() on EVENT show|render
MVIEW..model|collectionEvents     #Like MVIEW.events but:
                                  #  - listen to MVIEW.model|collection events
                                  #  - can use "FUNC ..." instead of "FUNC"
                                  #  - no SELECTOR
MVIEW.triggers                    #Like MVIEW.events, but:
                                  #  - use "MEVENT" instead of "FUNC", firing MEVENT(OBJ):
                                  #     - OBJ is { view MVIEW, model|collection MVIEW.model|collection }
                                  #     - can use { event: "MEVENT", preventDefault|stopPropagation BOOL } instead of "MEVENT"
                                  #  - can use @SELECTOR
MVIEW.ui                          #{ KEY: SELECTOR }
                                  #MVIEW.bindUIElements(), called by all M*VIEW.render() (but not MVIEW.render()), assigns
                                  #MVIEW.$(SELECTOR) to:
                                  #  - MVIEW.ui.KEY
                                  #  - @SELECTOR, i.e. SELECTOR that can also be "@ui.KEY".
                                  #    Should always use when possible, in order to decouple UI from logic.
MVIEW.destroy()                   #Like MOBJECT.destroy() but also:
                                  #  - remove from DOM 
                                  #  - sets MVIEW.isDestroyed true
MVIEW.isRendered                  #Set to true after render(), false after destroy() by all M*VIEW (not MVIEW itself)

MVIEW|MBEHAVIOR.behaviors OBJ[()] #{ BKEY: BOBJ }
                                  #Build the MBEHAVIOR, which decouple the logic ([M]EVENT triggers/handling) of MVIEW.
                                  #MBEHAVIOR proxies MVIEW:
                                  #  - inherits its ui|$|el|$el
                                  #  - MBEHAVIOR.view = MVIEW
                                  #  - can define its model|collectionEvents (will use MVIEW.model|collection), 
                                  #    events|triggers, MEVENTs handlers and MVIEW.FUNC() event handlers
                                  #     - for MVIEW.FUNC() event handler, the model|collectionEvents|events must be in 
                                  #       same MBEHAVIOR
                                  #Fire new MBEHAVIOR_CTOR(BOBJ, MVIEW):
                                  #  - MBEHAVIOR is MARIONETTE.Behavior
                                  #  - look up MBEHAVIOR_CTOR in:
                                  #      - BOBJ.behaviorClass
                                  #      - or MARIONETTE.Behaviors.behaviorsLookup(BOBJ, BKEY)[BKEY]
                                  #        behaviorsLookup() must be redefined, e.g. returning global object 
                                  #        { BKEY: MBEHAVIOR_CTOR }
                                  #  - MBEHAVIOR.options = BOBJ (can use MBEHAVIOR.defaults OBJ[()])


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           MITEMVIEW           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


MARIONETTE.TemplateCache.get      #Returns TEMPLATE_FUNC. By def., returns __.template($(ID).html()[, OBJ])
(ID[, OBJ])                       #Details (in order):
                                  #  - new MARIONETTE.TemplateCache(ID)->TEMPLATECACHE, with TEMPLATECACHE.templateId ID
                                  #  - TEMPLATECACHE.loadTemplate(ID[, OBJ])->"TEMPLATE" (def: $(ID).html())
                                  #  - TEMPLATECACHE.compileTemplate("TEMPLATECACHE"[, OBJ])->TEMPLATE_FUNC
                                  #    (def: forward to _.template(...)), 
                                  #  - TEMPLATECACHE.compiledTemplate = TEMPLATE_FUNC
                                  #Last two functions can be overriden.
                                  #Caching:
                                  #  - stores TEMPLATECACHE in MARIONETTE.TemplateCache.templateCaches[ID] used in next call
                                  #  - can MARIONETTE.TemplateCache.clear([ID...])

MARIONETTE.ItemView               #MITEMVIEW. Child of MVIEW, to render a single MODEL (or sometimes a simple COLL)
MITEMVIEW.serializeData([...])    #MITEMVIEW.model.toJSON(...)
                                  #or (if no MITEMVIEW.model) { items: MITEMVIEW.collection.toJSON(...) }
                                  #mixed in MITEMVIEW..templateHelpers OBJ[()]
MITEMVIEW.render()                #Calls (unless MITEMVIEW..template false):
                                  #  - "COMPILED_TEMPLATE" = MARIONETTE.Renderer.render
                                  #    (MITEMVIEW..template VAL, MITEMVIEW.serializeData() OBJ, MITEMVIEW) which by def:
                                  #      - if VAL FUNC, calls FUNC(OBJ)
                                  #      - otherwise MARIONETTE.TemplateCache.get(VAL)(OBJ)
                                  #  - MITEMVIEW.attachElContent("COMPILED_TEMPLATE") (def: MITEMVIEW.$el.html(...))
                                  #  - both functions can be overriden
                                  #Fires MEVENT "[before:]render"(MITEMVIEW)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           MCOLLVIEW           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


new Backbone.ChildViewContainer   #Container for VIEW_ARR, underlying MCOLLVIEW (i.e. MCOLLVIEW.children)
([VIEW_ARR])                      #Based on Backbone.Babysitter 0.1.6
                                  #Mixes in the following Underscore methods: forEach|map|reduce|find|filter|reject|every|
                                  #some|contains|invoke|toArray|first|initial|rest|last|without|isEmpty|pluck
CHILDVIEWCTNER.add(VIEW[, KEY])   #
CHILDVIEWCTNER.remove(VIEW)       #
CHILDVIEWCTNER.length             #

CHILDVIEWCTNER.call("FUNC"[, ...])#
CHILDVIEWCTNER.apply("FUNC"[,ARR])#Call each VIEW.FUNC(...)

CHILDVIEWCTNER.findByModel(MODEL) #
CHILDVIEWCTNER.findByModelCid(VAL)#Retrieve VIEW by MODEL.cid
CHILDVIEWCTNER.findByCid(VAL)     #Retrieve VIEW by VIEW.cid
CHILDVIEWCTNER.findByCustom(KEY)  #Retrieve VIEW by KEY
CHILDVIEWCTNER.findByIndex(NUM)   #Retrieve VIEW by position


MARIONETTE.CollectionView         #MCOLLVIEW. Child of MVIEW, to render a COLL.
MCOLLVIEW.collection              #COLL
MCOLLVIEW.children                #CHILDVIEWCTNER, rebuilt by MCOLLVIEW.render()
MCOLLVIEW.childEvents             #Like VIEW.events except as { "MEVENT": FUNC }:
                                  #  - refers to children MEVENTs
                                  #  - setup by render()
                                  #Children events also trigger MEVENT "PREFIX:EVENT"(...), where PREFIX is
                                  #MCOLLVIEW..childViewEventPrefix (def: "childview")
MCOLLVIEW.render()                #For each child MODEL:
                                  #  - create/add a CHILD_MVIEW:
                                  #     - CHILD_MVIEW_CTOR = MCOLLVIEW..childView 
                                  #       or overriding MCOLLVIEW.getChildView(MODEL)
                                  #     - OPTS = MCOLLVIEW..childViewOptions OBJ[(MODEL, NUM)])
                                  #     - CHILD_MVIEW = new CHILD_MVIEW_CTOR(OPTS), adding also OPTS.model MODEL,
                                  #       or overriding MCOLLVIEW.buildChildView(MODEL, CHILD_MVIEW_CTOR, OPTS)
                                  #  - CHILD_MVIEW.render(), then appends it to MCOLLVIEW.$el
                                  #Listens to COLL events "add|remove|reset" to keep child views in sync with collection models
                                  #If MCOLLVIEW.collection is empty:
                                  #  - add child MODEL like above but:
                                  #     - use new MODEL() as MODEL
                                  #     - must use emptyView|getEmptyView instead of childView|getChildView
                                  #     - can use emptyViewOptions instead of childViewOptions
                                  #  - can override MCOLLVIEW.isEmpty()->BOOL (def: no COLL or COLL.length === 0)
                                  #Fires MEVENT:
                                  #  - [before:]render(COLL)
                                  #  - [before:]render:collection"COLL)
                                  #  - [before:]add|remove:child(CHILD_MVIEW)
                                  #  - [before:]render|remove:empty()
MCOLLVIEW..viewComparator         #Sort CHILD_MVIEW in the DOM according to their MODEL.
                                  #Can be "VAR", LFUNC(MODEL)->NUM or FUNC(MODEL, MODEL2)->-1|0|1
                                  #Sort when:
                                  #  - MCOLLVIEW.render()
                                  #  - COLL event "sort": 
                                  #     - also re-render() unless MCOLLVIEW..reorderOnSort true
                                  #     - disable with MCOLLVIEW..sort false (to force manual sorts)
                                  #  - manual MCOLLVIEW.reorder(): also fires MEVENT [before:]reorder()
MCOLLVIEW..filter
(MODEL, NUM, COLL)->BOOL          #Do not show children returning false
MCOLLVIEW.destroy()               #Like MOBJECT but also:
                                  #  - fire MEVENT [before:]destroy:collection()
                                  #  - destroy children, firing MEVENT [before:]remove:child(CHILD_MVIEW)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           MCOMPVIEW           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


MARIONETTE.CompositeView          #MCOMPVIEW. Mix of a MCOLLVIEW and a MITEMVIEW, e.g. for a tree (root node and children) 
                                  #Using MCOMPVIEW.collection, is like MCOLLVIEW but:
                                  #  - can use MCOMPVIEW..childViewContainer @SELECTOR[()] to attach children to something 
                                  #    else than MCOMPVIEW.$el (can be inside the MITEMVIEW) 
                                  #    (otherwise appended after the MITEMVIEW)
                                  #  - def CHILD_MVIEW_CTOR is MCOMPVIEW_CTOR
                                  #Using MCOMPVIEW.model, is like MITEMVIEW but:
                                  #  - fires MEVENT [before:]render:template()


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:      MREGION/MLAYOUTVIEW      :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


MARIONETTE.Region                 #MREGION. Container of a MVIEW.
MREGION..el                       #ELEM|SELECTOR, to define the container DOM element.
                                  #Can be @SELECTOR from a MLAYOUTVIEW
                                  #If undefined, MREGION.show() will throw error unless MREGION..allowMissingEl true
MREGION..$el                      #JQ, to use.
MREGION.show(MVIEW[, OBJ])        #Does:
                                  #  - MVIEW.render() 
                                  #  - then put as unique DOM child with MREGION.attachHtml(MVIEW), which by def:
                                  #     - $el.contents().detach() (remove current DOM child)
                                  #     - el.appendChild(MVIEW.el)
                                  #    Can redefine for transitions effects.
                                  #Former MVIEW2:
                                  #  - if same, does nothing unless OBJ.forceShow true
                                  #  - is destroyed with MREGION.empty() unless OBJ.preventDestroy true
                                  #Fires MEVENT:
                                  #  - on MREGION:
                                  #     - [before:]swap[Out](MVIEW[2], MREGION, OBJ): when MVIEW2 changes for another MVIEW
                                  #     - [before:]show(MVIEW, MREGION, OBJ)
                                  #  - on MVIEW:
                                  #     - [before:]attach(MVIEW, MREGION): unless:
                                  #        - OBJ|MREGION.trigger[Before]Attach false (to improve performance if a lot of MVIEW)
                                  #        - or MREGION not attached to DOM
                                  #     - [before:]show(MVIEW, MREGION, OBJ)
MREGION.currentView MVIEW
MREGION.attachView(MVIEW)         #Adds already render()'d MVIEW. Does not fire any MEVENT.
MREGION.empty([OBJ])              #Remove MVIEW.
                                  #If OBJ.preventDestroy true, do not call MVIEW.destroy()
                                  #Fires MEVENT [before:]empty(MVIEW)
MREGION.reset()                   #Same but also clear cache for MREGION..$el
MREGION.hasView()->BOOL           #


MARIONETTE.RegionManager          #MREGIONMANAGER. Is a MREGION_ARR.
                                  #Mixes in same Underscore methods as COLL.
MREGIONMANAGER.addRegions         #Calls each MREGIONMANAGER.addRegion(R_NAME, VAL)
({ R_NAME: VAL ... }[, OBJ2])     #OBJ2 are default VAL value (when it is an OBJ)
                                  #Called with MREGIONMANAGER..regions OBJ at instantiation.
                                  #Returns MREGIONMANAGER.getRegions()
MREGIONMANAGER.addRegion          #Stores new MREGION_CTOR(OBJ) where OBJ can also have:
(R_NAME, OBJ)                     #  - selector: same as el
                                  #  - regionClass CTOR: use instead of MREGION_CTOR
                                  #OBJ can be also be:
                                  #  - STR: same as { el: STR }
                                  #  - CTOR: same as { regionClass: CTOR }
                                  #Fires MEVENT [before:]add:region(R_NAME, MREGION)
MREGIONMANAGR.get(R_NAME)->MREGION#
MREGIONMANAGER.getRegions()       #Returns { R_NAME: MREGION ... }
MREGIONMANAGR.removeRegion(R_NAME)#Does MREGION.empty() and remove from MREGIONMANAGER.
MREGIONMANAGER.removeRegions()    #Fires MEVENT [before:]remove:region(R_NAME, MREGION)
MREGIONMANAGER.emptyRegions()     #Call each MREGION.empty(), but keep in MREGIONMANAGER.


MARIONETTE.LayoutView             #MLAYOUTVIEW. Child of both MITEMVIEW and MREGIONMANAGER, but:
new MLAYOUTVIEW_CTOR([OBJ])       #  - use MLAYOUTVIEW|OBJ..regions { R_NAME: VAL ... }[(OBJ)]
                                  #  - MLAYOUTVIEW|OBJ..regionClass instead of OBJ.regionClass
                                  #  - MREGION..el is scoped within MLAYOUTVIEW..el
                                  #  - no addRegions() OBJ2, no removeRegions|emptyRegions()
                                  #  - getRegion(R_NAME) instead of get(R_NAME)
                                  #  - can override MLAYOUTVIEW.getRegionManager()->MREGIONMANAGER to provide custom one
                                  #    (def: new MREGIONMANAGER())
MLAYOUTVIEW.render()              #Calls MITEMVIEW.render() and MREGIONMANAGER.removeRegions()
MLAYOUTVIEW.showChildView
(R_NAME, MVIEW)                   #Same as getRegion(R_NAME).show(MVIEW)
MLAYOUTVIEW.getChildView(R_NAME)
->MVIEW
MLAYOUTVIEW.childEvents           #Like MCOLLVIEW, including children events triggering "PREFIX:EVENT"
