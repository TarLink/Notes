
                
   MARIONETTE   
                


VERSION ==>                       #2.4.1 (depends on Backbone 1.1.2, must be loaded before)

Marionette inspector Chrome extension???

Backbone.Marionette               #MARIONETTE


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            MOBJECT            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/



OBJ..VAR                          #Means either OBJ.options[VAR] or OBJ[VAR]
MEVENT(...)                       #Means either fire event MEVENT(...) or (if available) calls MOBJECT.onMEVENT(...), where 
                                  #MEVENT has different case: "aa:bb:cc" -> "AaBbCc"

MARIONETTE.Object                 #MOBJECT: is a G* with some extra methods
                                  #Main Marionette objects are MOBJECT: MAPPLICATION, MAPPROUTER, MVIEW, MBEHAVIOR, MREGION
MOBJECT_ATTR.options              #Is OBJ[()], which can be overriden by new MOBJECT_CONSTRUCTOR([OBJ])
                                  #Exceptions:
                                  #  - MAPPROUTER can only use MOBJECT_CONSTRUCTOR to define it
                                  #  - MVIEW can use new MOBJECT_CONSTRUCTOR([OBJ[()]])
MOBJECT_ATTR.getOption("VAR")     #Returns OBJ..VAR
MOBJECT_ATTR.mergeOptions
(OBJ, STR[_ARR])                  #Adds each OBJ[STR] to MOBJECT_ATTR[STR]
MOBJECT_ATTR.triggerMethod        
("MEVENT"[, ...])                 #Fires MEVENT(...)
MOBJECT_ATTR.destroy()            #Calls stopListening() and fires MEVENT [before:]destroy()
MOBJECT_ATTR.[un]bindEntityEvents #OBJ is { EVENT: FUNC|"FUNC ..." ... }
(EVENTS, OBJ[()])                 #Make events fired on EVENTS fire on MOBJECT too, by calling each
                                  #MOBJECT.listenTo(EVENTS, "EVENT", FUNC|EVENTS.FUNC)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:     MAPPLICATION/MMODULE      :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


MARIONETTE.Application            #MAPPLICATION: global/main object
MAPPLICATION.start([OBJ])         #Fires MEVENT [before:]start(OBJ)
                                  #Does it trigger registered modules start()??? (do not think so)

MARIONETTE.Module                 #MMODULE: set of objects getting initialized/stopped and attached to MMODULE together.
                                  #Is a G* but not a MOBJECT
new MMODULE_CONSTRUCTOR
("MODULE", MAPPLICATION, OBJ)     #MMODULE.moduleName|app|options gets arguments
MMODULE.submodules                #{ "MODULE": MMODULE ... } children
MMODULE.start(OBJ)                #Fires MEVENT [before:]start(OBJ)
                                  #Calls all children MMODULE2.start(OBJ) unless MMODULE2.startWithParent false
                                  #Only does it once (unless stopped)
MMODULE.stop()                    #Fires MEVENT [before:]stop()
                                  #Calls all children MMODULE2.stop()

MAPPLICATION.module("MODULE")     #Retrieve registered MMODULE
MAPPLICATION.module               #Register new MMODULE_CONSTRUCTOR("MODULE", MAPPLICATION, OBJ) then fires:
("MODULE"[, OBJ[, ...]])          #  - OBJ|MMODULE_ATTR.initialize("MODULE", MAPPLICATION, OBJ) (can be inherited)
                                  #  - OBJ|MMODULE_ATTR.define(MMODULE, MAPPLICATION, BACKBONE, MARIONETTE, JQ, __, ...)
                                  #    (cannot be inherited)
                                  #If called again, does not register again, but fires initialize|define() again
                                  #Can use "MODULE.SUBMODULE...": will create MMODULE.submodules chain
                                  #MMODULE_CONSTRUCTOR: can redefine with OBJ.moduleClass
                                  #OBJ can be:
                                  #  - FUNC -> { define FUNC }
                                  #  - MMODULE_CONSTRUCTOR -> { moduleClass MMODULE_CONSTRUCTOR }


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:        BACKBONE.WREQR         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Backbone.Wreqr.radio              #RADIO
                                  #Like EVENTS but also add:
                                  #  - CHANNEL: namespaces
                                  #  - REQRES|commands: 
                                  #     - only one callback by event, so means several emitters, few listeners (as opposed to
                                  #       EVENTS)
                                  #     - REQRES returns value, "commands" buffer calls
                                  #Used as a global app-wide event register/handler.
                                  #Version 1.3.2

RADIO.channel("CHANNEL")          #Returns WCHANNEL
RADIO.*.FUNC("CHANNEL", ...)      #Same as WREQR.radio.channel("CHANNEL").*.FUNC(...)
WCHANNEL.channelName              #
WCHANNEL.reset()                  #Remove all WCHANNEL.vent|commands|reqres handlers

WCHANNEL.vent                     #EVENTS

WCHANNEL.reqres                   #REQRES. Similar to EVENTS but sync
REQRES.setHandler
("HDLR", FUNC[, THIS])
REQRES.setHandlers                #Register an event listener
({ "HDLR": FUNC|WOBJ })           #WOBJ: callback FUNC()[, context THIS]
REQRES.getHandler("HDLR")         #Returns FUNC
REQRES.hasHandler("HDLR")         #
REQRES.removeHandler("HDLR")      #
REQRES.removeAllHandlers()        #
REQRES.request("HDLR", ...)       #Fires event listener FUNC(...) synchronously and return value

WCHANNEL.commands                 #Same as WCHANNEL.reqres but:
                                  #  - if event listener missing, buffers calls until it is declared 
                                  #  - use execute() instead of request(), which does not return value


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          MAPPROUTER           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


MARIONETTE.AppRouter              #MAPPROUTER
                                  #Child of ROUTER, which uses MAPPROUTER..appRoutes instead of ROUTER.routes, same but use:
                                  #  - MAPPROUTER..controller.ROUTE(...) instead of ROUTER_ATTR.ROUTE(...)
                                  #    Goal: separate MAPPROUTER..controller OBJ (logic) from MAPPROUTER (routing)
                                  #  - MAPPROUTER.appRoute(...) instead of ROUTER.route(...) (cannot use last arg R_FUNC)
                                  #  - MAPPROUTER_ATTR.onRoute("ROUTE", R_PATH, R_VAR_ARR) instead of 
                                  #    EVENT route("ROUTE", R_VAR_ARR).
                                  #    Based on MAPPROUTER..appRoutes


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            MVIEW              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


MARIONETTE.View                   #Child of VIEW
                                  #Fires MEVENT dom:refresh() on EVENT show|render
MVIEW..model|collectionEvents     #{ EVENT: FUNC|"FUNC ..." } that will fire on MVIEW when fired on MVIEW.model|collection
MVIEW_ATTR.triggers               #Like MVIEW_ATTR.events, but triggering MEVENT instead of functions.
                                  #Values are "MEVENT", which will fire MEVENT(OBJ):
                                  #  - with OBJ.view MVIEW and OBJ.model|collection MVIEW.model|collection
                                  #  - can use values { eventName: "MEVENT", preventDefault|stopPropagation BOOL } too
MVIEW_ATTR.ui                     #{ KEY: SELECTOR }:
                                  #  - MVIEW.bindUIElements() assigns MVIEW.ui = MVIEW.$(SELECTOR)
                                  #    (called by MITEMVIEW|MCOMPOSITEVIEW.render())
                                  #  - can use "@ui...." which will refer to MVIEW.$(SELECTOR) in: 
                                  #     - MVIEW_ATTR.triggers keys
                                  #     - OBJ.region.selector|el values (not keys)
MVIEW_ATTR.destroy()              #Like MOBJECT.destroy() but also:
                                  #  - remove from DOM 
                                  #  - sets MVIEW.isDestroyed true, MVIEW.isRendered false
                                  #  - MBEHAVIOR do not fire MEVENTs

MVIEW_ATTR|MBEHAVIOR.             #{ BKEY: BOBJ }, firing behaviors, which decouple the logic (MEVENT handling) of MVIEW.
behaviors OBJ[()]                 #Fire new MBEHAVIOR_CONSTRUCTOR(BOBJ, MVIEW):
                                  #  - MBEHAVIOR is MARIONETTE.Behavior
                                  #  - look up MBEHAVIOR_CONSTRUCTOR in:
                                  #      - BOBJ.BehaviorClass
                                  #      - or MARIONETTE.Behaviors.behaviorsLookup(BOBJ, BKEY)[BKEY]
                                  #        behaviorsLookup() must be redefined, e.g. returning global object 
                                  #        { BKEY: MBEHAVIOR_CONSTRUCTOR }
                                  #  - MBEHAVIOR.options = BOBJ (can use MBEHAVIOR_ATTR.defaults OBJ[()])
                                  #MBEHAVIOR proxies MVIEW:
                                  #  - inherits its ui|$|el|$el, gets its MEVENTs
                                  #  - can define model|collectionEvents (will use MVIEW.model|collection) and MEVENTs handlers
                                  #  - MBEHAVIOR.view = MVIEW
                                  #  - MBEHAVIOR.events|triggers are namespaced???


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           MITEMVIEW           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


MARIONETTE.TemplateCache.get      #Returns TEMPLATE_FUNC. By def., returns __.template($(ID).html()[, OBJ])
(ID[, OBJ])                       #Details (in order):
                                  #  - new MARIONETTE.TemplateCache(ID)->TEMPLATECACHE, with TEMPLATECACHE.templateId ID
                                  #  - TEMPLATECACHE.loadTemplate(ID[, OBJ])->"TEMPLATE" (def: $(ID).html())
                                  #  - TEMPLATECACHE.compileTemplate("TEMPLATECACHE"[, OBJ])->TEMPLATE_FUNC
                                  #    (def: forward to _.template(...)), 
                                  #  - TEMPLATECACHE.compiledTemplate = TEMPLATE_FUNC
                                  #Last two functions can be overriden.
                                  #Caching:
                                  #  - stores TEMPLATECACHE in MARIONETTE.TemplateCache.templateCaches[ID] used in next call
                                  #  - can MARIONETTE.TemplateCache.clear([ID...])

MARIONETTE.ItemView               #MITEMVIEW. Child of MVIEW, to render a single MODEL.
MITEMVIEW.serializeData([...])    #MITEMVIEW.model.toJSON(...)
                                  #or (if no MITEMVIEW.model) { items: MITEMVIEW.collection.toJSON(...) }
                                  #mixed in MITEMVIEW..templateHelpers OBJ[()]
MITEMVIEW.render()                #  - calls (unless MITEMVIEW..template false):
                                  #     - "COMPILED_TEMPLATE" = MARIONETTE.Renderer.render
                                  #       (MITEMVIEW..template VAL, MITEMVIEW.serializeData() OBJ, MITEMVIEW) which by def:
                                  #         - if VAL FUNC, calls FUNC(OBJ)
                                  #         - otherwise MARIONETTE.TemplateCache.get(VAL)(OBJ)
                                  #     - MITEMVIEW.attachElContent("COMPILED_TEMPLATE") (def: MITEMVIEW.$el.html(...))
                                  #     - both functions can be overriden
                                  #  - fires MEVENT "[before:]render"(MITEMVIEW)
                                  #  - MITEMVIEW.isRendered = true


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           MCOLLVIEW           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


new Backbone.ChildViewContainer   #Container for VIEW_ARR, underlying MCOLLVIEW (i.e. MCOLLVIEW.children)
([VIEW_ARR])                      #Based on Backbone.Babysitter 0.1.6
                                  #Mixes in the following Underscore methods: forEach|map|reduce|find|filter|reject|every|
                                  #some|contains|invoke|toArray|first|initial|rest|last|without|isEmpty|pluck
CHILDVIEWCTNER.add(VIEW[, KEY])   #
CHILDVIEWCTNER.remove(VIEW)       #
CHILDVIEWCTNER.length             #

CHILDVIEWCTNER.call("FUNC"[, ...])#
CHILDVIEWCTNER.apply("FUNC"[,ARR])#Call each VIEW.FUNC(...)

CHILDVIEWCTNER.findByModel(MODEL) #
CHILDVIEWCTNER.findByModelCid(VAL)#Retrieve VIEW by MODEL.cid
CHILDVIEWCTNER.findByCid(VAL)     #Retrieve VIEW by VIEW.cid
CHILDVIEWCTNER.findByCustom(KEY)  #Retrieve VIEW by KEY
CHILDVIEWCTNER.findByIndex(NUM)   #Retrieve VIEW by position


MARIONETTE.CollectionView         #MCOLLVIEW. Child of MVIEW, to render a COLL.
MCOLLVIEW.collection              #COLL
MCOLLVIEW.children                #CHILDVIEWCTNER, rebuilt by MCOLLVIEW.render()
MCOLLVIEW.render()                #
                                  #Fires MEVENT:
                                  #  - [before:]render(COLL)
                                  #  - [before:]render:collection"COLL)
                                  #  - [before:]add:child(CHILD_MVIEW)
                                  #  - [before:]render|remove:empty()
                                  #Sets MITEMVIEW.isRendered = true
                                  #Also:
                                  #  - for each MODEL:
                                  #     - gets CHILD_MVIEW_CONSTRUCTOR with MCOLLVIEW.getChildView(MODEL)
                                  #       (def: ->MCOLLVIEW..childView)
                                  #     - does MCOLLVIEW.addChild(MODEL, CHILD_MVIEW_CONSTRUCTOR, NUM)
                                  #        - CHILD_MVIEW = MCOLLVIEW.buildChildView(MODEL, CHILD_MVIEW_CONSTRUCTOR, OBJ) 
                                  #          where OBJ is MCOLLVIEW..childViewOptions OBJ[(MODEL, NUM)])
                                  #          which returns new CHILD_MVIEW_CONSTRUCTOR(OBJ), adding OBJ.model MODEL to OBJ
                                  #        - CHILD_MVIEW.render()
                                  #        - MCOLLVIEW.attachHtml(MCOLLVIEW, MVIEW, NUM)
                                  #           - this appends CHILD_MVIEW to MCOLLVIEW.$el
                                  #  - any "EVENT"(...) on children triggers MEVENT "childview:EVENT"(...)
                                  #     - if MCOLLVIEW.childEvents.EVENT VAL[()] defined, calls VAL(...)
                                  #       VAL is FUNC or "FUNC" (refers to MCOLLVIEW.FUNC)
                                  #  - if MCOLLVIEW.collection is empty:
                                  #     - add child like above but:
                                  #        - use new MODEL() as MODEL
                                  #        - can use MCOLLVIEW..emptyView for CHILD_MVIEW_CONSTRUCTOR 
                                  #        - can use MCOLLVIEW..emptyViewOptions for childViewOptions
                                  #Listens to COLL events "add|remove|reset" to keep child views in sync with collection models.
MCOLLVIEW.destroy()               #Also:
                                  #  - fire MEVENT [before:]destroy:collection()
                                  #  - remove children too, calling their CHILD_MVIEW.destroy()
                                  #Each child when removed:
                                  #  - fire [before:]remove:child(CHILD_MVIEW)
SORTING ==>                       #Sort in the DOM when:
                                  #  - MCOLLVIEW.render()
                                  #  - COLL event "sort" (also re-render() unless MCOLLVIEW..reorderOnSort false)
                                  #  - manual MCOLLVIEW.reorder(): also fires MEVENT [before:]reorder()
                                  #Sort according to MCOLLVIEW..viewComparator "VAR"|FUNC(VAL, VAL2)->-1|0|1
                                  #("VAR" sorts according to MODEL.VAR)
FILTERING ==>                     #According to MCOLLVIEW..filter(MODEL, NUM, COLL)->BOOL (false to filter)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:        MCOMPOSITEVIEW         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


MCOMPOSITEVIEW: check difference with MITEMVIEW???

																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          MLAYOUTVIEW          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/



Check MVIEW._triggerEventOnParentLayout() to see how child MVIEW trigger their MEVENT on parent MLAYOUTVIEW
MVIEW._parentLayoutView()->MLAYOUTVIEW

See how [before:]show MEVENT is triggered in different MVIEW types





																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           UNSORTED            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/

