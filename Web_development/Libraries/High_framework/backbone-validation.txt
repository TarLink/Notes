
                         
   BACKBONE-VALIDATION   
                         


VERSION ==>                       #0.11.5
Backbone.Validation               #VALIDATION, client-side
require("backbone-validation")    #VALIDATION, server-side (Node)

MODEL.validation                  #VAL_OBJ[()], where VAL_OBJ is { VARR: RULE }, where RULE:
                                  #  - specifies schema for _.get(MODEL, VARR)
                                  #  - can be:
                                  #     - OBJ[_ARR]:
                                  #        - msg "ERROR"[()]:
                                  #           - otherwise use VALIDATION.messages.VFUNC "ERROR"
                                  #           - can contain:
                                  #              - "{0}": "VARR", after formatting according to VALIDATION.bind() OBJ.labelFormatter STR:
                                  #                 - "none": does nothing
                                  #                 - "sentenceCase" (def): aaBB|aa_bb -> "Aa bb"
                                  #                 - "label": use MODEL.labels.VARR (if undefined, same as "sentenceCase")
                                  #              - "{NUM}": VF_VAL[NUM]
                                  #        - VFUNC VF_VAL
                                  #     - FUNC: same as { fn FUNC }
                                  #VFUNC VF_VAL can be:
                                  #  - fn "FUNC"|FUNC(VAL, "VARR", ATTR_OBJ)->undefined|"ERROR":
                                  #     - this is MODEL
                                  #     - "FUNC", i.e. MODEL.FUNC
                                  #  - required BOOL: null|undefined|""(trimmed)|[]
                                  #  - acceptance BOOL: === true|'true'
                                  #  - min|max NUM
                                  #  - range [ MIN, MAX ]
                                  #  - length|minLength|maxLength NUM: for a STR
                                  #  - rangeLength [ MIN, MAX ]: for a STR
                                  #  - equalTo VAL
                                  #  - oneOf VAL_ARR
                                  #  - pattern REGEXP|STR:
                                  #     - STR is "email", "url", "digits" /^\d+$/ or "numbers" (can have leading -, decimals and commas)
                                  #     - registered as VALIDATION.patterns.STR REGEXP and VALIDATION.messages.STR "ERROR"
                                  #VFUNC are registered as VALIDATOR.validators.VFUNC(VAL, "VARR", VF_VAL, MODEL, ATTR_OBJ)->undefined|"ERROR"
VALIDATION.[un]bind(VIEW[, OBJ])  #Sets/overrides MODEL properties:
                                  #  - validate([ATTR_OBJ[, OBJ2])]:
                                  #     - fires events:
                                  #        - validated(BOOL, MODEL, OBJ_ARR), where OBJ_ARR { "VARR": "ERROR" }
                                  #        - validated:[in]valid(MODEL, OBJ_ARR)
                                  #     - if invalid, returns ERROR[_STR], making MODEL.set|save|fetch() stop and firing
                                  #       "invalid" event, unless OBJ|OBJ2.forceUpdate true (def: false)
                                  #  - isValid([VAL])->BOOL, where VAL can be:
                                  #     - "VARR"[_ARR]: checks ATTR_OBJ.VARR
                                  #     - true: checks all, triggering MODEL.validate()
                                  #     - undefined: according to last MODEL.validate() 
                                  #  - preValidate({ VARR: VAL }) or ("VARR", VAL): same as isValid() but running after an
                                  #    hypothetical MODEL.set(...)
                                  #  - MODEL event invalid(MODEL, { VARR: "ERROR" ... }, OBJ2), also fired by isValid()
                                  #MODEL:
                                  #  - is VIEW|OBJ.model
                                  #  - if VIEW|OBJ.collection COLL, do it on each children MODEL, including new ones 
                                  #    (by listening to COLL event)
                                  #OBJ:
                                  #  - [in]valid(): called by isValid|validate()
                                  #  - invalid(VIEW, "VARR", "ERROR", SELECTOR): by def:
                                  #      VIEW.$('[ATTR~="VARR"]').addClass("invalid").attr("data-error", "ERROR")
                                  #    ATTR is OBJ.selector (def: "name")
                                  #  - valid(VIEW, "VARR", SELECTOR): by def:
                                  #      VIEW.$('[ATTR~="VARR"]').removeClass("invalid").removeAttr("data-error")
                                  #  - forceUpdate BOOL: if true (def: false), does not trigger error event anymore, and let
                                  #    MODEL.set|save|fetch() work even if not valid???
                                  #     - can be also on MODEL.set|save|fetch() OBJ2.forceUpdate
                                  #  - attributes "VARR"_ARR[(VIEW)]|"FUNC":
                                  #     - restrict isValid() and validate() to MODEL.VARR
                                  #     - "FUNC" use VALIDATION.attributeLoaders.FUNC(VIEW)->"VARR"_ARR. Only def "FUNC" is:
                                  #        - "inputNames": VIEW input|select|textarea (with a form ancestor) name HTML attribute
                                  #Must be called after MODEL initialized, e.g. VIEW.initialize() or onBeforeRender()
                                  #OBJ.model|collection (def: VIEW.model|collection)
                                  #unbind() should be called in VIEW.destroy()
_.extend
(MODEL.prototype,VALIDATION.mixin)#Same as VALIDATION.bind() but with MODEL and no VIEW (for server-side or tests)

DEFAULT VALUES ==>                #Must _.extend(OBJ2, OBJ), where OBJ2 is:
                                  #  - VALIDATION.defaultOptions: for VALIDATION.bind() OBJ
                                  #     - can also do VALIDATION.configure(OBJ)
                                  #  - VALIDATION.callbacks: for OBJ2.[in]valid
                                  #  - VALIDATION.attributeLoaders|validators|patterns|messages: see above
