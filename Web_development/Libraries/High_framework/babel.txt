
           
   BABEL   
           


GOAL ==>                          #ES6 -> ES5

POLYFILL ==>                      #Includes regenerator (for generators) and core.js (other polyfills).
                                  #Install:
                                  #  - browser: browser-polyfill.js
                                  #  - Node: require("babel/polyfill") (done by require("babel/register") and babel-node)
                                 +#Means requires polyfill

babel [FILE|DIR]                  #Node module binary (version 5.6.4) (def: stdin)
[--out-file|dir FILE2|DIR2]       #Def: output ES5 to stdout
--watch                           #
--source-maps [inline]            #

BABEL-CORE                        #As Node module
BABEL-CORE.transform(STR[, OBJ])  #Returns OBJ2:
                                  #  - code STR2
                                  #  - map STR3
                                  #  - ast
BABEL-CORE.transformFile
(FILE[, OBJ], FUNC(ERROR, OBJ2))  #
BABEL-CORE.transformFileSync
(FILE[, OBJ])->OBJ2               #

babel-node                        #Same as Node REPL, but compiling ES6 first.
                                  #Can use same options as babel + Node REPL

require("babel/register")[OBJ]    #Patch Node require() so it uses Babel on *.es6|es|jsx|js, except "node_modules/**" 
                                  #(unless OBJ.ignore false).
                                  #OBJ: same options as above.
                                  #Caches. Can use ENVVAR BABEL_DISABLE_CACHE=1 and BABEL_CACHE_PATH=DIR
                                  #Should not be used in library, as it will patch require() for other libraries too.

BROWSER ==>                       #Load browser.js from NPM module babel-core
                                  #  - should put ES6 in <script type="text/babel|ecmascript-6">
                                  #  - can also use babel.transform(STR[, OBJ]).code or babel.run(STR[, OBJ])

GULP-BABEL([OBJ])                 #Version 5.1.0
                                  #Same options, except:
                                  #  - filename not needed
                                  #  - sourcemaps: need to use SOURCEMAPS.init|write() before|after

grunt-babel                       #Grunt plugin (5.0.1)
                                  #  - TASK "babel"
                                  #  - TARGET src, dest
                                  #  - options OBJ: same as above

requirejs-babel                   #Version 0.0.6
                                  #Plugin adding "es6!FILE"
                                  #Must use CONFVAR paths.es6 PATH_TO_ES6 and paths.babel PATH_TO_BABEL

babelify[.configure(OBJ)]         #Browserify transform (6.1.2)

MOCHA ==>                         #Can use --compilers js:babel/register

karma-babel-preprocessor          #Version 5.2.1
                                  #PLUGIN "babel", CONFIGVAR babelPreprocessor OBJ:
                                  #  - options OBJ: same as above
                                  #  - [source]filename(FILE)->STR

BABEL-CONNECT(OBJ2)               #Express MDW (6.0.1) that compile static assets. OBJ2:
                                  #  - options OBJ: same as above
                                  #  - src|dest DIR
                                  #  - ignore DIR

JADE-BABEL([OBJ])                 #Jade filter (5.0.0), used as :babel


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           POLYFILLS           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/



																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              ES6              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


SYSTEMJS ==>                      #Can be used:
                                  #  - develop-time: must load es6-module-loader-dev.js (after Babel) and sets System.transpiler = "babel"
                                  #  - production: compile to SystemJS with --modules system, then use SystemJS builder


"use strict";                     #Added on top


VAR = function(){...}             #VAR = (function VAR(){...}).bind(this)
(...) => {...}                    #function(...) {...}
(...) => VAL                      #Same as (...) => {return VAL}
ARG => {...}                      #Same as (ARG) => {...}

this                              #Global this -> undefined


class TYPE [extends TYPE2]        #var TYPE = FUNC that throws ERROR if not called with new
{                                 #  - extends TYPE2:
  [constructor(...) { ... }]      #      constructor() -> function TYPE():
  [static] FUNC(...) { ... }      #       - must call super(...) before assigning to this 
}                                 #       - by def: constructor() { super(arguments) }
                                  #      TYPE.prototype = Object.create(TYPE2.prototype)
                                  #      TYPE.prototype.constructor = TYPE (non-enumerable)
                                  #      TYPE.__proto__ = TYPE2
                                  #  (non-static)
                                  #  - TYPE.prototype.FUNC = FUNC (non-enumerable)
                                  #  (static)
                                  #  - TYPE.FUNC = FUNC (non-enumerable)
                                  #No comma between definition members.
super.*                           #TYPE2.prototype.*
super(...)                        #TYPE2.prototype.constructor(...)


{ VAR }                           #{ VAR: VAR }
{ FUNC() {...} }                  #{ FUNC: function FUNC() {...} }
{ [ STR ]: VAL }                  #OBJ[STR] = VAL (STR do not have to be literal)


`...${EXPR}...`                   #"..." + EXPR + "..."
                                  #Escape everything in it, including " ' newline
FUNC`...`                         #FUNC(STR_ARR, VAL...):
FUNC `...`                        #  - VAL... are each ${EXPR}
                                  #  - STR_ARR[.raw][NUM] are each `...` in-betwen, including empty "" at beginning|end if starts|ends
                                  #    with ${EXPR}
                                  #    If "raw", escape backslashes
                                  #FUNC can be String.raw(), which concanates all like normal template, except it escape backslashes


UNICODE ==>                       #ES5 supports it, except over FFFF. For over FFFF, can use the following methods 
                                  #(but others, including STR.length and STR[NUM], will report 2 chars instead of 1):
'\u{CODEPOINT}'                   #Like \uXXXX. Assumes hexadecimal
String.fromCodePoint(CODEPOINT)   #Like \u{CODEPOINT}, but does not assume hexadecimal.
STR.codePointAt(NUM)              #Like STR.charCodeAt(NUM)
/REGEXP/u                         #Make . match a Unicode char


var [ VAR[ = VAL], ... ] = ARR    #var VAR = ARR[NUM], ...
                                  #VAL is default value
var { KEY: VAR[ = VAL] } = OBJ    #var VAR = OBJ[KEY], ...
                                  #VAL is default value
var { KEY[ = VAL] } = OBJ         #Same as var { KEY: KEY[ = VAL] } = OBJ
function({...}) {...}             #function(obj){ var {...} = obj; }
var {KEY2:{KEY3:VAR2[=VAL]}} = OBJ#VAR2 = OBJ[KEY2][KEY3], ...
                                  #Also works with the shortcut syntax


for (var VAL of ARR|STR) {...}        #Iterates over values

function(VAR=VAL){...}            #Default value
function(VAR, ...ARR) {...}       #Variadic arguments
FUNC([..., ]ARR...)               #FUNC.apply(undefined, [...].concat(ARR))


let VAR                           #Like var VAR, but {} block scoped.
                                  #Can use { ... } without anything before it.
                                  #Babel just rename VAR names to make it work.
const VAR                         #Same but read-only (compile-time errors)


var SYM = Symbol(["VAR"])        +#Same as OBJ["VAR"], but
OBJ[SYM]                         
                                 +#  - not a STR:
                                 +#     - length is 1
                                 +#     - primitive type. typeof "symbol"
                                 +#     - cannot convert to NUM
                                 +#     - String(SYM) or SYM.toString()
                                 +#     - no STR methods
                                 +#  - semantically for private members:
                                 +#      - properties with a key of SYM will be ignored by JSON.stringify()
                                 +#      - not enumerable in "for in"
                                 +#      - "VAR" optional (just used for debugging description)
                                 +#      - getOwnPropertyNames() -> getOwnPropertySymbols()
                                 +#OBJ[Symbol("VAR")] !== OBJ["VAR"]


FUNC()->{ 
  next()->{done BOOL, value VAL}
  [return()->{done true}]        +#Generator. Convention for a FUNC returning specific functions.
}                                +#Return should make following next() return the same thing
function*(){...}                 +#Returns a generator where next():
                                 +#  - stops at the next "yield VAL" returning {done false, value VAL}
                                 +#  - or return {done true}
for ([var ]VAR of OBJ) {...}     +#Iterates by calling var VAR = OBJ[Symbol.Iterator]().next().value until OBJ.done true, finally calling return()

* FUNC() {...}                    #FUNC: function *() {...}


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            MODULES            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


EXPORT/IMPORT ==>                 #Use ES6 syntax but is compiled according to --modules to:
                                  #  - common (def): CommonJS
                                  #  - amd
                                  #  - umd
                                  #  - system: SystemJS (System.register())
                                  #  - ignore: nothing
                                  #  - MODULE: custom
                                  #So must then use the appropriate loader (Browserify, RequireJS, SystemJS, etc.)
export var VAR = VAL
export function VAR(...){...}     #
export { VAR[ as VAR2] }          #With VAR name
export default VAL                #Without VAR name
export ... from "MDL"             #Same as import ... from "MDL", then multiple export

import {VAR[ as VAR2],...} 
from "MDL"                        #
import * as VAR2 from "MDL"       #With VAR name
import VAR from "MDL"             #Without VAR name. Can be combined, e.g. import VAR, {...} from "MDL"
import "MDL"                      #Do not import the variable, just execute the file
