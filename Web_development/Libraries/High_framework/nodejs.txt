
            
   NODEJS   
            



																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         COMMAND LINE          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


PURPOSE ==>                                     #Execute JavaScript code server-side
                                                #Based on Chrome JavaScript engine V8

VERSION ==>                                     #2.1.0

node[js] [[-e] FILE] [FILE_ARGS]                #Command-line
node[js] -p STR [ARGS]                          #nodejs is symlink to node (prefer the later as this is what nvm uses).
                                                #FILE is JavaScript file (déf: stdin)
                                                #With -p, evaluates STR, and returns last return value.
-i                                              #Enters REPL even if stdin does not come from a terminal
--v8-options                                    #Prints available v8 options. Some documented just below:
-c                                              #Run-dry (syntax check)

#!/usr/bin/env node                             #Shabang to execute a Node file directly with ./FILE

node debug ...                                  #Debugging:
                                                #  - must provide FILE
                                                #  - launch in debug mode. Puts a breakpoint in first line and can use:
                                                #     - breakpoints are specified by:
                                                #       - putting breakpoint; in FILE
                                                #       - sb([[FILE, ]LINE_NUM]): by def, current line
                                                #       - sb('FUNC()')
                                                #       - cb(...): clear breakpoints
                                                #     - [un]watch(VAL): watch points
                                                #     - watchers: list watch points
                                                #     - c: continue
                                                #     - n: next
                                                #     - s: step in
                                                #     - o: step out
                                                #     - pause: pause running code
                                                #     - run|restart|kill
                                                #     - repl: open console to execute in current context
                                                #     - bt: call stack
                                                #     - list(NUM): list NUM next lines
                                                #     - scripts: list all FILE
                                                #Can debug Mocha with node debug _mocha ...
node --debug[-brk][=NUM] ...                    #Launch debugger but in background.
                                                #If -brk, will put breakpoint at first line.
                                                #Can also send SIGUSR1 to exisiting node process to make in same debugging
                                                #state.
                                                #Can then connect to it with node debug -p PID or node debug URL
                                                #(port 5858, or NUM)
node-inspector                                  #Node package (0.7.4). Use node debugger via the Chrome developer tools.
                                                #How:
                                                #  - use node --debug[-brk]
                                                #  - on same machine, node-inspector & (if /usr/bin/node not available, 
                                                #    make a symlink from /usr/bin/node)
                                                #  - on any machine, visit http://HOST:PORT/debug?port=PORT2 (see options)
                                                #Options can be in a conf JSON file, without first two dashes: --config FILE,
                                                #or $PWD|$HOME|etc/.node-inspectorrc
--web-port=PORT                                 #Déf: 8080. Port to be listened.
--web-host=HOST                                 #Déf: 127.0.0.1
--debug-port=PORT2                              #Déf: 5858. Listening port.
--save-live-edit=BOOL                           #Live edit change files directly

node-debug ...                                  #Part of node-inspector package.
                                                #Same as node --debug-brk ..., followed by node-inspector, then open browser.
--web-port=PORT
--debug-port=PORT2
--no-debug-brk                                  #Don't stop on first line
-c                                              #Don't open browser

npm                                             #Node packet manager (see doc)

nvm                                             #Manage different versions of Node. Version 0.23.3
                                                #Must install via manual Bash script, not npm
nvm install [-s] [VERSION]                      #Install Node, VERSION in ~/.nvm/
                                                #VERSION def. is .nvmrc content. .nvmrc is looked in project root directory, or
                                                #any parent. Should create /home/ether/.nvmrc for default VERSION
                                                #VERSION can also be:
                                                #  - stable
                                                #  - unstable
                                                #  - iojs: IO.js
                                                #  - system: version used on current system
                                                #  - ALIAS: after nvm alias ALIAS VERSION. Can also nvm unalias ALIAS.
                                                #-s is from source
nvm use [VERSION]                               #Make default binary point to this VERSION (by changing $PATH)
nvm current                                     #Show current VERSION
nvm run [VERSION] ARGS                          #Calls node (non-interactive)
nvm exec VERSION node                           #Calls node (interactive)
nvm which [VERSION]                             #
nvm ls                                          #Show which versions are installed
nvm ls-remote                                   #Show which versions can be installed
nvm deactivate                                  #
nvm reinstall-packages [VERSION]                #Redo npm install -g, but with VERSION



																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             MAIN              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


global                                          #Global object (like WINDOW in a browser)

Error                                           #Error code / exception. null si pas d'erreur.
ERROR.errno                                     #UINT
ERROR.code                                      #STR
ERROR.path                                      #STR, for filesystem errors

console.log|info|error|warn(...)                #
console.dir(VAL[, OBJ])                         #OBJ:
                                                #  - showHidden BOOL: if true, show non-enumerable
                                                #  - depth NUM (def: 2)
                                                #  - colors BOOL (def: false)
console.time[End](STR)                          #Timer start|end
console.trace(STR)                              #Prints error message with current stack trace
console.assert(VAL, ...)                        #Same as ASSERT.ok(VAL, UTIL.format(...))

__filename|dirname                              #Currently executing code absolute path|absolute dirname (doesn't work in REPL)
                                                #Not in "process" module

EVENT QUEUE ==>                                 #Async events (event handlers and timer callbacks) are given a chance to fire
                                                #only once a root function (main function or async event) and all the functions
                                                #called by it has returned ("tick").
                                                #In other terms, async events will queue each other (their synchronous code).
                                                #This is the node.js "event loop".
                                                #Consequences:
                                                #  - var VAR = FUNC(CALLBACK): can use VAR in current function with 
                                                #    guarantee that CALLBACK will not be fired, providing CALLBACK is async
                                                #      - examples where that guarantee is essential:
                                                #         - CALLBACK fire events that should be attached to by calling function
                                                #           Ex: emit a start event, but calling function should do
                                                #           VAR.on("start",...)
                                                #         - CALLBACK uses VAR
                                                #           Ex: var VAR = FUNC(function(){ VAR.FUNC2() })
                                                #      - to provide this guarantee, CALLBACK should always be really async, 
                                                #        i.e. not be called like CALLBACK() but with nextTick(CALLBACK)
                                                #  - so to keep the event loop responsive, use as little synchronous code as
                                                #    possible
                                                #     - if time consuming synchronous code, make it recursive and call each
                                                #       recursion asynchronously with nextTick()
                                                #  - whatever the time interval, timers callbacks will wait for the current 
                                                #    function and its caller (until ancestor) to complete before firing.

clear|setTimeout|Interval(...)                  #Like DOM ones, but:
                                                #  - can use ARGS... in end of setTimeout|Interval(...)
                                                #    (Possible in DOM except IE<=9)
                                                #  - call underlying [un]ref() to keep the program running. 
                                                #    But can call ID.unref() on the ID returned (then ID.ref() later too). Do
                                                #    wisely cause performance impact.
clear|setImmediate(...)                         #Same but with 0 seconds.
process.nextTick(CALLBACK()[, ...])             #Like setImmediate(CALLBACK), but faster (has priority on the next loop),
                                                #and can bind arguments.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            EVENTS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


EventEmitter                                    #Base class des objects ayant des events.
                                                #All returns EVENTEMITTER, so can chain it.
                                                #Event handlers are synchronous (but do not return anything), so must wrap in
                                                #process.nextTick() if want it async.
EVENTEMITTER.on|removeListener( EVENT, FUNC )   # 
EVENTEMITTER.once( EVENT, FUNC )                #
EVENTEMITTER.removeAllListeners([EVENT])        #
EVENTEMITTER.emit(EVENT[, ...])                 #Emit EVENT avec ARGS ...
                                                #Renvoie true s'il y avait event handler, false sinon.

EVENTEMITTER.listeners(EVENT)                   #Renvoie event handlers d'EVENT, sous forme de FUNC_ARR
EventEmitter.listenerCount(EVENTEMITTER, EVENT) #Same as EVENTEMITTER.listeners(STR).length, slightly faster.
EVENTEMITTER.setMaxListeners(NUM)               #Returns EVENTEMITTER. 0 for unlim.
EVENTEMITTER.defaultMaxListeners                #10
EVENTEMITTER.on( "new|removeListener",          #Event when a new event handler is added or removed.
FUNC( EVENT, FUNC ) )                           #Added|removed FUNC might still [not] be in EVENTEMITTER.listeners(EVENT)



																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            MODULE             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


module                                          #Current MODULE, i.e. file being loaded. Used for library files.
                                                #There are builtin modules, which are the chapters of this doc.
node -r STR                                     #Load file STR (MODULE.id or MODULE.filename). Can be:
[MODULE.]require(STR)                           #  - a Node JavaScript file:
                                                #     - execute the whole file
                                                #     - and returns its module.exports object as a VAL (anything, but generally
                                                #       a OBJ|FUNC).
                                                #       Returns it by reference, which means the module can still manipulate it
                                                #       asynchronously. One example is to make VAL a new EventEmitter, and 
                                                #       asynchronously emit ready event when module is set up.
                                                #     - variable declaration are local to STR apart from that.
                                                #  - a JSON file, returned as is.
                                                #    Can e.g. be PACKAGE/package.json, to return OBJ. 
                                                #    Could then use OBJ.version to check version. 
                                                #    Should use PACKAGE semver for version tests.
                                                #  - a machine code file (often "*.node"), loaded by dlopen()
                                                #    Needs to create a void init(Handle<Object> exports), and assign to
                                                #    exports in C/C++.
                                                #    See online doc: requires writting with V8 library, libuv and other 
                                                #    internal Node libraries.
                                                #    Use node-gyp command line tool for packaging/compilation.
                                                #Relative filename STR must start with "./" or "../"
                                                #If file STR is not found or is not a relative/absolute pathname:
                                                #  - try STR.js, STR.json and STR.node
                                                #  - look into ./node_modules/, then ../node_modules/, then ../../node_modules/
                                                #    etc.
                                                #    This allow dependencies to be self-contained in a folder.
                                                #  - look into $NODE_PATH (colon-separated list),
                                                #    $HOME/.node_modules|libraries and $PREFIX/lib/node/ 
                                                #    ($PREFIX is process.config.variables.node_prefix, e.g. "/usr")
                                                #    Prefer using local folders instead of system-wise installations.
                                                #  - try to find a module file from [...]/node_modules/STR/package.json|
                                                #    index.js|index.node. For package.json, doesn't export as is, but use
                                                #    member main STR2, path to the module to load.
                                                #    Goal is to package a module as a DIR instead of a file.
                                                #    The package file usually has more entries, like version, description, etc.
                                                #  - if not found, throw ERROR with code "MODULE_NOT_FOUND"
                                                #Can use [MODULE.]require.resolve(STR) to see which path STR2 will be loaded.
                                                #Result is cached (except builtins), so need to bypass cache:
                                                #  - remove [MODULE.]require.cache[ID_STR]
                                                #  - restart current code
                                                #  - use a exports.FUNC() that generate dynamically new objects
                                                #In general, it will be the main object of the library. 
                                                #Convention is to assign to VAR which name is same as STR.
                                                #Main object of each module is always implied when discussed below 
                                                #(chapter title is main object).
this                                            #Is, according to NODE_MODULE_CONTEXTS:
                                                #  - 0 (def): module.exports
                                                #  - 1: global
MODULE.require.main                             #Root filename (first file to have been loaded).
                                                #For command line, this is undefined
                                                #Can also use process.mainModule. Difference: the later is updated if changed
                                                #runtime.
MODULE.filename                                 #Current file STR.
                                                #For command line, this is "$PWD/repl"
MODULE.id                                       #For builtin modules, a string like "buffer". For others, module.filename.
                                                #For command line, this is "repl"
MODULE.loaded                                   #False is currently loading. 
                                                #For command line, it is always false.
MODULE.parent|children                          #MODULE[_ARR] dependent or depending (null if none)
                                                #For master file (including command line), it is none.

																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         STRINGDECODER         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


new STRINGDECODER([ENCODING_STR])								#Returns DECODER. Def: "utf8"
DECODER.write(BUFFER)
DECODER.end()																		#Returns as STR


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            BUFFER             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


Buffer                                          #Fixed-size byte array
                                                #Can be JSON's by JSON.stringify()
                                                #Don't need to use require("buffer").
BUFFER(UINT)                                    #Constructor, with non-initialized data.
BUFFER(UINT_ARR)                                #Constructor, with byte values.
BUFFER(STR[, STR2])                             #Constructor, with STR.
                                                #Encoding STR2 can be "utf8" (déf), "utf16le", "ucs2", "base64", "hex" or 
                                                #"ascii"
BUFFER(BUFFER2)                                 #Constructor by copy

BUFFER.length                                   #In bytes
Buffer.byteLength(STR[, STR2])                  #Returns byte length of STR. STR2 is encoding (déf: "utf8").

Buffer.isEncoding(STR)                          #Returns BOOL. Same encoding as BUFFER(STR[, STR2])
Buffer.isBuffer(VAL)                            #Returns BOOL

BUFFER[UINT]                                    #Returns the hex code UINT2 at position UINT (can be written)
BUFFER.toString([STR[, UINT[, UINT2]]])         #Returns BUFFER as STR, using encoding STR, from position UINT to UINT2
BUFFER.toArrayBuffer()                          #Returns as JavaScript ARRAYBUFFER
BUFFER.toJSON()                                 #Returns as '{"type": "Buffer", "data": [...]}'
BUFFER.write(STR[,UINT[, UINT2[, STR2]]])       #Writes STR on BUFFER with encoding STR2.
                                                #UINT is offset (déf: 0) and UINT2 is length (déf: all)
BUFFER.copy(BUFFER2[, UINT[, UINT2[, UINT3]]])  #Copies bytes from BUFFER at position UINT to BUFFER2 from position UINT2 to
                                                #UINT3 (déf: BUFFER2.length)
BUFFER.readFloat|Double|[U]Int8|16|32LE|BE      #Returns a VAL from position UINT. 
(UINT[, BOOL])                                  #If BOOL true, faster but no validation of UINT.
BUFFER.writeFloat|Double|[U]Int8|16|32LE|BE
(VAL, UINT[, BOOL])                             #Writes a VAL at position UINT
BUFFER.read[U]Int[LE|BE](UINT, UINT2[, BOOL])   #
BUFFER.write[U]Int[LE|BE](VAL,UINT,UINT2[,BOOL])#Same but specifies [U]Int size UINT2 (up to 48)
BUFFER.fill(VAL[UINT[, UINT2]])                 #Fill with hexa code or STR, from specified offsets.

BUFFER.slice([UINT[, UINT2]])                   #Returns a reference
Buffer.concat(BUFFER_ARR[, UINT])               #Returns a BUFFER. Providing final length UINT can speed up performance.
Buffer.compare(BUFFER, BUFFER2)
BUFFER.compare(BUFFER2)                         #Sort comparaison, returning -1|0|1
BUFFER.equals(BUFFER2)                          #
BUFFER.indexOf(STR|UINT|BUFFER2[, NUM])         #Similar to ARR.indexOf(...)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            STREAM             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


ISTREAM ==>                                     #Input stream. Actually called Readable
                                                #When says BUFFER|STR: depends on whether setEncoding() has been called, and
                                                #is null if nothing to read.
STREAM.Readable([OBJ])                          #Constructor for ISTREAM. OBJ members are:
                                                #  - encoding STR (déf: null, i.e. uses BUFFER)
                                                #  - objectMode BOOL: if true, ISTREAM.read(NUM) returns a single OBJ, 
                                                #    whatever NUM is.
                                                #  - highWaterMark NUM: buffer size (déf: 16kb). Buffering happens with
                                                #    internal method ISTREAM.push() and OSTREAM.write()
ISTREAM.read( [UINT] )                          #Returns BUFFER|STR de (max) UINT octets (déf: all available).
                                                #If nothing available, returns null. Prefer using on("data")
                                                #Will not return anything until some chunks of data are available:
                                                #  - ISTREAM.on( "readable", FUNC() ): fired once when first chunks are there
                                                #  - ISTREAM.on( "end", FUNC() ): all chunks have been read()
                                                #  - ISTREAM.on( "close", FUNC() ): fired when underlying fd is closed 
                                                #    (not all ISTREAM close)
                                                #  - ISTREAM.on( "error", FUNC() )
ISTREAM.on( "data", FUNC( BUFFER|STR ) )        #When chunk of data is available, fires FUNC(ISTREAM.read()).
                                                #Usually only one chunk, but should accumulate and wait for "end" FUNC() event.
                                                #Be careful: doesn't fire if ISTREAM is empty (e.g. REQ with no body).
ISTREAM.pause|resume()                          #Makes it stop|resume emit "data" events.
ISTREAM.isPaused()															#
ISTREAM.setEncoding( STR )                      #Makes it return a STR instead of a BUFFER, with encoding STR (e.g. "utf8", 
                                                #see BUFFER).
ISTREAM.pipe(OSTREAM[, { end: BOOL }])          #Same as OSTREAM.write(ISTREAM.read()), but waits for "data" event.
                                                #If end: true (déf), call OSTREAM.end() afterwards (except on stdout|stderr).
                                                #Returns OSTREAM, so can chain to another pipe()
ISTREAM.unpipe([OSTREAM])                       #Stop pipe() (déf: all OSTREAM)
ISTREAM.unshift(BUFFER|STR)                     #Put last BUFFER|STR read back in ISTREAM

OSTREAM ==>                                     #Output stream. Actually called Writable
STREAM.Writable([OBJ])                          #Constructor for OSTREAM. OBJ members are:
                                                #  - decodeStrings BOOL: if true (déf), decodes to BUFFER before writing
                                                #  - objectMode BOOL: if true, OSTREAM.write(OBJ) becomes possible, and 
                                                #    encoding is then ignored.
OSTREAM.write(BUFFER|STR[, STR2[, FUNC()]])     #Writes chunks.
                                                #STR2 is the encoding (when using a STR)
                                                #FUNC() is fired when buffered + flushed.
                                                #Returns false if data have been buffered but not flushed, which means one 
                                                #should wait for the event "drain" to write again : OSTREAM.once( "drain", ...)
OSTREAM.end(BUFFER|STR[, STR2[, FUNC()]])       #Writes final chunk. FUNC is the finish event handler
                                                #Also returns true|false.
OSTREAM.[un]cork()                              #Forces buffering|flushing to disk. 
                                                #To do when writing a lot of small I/O, to make them all flush at once.
OSTREAM.on( "finish", FUNC() )                  #Fired by end()
OSTREAM.on( "[un]|pipe", FUNC(ISTREAM) )        #Fired by ISTREAM.[un]pipe()
OSTREAM.on( "error", FUNC() )                   #

IOSTREAM ==>                                    #Implement both ISTREAM and OSTREAM. Actually called either:
                                                #  - STREAM.Duplex
                                                #  - STREAM.Transform: same but where there is a correlation between input and 
                                                #    output (ex: crypto, but not socket). Only semantique.

INHERITING STREAMS ==>                          #To create STREAM child classes, just inherit them and reimplement functions
                                                #._read(), ._write[v](), ._transform() or ._flush() (see online doc), without
                                                #calling them directly.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           READLINE            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


createInterface(OBJ)                            #Returns an INTERFACE object, i.e. will read all input and pipe it to output.
                                                #When using stdin and stdout on a terminal, will create a CLI. If Node prompt
                                                #is already there, will double output on input.
                                                #OBJ members are:
                                                #  - input ISTREAM
                                                #  - output OSTREAM
                                                #  - completer FUNC(STR[, CALLBACK]), used to tab completion.
                                                #    Either returns [ STR2_ARR, STR ] or fire CALLBACK(ERROR, [ STR2_ARR,STR ])
                                                #    If ARR is several elements, show them, otherwise complete current word,
                                                #    providing it starts with same letters.
                                                #  - terminal BOOL (déf: OSTREAM.isTTY) if tty
INTERFACE.close()                               #Destroy it.
                                                #Called by ISTREAM.end(), CTRL-C and CTRL-D.
INTERFACE.on("close", CALLBACK())               #

INTERFACE.on("line", CALLBACK(STR))             #Fired each time a line is read from ISTREAM.
INTERFACE.write(STR|BUFFER[, OBJ])              #Prints STR|BUFFER on OSTREAM or, if OBJ { ctrl: true, name: STR }, do CTRL-STR
                                                #Be careful as it will be read by ISTREAM, if ISTREAM and OSTREAM point to
                                                #same thing (e.g. terminal).
INTERFACE.prompt([BOOL])                        #Write in beginning of current OSTREAM line the STR set by 
                                                #INTERFACE.setPrompt(STR) (déf: "> ").
                                                #If line was not empty, will place cursor at character number UINT of prompt 
                                                #(déf) or, if true, at end of line.
INTERFACE.question(STR|BUFFER, CALLBACK(STR2))  #Replace current prompt by STR|BUFFER on OSTREAM, and fires CALLBACK(STR2) on
                                                #line event instead of normal line event.
INTERFACE.pause|resume()                        #Pause|resume ISTREAM. 
                                                #ISTREAM still accept input but buffers it, and reads it once resumed.
                                                #resume() is also called by write(), prompt() and question()
INTERFACE.on("pause|resume", CALLBACK())        #
INTERFACE.on("SIGNINT|TSTP|CONT", CALLBACK())   #

readline                                        #Global object
readline.clearScreenDown(OSTREAM)               #
readline.clearLine(OSTREAM, NUM)                #Can be 0 (entire line) or -1 (to the left|right of cursor)
readline.cursorTo|moveCursor(OSTREAM, NUM, NUM2)#Move cursor absolutely|relatively


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             REPL              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


start(OBJ)                                      #Creates and returns a REPLSERVER, INTERFACE made specifically for Node.js 
                                                #command line, e.g. whose line event handler is eval().
                                                #This is what is used by node with no FILE.
                                                #If NODE_NO_READLINE envvar is defined to 1, readline is not used.
                                                #OBJ members are:
                                                #  - prompt STR (déf: "> ")
                                                #  - input ISTREAM (déf: process.stdin)
                                                #  - output OSTREAM (déf: process.stdout)
                                                #  - terminal BOOL (déf: OSTREAM.isTTY)
                                                #  - eval FUNC(STR, OBJ, FILENAME, CALLBACK(ERROR, STR)): 
                                                #    function to perform after each line. Déf. is async. wrapper of eval():
                                                #      - STR is command. 
                                                #      - OBJ is current context (global object)
                                                #      - STR2 is current module.filename
                                                #  - useColors BOOL (déf: same as terminal). 
                                                #    Can also use ENVVAR NODE_DISABLE_COLORS=1
                                                #  - useGlobal BOOL (déf: false): use current context, and not local one
                                                #  - ignoreUndefined BOOL (déf: false): if true, doesn't print output when
                                                #    it is undefined
                                                #  - writer FUNC: output printing, déf. is util.inspect
REPLSERVER.on("reset", FUNC())                  #When ".clear" is called.
REPLSERVER.on("exit", CALLBACK())               #
REPLSERVER.context                              #Global environment, as OBJ
                                                #REPL command ".clear" resets it.

REPL COMMANDS ==>                               #Without repl.*
                                                #Can use REPL.commands.STR = { help STR, action FUNC() } to add custom ones.
_                                               #Last expression evaluated
.save FILE                                      #Save all input so far to FILE
.load FILE                                      #Input FILE
.exit                                           
CTRL-D                                          #
.break
CTRL-C                                          #
.help                                           #

NODE_REPL_HISTORY                               #ENVVAR (def: ~/.node_repl_history)
NODE_REPL_HISTORY_SIZE                          #Def: 1000
NODE_REPL_MODE                                  #Whether to use strict mode:
                                                #  - sloppy: never
                                                #  - magic (def): when 'use strict' specified
                                                #  - strict: always


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             DGRAM             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


createSocket(STR|OBJ[, CALLBACK(BUFFER, OBJ2)]) #Returns a DGRAM.SOCKET
                                                #OBJ:
                                                #  - type "udp4|6"
                                                #  - reuseAddr BOOL (def: false): make DGRAM.SOCKET.bind() reuse an address
                                                #    already bound
                                                #STR is OBJ.type
                                                #CALLBACK is message event handler.
DGRAM.SOCKET.address()                          #{ address, port, family }

DGRAM.SOCKET.bind(UINT[, STR][, CALLBACK()])    #Start listening to port UINT, address STR (déf: all available)
                                                #Then fires CALLBACK()
                                                #Program will block until DGRAM.SOCKET.close() is called. Can also use
                                                #DGRAM.SOCKET.[un]ref()
DGRAM.SOCKET.on("listening", CALLBACK())        #
DGRAM.SOCKET.on("message", CALLBACK(BUFFER,OBJ))#OBJ is like DGRAM.SOCKET.address(), but also with size UINT of message
DGRAM.SOCKET.close()                            #
DGRAM.SOCKET.on("close", CALLBACK())            #
DGRAM.SOCKET.on("error", CALLBACK(ERROR))

DGRAM.SOCKET.send(BUFFER, UINT, UINT2, UINT3,   #Sends to port UINT3, address STR. 
STR[, CALLBACK(ERROR, UINT4)])                  #Payload is BUFFER, from byte UINT, length UINT2
                                                #If bind() has not been called, DGRAM.SOCKET gets assigned a random port,
                                                #and an adress "0.0.0.0"
                                                #Then fires CALLBACK: UINT4 is the number of bytes sent.
                                                #Max. BUFFER size is the MTU, which must be found with PMTUD.

DGRAM.SOCKET.setBroadcast(BOOL)
DGRAM.SOCKET.setMulticastLoopback(BOOL)
DGRAM.SOCKET.add|dropMembership(STR[, STR2])    #Routing options
DGRAM.SOCKET.set[Multicast]TTL(UINT)            #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              NET              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


createServer([{ allowHalfOpen: BOOL }],[FUNC()])#Renvoie un NET.SERVER, server TCP.
                                                #FUNC is the event handler for listening.
                                                #allowHalfOpen: see ci-dessous
SERVER.listen(UINT|STR[,STR2][,UINT2][,FUNC()]) #Makes the SERVER:
                                                #  - listen to port number UINT|STR (if 0, random port).
                                                #    Can fire error event with ERROR.code "EADDRINUSE" if another process 
                                                #    already uses this port.
                                                #  - listen to HOST STR2 (déf: INADDR_ANY, i.e. any available IP on the machine
                                                #    will work)
                                                #  - UINT2 is the max number of pending connections (déf: 511, OS limits are
                                                #    determined by sysctl settings like tcp_max_backlog and somaxconn)
                                                #  - FUNC is the event hander for listening event.
                                                #Program will block until SERVER.stop() is called and close event handlers have
                                                #been called.
                                                #Can only be called once.
SERVER.listen( STR[, FUNC()] )                  #Same but by explictely creating a socket at path STR (should be in /tmp)
SERVER.listen( OBJ[, FUNC()] )                  #Same but for either { fd: UINT } (with file descriptor, not on Windows) 
                                                #or a SERVER|SOCKET.
SERVER.on( "listening", FUNC() )                #Fired when listen() is called.
SERVER.close([ FUNC() ])                        #Stops the server from accepting new connections. Keeps existing ones. When
                                                #existing ones have stopped, emits "close" event.
SERVER.on( "close", FUNC() )                    #Fired when SERVER closes (see SERVER.close())
SERVER.address()                                #Returns address (after listen() has been called) as 
                                                #{ port: UINT, address STR, family: "IPv4|6" }
SERVER.[un]ref()                                #The program will block until at least one SERVER is ref'd.
                                                #listen() call ref(), and stop() or stop event handlers call unref()

SERVER.on( "connection", FUNC(SOCKET) )         #Fired when a TCP connection is initiated.
SERVER.on( "error", FUNC( ERROR ) )             #Fired when connection problem. Will fire close event.
SERVER.maxConnections                           #Déf: null.
SERVER.getConnections([FUNC( ERROR, UINT )])    #Returns number of connections

connect|createConnection(ARGS[, FUNC()])        #Initiates a new TCP connection with ARGS:
																								#  - OBJ:
                                                #     - port UINT|STR
                                                #     - host STR
                                                #     - localAddress|localPort
                                                #     - path STR (only for UNIX sockets, only option then)
                                                #     - allowHalfOpen: see ci-dessous
                                                #     - family 4|6|null (see DNS.lookup())
                                                #     - lookup (def: DNS.lookup)
																								#  - or HOST[, PORT]
																								#  - or "HOST:PORT"
                                                #Returns a SOCKET
                                                #FUNC() is connect event handler.

SOCKET                                          #Socket of a single TCP connection
                                                #Is a IOSTREAM, with following changes:
                                                #  - no readable event, read() or unshift() (but still data event)
                                                #  - nothing about piping
                                                #  - close event handler: FUNC(BOOL): true if close because of error
                                                #  - error event handler: FUNC(ERROR)
SOCKET([OBJ])                                   #Constructor. OBJ members are:
                                                #  - fd: UINT
                                                #  - readable|writable BOOL (déf: false)
                                                #  - allowHalfOpen BOOL (déf: false): if true, when other socket closes
                                                #    connection, doesn't automatically call end(), which means:
                                                #      - can still write to it (but non-readable)
                                                #      - must manually call end()
SOCKET.connect(...)															#Same as connect(...), but ARGS cannot be OBJ
SOCKET.on( "lookup", FUNC(...) )                #Fired after hostname resoution, but before TCP connection.
                                                #Same callback as DNS.lookup()
SOCKET.on( "connect", FUNC() )                  #Used with client connections (connect()), not server (createServer())
SOCKET.bufferSize                               #Currently buffered characters. If ever growing, should use pause|resume()
SOCKET.destroy()                                #No more read|write. Only necessary when error happened.
SOCKET.setTimeout(UINT[, FUNC() ])              #Trigger a timeout event (event handler FUNC()) after UINT ms of idleness
                                                #(0 to disable (déf)), a single time.
                                                #Event handler can end() or destroy()
SOCKET.setNoDelay(BOOL)                         #If true, disable the buffering of emitting small data (to send data in chunks,
                                                #more efficient when using a lot of small requests, but can delay them)
SOCKET.setKeepAlive(BOOL, UINT)                 #Déf: false and 0.
SOCKET.address()                                #
SOCKET.[un]ref()                                #Like NET.SERVER
SOCKET.local|remotePort|Address                 #
SOCKET.bytesRead|Written                        #So far

isIp[v4|6](STR)                                 #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              TLS              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


getCiphers()                                    #All suite of SSL ciphers, as STR_ARR: AES, Camellia, DES, DH[E], ECDH[E], EDH,
                                                #IDEA, PSK, RC4, SEED, SRP

createServer(OBJ[, CALLBACK(TLSSOCKET)])        #Returns a TLS.SERVER, child of NET.SERVER.
                                                #Since it inherits from NET.SERVER, can accept TCP connections, not only SSL
                                                #ones.
                                                #All NET.SERVER will fire for both SSL and normal TCP connections.
                                                #Unless rejectUnauthorized is true, non-authorized SSL are still accepted (and
                                                #communication is encrypted), but can checked as non-authorized. 
                                                #Certificate check will follow CA chain until CA roots which are known builtin.
                                                #Authorization also check the domain in certificate is same as host being 
                                                #connected.
                                                #OBJ has members:
                                                #  - key STR|BUFFER: server private key, in PEM format
                                                #  - cert STR|BUFFER: server certificate, in PEM format
                                                #  - pfx STR|BUFFER: key+cert+ca in PFX or PKCS12 format
                                                #  - requestCert BOOL (déf: false): request authentication (with certificate)
                                                #    of other end (i.e. client)
                                                #      - rejectUnauthorized BOOL (déf: false): throw error to other end if 
                                                #        cannot authentify it.
                                                #      - ca STR_ARR|BUFFER_ARR: list of root certificates, in PEM format.
                                                #        By def., well-known root CAs. Otherwise, can be used to authorize
                                                #        self-signed certificates.
                                                #  - passphrase STR: passphrase used to decrypt the server private key
                                                #    (when a private key is encrypted)
                                                #  - crl STR[_ARR]: CRLs, in PEM format
                                                #  - secureProtocol STR: forces SSL version for client and/or server among 
                                                #    "SSLv2|3|TLSv1_[client|server_]method". No client|server means both.
                                                #    Otherwise, uses the best one accepted by client.
                                                #  - honorCipherOrder BOOL: if true (recommended, but déf: false), server will
                                                #    choose cipher preference, not client. List is designated by ciphers STR,
                                                #    which defaults to "AE128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH"
                                                #  - handshakeTimeout (déf: 120000, in ms): when timing out, emits clientError
                                                #  - NPNProtocols STR_ARR|BUFFER_ARR: list of application protocols that can
                                                #    be used, ordered by priority.
                                                #  - SNICallback CALLBACK(STR,FUNC(ERROR,OBJ)): when client asks for SNI, 
                                                #    calls CALLBACK(STR) with servername (requested hostname), which must 
                                                #    call FUNC(null, OBJ2), where OBJ2 is TLSSOCKET.secureContext
                                                #    Can also use TLS.SERVER.addContext(STR, OBJ), which adds a hostname STR, 
                                                #    with OBJ { key, cert, ca, ... }
                                                #  - sessionIdContext STR: STR concatened in front of SSL session ID.
                                                #    If requestCert is true, it is a MD5 nonce. Otherwise, it is "".
                                                #  - sessionTimeout (def: 300, in sec): expiration for TLS identifiers and 
                                                #    session tickets
                                                #  - ticketKeys BUFFER: 48 bytes divided in three 16 bytes parts: prefix, HMAC,
                                                #    AES key.
                                                #  - ecdhCurve STR (def: "prime256v1"): for ECDH
                                                #CALLBACK is the secureConnection event handler..
TLS.SERVER.on("secureConnection",               #Like SERVER.on("connection"), but for SSL.
FUNC(TLSSOCKET))                                #Only fired by SSL connections, not normal TCP ones.
TLS.SERVER.on("clientError", 
CALLBACK(ERROR, SECUREPAIR))                    #
TLS.SERVER.on("newSession", CALLBACK(ID, DATA)) #Fired when client creates new session: ID is the session ID, DATA the shared
                                                #secret.
TLS.SERVER.on("resumeSession",                  #Fired when client wants to resume a session. Must call CALLBACK2() to do so.
CALLBACK(ID, CALLBACK2(ERROR, DATA)))           #DATA is the one stored with newSession event. ERROR should be null if none.
                                                #DATA should be none if no new session.

connect(OBJ[, CALLBACK(TLSSOCKET)])             #Like TCP.connect(), but for TLS (client connection). OBJ members are:
                                                #  - host STR, port UINT
                                                #  - socket SOCKET|IOSTREAM: use an existing SOCKET (host+port can be ommitted then)
                                                #  - pfx, key, passphrase, cert, ca, rejectUnauthorized, NPNProtocols, 
                                                #    secureProtocol: like for createServer(), but for client.
                                                #    Also, rejectUnauthorized is true by def.
                                                #  - servername: for SNI, hostname to choose
                                                #CALLBACK is the secureConnect event handler
                                                #Returns a TLSSOCKET.

TLSSOCKET                                       #Like a SOCKET, but for SSL.
                                                #Contains other end's authentication status and certificate, providing
                                                #requestCert: true has been used.
new TLSSocket(SOCKET, OBJ)                      #Returns as TLSSOCKET. OBJ:
                                                #  - secureContext OBJ: returned by TLS.createSecureContext()
                                                #  - session BUFFER
                                                #  - requestOCSP BOOL (def: false): OCSP is alternative protocol to use CRL
                                                #    (ask to Certificate authority instead of using CRL list). 
                                                #    Events:
                                                #     - TLSSERVER.OCSPRequest(BUFFER, BUFFER2, FUNC(ERROR, BUFFER3)): 
                                                #       BUFFER[2] are primary|issuer DER-encoded certificates.
                                                #       BUFFER3: see just below.
                                                #     - TLSSOCKET.OCSPResponse(BUFFER3)
                                                #  - isServer BOOL
                                                #  - server SERVER
                                                #  - requestCert, rejectUnauthorized, NPNProtocols, SNICallback
TLSSOCKET.on("secureConnect", CALLBACK())       #Like SOCKET.on("connect"), but for SSL.
TLSSOCKET.getPeerCertificate()                  #Returns certificate as OBJ, with members like subject, issuer, valid_to,
                                                #fingerprint, etc.
TLSSOCKET.encrypted                             #Always true. To distinguish from SOCKET.
TLSSOCKET.authorized                            #False if certificate was not signed by CA specified in ca: STR_ARR
                                                #If false, reason might be given in TLSSOCKET.authorizationError STR
TLSSOCKET.getCipher()                           #Returns current SSL cipher used as { name STR, version STR }
TLSSOCKET.address()                             #
TLSSOCKET.local|remoteAddress|Port              #Like for SOCKET.
TLSSOCKET.npnProtocol                           #List of protocols selected among NPNProtocols (see above).
TLSSOCKET.servername                            #For SNI, chosen hostname.
TLSSOCKET.renegotiate(OBJ[,FUNC(ERROR)])        #Automatically done after session expires. OBJ: rejectUnauthorized, requestCert
TLSSOCKET.setMaxSendFragment(NUM)               #Def/Max: 16384. Min: 512. Returns true on success.
                                                #Smaller: smaller latency but slower.
TLSSOCKET.getSession()                          #Returns OBJ (ASN.1 encoded)
TLSSOCKET.getTLSTicket()                        #

createSecurePair(OBJ[, BOOL[, BOOL2[, BOOL3]]])	#Returns SECUREPAIR
																								#OBJ is TLSSOCKET.secureContext, BOOL isServer, BOOL2 requestCert, 
																								#BOOL3 rejectUnauthorized
SECUREPAIR.cleartext|encrypted									#IOSTREAM
SECUREPAIR.on("secure", FUNC())									#Like SERVER.on("connection"), but for SSL.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             HTTP              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


STATUS_CODES                                    #An OBJ with common status codes, with STR: STR2, STR being the number and 
                                                #STR2 the text
METHODS                                         #STR_ARR of HTTP methods, including "GET", "POST", "PATCH" and more obscure,
                                                #e.g. "M-SEARCH"

createServer( [FUNC] )                          #Renvoie un HTTP.SERVER, avec comme request event handler FUNC.
                                                #Enfant de NET.SERVER, except functions [un]ref(), maxConnections and 
                                                #getConnections()
SERVER.on( "request", FUNC( REQ, RES ) )        #Fired when a client starts requesting a resource from the server.
SERVER.on( "checkContinue", FUNC( REQ, RES ) )  #Fired when a client use "Expect: 100-continue" header.
                                                #If request is ok, should use RES.writeContinue() to sends a 
                                                #100 status code to the client.
SERVER.on( "connect",FUNC( REQ, SOCKET, BUFFER))#Fired when client sends an HTTP CONNECT demand.
                                                #Client's body is in BUFFER. Client's connection is in SOCKET.
SERVER.on( "upgrade",FUNC(REQ,SOCKET, BUFFER )) #Same for HTTP request with Upgrade [C].
SERVER.on( "clientError", FUNC( ERROR, SOCKET)) #Fired when connection problem.
SERVER.maxHeadersCount                          #Maximum number of headers incoming (déf: 1000, 0 for unlim)
SERVER.setTimeout(UINT[, FUNC()])               #Do setTimeout(...) on all underlying SOCKET
SERVER.timeout                                  #Def: 120000 (2 mins)

REQ                                             #Enfant d'ISTREAM (reads the body). Actually called INCOMINGMESSAGE
REQ.httpVersion                                 #
REQ.method                                      #"GET|DELETE|..." (not for CLIENTREQUEST's REQ)
REQ.url                                         #STR (not for CLIENTREQUEST's REQ)
REQ.headers                                     #As { VAR: STR ... }
REQ.rawHeaders                                  #As [ VAR_STR, STR, ... ]. As opposed to REQ.headers, VAR_STR not lowercase,
                                                #and duplicate not merged.
REQ.trailers                                    #Trailer headers OBJ
REQ.rawTrailers                                 #Same as REQ.rawHeaders, but for REQ.trailers
REQ.statusCode|Message                          #Only for CLIENTREQUEST's REQ
REQ.socket                                      #The underlying SOCKET.
REQ.setTimeout(UINT[, FUNC()])                  #Calls underlying SOCKET.setTimeout()
REQ.flush()                                     #Send the headers right away, instead of trying to send in same TCP packet 
                                                #as body.
                                                #Useful if headers are given quickly but body retrieval takes time.

RES                                             #Enfant d'OSTREAM (without piping). Actually called SERVERRESPONSE
                                                #write() et end() fill the body, not the headers, which must be written before.
                                                #Each write() sends to the client, end() only signifies it's over.
                                                #Automatically create following headers: 
                                                #  - date (if RES.sendDate true (def))
                                                #  - connection: keep-alive
                                                #  - transfer-encoding: chunked
RES.on( "close", FUNC() )                       #Fired if closed before end() was called
RES.on( "timeout", FUNC() )                     #See setTimeout()
RES.setHeader(STR, STR2[_ARR])                  #STR2 sets a single header field.
                                                #STR2_ARR: same as doing setHeader() several times.
RES.getHeader(STR)                              #
RES.removeHeader(STR)                           #
RES.writeHead( UINT[, STR][, OBJ] )             #Writes the header (must be done only once) :
                                                #  - status code UINT (déf: 200) et STR
                                                #  - OBJ sont les header fields : { STR, STR2[_ARR] }
RES.statusCode|Message                          #Setting it is another way to set status code|message.
                                                #If statusMessage not set, use STATUS_CODES[statusCode]
RES.addTrailers(OBJ)                            #Add trailing header fields, i.e. between write() and end() of the body.
                                                #Header field 'Trailer': 'STR' must be present at the beginning for each
                                                #trailing header field 'STR'.
                                                #Example of trailing header fields: checksums of data that are still
                                                #unknown at beginning of response)
RES.setTimeout(UINT[, FUNC() ])                 #For the underlying SOCKET.
RES.headersSent                                 #True if headers are sent

request(OBJ[, FUNC(REQ)])                       #Returns a CLIENTREQUEST, i.e. a request to be sent to another server.
                                                #OBJ has members:
                                                #  - host[name] STR (déf: "localhost") (prefer hostname)
                                                #    Should not start with protocol. Will fire exception if non existing.
                                                #  - port UINT (déf: 80)
                                                #  - socketPath STR: incompatible with host[name] and port
                                                #  - localAddress STR
                                                #  - method STR (déf: "GET")
                                                #  - path STR (déf: "/")
                                                #  - headers OBJ
                                                #  - auth STR: e.g. "auth:password"
                                                #  - agent: AGENT used. Can be undefined (default globalAgent), false
                                                #    (no AGENT) or AGENT.
																								#  - keepAlive[Msecs]: see AGENT below
                                                #FUNC is response event handler.
                                                #It is a OSTREAM: write to it to write body.
                                                #Use OSTREAM.end() to send request.
                                                #Content-length header is only compatible with utf8 encoding for write().
                                                #Expect: 100-continue:
                                                #  - call end() right away
                                                #  - should set a timeout
                                                #  - and listen to continue event, with event handler FUNC()
                                                #Default headers sent:
                                                #  - all: 
                                                #     host: HOST:PORT
                                                #     connection: keep-alive
                                                #  - not GET|HEAD:
                                                #     transfer-encoding: chunked
get(OBJ[, FUNC(REQ)])                           #Same but put method "GET" and automatically calls OSTREAM.end()
CLIENTREQUEST.on("socket", FUNC(SOCKET))        #Fired when socket is created to send the request.
CLIENTREQUEST.on("response",FUNC(REQ))          #Response of the server. 
                                                #REQ must be read, no matter what.
CLIENTREQUEST.on("connect|upgrade",             #Fired when server responds to a connect|upgrade demand.
FUNC(REQ, SOCKET, BUFFER) )                     #See above.
CLIENTREQUEST.abort()                           #Emits 'abort' the first time.
CLIENTREQUEST.setTimeout|NoDelay|
SocketKeepAlive(...)                            #Do it on underlying SOCKET.
CLIENTREQUEST.flushHeaders()										#Like REQ.flush()

AGENT                                           #Socket pools manager for requests (not server)
new AGENT(OBJ)                                  #OBJ is:
                                                #  - maxSockets NUM (déf: Infinity): max busy + free sockets per host.
                                                #    Increasing just affect pooling, i.e. more memory used but faster, but 
                                                #    does not affect max. number of sockets per host (unlim.)
                                                #  - maxFreeSockets NUM (def: 256): max free sockets. 
                                                #    Only relevant if keepAlive true
                                                #  - keepAlive BOOL (def: true): keep free sockets opened for use
                                                #  - keepAliveMsecs NUM (def: 1000)
AGENT.max[Free]Sockets                          #
AGENT.[free]sockets                             #Current SOCKET_ARR
AGENT.requests                                  #Current REQ_ARR, not assigned to sockets yet.
AGENT.destroy()                                 #To do to destroy free sockets if keepAliveMsecs high, to avoid hanging.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             HTTPS             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


HTTPS ==>                                       #Has exactly same members as HTTP except:
                                                #  - createServer(OBJ[, FUNC]): OBJ is same as tls.createServer()
                                                #  - all members:
                                                #      - inherit from HTTP, e.g. HTTPS.SERVER inherits HTTP.SERVER
                                                #      - use TLS.* objects instead of NET.*, e.g. TLS.SERVER instead of 
                                                #        NET.SERVER, TLSSOCKET instead of SOCKET, etc.
                                                #      - but TLS.SERVER inherits itself from NET.SERVER, so can be used as
                                                #        a HTTP server too
                                                #  - to provide TLS OBJ members (same as tls.connect(OBJ), e.g. key, cert, 
                                                #    etc.) to connect|get(...), use a custom AGENT, and provide AGENT.options


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              URL              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


parse(URL_STR[, BOOL[, BOOL2]])                 #Returns a URL_OBJ similar as WINDOW.location but:
                                                #  - no functions
                                                #  - extra members: 
                                                #     - auth: e.g. "user:password"
                                                #     - query: if BOOL false, like search but without "?". 
                                                #       Otherwise the OBJ returned by querystring.parse()
                                                #     - path: pathname + search
                                                #  - members are null if absent.
                                                #  - can use "//" instead of "PROTOCOL://", providing BOOL2 is true, or 
                                                #    USER:PASSWORD@ is in the URL. OBJ will also include member
                                                #    slashes: true|false. Protocol member will be null though.
format(URL_OBJ)                                 #Inverse. 
                                                #Trailing/leading characters are unnecessary for:
                                                #  - protocol: :
                                                #  - pathname: /
                                                #  - search: ?
                                                #  - hash: #
resolve(STR, STR2)                              #May STR be a URL with/without pathname, and STR2 a pathname, concat them,
                                                #by removing|adding "/" between them.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:          QUERYSTRING          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


stringify(OBJ[, STR[, STR2]])                   #Returns a percent-encoded GET query string for all members of OBJ as
                                                #VAR=VAL&VAR2=VAL2, etc., with separator STR (déf: "&") and STR2 (déf: "=")
parse(STR[, STR2[, STR3]][, { maxKeys: UINT }]) #Inverse. UINT is the max number of keys (déf: 1000, 0 for unlim)
[un]escape(STR)                                 #Same as en|decodeURIComponent, but can be overriden to change 
                                                #stringify|parse() behavior

QS.parse(STR[, UINT][, STR2])								    ##Node module (1.2.0). Same as QUERYSTRING except can include OBJ|ARR in query:
QS.stringify(OBJ[, STR2])						            ##  - if VAL is OBJ, VAR[KEY]=VAL&VAR[KEY2]=VAL&... instead
														                    ##  - If more depth, VAR[KEY][KEY2]...
                                                ##    Max depth is UINT (def: 5)
                                                ##  - if VAL in an OBJ is ARR, VAR[UINT]=VAL&..., or (means pushing) 
                                                ##    VAR[]=VAL&...
                                                ##    Max index is 20 (otherwise treated as an OBJ)
                                                ##    Can also create ARR_ARR or ARR_OBJ
														                    ##  - STR2 is separator (def: "&")
                                                ##  - no other extra arguments


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              DNS              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


DIFFERENCE ==>                                  #DNS.resolve*|reverse() and DNS.lookup*() are similar but:
																								#  - resolve*|reverse(): use C-Ares, a fast library for DNS resolution.
																								#    It does DNS query directly.
                                                #  - lookup*() uses getaddrinfo(), which is slower. It uses underlying OS,
																								#    i.e. how DNS resolution would behave on that system (e.g. /etc/hosts)
																								#    It is used by http.*, tcp.* and udp.* modules.
																								#Resolving manually the host can give better performance.
lookup(STR[, OBJ], CALLBACK(ERROR, STR3, STR4))	#DNS forward lookup.
                                                #STR|STR3 are host. STR4 is family: 4 (IPv4), 6 (IPv6) or null (both).
																								#OBJ:
																								#  - family 4|6|null
																								#  - hints NUM: or'd flags among:
																								#     - DNS.ADDRCONFIG
																								#     - DNS.V4MAPPED: if look for IPv6 but none found, return IPv4 mapped as
																								#       IPv6
                                                #  - all BOOL: if true (def: false), return all address as STR4_ARR, not only
                                                #    first one
                                                #The ERROR.name can correspond to several DNS.*, like DNS.NOTFOUND, 
                                                #DNS.NODATA, DNS.NOMEM, etc. (see online doc)
lookupService(IP, PORT, FUNC(HOST, PROTOCOL))		#
resolve(STR[, STR2], CALLBACK(ERROR, STR3_ARR)) #Same but STR2 can any PTR record type: "A" (déf), "AAAA", "MX", "TXT", "SRV", 
                                                #"PTR", "NS", "CNAME", "SOA"
resolveSTR2(STR, CALLBACK(ERROR, STR3_ARR))     #Same. STR2 is camelcase.
reverse(STR, CALLBACK(ERROR, STR2_ARR))         #DNS reverse lookup.

getServers()                                    #Returns list of servers IP as STR_ARR
setServers(STR_ARR)                             #Sets list of servers IP to use for DNS resolution


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           PUNYCODE            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


[ucs2.]de|encode(STR)                           #For a DNS label
toUnicode|ASCII(STR)                            #For a full domain name
version                                         #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              OS               :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


tmpdir()                                        #e.g. "/tmp"
endianness()                                    #"BE" or "LE"
hostname()                                      #e.g. "ether-laptop"
type()                                          #e.g. "Linux"
platform()                                      #e.g. "linux"
release()                                       #e.g. "3.11.0-14-generic"
arch()                                          #e.g. "x64"
uptime()                                        #DOUBLE, in seconds
loadavg()                                       #As a DOUBLE_ARR, for last 1, 5 and 15 minutes. Not for Windows.
total|freemem()                                 #RAM
cpus()                                          #OBJ_ARR, where OBJ has members:
                                                #  - model STR
                                                #  - speed UINT (MHz)
                                                #  - times OBJ, ms spent by CPU on each member since uptime: user, sys, 
                                                #    idle, nice, irq
networkInterfaces()                             #OBJ_ARR, where OBJ key is interface name ("lo", "wlan0", etc.), and contains
                                                #another OBJ_ARR, where each OBJ is an address with members address STR,
                                                #family "IPv4|6", internal BOOL (true if boucle local)
EOL                                             #"\n" or "\r\n"


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             PATH              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


PATH ==>                                        #All these functions look at PATH without caring if file exists.
normalize(STR)                                  #Remove the ".", ".." and extra "/"
join(STR...)                                    #Concat paths, by adding|removing "/" in-between, and normalize()
resolve(STR...)                                 #Like doing several cd STR from current directory (can be fictional DIR)
                                                #(STR can be relative or absolute), and returning final DIR, normalized()
relative(STR, STR2)                             #Show path to go from absolute path STR to absolute path STR2.
isAbsolute(STR)                                 #
dirname(STR)                                    #
basename(STR[, EXTENSION])                      #
extname(STR)                                    #Returns STR from first "." ("" if none)
sep                                             #"/" or "\\"
delimiter                                       #":" or ";"
parse(STR)                                      #Returns OBJ: root STR, dir STR, base STR, ext STR, name STR 
format(OBJ)                                     #Inverse

posix|win32                                     #Like PATH, but always behave like if on those platforms


																						 /=+===============================+=\
																						/  :                               :  \
							 														  )==:              FS               :==(
																						\  :_______________________________:  /
																						 \=+===============================+=/


FS-EXTRA                                       ##Replacement for FS, with extra methods.
                                               ##Version 0.16.3
                                               ##Works well with BLUEBIRD.promisifyAll(FS-EXTRA)
WRENCH                                         ##Other filesystem module, but not drop-in replacement of FS.
                                               ##Version 1.5.8

PWD ==>                                         #All relative to process.cwd()
...Sync(...)                                    #All functions have a synchronous variant, without CALLBACK, except
                                                #[un]watch[File]() and createRead|WriteStream()
                                                #Will throw exceptions instead of using ERROR.
FS-EXTRA.copy(FILE|DIR, FILE|DIR2, FUNC(ERROR))##
WRENCH.copyDirSync[Recursive]                  ##OBJ:
(FILE|DIR, FILE|DIR2[, OBJ][,FUNC(ERROR)])     ##  - forceDelete BOOL: overwrite destination
                                               ##  - excludeHiddenUnix BOOL: copy dotfiles
                                               ##  - preserveFiles BOOL: keep copy when overwriting
                                               ##  - preserveTimestamps BOOL
                                               ##  - inflateSymlinks BOOL: follow symlinks
                                               ##  - filter REGEXP|FUNC(STR)->BOOL: exclude files to copy
                                               ##  - whitelist BOOL: if true, filter works
                                               ##  - include|exclude REGEXP|FUNC(STR)->BOOL
rename(STR, STR2, CALLBACK(ERROR))      				#
FS-EXTRA.move(FILE|DIR, FILE|DIR2[, OBJ], 
FUNC(ERROR))                                   ##Can use OBJ.clobber true to overwrite.
GULP-RENAME(VAL)                               ##Rename filenames. VAL can be:
                                               ##  - FILENAME_STR (single file)
                                               ##  - OBJ: dirname STR, basename STR, prefix STR, suffix STR, extname STR 
                                               ##    (e.g. ".js")
                                               ##  - FUNC(OBJ)->OBJ, with same OBJ as above
                                               ##Version 1.2.0
[f]truncate(STR|FD_INT, UINT, CALLBACK(ERROR))  #f is with a file descriptor FD_INT
[f|l]chown(STR|FD_INT, UID, GID, CALLBACK(EROR))#l is same, but doesn't deference symlinks
WRENCH.chownSyncRecursive(DIR, UID, GID)       ##
[f|l]chmod(STR|FD_INT, UINT, CALLBACK(ERROR))   #
WRENCH.chmodSyncRecursive(DIR, UINT)           ##
[f|l]stat(STR|FD_INT, CALLBACK(ERROR, OBJ))     #OBJ has members: 
                                                #  - isFile|Directory|Block|CharacterDevice|FIFO|Socket() and
                                                #    isSymbolicLink() (only with lstat())
                                                #  - dev UINT
                                                #  - ino UINT
                                                #  - mode UINT
                                                #  - nlink UINT
                                                #  - uid|gid UINT
                                                #  - rdev UINT
                                                #  - [blk]size UINT
                                                #  - blocks UINT
                                                #  - a|m|ctime DATE
[sym]link(STR, STR2, CALLBACK(ERROR))           #
GULP-SYMLINK.relative|absolute                 ##Creates a symlink in DIR (creates it if not existing, overwrite if OBJ.force
(DIR_ARR|FUNC(VINYLOBJ)->VINYLOBJ2[,OBJ])      ##true) with same filename as current file, poiting to that file (with a 
                                               ##relative|absolute path). Version 2.0.1
readlink(STR, CALLBACK(ERROR, STR2))            #STR must be a symlink
realpath(STR[, OBJ], CALLBACK(ERROR, STR2))     #Like normalize(), but also resolve symlinks, and STR must exist.
                                                #OBJ is a cache: if STR is a key of OBJ, returns the corresponding VAL.
unlink(STR, CALLBACK(ERROR))                    #
rmdir(STR, CALLBACK(ERROR))                     #
FS-EXTRA.remove(FILE|DIR, FUNC(ERROR))         ##Like rm -rf
WRENCH.rmdirSyncRecursive(FILE|DIR[, BOOL])    ##Same. If true, fails silently.
RIMRAF(DIR|FILE[, FUNC()])		                 ##Same
                                               ##Version 2.2.8
                                               ##Also GULP-RIMRAF([OBJ]):
                                               ##  - Only makes sense after GULP-IGNORE() in the middle of the pipeline 
                                               ##    (otherwise use RIMRAF() directly).
															                 ##  - gulp.src() should use { read: false } if only GULP-IGNORE() then 
                                               ##    GULP-RIMRAF() are used, so it is faster.
															                 ##  - Must use OBJ.force true if not in $PWD
                                               ##  - Version 0.1.0
mkdir(STR[, MODE_INT], CALLBACK(ERROR))         #MODE_INT is 0777 by def
FS-EXTRA.ensureFile|Dir(FILE|DIR,FUNC(ERROR))  ##Create file|dir, including parent dirs, if not existing.
FS-EXTRA.mkdirs(DIR, FUNC(ERROR))              ##Like ensureDir()
WRENCH.mkdirSyncRecursive(DIR[, MODE_INT])
readdir(STR, CALLBACK(ERROR, STR2_ARR))         #ls: STR2_ARR are the filenames (excluding . and ..)
WRENCH.readdirSync[Recursive]
(DIR[,FUNC(ERROR, STR2_ARR)])                  ##Same but recursive
[f]utimes(STR|FD_INT, ATIME, MTIME, 
CALLBACK(ERROR))                                #Change atime|mtime
exists(STR, CALLBACK(BOOL))                     #Do only to test switch files.
                                                #Otherwise, testing for existence before doing operation can introduce 
                                                #race condition (if file has been deleted in-between).
access(PATH[, NUM], FUNC(ERROR))								#Checks if has permission, according to NUM or'd flags:
																								#  - FS.F_OK (def): files exists and its directory list it
																								#  - FS.R|W|X_OK: can be read|written|executed

open(STR, STR2[, MODE_INT],                     #Open a file and return a file descriptor.
CALLBACK(ERROR, FD_INT))                        #STR2 are flags: "r|w|a[s|x][+]":
                                                #  - r|w|a: read, write (create if not exist, or truncate), 
                                                #    append (create if not exist)
                                                #  - s: for read only. Bypass cache (synchronous mode): has bad performance
                                                #    impact.
                                                #  - x: for write|append only. Don't overwrite file. 
                                                #  - +: Open for read and writing.
                                                #MODE_INT is 0666 by def.
close(STR, CALLBACK(ERROR))                     #
write(FD_INT, BUFFER, INT, INT2, [ INT3,]				#Write INT2 bytes from BUFFER at its position INT to file FD_INT at its 
CALLBACK(ERROR, INT4, BUFFER))              		#position INT3 (def: current). 
                                                #INT4 is the number of bytes written.
write(FD_INT, BUFFER|STR[, INT3, [STR2, ]]  		#
CALLBACK(ERROR, INT4, BUFFER))              		#Similar. INT3 is position, STR2 encoding.
read(FD_INT, BUFFER, INT, INT2, INT3, 
CALLBACK(ERROR, INT4, BUFFER))                  #
fsync(FD_INT, CALLBACK(ERROR))                  #Flushes to disk

readFile(STR,[OBJ,]CALLBACK(ERROR,BUFFER|STR2)) #Easier way than using open() and read()
                                                #STR is the path. OBJ has members:
                                                #  - encoding STR (déf: null, i.e. returns BUFFER, otherwise returns STR2)
                                                #  - flag STR (déf: "r")
                                                #Prefer createReadStream(...).pipe(OSTREAM)
FS-EXTRA.readJson(...)                         ##Same as readFile(), but return as OBJ
write|appendFile(STR,[STR2|BUFER,][OBJ,]        #OBJ has same members but also mode MODE_INT (déf: 0666)
CALLBACK(ERROR))                                #Déf flag is "w|a"
FS-EXTRA.outputFile(...)                       ##Same as writeFile(), but calls ensureFile() first
FS-EXTRA.writeJson|outputJson(...)             ##Same as writeFile|outputFile(), but with an OBJ (JSON.stringify'd).
createReadStream(STR[, OBJ])                    #Returns as ISTREAM.
                                                #Preferred over readFile(). 
                                                #Useful with ISTREAM.[.pipe(IOSTREAM)...]pipe(OSTREAM):
                                                #  - transmits to OSTREAM by chunks ("data" events) instead of at once 
                                                #    (readFile())
                                                #  - can use IOSTREAM as modular transforms functions (like Unix commands)
                                                #OBJ has members:
                                                #  - flags (déf: "r")
                                                #  - encoding (déf: null)
                                                #  - fd (déf: null)
                                                #  - mode (déf: 0666)
                                                #  - autoClose (déf: true): close the file descriptor on error|end event
                                                #  - start|end UINT: only use from bytes UINT to UINT2
                                                #ISTREAM has extra:
                                                #  - event "open", with event handler FUNC(FD_INT)
                                                #  - same members as OBJ, plus path STR
                                                #  - pos UINT
createWriteStream(STR[, OBJ])                   #Same for OSTREAM. OBJ has members flags, encoding, mode and start.
                                                #OSTREAM has extra:
                                                #  - event "open", and same members as OBJ, plus path STR, fd and post
                                                #  - bytesWritten UINT
new WRENCH.LineReader(FILE)                    ##Returns LINEREADER
LINEREADER.hasNextLine()                       ##
LINEREADER.getNextLine()                       ##Returns FILE line by line
LINEREADER.close()                             ##

TEMP.open(PREFIX,FUNC(ERROR,OBJ))              ##Creates temp file with permission 0600 under temp directory.
                                               ##OBJ:
                                               ##  - path STR
                                               ##  - fd NUM
                                               ##PREFIX: 
                                               ##  - OBJ: prefix STR, suffix STR, dir DIR (def: "", "", OS temp dir)
                                               ##  - STR: only PREFIX_STR
                                               ##  - Path will be TMP_DIR/PREFIX-UUID-AFFIX
                                               ##If TEMP.track() called before, it will erase file on process exit.
                                               ##Version 0.8.1
TEMP.mkdir(PREFIX,FUNC(ERROR,PATH))            ##Same with directory
TEMP.createWriteStream()                       ##Same for file as OSTREAM
TEMP.path(PREFIX)                              ##Same for only the path
TEMP.cleanup(FUNC(ERROR,OBJ))                  ##Remove temp files. TEMP.track() must have been called before.
                                               ##OBJ: files|dirs NUM


watch(STR[, { persistent: BOOL }], FUNC)        #Returns a FSWATCHER, which fires events when file STR changes name or content.
                                                #Calls ref() (meaning program doesn't close until unwatch()), unless BOOL is
                                                #false (déf: true).
                                                #FUNC is the FSWATCHER change event handler.
                                                #Unstable. Prefer Chokidar.
FSWATCHER.close()                               #
FSWATCHER.on("change",FUNC("change|rename",STR))#STR is the filename, but is not always provided (e.g. never on MacOSX, and 
                                                #not always on other OS)
FSWATCHER.on( "error", FUNC(ERROR) )            #

CHOKIDAR.watch(FILE|DIR[, OBJ])                ##Returns WATCHER
                                               ##OBJ:
                                               ##  - persistent BOOL (def: true): like watch()
                                               ##  - ignore REGEXP or FILE|DIR_STR with globbing or FUNC(STR)->BOOL
                                               ##  - ignoreInitial (def: false): ignore initial add event
                                               ##  - followSymlinks (def: true)
                                               ##  - cwd (def: null)
                                               ##  - usePolling BOOL (def: false): if true, slower, but works over networks.
                                               ##    Also use interval NUM (def: 100) and binaryInterval (def: 300) 
                                               ##    (for binary files only)
                                               ##  - depth NUM (def: null): recursion level
                                               ##  - ignorePermissionErrors BOOL (def: false)
                                               ##  - atomic BOOL: fixes problems with editors that rewrites several times
                                               ##FILE|DIR can include blog (uses Minimatch) or be a REGEXP
                                               ##Version 1.0.0-rc3
WATCHER.on("add[Dir]|change|unlink[Dir]",FUNC(PATH, OBJ))
                                               ##OBJ is FS.stat() object, and might be absent sometimes unless CHOKIDAR.watch()
                                               ##OBJ.alwaysStat true (def: false)
WATCHER.on("all",FUNC(PATH, OBJ))              ##Check "add[Dir]|change|unlink[Dir]" events.
WATCHER.on("error",FUNC(ERROR))
WATCHER.on("ready",FUNC())
WATCHER.add|unwatch(FILE|DIR[_ARR])
WATCHER.close()                                ##Only if persistent true


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             ZLIB              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


createGzip|Deflate[Raw]([OBJ])                  #Returns a COMPRESS, i.e. a IOSTREAM, so should do:
                                                #  ISTREAM.pipe(IOSTREAM).pipe(OSTREAM)
                                                #See HTTP for different formats.
                                                #Raw: same but does not append a zlib header.
                                                #OBJ can be:
                                                #  - flush, among:
                                                #     - Z_NO_FLUSH (déf)
                                                #     - Z_PARTIAL_FLUSH
                                                #     - Z_SYNC_FLUSH
                                                #     - Z_FULL_FLUSH
                                                #     - Z_FINISH
                                                #     - Z_BLOCK
                                                #     - Z_TREES
                                                #  - chunkSize (déf: 16*1024)
                                                #  - windowBits (déf: 15): from 8 to 15, higher means better compression but 
                                                #    more memory.
                                                #  - dictionary (deflate|inflate only) (déf: "")
                                                #OBJ (compression only):
                                                #  - level: higher means better compression but slower, among:
                                                #     - Z_DEFAULT_COMPRESSION (déf)
                                                #     - Z_BEST_SPEED
                                                #     - Z_BEST_COMPRESSION
                                                #     - Z_NO_COMPRESSION
                                                #  - memLevel (déf: 8): from 1 to 9, higher means better compression but more 
                                                #    memory.
                                                #  - strategy, make compression better, according to type of data, among:
                                                #     - Z_DEFAULT_STRATEGY: almost random data, and small values
                                                #     - Z_FILTERED: in-between 
                                                #     - Z_HUFFMAN_ONLY: less random, and large repeating chunk
                                                #     - Z_RLE: same, but specially for PNG data
                                                #     - Z_FIXED
                                                #Memory required (in bytes) is:
                                                #  - for compression:
                                                #     - 2^windowBits * 4 + 2^memLevel * 512 + chunkSize, i.e. 272K by def
                                                #  - for decompression:
                                                #     - 2^windowBits + chunkSize, i.e. 48K by def
createGunzip|Inflate[Raw]|Unzip([OBJ])          #Returns an UNCOMPRESS, i.e. a IOSTREAM.
                                                #Unzip: autodetect whether Gunzip or Deflate (but not DeflateRaw).
[UN]COMPRESS.flush([NUM, ]CALLBACK(ERROR))      #Compression uses an internal cache. Flush it.
                                                #Don't call unless necessary, because it impacts performance.
                                                #NUM def is ZLIB.Z_FULL_FLUSH. See above for other values.
[UN]COMPRESS.reset()                            #Stop compressing any data going through.
                                                #Only for Deflate|Inflate
[UN]COMPRESS.params(LEVEL, STRATEGY,FUNC(ERROR))#

gzip|deflate[Raw](BUFFER|STR[, OBJ], 
CALLBACK(ERROR, BUFFER))                        #
gunzip|inflate[Raw]|unzip(BUFFER[, OBJ], 
CALLBACK(ERROR, BUFFER2))                       #Convenience methods


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            DOMAIN             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


create()                                        #Returns a DOMAIN.
                                                #A DOMAIN is like a try catch block, but:
                                                #  - catch block keeps the context (i.e. variables) of the initialization.
                                                #  - catches also error events.
                                                #  - using DOMAIN.add|remove(VAR), catches errors event when not in the 
                                                #    pseudo-"try block":
                                                #      - any VAR: catch error event, or (in a event handler) exceptions thrown
                                                #      - ID of setTimeout|Interval(): catch error event or exceptions of 
                                                #        CALLBACK
                                                #  - any CALLBACK using DOMAIN.bind(CALLBACK), which returns another CALLBACK2
                                                #      - DOMAIN.intercept(CALLBACK(ERROR[,...])): same as 
                                                #        DOMAIN.bind(CALLBACK([...])), but if ERROR != null, rethrow it 
                                                #        right away
                                                #Catch error events, not only exceptions.
DOMAIN.on("error", CALLBACK(ERROR))             #Like the catch block of try catch: pseudo-"catch block"
                                                #When catching error event from a bound VAR, ERROR has the following extra 
                                                #members:
                                                #  - domain: DOMAIN
                                                #  - domainEmitter: the bound VAR 
                                                #  - domainThrown: false if error event, true if exception
                                                #  - domainBound: CALLBACK(ERROR[,...]) when using DOMAIN.intercept()
DOMAIN.run(CALLBACK())                          #Like the try block of try catch: pseudo-"try block"
                                                #In a pseudo-"try block", domain.active is set to DOMAIN.
                                                #Can also create a pseudo-"try block" manually by using DOMAIN.enter(), 
                                                #calling sync or async functions, then doing DOMAIN.exit()

DOMAIN.members                                  #All VAR bound via DOMAIN.add(), as a OBJ_ARR
                                                #DOMAIN.add() replaces current DOMAIN if add() was already called on VAR.
DOMAIN.dispose()                                #Destroy DOMAIN.
                                                #Associated VAR are closed too: STREAM are closed, setTimeout|Interval 
                                                #reset, CALLBACK not called anymore.
                                                #Goal is to put in the DOMAIN error event handler, to avoid further
                                                #manipulation of the problematic VAR fire another error event infinitely.
DOMAIN.on("dispose", CALLBACK())                #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              TTY              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


READSTREAM                                      #Enfant de SOCKET, but without destroy(), connect event and *address*
                                                #Usually only instantiated by process.stdin
READSTREAM.isRaw                                #BOOL: raw or character device.
READSTREAM.setRawMode(BOOL)
WRITESTREAM                                     #Same but for process.stdout|err for example.
WRITESTREAM.columns|rows                        #UINT
WRITESTREAM.on("resize", CALLBACK())            #

isatty(FD_INT)                                  #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            PROCESS            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


process                                         #Don't need to use require("process").

on("exit", CALLBACK(INT))                       #INT is the exit code. process.exitCode is same, except undefined if 
                                                #process.exit() not called explicitely.
                                                #CALLBACK should only use synchronous functions.
on("beforeExit", FUNC(INT))                     #Fired when programs finishes because no more code, not because explicit 
                                                #return/exception/process.exit()
on("uncaughtException", FUNC(ERROR))						#Prefer using DOMAIN
on('rejectionHandled, FUNC(PROMISE))            #On PROMISE rejected but handled.
on('unhandledRejection, FUNC(VAL, PROMISE))     #On PROMISE rejected and not handled.
exit([UINT])                                    #Exit with exit code UINT (déf: 0)
abort()                                         #Aborts: exits + produce a core file.

pid                                             #
kill(PID_INT[, SIGNAL_STR])                     #Sends a signal (déf: "SIGTERM").
                                                #If PID_INT, doesn't exit, throw exception (can use SIGNAL_STR 0 to just test
                                                #process existence).
on(SIGNAL_STR, CALLBACK())                      #Fires when signal emitted on current process. Special cases:
                                                #  - "SIGUSR1" will start debugger
                                                #  - handling SIGINT or SIGTERM will remove default handler.
                                                #  - cannot handle SIGKILL or SIGSTOP
																								#  - SIGWINCH: when window resized

stdout|err|in                                   #OSTREAM|ISTREAM with extra member:
                                                #  - isTTY BOOL: if true, will be a READ|WRITESTREAM
                                                #And those members for ISTREAM :
                                                #Unless used as a pipe, are blocking (unless other STREAM which are async by
                                                #def).
argv                                            #Command line args as STR_ARR. Doesn't include node options.
                                                #First is "node", second the absolute path of FILE, then the other arguments.
execArgv                                        #Same but only for node options (exclude all STR of argv)
execPath                                        #Absolute path of node executable used.
env                                             #Environment variables, as OBJ
title                                           #Process title displayed in ps. Read/write. Usually short max length.

cwd()                                           #Current directory
chdir(STR)                                      #

get[e]gid|[e]uid()                              #
set[e]gid|[e]uid(UINT|STR)                      #
getgroups()
setgroups(STR_ARR)                              #Supplementary GIDs.
initgroups(STR, STR2[_ARR])                     #
umask([UINT])                                   #

version                                         #
versions                                        #OBJ with members http_parser, node, v8, ares, uv, zlib, modules, openssl
config                                          #Config flags and variables used during compilation, as OBJ
arch                                            #"arm", "ia32" or "x64"
platform                                        #"darwin", "freebsd", "linux", "sunos" or "win32"

memoryUsage()                                   #Returns OBJ with members rss, heapTotal and heapUsed
uptime()                                        #
hrtime()                                        #Current time as [UINT, UINT2], where UINT is seconds and UINT2 nanoseconds.
                                                #Not real time, but arbitrary one just to compare with another time check.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:        CHILD_PROCESS          :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


spawn(STR[, STR2_ARR], OBJ)                     #Creates, runs and return a CHILDPROCESS, from command line STR, with 
                                                #args STR2_ARR.
                                                #OBJ (should be at least {}) are options among:
                                                #  - cwd STR
                                                #  - env OBJ (déf: process.env)
                                                #  - uid|gid UINT
                                                #  - detached BOOL: if true, becomes leader a new process group, i.e. will
                                                #    not exit when parent does. Must not inherit any file descriptor from 
                                                #    parent.
                                                #  - stdio STR_ARR, how parent can access child's file descriptors 
                                                #    (at least first three ones, stdin|out|err, but can continue with
                                                #    fd 3, etc.) among:
                                                #      - "pipe": enable CHILDPROCESS.stdio[FD_INT]|stdin|out|err
                                                #      - "ipc": enable CHILDPROCESS.send()
                                                #        Can only do it for one file descriptor.
                                                #        send() is synchronous. For large data prefer "pipe".
                                                #      - "ignore": with nothing
                                                #      - STREAM: use the underlying file descriptor (like doing NUM> FILE)
                                                #      - FD_INT: use parent file descriptor FD_INT (like doing NUM&>FD_INT)
                                                #      - null: "pipe" for stdin|out|err, "ignore" for others.
                                                #    Can use the following shortcuts STR instead:
                                                #      - "ignore": [ "ignore", "ignore", "ignore" ]
                                                #      - "pipe": [ "pipe", "pipe", "pipe" ]
                                                #      - "inherit": [ 0, 1, 2 ]
                                                #Use CHILDPROCESS.ref(), so needs to use unref() if program can exit while
                                                #CHILDPROCESS is running.
spawnSync(...)                                  #Same except:
                                                #  - extra arguments:
                                                #     - input STR: overrides stdio[0]
                                                #     - timeout, killSignal, maxBuffer, encoding: see exec()
                                                #  - waits for completion and returns:
                                                #     - pid UINT
                                                #     - output STR_ARR
                                                #     - stdout|err BUFFER|STR: same as output[1|2]
                                                #     - status NUM
                                                #     - signal STR
                                                #     - error ERROR
fork(STR[, STR2_ARR], OBJ)                      #Same as spawn(), but:
                                                #  - for a file STR. Use: 
                                                #     - execPath STR: déf is "node", so STR is a JavaScript node.js file,
                                                #       but could use Bash, Python, etc.
                                                #     - execArgv STR_ARR to pass arguments.
                                                #  - OBJ options are cwd, env, encoding, execPath, execArgv, uid|gid and:
                                                #     - silent BOOL: if true use "pipe" stdio, otherwise "inherit" (def)
                                                #       In all cases, send() is available.
                                                #Sets ENVVAR NODE_CHANNEL_FD, which is a file descriptor that I don't 
                                                #understand how to use.
                                                #Can consume quite a lot of resources.
exec(STR, OBJ, CALLBACK(ERROR,BUFFER,BUFFER2))  #Same as spawn() but current process becomes CHILDPROCESS (which is returned) 
                                                #and:
                                                #  - STR is command line, including arguments
                                                #  - when terminated, fires CALLBACK where BUFFER[2] is stdout|err
                                                #  - OBJ have members:
                                                #     - cwd STR
                                                #     - env OBJ
                                                #     - uid|gid UINT
                                                #     - encoding STR (déf: "utf8")
                                                #     - timeout UINT (déf: 0): if > 0, will send killSignal after UINT ms
                                                #     - killSignal STR (déf: "SIGTERM")
                                                #     - maxBuffer UINT (déf: 200KB): killSignal if more is used
                                                #     - shell STR (def: "/bin/sh")
execSync(STR[, OBJ])                            #Same but:
                                                #  - extra argument: input STR|BUFFER (overrides stdio[0])
                                                #  - returns BUFFER|STR (result stdout)
execFile(STR[, STR2_ARR], OBJ, CALLBACK(...))   #Same but specifies a file STR, and arguments STR2_ARR.
execFileSync(STR[, STR2_ARR][, OBJ])            #
execSync(STR[, OBJ])                           ##Same as native execSync() (module sync-exec 0.5.0) but:
                                               ##  - works on Node 0.10
                                               ##  - returns OBJ2.stdout|stderr|status
execSync.exec|run(STR)                         ##Same as native execSync() (module execSync, 1.0.4) but:
                                               ##  - not maintained, does not work on Node 0.12
                                               ##  - exec()->EXIT_NUM, run()->OBJ.code|stdout

CHILDPROCESS.stdio[FD_INT]                      #I|OSTREAM for file descriptor FD_INT
CHILDPROCESS.stdin|out|err                      #Same for 0|1|2
CHILDPROCESS.pid                                #
CHILDPROCESS.send(VAL[,SOCKET|NET.SERVER])      #Communication:
                                                #  - parent use CHILDPROCESS.on("message") and CHILDPROCESS.send()
                                                #  - child use process.on("message") and process.send()
                                                #When sending a SOCKET|NET.SERVER, it will be shared between parent and child
                                                #(packets will arrive randomly at both).
CHILDPROCESS.on("message",
CALLBACK(OBJ[,SOCKET|NET.SERVER]))              #CHILDPROCESS will not exit until disconnect() is called or parent exits.
CHILDPROCESS.disconnect()                       #Flush all communication, then becomes impossible to do send()
                                                #Do it before exiting.
CHILDPROCESS.connected                          #
CHILDPROCESS.on("disconnect", CALLBACK())       #
CHILDPROCESS.on("error", CALLBACK(ERROR))       #When CHILDPROCESS could not send(), be kill() or be spawn()
                                                #The exit event might be fired or not after error event.
CHILDPROCESS.on("exit|close",CALLBACK(UINT,STR))#UINT is the exit code, STR the terminating signal (or null).
                                                #exit is when process exits, close is when its file descriptors are closed.
                                                #file descriptors don't close if shared by other processes.
CHILDPROCESS.kill([STR])                        #Déf: "SIGTERM"


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            CLUSTER            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


GOAL ==>                                        #A single process will only use only one CPU core.
                                                #Using CHILDPROCESS.fork() on the same code to create one child for each CPU
                                                #core.
                                                #Can manage the workers: kill some, manage a pool, etc.
                                                #Work should be done by child processes, master should only manage them.
                                                #Child processes cannot fork() to grandchild processes.
                                                #One common task is to make CHILDPROCESS SERVER.listen(), in which case:
                                                #  - connections will arrive randomly at the child processes listening to
                                                #    the same port.
                                                #    The randomness uses CLUSTER.schedulingPolicy:
                                                #      - CLUSTER.SCHED_RR (def): improved round-robin
                                                #      - CLUSTER.SCHED_NONE: previous version
                                                #    or use ENVVAR NODE_CLUSTER_SCHED_POLICY "rr|none"
                                                #  - be careful:
                                                #     - listen(SERVER|SOCKET): SERVER|SOCKET must have been sent by master
                                                #       to child, or will create problems
                                                #     - listen({ fd: INT }): looks at parent file descriptor
fork([OBJ])                                     #Like child_process.fork(), but returns a WORKER, which gives extra functions.
                                                #Can fork a separate file for children, but if forking the same file, should
                                                #use if ( cluster.isMaster|Worker ) in beginning of code.
                                                #OBJ is env (déf: process.env).
                                                #Options are controlled by CLUSTER.settings, that is available for read once
                                                #cluster.setupMaster(OBJ) has been called to change it (only once):
                                                #  - exec STR: the file the child is forked with (déf: process.argv[1])
                                                #  - args STR (déf: process.argv.slice(2)): to worker
                                                #  - execArgv STR_ARR (déf: process.execArgv): to node
                                                #  - silent BOOL: like CHILDPROCESS.fork() (déf: false)
                                                #  - uid|gid UINT
                                                #setupMaster() fire the setup event (event handler: CALLBACK())
on("fork|online", CALLBACK(WORKER))             #Fired when a child process is created|ready to respond.
WORKER.on("online", CALLBACK())                 #
on("listening", CALLBACK(WORKER, OBJ))          #Fired when a child process use SERVER.listen(). 
                                                #OBJ has members { address, port, addressType: "[udp]4|6|-1(Unix socket)" }
WORKER.on("listening", CALLBACK(OBJ))           #

workers                                         #All WORKER in an OBJ, where the key is the WORKER.id
                                                #Only available in parent process.
worker                                          #Current WORKER. Only available in child processes.
WORKER.id                                       #
WORKER.process                                  #The underlying CHILDPROCESS.
                                                #In a WORKER, can use process.* directly

WORKER.send(VAL[,SOCKET|NET.SERVER])            #
WORKER.on("message",
CALLBACK(OBJ[,SOCKET|NET.SERVER]))              #
WORKER.kill([STR])                              #Calls WORKER.disconnect(), then in:
                                                #  - the parent, sends signal (déf: "SIGTERM")
                                                #  - the child processes, exit with error code 0

WORKER.disconnect()                             #If listen() was called, don't accept new connections and emit SERVER.close()
                                                #when no more connections (only server connections, not CLIENTREQUEST, that
                                                #are closed directly).
                                                #Might be useful to use a timeout to kill the WORKER if connections keep on
                                                #living.
disconnect(CALLBACK())                          #Call disconnect() on all child processes (must be done from parent).
on("disconnect", CALLBACK(WORKER))              #Fired when a child process use disconnect()
WORKER.on("disconnect", CALLBACK())             #
WORKER.isConnected()                            #
WORKER.isDead()                                 #True if exited of thrown exception
WORKER.suicide                                  #When WORKER exits, will be false if exited because of an exception, and true
                                                #if because of kill() or disconnect()
on("exit", CALLBACK(WORKER, UINT, STR))         #Fired when a child process exits.
                                                #UINT is the exit code, STR the signal (null if none).
WORKER.on("exit", CALLBACK(UINT, STR))          #
WORKER.on("error", CALLBACK(ERROR))             #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:              VM               :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


VM.createContext([OBJ4])                        #Returns a COBJ, i.e. an OBJ with some hidden properties.
VM.isContext(OBJ)                               #Returns true if COBJ
 
runInContext(STR, COBJ[, OBJ2])                 #Like eval() but use context COBJ as unique global environment: 
                                                #  - passed by reference.
                                                #  - does not have any other access to caller otherwise, including current 
                                                #    caller local scope
                                                #Also:
                                                #  - use current process:
                                                #     - same file descriptors
                                                #     - throw exception in current process
                                                #     - sould create a new process first if VM used for security reason.
                                                #  - returns synchronous return value from code STR, but can still inspect
                                                #    COBJ passed by reference for async return value, or pass COBJ.FUNC()
                                                #OBJ2:
                                                #  - filename STR: for stack trace error message
                                                #  - displayErrors BOOL (def: true): prints to current stderr any stderr from
                                                #    code
                                                #  - timeout NUM: throw error if timeout
runInNewContext(STR[, OBJ4][, OBJ2])            #Same but automatically use VM.createContext(OBJ4)
runInThisContext(STR[, OBJ2])                   #Same as runInNewContext(STR, global)

new VM.Script(STR[, OBJ2])                      #Returns a SCRIPT, i.e. a compiled version of STR:
                                                #  - can call SCRIPT.run*(...): same as VM.run*(STR, ...) but delayed
                                                #    Every SCRIPT.run*(...) can be bound to different COBJ.
                                                #  - OBJ2 does not include: 
                                                #     - timeout in new VM.Script()
                                                #     - filename in SCRIPT.run*(...)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            CRYPTO             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


setEngine(PATH[, NUM])                          #When using custom OpenSSL or alternative crypto library.
                                                #NUM are or'd flags: ENGINE_METHOD_ALL|RSA|DSA|DH|RAND|ECDH|ECDSA|CIPHERS|
                                                #DIGESTS|STORE|PKEY_[ASN1_]METH|NONE

createHash(STR)                                 #Returns a HASH, i.e. a IOSTREAM generator: write|read to it to get hashes.
                                                #STR is the algo. 
                                                #CRYPTO.getHashes() gives list of supported hashes algos, as STR_ARR:
                                                #includes [EC]DSA, DSS1, MD4|5, RIPEMD, RMD, SHA1|224|256|384|512, Whirlpool
createHmac(STR, BUFFER|STR2)                    #Same but for a HMAC. STR is hash algo. Second argument is the key.
createCipher(STR, BUFFER|STR2)                  #Same but for a CIPHER (sym. cipher). Key must be BUFFER or STR with encoding
                                                #"binary". If there is an IV, it is derived from the key.
                                                #CRYPTO.getCiphers() gives list of supported sym. ciphers (including mode of 
                                                #operation), as STR_ARR: includes AES, Blowfish, Camellia, CAST, DES, DES3, 
                                                #DES-X, IDEA, RC2, RC4, SEED.
createCipheriv(STR, BUFFER|STR2, BUFFER2|STR3)  #Same but IV is specified in third argument, not derived from key.
CIPHER.setAutoPadding(BOOL)                     #If false (déf: true), disables padding (PKCS padding).
                                                #Use it for personalized padding, i.e. filling with nulls.
CIPHER.getAuthTag()                             #Returns MAC as BUFFER, for sym. ciphers that produce one ("authenticated
                                                #encryption"), i.e. "GCM" only.
CIPHER.setAAD(BUFFER)                           #Same but for "additional authenticated data" ("GCM" only)
createDecipher[iv](...)
DECIPHER.setAutoPadding(BOOL)                   #Same for decryption.
DECIPHER.setAuthTag(BUFFER)                     #
DECIPHER.setAAD(BUFFER)                         #

createDiffieHellman(ARGS)                       #Creates a DIFFIEHELLMAN (used for asym. encryption with HL algo).
                                                #ARGS can be:
                                                #  - NUM[, NUM2]: prime length NUM and generator NUM2 (def: 2).
                                                #  - STR|BUFFER[, ENCODING][, NUM|STR|BUFFER2[, ENCODING2]]: prime STR|BUFFER 
                                                #    (def ENCODING: "buffer", can also be "binary|base64") and generator 
                                                #    NUM|STR|BUFFER2 (def: 2)
DIFFIEHELLMAN.getPrime([ENCODING])              #
DIFFIEHELLMAN.getGenerator([ENCODING])          #
DIFFIEHELLMAN.generateKeys([ENCODING])          #Creates private and public key, and returns public key.
DIFFIEHELLMAN.getPublic|PrivateKey([ENCODING])  #
DIFFIEHELLMAN.setPublic|PrivateKey(STR|BUFFER,
[ENCODING])                                     #
DIFFIEHELLMAN.computeSecret(STR|BUFFER          #Creates shared secret by using current private key and other part public key
[, ENCODING][, ENCODING2])                      #STR|BUFFER (must have used the same prime and generator)
                                                #ENCODING is other part public key encoding, ENCODING2 shared secret returned.
DIFFIEHELLMAN.verifyError                       #Or'd flags showing warning after initialization among: 
                                                #  - CRYPTO.DH_CHECK_P_NOT_SAFE_PRIME
                                                #  - CRYPTO.DH_CHECK_NOT_PRIME
                                                #  - CRYPTO.DH_UNABLE_TO_CHECK_GENERATOR
                                                #  - CRYPTO.DH_NOT_SUITABLE_GENERATOR
getDiffieHellman(STR)                           #Returns a DIFFIEHELLMAN but:
                                                #  - without setPublic|PrivateKey()
                                                #  - according to STR "modp1|2|5|14|15|16|17|18", i.e. prime is constant, but
                                                #    it is faster

createECDH(CURVE_STR)														#Returns ECDH, elliptic curve version of Diffie-Hellman. 
																								#Same as DIFFIEHELLMAN but:
																								#  - last arg FORMAT "[un]compressed|hybrid" (def: "uncompressed") to
																								#    generateKeys() and getPublicKeys()
																								#  - no getPrime(), getGenerator() nor verifyError
																								
public|privateEncrypt|Decrypt(STR|OBJ, BUFFER)  #Encrypts/decrypts asym. (RSA) BUFFER, with private|public key STR|OBJ:
																								#  - key STR: PEM format
																								#  - passphrase STR (decoding only)
																								#  - padding: CRYPTO.constants.RSA_NO|PKCS1[_OAEP]_PADDING
																								
createSign(STR)                                 #Same as createDecipher() but for signing algo STR. 
                                                #List can be found with openssl list-public-key-algorithms. 
                                                #Includes RSA, DH, DSA, HMAC and CMAC.
                                                #Unless createCipher(), is only a OSTREAM. To read from it, use 
                                                #SIGN.sign(BUFFER|STR[, ENCODING]), where BUFFER|STR is the private key.
createVerify(STR)                               #Same for verifying algo STR.
                                                #Like createSign(), is only a OSTREAM. To read from it, use 
                                                #VERIFY.verify(STR, STR2|BUFFER[, ENCODING]), where STR is a certificate or
                                                #a RSA|DSA public key in PEM format, and STR2|BUFFER the signature.

Certificate()                                   #Returns CERTIFICATE, used for SPKAC, used to send certificates client-side to 
                                                #the server with the HTML5 <keygen>.
CERTIFICATE.verifySpkac(BUFFER)                 #Returns BOOL
CERTIFICATE.exportChallenge|PublicKey
(STR|BUFFER[, ENCODING])                        #Returns BUFFER

pbkdf2(STR|BUFFER, STR2|BUFFER2, NUM, NUM2,     #Generate a random BUFFER using PBKDF2 with HMAC-SHA1, with first arg being
[DIGEST, ]CALLBACK(ERROR, BUFFER))              #the input, second the salt (should be min. 64 bits), NUM the number of 
                                                #iterations (should be min. 1000) and NUM2 the final string length.
pbkdf2Sync(STR|BUFFER, STR2|BUFFER2, NUM, NUM2  
[, DIGEST])                                     #Same but synchronous (returns BUFFER).
[pseudoR|r]andomBytes(NUM[,CALBACK(EROR,BUFER)])#Generates random BUFFER of length NUM  
                                                #Is either cryptographically secure (randomBytes, like from /dev/random) or
                                                #not (pseudoRandomBytes, like from /dev/urandom)
                                                #If no CALLBACK, synchronous (returns BUFFER)

																								
																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            ASSERT             :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


ASSERT		                                      #Throws ASSERTIONERROR with message STR (default messages provided) if fails.
                                                #ASSERTIONERROR have members message STR, actual|expected VAL, operator STR
ASSERT.fail(VAL, VAL2, STR, STR2)		            #Throws ASSERTIONERROR({ message: STR, actual: VAL, expected: VAL2, 
                                                #operator: STR2 })
ASSERT[.ok](BOOL[, STR])		                    #Checks BOOL is true
ASSERT.[not][Deep|Strict]e|Equal(VAL,VAL2[,STR])#  - equal is == 
                                                #  - strictEqual === 
                                                #  - deepEqual for objects (doesn't compare prototypes)
ASSERT.throws|doesNotThrow(FUNC()
[, ERROR|FUNC(ERROR)|REGEXP][, STR])	          #
ASSERT.ifError(ERROR)		                        #


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:             UTIL              :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


inspect(VAL[, OBJ])                             #Print function used by repl. Returns as STR.
                                                #OBJ members are:
                                                #  - showHidden BOOL: if false (déf), doesn't show non-enumerable properties
                                                #  - depth NUM (déf: 2): max recursion (null for infinite)
                                                #  - colors BOOL (déf: false)
                                                #  - customInspect BOOL: if true (déf), will call VAL.inspect(UINT)
                                                #    (UINT is depth, and it returns STR) if it exists
                                                #require("buffer").INSPECT_MAX_BYTES: number of bytes printed for BUFFER 
                                                #(déf: 50)
inspect.colors                                  #OBJ with members defining colors. styles points category (e.g. number) to
inspect.styles                                  #color category, and colors point color category to color codes.

format(STR[, STR2...])                          #Printf-like FUNC, STR can contain "%s" (STR), "%d" (NUM) or "%j" (JSON)
puts(STR...)                                    #Same as console.log(), but put newline between each STR
print(STR...)                                   #Same as console.log(), but don't put anything between each STR
error(STR...)                                   #Same as puts() but to stderr
debug(STR...)                                   #Same as puts() but prepends "DEBUG: "
log(STR)                                        #Same as puts(STR), but prepends a timestamp

debuglog(STR)                                   #Returns FUNC() that works like console.error() except:
                                                #  - appends STR
                                                #  - noop unless envvar NODE_DEBUG "STR2,..." includes STR 

deprecate(FUNC(...), STR)											  #Same as console.log(STR); FUNC(...), but influenced by Node options:
																								#  --no-deprecation: does not console.log()
                                                #  --trace-deprecation: console.trace() instead of console.log()
																								#  --throw-deprecation: throws
																								
isArray|RegExp|Date|Error(VAL)                  #

inherits(TYPE_FUNC, TYPEPARENT_FUNC)            #Makes TYPE inherits from TYPEPARENT, i.e. executes:
                                                #  TYPE.prototype = Object.create(TYPEPARENT.prototype)
                                                #  TYPE.prototype.constructor = TYPE
                                                #Also creates a TYPE.super_ that points to TYPEPARENT
                                                #Since it does not use OBJ in Object.create(), needs to create own static 
                                                #members with TYPE.prototype.VAR = VAL
