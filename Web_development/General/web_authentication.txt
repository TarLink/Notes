
                        
   WEB_AUTHENTICATION   
                        


Cookie Authentication:
  - credentials are remembered in a cookie. Good for normal browsing.
	- client POST username+password, server sends back an ID cookie
	- logout: erase cookie

HTTP Authentication:
  - client sends credentials with each request. 
	- Good for APIs:
	   - Request can be made from another domain (as opposed to cookies)
		 - stateless
  - Browser behavior:
     - prompt end-user for crendentials if none supplied
     - ask if want to remember password
     - can use http://user:password@HOST:PORT/PATH to tell browser to add [Proxy-]Authorization header
  - Status codes:
     - 403 (Forbidden)
     - 511 (Network Authentication required): sent by proxy for authentication pb
     - 419 (Authentication timeout)
     - 429 (Too many requests)
	- Basic|Digest: 
	   - usually successful login set a cookie with username + password, to avoid asking at each page (by def cached by browsers)
		 - logout: fires an AJAX request with wrong credentials, which would get a 401|407 response 
		   (request must have same realm and same path as login page)
		 - realm represents a set of pages that share authentication credentials
	- Basic:
	   - 401|407 WWW-Authenticate: Basic realm="REALM",... [S]
        - 407 is for Proxy-Authorization
		 - [Proxy-]Authorization: Basic BASE64_USERNAME:PASSWORD [C]
	- Digest:
	   - 401|407 WWW-Authenticate: Digest VAR="VAL",... [S]
		    - realm="REALM": like Basic Authentication
				- qop="auth[, auth-int]": different algorithms let to client (optional)
				- algorithm="MD5[-sess]": same but for different part of algo (optional)
				- nonce="RANDOM_ALNUM": server-side nonce. Prevents building rainbow tables.
				- opaque="RANDOM_ALNUM", domain="DOMAIN": used to pass state information around during the process (optional).
		 - [Proxy-]Authorization: Digest VAR="VAL",... [C]:
		    - retake same VAR="VAL" as response (chooses gop|algorithm too)
				- username="USERNAME"
				- response="HASHED_PASSWORD"
				- uri="URI": must match first request URL
				- cnonce="RANDOM_ALNUM", nc="NUM": (if gop="auth-int"):
   				  - if Mallory can simulate Bob (not case if SSL), prevents him to build random tables using unique server nonce,
						  then guessing plaintext password from HASHED_PASSWORD
						- cnonce is the client nonce. nc is incrementing at each client request, keeping initial cnonce (allow reusing
						  same cnonce during a whole session)
		 - HASHED_PASSWORD: MD5(MD5(HA1):NONCE[:NC:CNONCE:QOP]:MD5(HTTPMETHOD:URI[:MD5(BODY)])):
				- HA1:
					 - if algorithm="MD5", MD5(USERNAME:REALM:PASSWORD)
					 - if algorithm="MD5-sess", MD5(MD5(USERNAME:REALM:PASSWORD):NONCE:CNONCE)
				- ":NC:CNONCE:QOP": if qop="auth[-int]". Prevents replay
				- ":MD5(BODY)": if qop="auth-int". Provides message integrity of BODY
	- Hawk:
	   - similar to Digest, but more secure and only one round trip. But too new to try.
  - HTTPS with client authentication:
     - requires client to create a certificate
     - should be used anyway with other authentication for confidentialy and integrity

Token-based Authentication:
  - client sends credentials, server replies with a temp authentication token.
	- same advantage as HTTP Authentication, but expose less the credentials
	- often a temp token is sent back
	- Bearer token:
	   - First client gets a TOKEN using another auth. method, then use Bearer token for the lifetime of TOKEN
	   - 401|407 WWW-Authenticate: Bearer VAR="VAL" [S]:
		    - realm="REALM": like HTTP Basic Auth. (only one required)
				- scope="SCOPE": sub-realm
				- error[_description|uri]="ERROR" (not for first round)
		 - [Proxy-]Authorization: Bearer TOKEN
		    - can also use access_token as POST|GET variable

Federated authentication/authorization:		 
  - Federated authentication:
		 - Delegates authentication to Trent:
	      - instead of Alice authenticating to Bob
		    - Alice authenticates to Trent
		    - Then many Bobs can ask Trent if Alice is authenticated (actually ask Alice to ask Trent)
	   - Goal: single login
	   - Roles:
	      - End-user / Resource owner (RO) (Alice)
		    - Relying party (RP) / client (Bob)
		    - OpenID Provider (OP) / Resource Server (RS) (Trent)
	- Federated authorization:
		 - instead of Alice authorizing Bob to do X
		 - Alice authorizes Trent to authorize many Bobs to do X (actually Bob ask Alice to hand over the authorization from Trent)
  - Pseudo-federated authentication:
	   - Bob assume that if Trent has authentication from Alice, it must have verified it was Alice, 
		   so authorization => authentication
	- OpenID:
	   - Federated authentication, token-based
	- Oz:
	   - Federated authentication, but wait too new to try
	- OAuth (see doc):
	   - Federated authorization, token-based 
	- OpenID Connect:
     - OAuth-based pseudo-federated authentication
