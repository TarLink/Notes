
                  
   WEB SECURITY   
                  


Code injection :
  - injecting code where data is expecting
  - problem is wrong assumption data
    - won't exceed size or min/max (buffer overflow)
      - pervention :
        - bound checking (including in most programming languages, but not C/C++ pointers)
    - won't include special characters/type (XSS, SQL injections, etc.)
      - prevention :
        - refusing input :
          - of a certain type : validation
          - of a certain user/domain : same origin policy, CSP
        - accepting input but changing it :
          - escaping/sanatirizing
    - will be legitimous or can't be modified by client
  - types :
    - XSS (cross-site scripting) :
      - injecting JavaScript code (usually <script>) to client in DOMAIN, so that script executes in DOMAIN context (e.g. to
        steal DOMAIN login cookies) 
         -> abuse user trust in DOMAIN, by manipulating DOMAIN data
      - types :
        - active vs passive :
          - active/persistent/stored : code written on server (static)
          - passive/not persistent/reflected : displayed dynamically only for that client
        - server-side (traditional) vs client-side (DOM-based)
      - ex : 
        - reading blog/forum post, with websites allowing HTML in post
        - eval(STR) et variantes (setTimeout|Interval(STR), Function(STR))
    - CSRF|XSRF (Cross-site request forgery)
      - inject URL (with side-effect) request in an element (JavaScript, image, etc.), while user is logged in to URL DOMAIN
         -> abuse URL's DOMAIN trust in user, by manipulating user behavior
      - types:
         - login CSRF: side-effect is logging to a website using attacker's credentials, so that activity on website can be
           retrieved later by attacker
      - solutions for URL request with side-effects:
         - can force providing login credentials, even if already logged in
         - can include secret information only known by client, e.g. a hash with salt of authentication data.
      - example on JSON:
         - visiting DOMAIN1/URL return a secret JSON while logged in
         - DOMAIN2 can get secret JSON by downloading it as JSONP and changing Array constructor:
             <script>var secrets; Array = function() { secrets = this; };</script>
             <script src="DOMAIN1/URL" type="text/javascript">
         - solution: server prefix JSON with exactly ")]}',\n", and client strips it.
    - SQL injection :
      - inject SQL command as argument of another SQL command (which was expecting STR/NUM/etc.)
      - by POST/GET variables to server
    - Header injection:
      - Header response splitting:
         - inserting a \r\n\r\n in header value (then rest is response|request body)
      - Location [C] redirections
      - Set-Cookie [C]
    - PHP injection 
    - ASP injection
    - Shell injection
    - Buffer overflow

Same origin policy :
  - browser enforce same origin (i.e. same protocol, port and domain (subdomain interdits)) :
    - DATATRANSFER (drag&drop et copier/coller) (programmatically, not with browser default action for selection, links and
      images)
    - IFRAME.*
    - XHR.open()
    - @font-face { src: URL } (Firefox only)
    - WebGL textures and Canvas images
    - many HTTP methods (PUT, DELETE, TRACE, CONNECT... but not GET/POST)
  - exception :
    - embedding :
      - href et src attributes (link, img, video, audio, script, object, iframe, etc.)
      - any URL/IMAGE in CSS (except @font-face)
    - sending (not receiving) :
      - links : <a href="URL">, using WINDOW.location, WINDOW.open(), HISTORY, etc.
      - <form action="URL">
    - WebSocket
  - conclusion : generally (apart @font-face), applies to JavaScript URLs, but not CSS or HTML URLs
  - circumventing :
    - CORS:
       - client:
          - goal is not to respect same origin policy, providing server allows CORS request
          - headers automatically by browsers when not same origin
       - server:
          - should allow resources only to some clients (according to Origin). Usually not HTML but images, scripts, etc.
          - example that works : http://remysharp.com/demo/cors.php
       - how:
          - first step is skipped if:
             - GET|POST|HEAD
             - Content-Type: "application/x-www-urlencoded", "multipart/form-data" or "text/plain"
             - only HTTP headers: Accept, Accept-Language, Content-Language, Last-Event-ID, Content-Type
          - first step "preflight request":
             - client (OPTIONS method):
                - Origin: URL [C] 
                - Access-Control-Request-Method: METHOD [C]
                - Access-Control-Request-Headers: HEADER,... [C]
                - Must use XHR.withCredentials true if want to send HTTP auth., cookies or client-side SSL certificates
             - server (status code 204):
                - Access-Control-Allow-Origin: URL [S]
                - Access-Control-Allow-Method: METHOD,... [S]
                - Access-Control-Allow-Headers: HEADER,... [S]
					      - Access-Control-Allow-Credentials: true [S] (not allowed if Access-Control-Allow-Origin: *)
                - Access-Control-Max-Age: NUM [S], how many seconds client should cache preflight response
                - Access-Control-Expose-Headers: HEADER,... [S]: 
                   - by default, client should not show to end-user other headers than:
                       Content-Type, Cache-Control, Content-Language, Expires, Pragma, Last-Modified
                   - can specify other to show with HEADER,...
          - second step:
             - Origin: URL [C], then Access-Control-Allow-Origin: URL [S] (can be *, but avoid it)
    - postMessage() (for communication with IFRAME)
    - changing document.domain (only for communication between a.b.com and c.b.com) :
      - put both to b.com
      - put port number to null, so if between a.b.com and b.com, do document.domain = document.domain for b.com, so port
        number becomes null

CSP (Content Security Policy) :
  - same origin policy still allows potential threat (XSS) :
    - instead of pointing to other website, injecting code (<script>, links) to website itself, e.g. a <script> which src
      points to another domain (not affected by same origin policy)
  - Content-Security-Policy: TYPE-src STR...;[...;] [sandbox;][report-uri STR] [S] 
     - restrict TYPE resources to STR
     - TYPE can be : 
       - default : default STR... for all TYPE (sinon "*")
       - script : <script>
       - connect : XHR.open(), WebSocket(), EventSource() (server-sent event)
       - font : @font-face
       - frame : <iframe>
       - image : <img>
       - media : <audio>, <video>, <source>, <track>
       - object : <object>
       - style : <style>, but not CSS <link>
     - STR is space-separated list
     - STR can be :
       - [PROTOCOL:][DOMAIN[:PORT][/PATH]]
         - wildcard * accept, but if DOMAIN, only in beginning of DOMAIN, and followed by "." or "/"
       - special values :
         - 'self' : same origin
         - 'none' : completly disabled
         - 'unsafe-inline|eval' : using CSP bans HTML-inline JavaScript and CSS and eval() (and the like :
           setTimeout|Interval(STR), Function(STR), etc.), unless using this
     - STR is not quoted, except special values (single-quoted)
     - only one occurence for a given TYPE
     - sandbox gives same restrictions as in a <iframe sandbox>
     - report-uri will:
        - POST - URL everytime a client sees attempts to circumvent CSP rules.
        - use Content-Type: "application/csp-report" and JSON body:
           - csp-report:
              - document-uri URL (origin)
              - blocked-uri
              - referrer URL
              - violated-directive, e.g. "img-src STR"
              - original-policy (full directive)
              - status-code
  - Content-Security-Policy-Report-Only: ... [S]: same but only sends reports via report-uri. 
    Used to test first before deploying.
  - CSP 1.1 features :
    - instead of HTTP headers, using HTML tags :
      - <meta http-equiv="Content-Security-Policy" content="...">, same as Content-Security-Policy: ...
      - others less interesting (JavaScript manipulation, etc.)
  - browser implementation
    - not by IE10
    - X-Webkit-CSP instead of Content-Security-Policy for Safari 7
    - <meta> only by Chrome

Typosquatting/URL hijacking:
  - creating similar URLs as well-known websites, but with typos/mistakes, similar word (e.g. plural) or different top-level
  - can also normal register URL if not used yet
  - can also use Unicode characters almost identical, thanks to IDNA
  - goal: selling it, redirecting to competitor, phishing, getting traffic, etc.

Clickjacking:
  - DOMAIN2 put DOMAIN in an <iframe> to make end-user work on DOMAIN while believing he is on DOMAIN2
  - X-Frame-Options: WORD [S] tells the client that the served page should:
     - deny: not be in an <[i]frame>
		 - sameorigin: only if same origin
		 - allow-from DOMAIN: only if DOMAIN (can be several, or with sameorigin)

HTTPS:
  - Strict-Transport-Security: max-age=VAL[; includeSubDomains] [S]:
     - goal:
        - redirects visitors visiting the domain using HTTP to using HTTPS instead, for a specific period of time (in seconds)
        - does not allow visiting HTTPS page if certificate not ok
		 - Must be supplied over HTTPS, so:
        - does not work if initial connection is HTTP, or in the time window when max-age expired. 
        - However, some browsers include a preloaded list of browsers using this header.
		 - Prevents SSL-stripping (man-in-the-middle attacks that convert request from https to http).
															
Sniffing:
  - Can use X-Powered-By [S] so should not be used

IE-specific:
  - X-XSS-Protection: 1; mode=block [S]: same goal as CSP but browser-specific. Also for Chrome.
  - X-Download-Options: noopen [S]: 
     - don't open automatically content on Content-Disposition [S]
     - could execute JavaScript code in current context otherwise
  - X-Content-Type-Options: nosniff [S]:
     - disables IE "MIME sniffing" feature, which would allow an attacker to inject JavaScript code in a file that looks like 
       another type.

Flash-specific:
  - Adobe products like Flash asks for /crossdomain.xml (if exists) as a policy file.

Other headers:
  - Allow: HTTP_METHOD... [S], if problem sends 405 (Method not allowed)
