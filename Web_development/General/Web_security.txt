
                  
   WEB SECURITY   
                  


Code injection :
  - injecting code where data is expecting
  - problem is wrong assumption data
    - won't exceed size or min/max (buffer overflow)
      - pervention :
        - bound checking (including in most programming languages, but not C/C++ pointers)
    - won't include special characters/type (XSS, SQL injections, etc.)
      - prevention :
        - refusing input :
          - of a certain type : validation
          - of a certain user/domain : same origin policy, CSP
        - accepting input but changing it :
          - escaping/sanatirizing
    - will be legitimous or can't be modified by client
  - types :
    - XSS (cross-site scripting) :
      - injecting JavaScript code (usually <script>) to client in DOMAIN, so that script executes in DOMAIN context (e.g. to
        steal DOMAIN login cookies) 
         -> abuse user trust in DOMAIN, by manipulating DOMAIN data
      - types :
        - active vs passive :
          - active/persistent/stored : code written on server (static)
          - passive/not persistent/reflected : displayed dynamically only for that client
        - server-side (traditional) vs client-side (DOM-based)
      - ex : 
        - reading blog/forum post, with websites allowing HTML in post
        - eval(STR) et variantes (setTimeout|Interval(STR), Function(STR))
    - SQL injection :
      - inject SQL command as argument of another SQL command (which was expecting STR/NUM/etc.)
      - by POST/GET variables to server
    - Header injection:
      - Header response splitting:
         - inserting a \r\n\r\n in header value (then rest is response|request body)
      - Location [C] redirections
      - Set-Cookie [C]
    - PHP injection 
    - ASP injection
    - Shell injection
    - Buffer overflow
    - URI template injection

CSRF|XSRF (Cross-site request forgery):
  - steps:
     - in a first context (page 'ORIGIN'), requests to ORIGIN creates confidential state (e.g. cookie authentication)
     - in a second context (page 'ORIGIN2'), requests to ORIGIN reuses that state
  - abuse ORIGIN trust in user, by manipulating user behavior
  - types:
     - login CSRF: CSRF requests with logging side-effect
  - preventions:
     - not keeping confidential state client-side 
        - e.g. never caching login credentials
     - same origin policy:
        - covers XHRs, IFRAME.*
        - but does not cover: 
           - GET requests using <any href|src>: must avoid GET with side-effects (makes this problem worst)
           - POST requests using <form> 
     - CSRF token:
        - unpredictable secret information sent together with ORIGIN's confidential state
           - e.g. hash with salt of authentication data
        - used to authenticate further requests to ORIGIN
  - example on JSON:
     - visiting DOMAIN1/URL return a secret JSON while logged in
     - DOMAIN2 can get secret JSON by downloading it as JSONP and changing Array constructor:
         <script>var secrets; Array = function() { secrets = this; };</script>
         <script src="DOMAIN1/URL" type="text/javascript">
     - solution: server prefix JSON with exactly ")]}',\n", and client strips it.

Same origin policy (SOP):
  - origin null???
  - Origin [C] with several ORIGIN (if request processed by several ORIGIN) ???
  - with file: ???
  - with data: ???
  - subresources should have same origin as parent resource, providing they can read|write parent resource
     - exact same HOST, including for subdomains
  - browsers behavior:
     - enforced because can read|write parent resource:
       - XHR
       - IFRAME.*
       - DATATRANSFER (drag&drop, cut/paste)
          - programmatically only, not with browser default action for selection, links and images
     - enforced for obscure reasons:
       - @font-face { src: URL } (Firefox only)
       - WebGL textures  
       - Canvas images
     - not enforced for historical reasons:
       - <form action="URL">
     - not enforced because Origin [C] always sent, so check must be done server-side
       - WebSocket
     - not enforced because embedded context:
       - <link href="URL">
       - <script|img|input|video|audio|source|iframe src="URL">
       - any URI in CSS (except @font-face)
     - not enforced because changes context:
       - links: <a|area|base href="URL">, LOCATION, HISTORY, WINDOW.open|alert()
  - circumventing :
    - CORS:
       - client:
          - goal is not to respect same origin policy, providing server allows CORS request
          - headers automatically by browsers when not same origin
       - server:
          - should allow resources only to some clients (according to Origin). Usually not HTML but images, scripts, etc.
          - example that works : http://remysharp.com/demo/cors.php
       - how:
          - first step is skipped if:
             - GET|POST|HEAD
             - Content-Type: "application/x-www-urlencoded", "multipart/form-data" or "text/plain"
             - only HTTP headers: Accept, Accept-Language, Content-Language, Last-Event-ID, Content-Type
          - first step "preflight request":
             - client (OPTIONS method):
                - Origin: URL [C] 
                - Access-Control-Request-Method: METHOD [C]
                - Access-Control-Request-Headers: HEADER,... [C]
                - Must use XHR.withCredentials true if want to send HTTP auth., cookies or client-side SSL certificates
             - server (status code 204):
                - Access-Control-Allow-Origin: URL [S]
                - Access-Control-Allow-Method: METHOD,... [S]
                - Access-Control-Allow-Headers: HEADER,... [S]
					      - Access-Control-Allow-Credentials: true [S] (not allowed if Access-Control-Allow-Origin: *)
                - Access-Control-Max-Age: NUM [S], how many seconds client should cache preflight response
                - Access-Control-Expose-Headers: HEADER,... [S]: 
                   - by default, client should not show to end-user other headers than:
                       Content-Type, Cache-Control, Content-Language, Expires, Pragma, Last-Modified
                   - can specify other to show with HEADER,...
          - second step:
             - Origin: URL [C], then Access-Control-Allow-Origin: URL [S] (can be *, but avoid it)
    - postMessage() (for communication with IFRAME)
    - changing document.domain (only for communication between a.b.com and c.b.com) :
      - put both to b.com
      - put port number to null, so if between a.b.com and b.com, do document.domain = document.domain for b.com, so port
        number becomes null

CSP (Content Security Policy) :
  - same origin policy still allows potential threat (XSS) :
    - instead of pointing to other website, injecting code (<script>, links) to website itself, e.g. a <script> which src
      points to another domain (not affected by same origin policy)
  - Content-Security-Policy: TYPE-src STR...;[...;] [sandbox;][report-uri STR] [S] 
     - restrict TYPE resources to STR
     - TYPE can be : 
       - default : default STR... for all TYPE (sinon "*")
       - script : <script>
       - connect : XHR.open(), WebSocket(), EventSource() (server-sent event)
       - font : @font-face
       - frame : <iframe>
       - image : <img>
       - media : <audio>, <video>, <source>, <track>
       - object : <object>
       - style : <style>, but not CSS <link>
     - STR is space-separated list
     - STR can be :
       - [PROTOCOL:][DOMAIN[:PORT][/PATH]]
         - wildcard * accept, but if DOMAIN, only in beginning of DOMAIN, and followed by "." or "/"
       - special values :
         - 'self' : same origin
         - 'none' : completly disabled
         - 'unsafe-inline|eval' : using CSP bans HTML-inline JavaScript and CSS and eval() (and the like :
           setTimeout|Interval(STR), Function(STR), etc.), unless using this
     - STR is not quoted, except special values (single-quoted)
     - only one occurence for a given TYPE
     - sandbox gives same restrictions as in a <iframe sandbox>
     - report-uri will:
        - POST - URL everytime a client sees attempts to circumvent CSP rules.
        - use Content-Type: "application/csp-report" and JSON body:
           - csp-report:
              - document-uri URL (origin)
              - blocked-uri
              - referrer URL
              - violated-directive, e.g. "img-src STR"
              - original-policy (full directive)
              - status-code
  - Content-Security-Policy-Report-Only: ... [S]: same but only sends reports via report-uri. 
    Used to test first before deploying.
  - CSP 1.1 features :
    - instead of HTTP headers, using HTML tags :
      - <meta http-equiv="Content-Security-Policy" content="...">, same as Content-Security-Policy: ...
      - others less interesting (JavaScript manipulation, etc.)
  - browser implementation
    - not by IE10
    - X-Webkit-CSP instead of Content-Security-Policy for Safari 7
    - <meta> only by Chrome

URI:
  - only location:
     - does not provide resource|provider authentication:
        - URI are transient. E.g. someone can buy out a domain name.
        - control can be stolen
     - does not guarantee security of resource it locates
  - URI spoofing:
     - creating one that looks the same (see typosquatting)
     - making USERINFO look like HOSTNAME|PATH
  - confidentiality:
     - knowing one URI gives hints or other possible sibling URIs:
        - unless random IDs or authorization are used
     - using USERINFO as plaintext, e.g. USER:PASSWORD

Typosquatting/URL hijacking:
  - creating similar URLs as well-known websites, but with typos/mistakes, similar word (e.g. plural) or different top-level
  - can also normal register URL if not used yet
  - can also use Unicode characters almost identical, thanks to IRI or IDNA
  - goal: selling it, redirecting to competitor, phishing, getting traffic, etc.

Clickjacking:
  - DOMAIN2 put DOMAIN in an <iframe|frame|object|embed> to make end-user work on DOMAIN while believing he is on DOMAIN2
  - defenses:
     - CSP2 frame-ancestors:
        - best but not supported by all browsers
        - when X-Frame-Options specified, frame-ancestors is ignored by Chrome/Firefox (although RFC says inverse)
     - X-Frame-Options: WORD [S]:
        - tells the client that the served page should deny being in an <iframe|frame|object|embed>:
           - deny: never
           - sameorigin: only if parent has same origin
           - allow-from DOMAIN: 
              - only if top-level from DOMAIN
              - not supported by Safari/Chrome/Opera
     - ensure before doing sensitive actions that WINDOW.top === WINDOW
     - WINDOW.confirm() before doing sensitive actions (popup cannot be framed)

HTTPS: see HTTPS doc
															
Sniffing:
  - Can use X-Powered-By [S] so should not be used

IE-specific:
  - X-XSS-Protection: 1; mode=block [S]: same goal as CSP but browser-specific. Also for Chrome.
  - X-Download-Options: noopen [S]: 
     - don't open automatically content on Content-Disposition [S]
     - could execute JavaScript code in current context otherwise
  - X-Content-Type-Options: nosniff [S]:
     - disables IE "MIME sniffing" feature, which would allow an attacker to inject JavaScript code in a file that looks like 
       another type.

Flash-specific:
  - Adobe products like Flash asks for /crossdomain.xml (if exists) as a policy file.

Cache attack:
  - steps:
     - Alice write confidential information, then cached/stored
     - Mallory takes control of Alice's device
     - Mallory read cached confidential information
  - examples:
     - accessing someone else device then browsing to logged in websites
     - use authentication URL with cached authentication headers
  - solution:
     - do not cache/store confidential information, or for shorter time
     - use no-cache="HEADER" for confidential headers, no caching for confidential body

Cookies:
  - cannot rely only on cookies for authorization, must also use anti-CSRF measures
  - content should be encrypted (for confidentiality) and signed (for authenticity) even over HTTPS
  - should use secure and HttpOnly
  - content should contain key (to server-side hash table, e.g. session id) not direct information
  - service on same URL but different port can access cookie
  - service on same domain or superdomain can set cookies

Open redirect:
  - redirection that depends on user-generated content in URLs
     - allowing user-generated URLs has same risk as well
  - if not validated, allows user to browse to different website without consent
     - can lead to phishing
