
          
   REST   
          



Do not expose database schemas as is, provide abstraction layer in-between

Proper authorization

Use right HTTP method (see HTTP doc)

Compatibility
  - (see compatiblity doc):
     - provide backward compatibility
     - provide forward compatibility
     - use versioning (changelog, semver)
     - introduce breaking changes in stages
  - version:
     - put in URL, not in headers (simpler for consumer)

Monitoring|logging:
  - analytics:
     - including to deprecated endpoints|parameters

URL:
  - root URL should be short|simple, e.g.:
     - https://api.DOMAIN/vNUM/
        - pros:
           - better security-wise, with same-origin policy
           - easier with the tools that think DOMAIN-wise
     - https://DOMAIN/api/vNUM/
        - pros: easier to setup

/COLLS[/ID]:
  - should avoid subcolls (/COLLS/ID/SUBCOLLS/ID), use inter-resources links only instead:
      - more flexible to change
      - allow consumers to define own schemas
      - can replace filtering by query e.g. ?coll=ID 
  - RES_ARR:
      - collection|array|list with each item having its id as attribute, as opposed to object|map with id as key

ID:
  - always use attribute id, unique and used in URI
  - if possible, provide also unique human-friendly attribute name STR, which can be used in URI instead of id
  - use UUID (or similar), as it allows client to create new id

Naming:
  - COLLS plural
  - not too generic
  - easy to understand for non-native speakers 
  - attributes underscored
  - path names dasherized 

Usual methods (see HTTP doc for more details):
  - GET|HEAD /COLLS -> RES_ARR
  - POST /COLLS -> RES (non-idempotent, e.g. create)
  - PUT /COLLS/ID -> RES (idempotent, e.g. update|upsert)
  - PATCH /COLLS/ID -> RES
     - can just send subsets 
     - or define patch operations (e.g. how JSON patch does)
  - DELETE /COLLS/ID -> {}
  - DELETE /COLLS -> {} (dangerous)
  - OPTIONS

Upsert:
  - can force update semantics with If-Match [C] or insert semantics with If-None-Match [C]

Usual query (usually for GET|HEAD): 
  - pagination:
      - offset-based (limit|offset=NUM, or Range [C], Accept-Ranges [S])
      - cursor-based (page_size=NUM + page_token=CURSOR|"" -> total_size NUM + next_page_token CURSOR|"")
      - both can be communicated through Link: <URL>; rel="first|last|prev|next|self" [S]
  - filtering (ATTR=VAL, query|filter=OBJ)
  - selecting (fields=ATTR[(SUBATTR2,...)],...)
  - sorting (sort_by|order_by=ATTR[ asc|desc],..., order=asc|desc)
  - views (server-predefined query) (view=VIEW)
  - populating:
     - return non-populated as child: { id ID } instead of child_id ID as it allows populated response to look more similar
  - aggregating
  - logical order: populating, filtering, sorting, aggregating, paginating, selecting

Usual mutation parameters:
  - dry-run (validate_only=true)

Right status codes, including:
  - 201 (after POST creation or PUT|PATCH creation on upsert), with Location [S]
  - 202 (async): can be [not] requested by Expected [C], and denied expectation rejected by 417
  - 204 (after DELETE)
  - 206: range request
  - 400 (bad input), 422
  - 401
  - 403
  - 404
  - 405 (wrong method)
  - 414
  - 429 (rate limiting)
  - 500

Authentication

Content type:
  - usually JSON, sometimes YAML, XML, HTML (for humans, e.g. <table>)
  - MIME should be:
     - application/x-collection|resource+json|yaml|xml or text/html
     - application/vnd.VENDOR+json|yaml|xml or text/html
  - should be independent, with content negotiation:
     - input: can accept several types, using Content-Type [C]
     - output: can accept several types, using Accept [C]

Hypermedia/HATEOAS:
  - client discover URLs endpoints at runtime:
      - no need to know beforehand
      - can change URLs without breaking compatibility
  - how:
     - root URL gives:
         - list of possible resources/collections
         - list of versions
         - list of features
     - each resource give links to others:
         - each resource (including subresource) has its own URL as attribute (e.g. href|self attribute)
         - each subresource has its link type, related to parent, as attribute (e.g. link attribute)
             - example link types: collection/COLL, resource/RES
         - can render only href+link, and let client populate, follow or neither
         - can also use Link [S]
  - self-documentation:
     - OPTIONS -> Allow [S]: allowed methods
     - OPTIONS -> Link: <DOC_URI>; rel="help"
  - self-describing resources:
     - contains their type as attribute (e.g. _type "TYPE", or !TYPE in YAML)

Documentation:
  - do not truncate examples
  - response codes, error messages
  - API console for experimentation
  - type, allowed values|chars|regexp
  - value constraints|validation
  - default value
  - example value
  - value units (e.g. milliseconds)
  - idempotency 
  - side effects 
  - authentication
  - versioning
  - example of client code in different codes (including CLI)

Errors:
  - status NUM (HTTP status code)
  - type|code STR (generic identifier)
  - code NUM (generic identifier)
  - innererror OBJ (recursive sub-OBJ, for precendent exceptions)
  - message STR: no i18n (makes it harder to debug)
  - more_info|url URL
  - target STR (object)
  - details STR (debug info, e.g. stack trace)
  - custom info, for specific error code
  - everything might be enclosed in error attribute, e.g. { error: { status ... } }

Protocol-independent:
  - not only HTTP
  - example: WebSocket

Input|output transformation layer:
  - from|to REST API consumers, to decouple (view layer)
  - from|to backend|database, to decouple (model layer)
      - should decouple, e.g. one REST API entity might merge several databases entities 

RPC/actions:
  - try to avoid, but sometimes REST makes no sense for some type of action/resource
  - should use /ACTION or /actions/ACTION
  - should use method that hast best semantics, but generally is POST
  - e.g.:
      - API status, monitoring
      - rate limits

Self-documentation, API description/discovery:
  - can be:
     - using top-level for all resources
     - per-resource, as a linked resource
  - includes input description (name, type, constraints, etc.), output, invariant, etc.

Common entity attributes:
  - description STR
  - start|end_time TIMESTAMP

Undelete behavior:
  - use DELETE as normal, but updates attribute deleted BOOL instead
  - not shown by queries, except if query parameter show_deleted BOOL

Should denote typing with suffix to attributes:
  - *_hours|mins|seconds|millis|micros|nanos NUM
  - *_date|time DATE|DATETIME
  - *_bytes|width_pixels|height_pixels
  - *_count

Time:
  - timestamp ISO8601 YYYY-MM-DDTHH:MM:SSZ
  - specify timezone: default one, with possibly allowing customizing per request

Idempotency/retries:
  - can be achieved with non-idempotent methods by:
      - including unique ID in request
      - returning cached response if matches a previous request ID

Compatibility:
  - use proper versioning, e.g. semver
  - version in header not URL:
      - Accept: TYPE; version=NUM [C]
  - types:
      - source compatiblity: code written against older version can compile to new version
      - binary compatibility: code written to run (including being linked) against old version can still be run
      - wire compatibility: code written to communicate against older version can still communicate
      - semantic compatiblity: new version does not break semantics
  - usually backward-compatible: adding things (collections, resources, request|response attributes)
     - providing consumers ignore unknown fields (should be documented)
     - providing consumers ignore fields ordering (should be documented)
  - usually backward-incompatible: removing things, changing things (while not keeping old behavior)
  - describe stability of endpoints: experimental, dev, stable, locked

Middleware:
  - clear division in input|output stages 

Input:
  - URI: for identity only
      - avoid: versioning prefix, query variables
  - request body: for contents
  - headers, query variable: for parameters, metadata (prefer headers)

Security:
  - HTTPS only, no redirect
  - CORS

Observability:
  - use request|response_id for [distributed] logging
  - create|update|delete_time, created|updated|deleted_at TIMESTAMP 

Performance:
  - use caching
  - use content range, streaming

Rate limiting:
  - return with each response as header, e.g. RateLimit-Remaining [S]

Go through HTTP doc: should support eveything there

Principle of autorest:
  - easy: 
      - fast|easy to deploy and maintain
      - declarative
      - convention over configuration
  - flexible:
      - agnostic to:
          - database (SQL, document-oriented, key-value store, realtime)
          - ORM itself (Waterline, etc.)
          - declarative file (Swagger, API blueprint, RAML)
          - protocol (HTTP, WebSocket)
          - input|output format (JSON, YAML, XML, HTML)
          - IDL (REST, GraphQL, JSON-RPC)
          - framework (Express, Koa, restify)
          - programming language (JavaScript, Go, etc.): do core in Node.js and only allow limited flexibility in programming languages, i.e. must be based on that core? E.g. for validation layer, do not pass raw request|response but abstracted function with abstracted input
          - each layer (validation, authorization, etc.) is wrapped by abstraction layer to allow for different core modules
          - logging
          - monitoring
      - modular, pluggable
      - does not dictate usage or semantics
  - open:
      - standard-driven
      - open-source
      
Async:
  - can:
      - keep status in an attribute of same model, e.g. status
      - return status in response
      - return status, as separate "operation" [sub]resource
  - status attributes:
      - status: at least not_started, running, succeeded, error, but potentially more 
      - created_time
      - updated_time
      - percent_complete FLOAT
      - resource_location: target resource
  - might allow cancelling, e.g. DELETE "operation" resource
  - client either:
      - poll, e.g. Retry-After [C]
      - wait for push (including web hooks)
  - too long running operations should become tombstones, i.e. cannot be queried but are still persisted for debug
