
        
   REST  
        



Compatibility
  - versioning can be put in either:
     - URL: https://DOMAIN/vNUM/
     - header: Accept: TYPE; version=NUM [C]
  - general (see compatiblity doc, this is summary):
     - provide forward compatibility
     - use versioning (changelog, semver)
     - introduce breaking changes in stages
     - document stability level
     - use support branches
  - can:
    - use redirects

Observability:
  - analytics:
     - including to deprecated endpoints|parameters
     - create[d]|update[d]|delete[d]_time|at TIMESTAMP
  - logging:
     - use request|response_id

URL:
  - root URL should be short|simple, e.g.:
     - https://api.DOMAIN/
        - better security-wise, with same-origin policy
        - easier with the tools that think DOMAIN-wise
     - https://DOMAIN/api/
        - easier to setup
  - /COLLS[/ID]

Resource relations:
  - subcolls:
    - /COLLS/ID/SUBCOLLS/ID
    - should avoid, use inter-resources links only instead:
      - more flexible to change
      - allow consumers to define own schemas
      - can replace filtering by query e.g. ?coll=ID

Decoupling:
  - protocol-independent: not only HTTP (e.g. WebSocket)
  - transformation layers:
    - from|to REST API consumers (view layer)
    - from|to backend|database (model layer)
  - use middleware: clear division in input|output stages
  - content negotiation:
     - input: can accept several types, using Content-Type [C]
     - output: can accept several types, using Accept [C]

Input|output:
  - content type:
    - usually JSON, sometimes YAML, XML, HTML (for humans, e.g. <table>)
    - MIME can be:
       - application/x-collection|resource+json|yaml|xml or text/html
       - application/vnd.VENDOR+json|yaml|xml or text/html
  - input:
    - URI: for identity only
       - avoid: versioning prefix, query variables
    - request body: for contents
    - headers, query variable: for parameters, metadata (prefer headers)

ID:
  - always use attribute id, unique and used in URI
  - if possible, provide also unique human-friendly attribute name STR, which can be used in URI instead of id
  - use UUID (or similar), as it allows client to create new id
  - RES_ARR should be array of items with id as attribute, as opposed to object with id as key

Naming:
  - COLLS plural
  - not too generic, but easy to understand for non-native speakers
  - attributes underscored, path names dasherized

Semantics:
  - methods:
     - GET|HEAD /COLLS -> RES_ARR
     - POST /COLLS -> RES (non-idempotent, e.g. create)
     - PUT /COLLS/ID -> RES (idempotent, e.g. update|upsert)
     - PATCH /COLLS/ID -> RES
        - can just send subsets (e.g. how JSON merge patch works)
        - or define patch operations (e.g. how JSON patch does)
     - DELETE /COLLS/ID -> {}
     - DELETE /COLLS -> {} (dangerous)
     - OPTIONS
  - should allow X-HTTP-Method-Override
  - upsert:
    - can force update semantics with If-Match [C] or insert semantics with If-None-Match [C]
  - undelete behavior:
    - use DELETE as normal, but updates attribute deleted BOOL instead
    - not shown by queries, except if query parameter show_deleted BOOL
  - status codes: see HTTP doc

Concurrency:
  - idempotency|retries:
    - can be achieved with non-idempotent methods by:
       - including unique ID in request
       - returning cached response if matches a previous request ID
  - see HTTP doc for conflicts resolution

Parameters:
  - usual query (usually for GET|HEAD):
    - pagination:
       - offset-based (limit|offset=NUM, or Range [C], Accept-Ranges [S])
       - cursor-based (page_size=NUM + page_token=CURSOR|"" -> total_size NUM + next_page_token CURSOR|"")
       - both can be communicated through Link: <URL>; rel="first|last|prev|next|self" [S]
    - filtering (ATTR=VAL, query|filter=OBJ)
    - selecting (fields=ATTR[(SUBATTR2,...)],...)
    - sorting (sort_by|order_by=ATTR[ asc|desc],..., order=asc|desc)
    - views (server-predefined query) (view=VIEW)
    - populating:
       - return non-populated as child: { id ID } instead of child_id ID as it allows populated response to look more similar
    - aggregating
    - logical order: populating, filtering, sorting, aggregating, paginating, selecting
  - less usual query:
    - i18n (see HTTP doc)
    - datetime (see HTTP doc)
  - usual mutation parameters:
    - dry-run (validate_only=true)

Security:
  - Authentication
  - Authorization
  - Rate limiting:
    - return with each response as header, e.g. RateLimit-Remaining [S]
  - Timeout
  - HTTPS only, no redirect
  - CORS

Hypermedia/HATEOAS:
  - client discover URLs endpoints at runtime:
     - no need to know beforehand
     - can change URLs without breaking compatibility
  - how:
     - root URL gives:
        - list of possible resources/collections
        - list of versions
        - list of features
     - each resource give links to others:
        - each resource (including subresource) has its own URL as attribute (e.g. href|self attribute)
        - each subresource has its link type, related to parent, as attribute (e.g. link attribute)
           - example link types: collection/COLL, resource/RES
        - can render only href+link, and let client populate, follow or neither
        - can also use Link [S]
  - self-documentation:
     - OPTIONS -> Allow [S]: allowed methods
     - OPTIONS -> Link: <DOC_URI>; rel="help"
     - any other way to get same info as documentation, using HATEOAS principle
  - self-describing resources:
     - contains their type as attribute (e.g. _type "TYPE", or !TYPE in YAML)

Documentation:
  - document:
    - response codes
    - error messages
    - type
    - allowed values|chars|regexp
    - value constraints|validation
    - default value
    - example value
    - value units (e.g. milliseconds)
    - idempotency
    - side effects
    - authentication
    - versioning
  - provide:
    - API console for experimentation
    - example of client code in different codes (including CLI)
  - do not truncate examples

Errors:
  - content:
    (standard "application/problem+json|xml"):
    - status NUM (HTTP status code)
    - type 'URI' (generic identifier)
    - title|description STR (short|long): no i18n (makes it harder to debug)
    - instance 'URI' (object)
    (non standard)
    - code NUM (generic identifier)
    - innererror OBJ (recursive sub-OBJ, for precendent exceptions)
    - more_info|url URL
    - details STR (debug info, e.g. stack trace)
    - custom info, for specific error code
  - status code: see HTTP doc
  - everything might be enclosed in error attribute, e.g. { error: { status ... } }
  - should validate input

RPC/actions:
  - try to avoid, but sometimes REST makes no sense for some type of action/resource
  - should use /ACTION or /actions/ACTION
  - should use method that hast best semantics, but generally is POST
  - e.g.:
     - API status, monitoring
     - rate limits

Async:
  - can:
     - keep status in an attribute of same model, e.g. status
     - return status in response
     - return status, as separate "operation" [sub]resource
  - status attributes:
     - status: at least not_started, running, succeeded, error, but potentially more
     - created_time
     - updated_time
     - percent_complete FLOAT
     - resource_location: target resource
  - might allow cancelling, e.g. DELETE "operation" resource
  - client either:
     - poll, e.g. Retry-After [C]
     - wait for push (including web hooks)
  - too long running operations should become tombstones, i.e. cannot be queried but are still persisted for debug

Types:
  - time:
    - timestamp ISO8601 YYYY-MM-DDTHH:MM:SSZ
    - specify timezone: default one, with possibly allowing customizing per request
  - should denote typing with suffix to attributes:
    - *_hours|mins|seconds|millis|micros|nanos NUM
    - *_date|time DATE|DATETIME
    - *_bytes|width_pixels|height_pixels
    - *_count

Performance:
  - use caching
  - use byte serving
  - use compression
  - use delta encoding
  - use prefetching, server push
  - send header before body
  - use partial body, empty body
  - use stream prioritization

Realtime:
  - see HTTP doc
