
                    
   PATH-TO-REGEXP   
                    



VERSION ==>                       #1.7.0
                                  #Parses Express-style 'PATH' into regexp
                                  #Can contain :VAR, * (catch-all) and quantifiers * ? +
                                  #Can also reverse parse, e.g. '/path/:var' + {var: val} -> '/path/val'


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            CONCEPT            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


PATH_STR                          #Can contain:
                                  #  - :VAR, with [:alnum:]_
                                  #  - (...), simple parenthesis group
                                  #  - *, "catch all", but not after :VAR nor (...)
                                  #  - quantifier * ? or + following :VAR or (...)
                                  #     - * and + do not stop at delimiters
                                  #The first three are path "tokens"
                                  #E.g. '/my/path/:var/:varb+/*/try(this)?'
                                  #OPTS:
                                  #  - sensitive BOOL (def: false): case insensitive
                                  #  - strict BOOL (def: false): optional trailing slash
                                  #  - end BOOL (def: true): must match until end. Always match from beginning
                                  #  - delimiter STR (def: '/')

PATH_REGEXP                       #REGEXP where each parenthesis group matches a path token
PATH_REGEXP.keys                  #TOKEN_ARR
TTOKEN                            #Path groups, either TOKEN or 'STR' (anything between TOKEN)
TOKEN                             #
TOKEN.pattern                     #REGEXP
TOKEN.name                        #'VAR' (if :VAR) or NUM (parenthesis group or "catch all")
TOKEN.optional                    #BOOL. If * or ?
TOKEN.repeat                      #BOOL. If * or +
TOKEN.asterisk                    #BOOL. If "catch all"
TOKEN.delimiter                   #According to OPTS.delimiter


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            PARSING            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


parse(PATH_STR)->TTOKEN_ARR       #
tokensToRegExp
(TTOKEN_ARR[, OBJ_ARR][, OPTS])
->PATH_REGEXP                     #If OBJ_ARR specified, push PATH_REGEXP.keys to OBJ_ARR

PATHTOREGEXP(PATH_STR[_ARR])      #Same as parse() + tokensToRegExp()
 ->PATH_REGEXP                    #If PATH_STR_ARR: alternatives


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:        REVERSE PARSING        :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


tokensToFunction(TTOKEN_ARR)      #Reverse parsing
->FUNC(OBJ[, OPTS])->PATH_STR     #Replaces:
                                  #  - :VAR by OBJ.VAR
                                  #  - (...) and * by OBJ[NUM]
                                  #Can use VAL_ARR:
                                  #  - if quantifier + or *
                                  #  - is replaced by VAL_ARR.join(delimiter)
                                  #Throws TypeError if does not match
                                  #Uses encodeURIComponent():
                                  #  - except : & = + $ , @ if OPTS.pretty or for "catch all"
                                  #  - also except / if "catch all"
compile(PATH_STR)->FUNC           #Same as parse() + tokensToFuncion()
