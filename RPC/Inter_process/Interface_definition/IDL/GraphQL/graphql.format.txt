
             
   GRAPHQL   
             



Versions:
  - spec from 7 Feb 2017


## RESOLVER ###################################################################################################################


{
  TYPE: {
    ATTR(RPARENT, ARGS, CONTEXT)->RATTR
    ...
  }  
}
  - RATTR|RPARENT:
     - is OBJ[_PROMISE][_ARR]
     - if complex type: RATTR only passed to child as RPARENT
     - if scalar type: RATTR rendered as output
     - i.e. shape of return value and TYPE are the same
     - null is treated same as undefined, i.e. is nothing
        - TYPE must be nullable
     - for top-level attributes, client can provide "initial value"???
  - ARGS:
     - ARG passed by query
     - is OBJ
  - CONTEXT:
     - request-long object, i.e. holding request info
     - provided by server

Resolver error:
  - can arise on:
     - result coercion error
     - any general exception|error during ATTR()
  - effect:
     - same as if resolver returned null


## GENERAL SYNTAX #############################################################################################################


VAL:
  - any of scalar types, i.e. STR, INT, FLOAT, BOOL, ENUM_VAL
  - null:
     - providing TYPE!
  - nothing|undefined:
     - providing TYPE!
  - ARR, i.e. [VAL,...]
  - OBJ, i.e. { ATTR: VAL, ... }

Naming:
  - [[:alnum:]_]
  - cannot start with __
  - case sensitive
  - for QUERY, $VAR|ARG, ALIAS|ATTR, TYPE, ENUM_VAL, FRAGMENT, DIRECTIVE

Commas:
  - always optional
     - i.e. trailing comma accepted
  - for ARG, ARR, OBJ
  
Whitespaces:
  - are ignored, except inside STR


## DEFINITION #################################################################################################################


TYPE
  - can be:
     - scalar: 
        - String: 
           - UTF-8
           - "STR" (double quotes)
           - must escape " \ newline, with \
           - can contain \uXXXX \/ \b \f \n \r \t
        - Int: signed 32 bits
        - Float: double precision
        - Boolean: true|false
        - ID: same as String, but with ID semantics
        - ENUM
     - or complex:
        - Object:
           - used as server output, OBJ-like
           - defined by type TYPE
           - includes METHOD
        - InputObject:
           - used as client input, OBJ-like
           - defined by input TYPE
  - can add modifiers TYPE! or [TYPE] (see below)

[TYPE]
  - means array
  - can be nested, e.g. [[TYPE]]

TYPE!
  - means not-nullable
  - for ATTR:
     - cannot be null (but can be undefined, i.e. always optional)
  - for ARG:
     - cannot be undefined|null (i.e. required)
  - raises query error otherwise
  - ARR:
     - [TYPE!]: TYPE not optional, TYPE_ARR optional
     - [TYPE]!: TYPE optional, TYPE_ARR non optional
     - TYPE_ARR non optional might still have length 0

ARG
  - TYPE: including complex
  - "= VAL" is default value
  - variadic argument:
     - should be last ARR
     - query needs to supply ARR, but VAL -> [VAL] typecasting possible (see below)

scalar TYPE
  Defines new scalar type:
    - must be serializable as string

type TYPE {
  ATTR[(ARG: TYPE [= VAL],...)]: TYPE  
  ...
}
  Defines Object type

METHOD:
  - Object TYPE, used as top-level entrypoint
  - also has extra semantics
  - can be:
     - query (def): 
        - same semantics as GET in REST
        - executed in parallel
     - mutation: 
        - same semantics as PUT|POST|DELETE|PATCH in REST
        - executed serially
     - are otherwise technically working the same way

input TYPE {
  ATTR: TYPE [= VAL]
}
  Defines InputObject type

enum ENUM { 
  ENUM_VAL
  ...
}
  Defines new ENUM type:
    - ENUM_VAL are not surrounded by quote
    - uppercase by convention

interface TYPE { ... }
type TYPE2 implements TYPE { ... }
  Inheritance:
    - TYPE is abstract, i.e. can only be implemented not directly used
    - TYPE2 must reimplement TYPE, as a superset|covariant:
       - can add ATTR, ARG, !-modifier
    - TYPE2 can be used where any parent is expected:
       - only TYPE's ATTR can be queried as is
       - TYPE2's ATTR must use fragment with "on TYPE2"


union TYPE = TYPE2 | ...
  Mixed type:
    - same as empty interface TYPE
    - TYPE2 must be complex, cannot include modifiers

Type coercion:
  - "result coercion":
     - typecasting from server to graphQL
     - resolver error if cannot typecast
     - is loose:
        - e.g.:
           - DOUBLE <-> 'NUM' <-> INT
           - any -> STR
           - NUM -> BOOL
        - but not:
           - VAL -> [VAL] (array)
  - "input coercion":
     - typecasing from client to graphQL
     - query error if cannot typecast
     - is strict (no coercion (verify this???)), except for:
        - VAL -> [VAL] (array)


## QUERY ######################################################################################################################


[METHOD QUERY[($VAR: TYPE [= DEF_VAL],...)]] {
  [ALIAS:] ATTR[(ARG: VAL,...)] { 
    ... (recursive)
  }]
  #COMMENT
  ...
}
  $VAR:
    - can then be used as const VAL inside query body, including fragments (macro substituted)
    - must be used
    - is up to the implementation how consumers provide variables values
       - but can e.g. be done using URL query variables
  ALIAS|ATTR:
    - by def same, but semantically different:
       - ALIAS is used for return value output, i.e. response shape
          - useful to differentiate to avoid collisions when using twice same ATTR but different arguments
       - ATTR is used to pick resolver, i.e. more like an action name:
          - with METHOD query, conceptually like "getAttr"
          - with METHOD mutation, conceptually like RPC action or specific REST method
  ARG:
    - passed to resolver
  Sub {...}:
    - necessary if TYPE is complex
    - forbidden otherwise
    - same syntax as OBJ

Comparison with REST:
  - query parameters and request body -> ARG
  - response body shape -> QUERY attributes shape

File:
  - contains 0-n operations|fragments
     - providing they do not have same names
  - can contain several top-level operations, and tell server which one to pick using "operationName" parameter
     - how this is communicated is implementation-specific, but e.g. using URL query variables

Query error:
  - returns { error ... }


## FRAGMENT ###################################################################################################################


fragment FRAGMENT on TYPE { ... }
  - named fragment
  - can be used as mixin in QUERY using ...FRAGMENT instead of ATTR
     - providing parent is instanceof TYPE
        - if not, just not applied
     - i.e. current RPARENT can have several possible types, so be polymorphic, i.e. either:
        - INTERFACE implementer
        - union TYPE
  - TYPE:
     - cannot include modifiers
     - must be complex (including INTERFACE)
  - can be nested
  - must be used in a query

... [on TYPE] { ... }
  - inline fragment
  - shortcut for ...FRAGMENT, followed by fragment FRAGMENT on TYPE {...}
  - only usage is coupled with polymorphism
  - "on TYPE" is only optional if @DIRECTIVE is used


## DIRECTIVE ##################################################################################################################


... @DIRECTIVE(ARG: VAL,...)... { ... }
  - same as ... { ... } except:
     - possibly change shape of data, implementation-defined
  - possibly used after:
     - METHOD QUERY[(...)]
     - ATTR[(...)]
     - fragment FRAGMENT on TYPE
     - ... [on TYPE]
  - spec define following:
     - @include|skip(if BOOL): skip field if false|true


## INTROSPECTION ##############################################################################################################


Introspection:
  - special attributes that request metadata
  - list:
     - __typename 'TYPE'
        - for SCHEMA|TYPEINFO|DIRECTIVEINFO|FIELD|INPUTVAL|ENUMVALINFO|TYPEKIND|DIRECTIVE|DIRECTIVELOCATION,
          it is __Schema|__Type|__Directive|__Field|__InputValue|__EnumValue|__TypeKind|__Directive|__DirectiveLocation
     - __schema SCHEMA:
        - types TYPEINFO_ARR:
           - all supported types, including scalar and __TYPE
        - queryType|mutationType TYPEINFO (top-level types METHOD)
        - directives DIRECTIVEINFO_ARR:
           - name 'DIRECTIVE'
           - description STR
           - args INPUTVALUE_ARR
           - locations DIRECTIVELOCATION_ARR:
              - enum among QUERY|MUTATION|FIELD|FRAGMENT_DEFINITION|FRAGMENT_SPREAD|INLINE_FRAGMENT
     - __type(name: 'TYPE') TYPEINFO:
        - name 'TYPE'
        - description STR
        - kind TYPEKIND:
           - enum among SCALAR|[INPUT_]OBJECT|INTERFACE|UNION|ENUM|NON_NULL|LIST
        (only NonNull|List modifiers)
        - ofType TYPEINFO
           - when kind is a modifier (NON_NULL|LIST), use "ofType" to get subtype
        (only Objects|Interface)
        - fields[(includeDeprecated: true)] FIELD_ARR
           - name 'ATTR'
           - description STR
           - type TYPE_INFO
           - args INPUTVALUE_ARR:
              - name 'VAR'
              - description STR
              - type TYPE_INFO
              - defaultValue STR
           - isDeprecated BOOL, deprecationReason STR
        (only InputObjects)
        - inputFields INPUTVALUE_ARR
        (only Objects)
        - interfaces TYPEINFO_ARR
        (only Interface|Union)
        - possibleTypes TYPEINFO_ARR
        (only Enums)
        - enumValues[(includeDeprecated: true)] ENUMVALINFO_ARR:
           - name 'ENUMVAL'
           - description STR
           - isDeprecated BOOL, deprecationReason STR
  - best practices:
     - specify description
     - specify isDeprecated, deprecationReason


## RETURN VALUE ###############################################################################################################

{
  data: OBJ
}

{
  errors OBJ_ARR
    message STR
    locations OBJ_ARR
      line NUM
      column NUM
}


## VALIDATION #################################################################################################################


Since query has explicit typing, can validate against server definition compile-time
  - can be done by client and|or by server

List of possible errors is available in spec


## NON MANDATORY ##############################################################################################################


Single endpoint:
  - usually /graphql
  - over HTTP:
     - either:
        - GET with query variable query JSON
        - POST with request body JSON (query)
     - query variables:
        - variables JSON:
           - VAR VAL
        - operationName 'METHOD': 
           - if query contains several possible top-level operations
  - application/json or application/graphql

No versioning (but I don't agree with that)
