
             
   GRAPHQL   
             



## ROOT TYPES

type METHOD { ... }

Like definition, but:
  - for entrypoints for a given METHOD
  - their resolver is "root resolver"


## DEFINITION

type TYPE {
  ATTR[(ARG: TYPE [= VAL],...)]: TYPE  
  ...
}

TYPE:
  - can be Query, i.e. top-level
  - TYPE! means not optional
     - ARR:
        - [TYPE!]: TYPE not optional, TYPE_ARR optional
        - [TYPE]!: TYPE optional, TYPE_ARR non optional
        - TYPE_ARR non optional might still have length 0
     - otherwise, resolver can return nothing:
        - including if because of exception|error
  - [TYPE] is array
  - can be:
     - scalar: 
        - String: UTF-8
        - Int: signed 32 bits
        - Float: double precision
        - Boolean: true|false
        - ID: same as String, but with ID semantics
        - ENUM
     - or complex, i.e. custom and OBJ-like

ARG:
  - TYPE: including complex
  - "= VAL" is default value

scalar TYPE

Defines new scalar type
  - each low-level implementation must have a (e.g.) JavaScript <-> graphQL layer ("scalar coercion")

enum ENUM { 
  VAL
  ...
}

Defines new ENUM type:
  - VAL are not surrounded by quote


interface INTERFACE { ... }
type TYPE implements INTERFACE { ... }

Inheritance:
  - interface is abstract, i.e. can only be implemented not directly used
  - TYPE must reimplement INTERFACE


union TYPE = TYPE2 | ...

Generic polymorphism:
  - TYPE is shared contracts between all TYPE2


## RESOLVER

{
  TYPE: {
    ATTR(RPARENT, ARGS, CONTEXT)->RATTR
    ...
  }  
}

ATTR(RPARENT, ARGS, CONTEXT)->RATTR:
  - RATTR|RPARENT:
     - is OBJ[_PROMISE][_ARR]
     - if complex type: RATTR only passed to child as RPARENT
     - if scalar type: RATTR rendered as output
     - i.e. shape of return value and TYPE are the same
  - ARGS:
     - ARG passed by query
     - is OBJ
  - CONTEXT:
     - request-long object, i.e. holding request info


## QUERY

[METHOD QUERY[($VAR: TYPE,...)]] {
  [ALIAS:] ATTR[(ARG: VAL,...)] [@DIRECTIVE(ARG: VAL,...)] [{ 
    ... (recursive)
    ... on TYPE { ... }
  }]
  #COMMENT
  ...
}

ALIAS:
  - use ATTR for resolver, but output as ALIAS in return value
$VAR:
  - can then be used as VAL
DIRECTIVE:
  - possibly change shape of data?
  - function whose return value is passed to resolver?
  - in the spec:
     - @include|skip(if BOOL): skip field if false|true
  - can add custom
Introspection:
  - special attributes that request metadata
  - list:
     - __typename 'TYPE'
     - __schema OBJ:
        - types OBJ_ARR (type information, including scalar and __TYPE):
           - name 'TYPE'
        - queryType OBJ
           - name METHOD
     - __type(name: 'TYPE'):
        - name 'TYPE'
        - description STR
        - kind|ofType 'OBJECT|INTERFACE|NON_NULL|LIST|SCALAR'
           - NON_NULL|LIST are wrapper types, use "ofType" to get subtype
Sub {...} is:
  - necessary if TYPE is complex
  - forbidden otherwise


METHOD:
  - query: 
     - like GET in REST
     - executed in parallel
  - mutation: 
     - like PUT|POST|DELETE|PATCH in REST
     - executed serially

Comparison with REST:
  - query parameters and request body -> ARG
  - response body shape -> QUERY attributes shape


## FRAGMENT

fragment FRAGMENT on TYPE { ... }

Named fragment
Can be then used as mixin in QUERY using ...FRAGMENT
  - providing parent is instanceof TYPE
     - if not, just not applied
  - i.e. parent must have several possible types, so be polymorphic, i.e. either:
     - INTERFACE implementer
     - union TYPE

... on TYPE { ... }

Inline fragment:
  - shortcut for ...FRAGMENT, followed by fragment FRAGMENT on TYPE {...}

## RETURN VALUE

{
  data: OBJ
}

{
  errors OBJ_ARR
    message STR
    locations OBJ_ARR
      line NUM
      column NUM
}


## VALIDATION

Since query has explicit typing, can validate against server definition compile-time


## NON MANDATORY

Single endpoint, usually HTTP

No versioning (but I don't agree with that)
