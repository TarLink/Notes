
             
   GRAPHQL   
             



Versions:
  - spec from 7 Feb 2017


## RESOLVER ###################################################################################################################


{
  TYPE: {
    ATTR(RPARENT, ARGS, CONTEXT)->RATTR
    ...
  }  
}
  - RATTR|RPARENT:
     - is OBJ[_PROMISE][_ARR]
     - if complex type: RATTR only passed to child as RPARENT
     - if scalar type: RATTR rendered as output
     - i.e. shape of return value and TYPE are the same
     - null is treated same as undefined, i.e. is nothing
        - TYPE must be nullable
  - ARGS:
     - ARG passed by query
     - is OBJ
  - CONTEXT:
     - request-long object, i.e. holding request info

Resolver error:
  - can arise on:
     - result coercion error
     - any general exception|error during ATTR()
  - effect:
     - same as if resolver returned null


## GENERAL SYNTAX #############################################################################################################


VAL:
  - any of scalar types, i.e. STR, INT, FLOAT, BOOL, ENUM_VAL
  - null:
     - providing TYPE!
  - nothing|undefined:
     - providing TYPE!
  - ARR, i.e. [VAL,...]
  - OBJ, i.e. { ATTR: VAL, ... }

Naming:
  - [[:alnum:]_]
  - cannot start with __
  - case sensitive
  - for QUERY, $VAR|ARG, ALIAS|ATTR, TYPE, ENUM_VAL, FRAGMENT, DIRECTIVE

Commas:
  - always optional
     - i.e. trailing comma accepted
  - for ARG, ARR, OBJ
  
Whitespaces:
  - are ignored, except inside STR


## DEFINITION #################################################################################################################


type TYPE {
  ATTR[(ARG: TYPE [= VAL],...)]: TYPE  
  ...
}
  TYPE:
    - can be:
       - scalar: 
          - String: 
             - UTF-8
             - "STR" (double quotes)
             - must escape " \ newline, with \
             - can contain \uXXXX \/ \b \f \n \r \t
          - Int: signed 32 bits
          - Float: double precision
          - Boolean: true|false
          - ID: same as String, but with ID semantics
          - ENUM
       - or complex:
          - Object:
             - used as server output, OBJ-like
             - defined by type TYPE
          - InputObject:
             - used as client input, OBJ-like
             - defined by input TYPE
          - METHOD:
             - top-level entrypoint
             - is not only resource, also has extra semantics (e.g. query does not have side effects)
    - modifiers:
       - TYPE! means not-nullable:
          - for ATTR:
             - cannot be null (but can be undefined, i.e. always optional)
          - for ARG:
             - cannot be undefined|null (i.e. required)
          - raises query error otherwise
          - ARR:
             - [TYPE!]: TYPE not optional, TYPE_ARR optional
             - [TYPE]!: TYPE optional, TYPE_ARR non optional
             - TYPE_ARR non optional might still have length 0
       - [TYPE] means array
          - can be nested, e.g. [[TYPE]]
  ARG:
    - TYPE: including complex
    - "= VAL" is default value
    - variadic argument:
       - should be last ARR
       - query needs to supply ARR, but VAL -> [VAL] typecasting possible (see below)

scalar TYPE
  Defines new scalar type:
    - must be serializable as string

input TYPE {
  ATTR: TYPE [= VAL]
}
  Defines InputObject type (verify this???)

enum ENUM { 
  ENUM_VAL
  ...
}
  Defines new ENUM type:
    - ENUM_VAL are not surrounded by quote
    - uppercase by convention

interface TYPE { ... }
type TYPE2 implements TYPE { ... }
  Inheritance:
    - TYPE is abstract, i.e. can only be implemented not directly used
    - TYPE2 must reimplement TYPE, as a superset|covariant:
       - can add ATTR, ARG, !-modifier
    - TYPE2 can be used where any parent is expected:
       - only TYPE's ATTR can be queried as is
       - TYPE2's ATTR must use fragment with "on TYPE2"


union TYPE = TYPE2 | ...
  Mixed type:
    - same as empty interface TYPE
    - TYPE2 must be complex, cannot include modifiers

Type coercion:
  - "result coercion":
     - typecasting from server to graphQL
     - resolver error if cannot typecast
     - is loose:
        - e.g.:
           - DOUBLE <-> 'NUM' <-> INT
           - any -> STR
           - NUM -> BOOL
        - but not:
           - VAL -> [VAL] (array)
  - "input coercion":
     - typecasing from client to graphQL
     - query error if cannot typecast
     - is strict (no coercion (verify this???)), except for:
        - VAL -> [VAL] (array)


## QUERY ######################################################################################################################


[METHOD QUERY[($VAR: TYPE [= DEF_VAL],...)]] {
  [ALIAS:] ATTR[(ARG: VAL,...)] { 
    ... (recursive)
  }]
  #COMMENT
  ...
}
  METHOD:
    - query (def): 
       - same semantics as GET in REST
       - executed in parallel
    - mutation: 
       - same semantics as PUT|POST|DELETE|PATCH in REST
       - executed serially
  $VAR:
    - can then be used as const VAL inside query body, including fragments (macro substituted)
  ALIAS|ATTR:
    - by def same, but semantically different:
       - ALIAS is used for return value output, i.e. response shape
          - useful to differentiate to avoid collisions when using twice same ATTR but different arguments
       - ATTR is used to pick resolver, i.e. more like an action name:
          - with METHOD query, conceptually like "getAttr"
          - with METHOD mutation, conceptually like RPC action or specific REST method
  ARG:
    - passed to resolver
  Sub {...}:
    - necessary if TYPE is complex
    - forbidden otherwise
    - same syntax as OBJ

Comparison with REST:
  - query parameters and request body -> ARG
  - response body shape -> QUERY attributes shape

File:
  - contains 0-n operations|fragments
     - providing they do not have same names

Query error:
  - returns { error ... }


## FRAGMENT ###################################################################################################################


fragment FRAGMENT on TYPE { ... }
  - named fragment
  - can be used as mixin in QUERY using ...FRAGMENT instead of ATTR
     - providing parent is instanceof TYPE
        - if not, just not applied
     - i.e. current RPARENT can have several possible types, so be polymorphic, i.e. either:
        - INTERFACE implementer
        - union TYPE
  - TYPE:
     - cannot include modifiers
     - must be complex (including INTERFACE)
  - can be nested
  - must be used in a query

... [on TYPE] { ... }
  - inline fragment
  - shortcut for ...FRAGMENT, followed by fragment FRAGMENT on TYPE {...}
  - only usage is coupled with polymorphism
  - "on TYPE" is only optional if @DIRECTIVE is used


## DIRECTIVE ##################################################################################################################


... @DIRECTIVE(ARG: VAL,...)... { ... }
  - same as ... { ... } except:
     - possibly change shape of data, implementation-defined
  - possibly used after:
     - METHOD QUERY[(...)]
     - ATTR[(...)]
     - fragment FRAGMENT on TYPE
     - ... [on TYPE]
  - spec define following:
     - @include|skip(if BOOL): skip field if false|true


## INTROSPECTION ##############################################################################################################


Introspection:
  - special attributes that request metadata
  - list:
     - __typename 'TYPE'
        - for SCHEMA|TYPEINFO|DIRECTIVEINFO|FIELD|INPUTVAL|ENUMVALINFO|TYPEKIND|DIRECTIVE|DIRECTIVELOCATION,
          it is __Schema|__Type|__Directive|__Field|__InputValue|__EnumValue|__TypeKind|__Directive|__DirectiveLocation
     - __schema SCHEMA:
        - types TYPEINFO_ARR:
           - all supported types, including scalar and __TYPE
        - queryType|mutationType TYPEINFO (top-level types METHOD)
        - directives DIRECTIVEINFO_ARR:
           - name 'DIRECTIVE'
           - description STR
           - args INPUTVALUE_ARR
           - locations DIRECTIVELOCATION_ARR:
              - enum among QUERY|MUTATION|FIELD|FRAGMENT_DEFINITION|FRAGMENT_SPREAD|INLINE_FRAGMENT
     - __type(name: 'TYPE') TYPEINFO:
        - name 'TYPE'
        - description STR
        - kind TYPEKIND:
           - enum among SCALAR|[INPUT_]OBJECT|INTERFACE|UNION|ENUM|NON_NULL|LIST
        (only NonNull|List modifiers)
        - ofType TYPEINFO
           - when kind is a modifier (NON_NULL|LIST), use "ofType" to get subtype
        (only Objects|Interface)
        - fields[(includeDeprecated: true)] FIELD_ARR
           - name 'ATTR'
           - description STR
           - type TYPE_INFO
           - args INPUTVALUE_ARR:
              - name 'VAR'
              - description STR
              - type TYPE_INFO
              - defaultValue STR
           - isDeprecated BOOL, deprecationReason STR
        (only InputObjects)
        - inputFields INPUTVALUE_ARR
        (only Objects)
        - interfaces TYPEINFO_ARR
        (only Interface|Union)
        - possibleTypes TYPEINFO_ARR
        (only Enums)
        - enumValues[(includeDeprecated: true)] ENUMVALINFO_ARR:
           - name 'ENUMVAL'
           - description STR
           - isDeprecated BOOL, deprecationReason STR
  - best practices:
     - specify description
     - specify isDeprecated, deprecationReason


## RETURN VALUE ###############################################################################################################

{
  data: OBJ
}

{
  errors OBJ_ARR
    message STR
    locations OBJ_ARR
      line NUM
      column NUM
}


## VALIDATION #################################################################################################################


Since query has explicit typing, can validate against server definition compile-time
  - can be done by client and|or by server

List of possible errors is available in spec


## NON MANDATORY ##############################################################################################################


Single endpoint:
  - usually /graphql
  - over HTTP:
     - GET: query variables:
        - query JSON
        - variables JSON:
           - VAR VAL
        - operationName 'METHOD'
     - POST
  - application/json or application/graphql

No versioning (but I don't agree with that)
