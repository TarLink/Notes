
             
   GRAPHQL   
             



Versions:
  - spec from october 2016
  - read doc in march 2017


## RESOLVER ###################################################################################################################


{
  TYPE: {
    ATTR(RPARENT, ARGS, CONTEXT)->RATTR
    ...
  }  
}
  - RATTR|RPARENT:
     - is OBJ[_PROMISE][_ARR]
     - if complex type: RATTR only passed to child as RPARENT
     - if scalar type: RATTR rendered as output
     - i.e. shape of return value and TYPE are the same
     - null is treated same as undefined, i.e. is nothing
  - ARGS:
     - ARG passed by query
     - is OBJ
  - CONTEXT:
     - request-long object, i.e. holding request info


## GENERAL SYNTAX #############################################################################################################


VAL:
  - any of scalar types, i.e. STR, INT, FLOAT, BOOL, ENUM_VAL
  - null:
     - providing TYPE!
  - nothing|undefined:
     - providing TYPE!
  - ARR, i.e. [VAL,...]
  - OBJ, i.e. { ATTR: VAL, ... }

Naming:
  - [[:alnum:]_]
  - case sensitive
  - for QUERY, $VAR|ARG, ALIAS|ATTR, TYPE, ENUM_VAL, FRAGMENT, DIRECTIVE

Commas:
  - always optional
     - i.e. trailing comma accepted
  - for ARG, ARR, OBJ
  
Whitespaces:
  - are ignored, except inside STR


## DEFINITION #################################################################################################################


type TYPE {
  ATTR[(ARG: TYPE [= VAL],...)]: TYPE  
  ...
}
  TYPE:
    - can be:
       - scalar: 
          - String: 
             - UTF-8
             - "STR" (double quotes)
             - must escape " \ newline, with \
             - can contain \uXXXX \/ \b \f \n \r \t
          - Int: signed 32 bits
          - Float: double precision
          - Boolean: true|false
          - ID: same as String, but with ID semantics
          - ENUM
       - or complex:
          - i.e. custom and OBJ-like
          - METHOD:
             - top-level entrypoint
             - is not only resource, also has extra semantics (e.g. query does not have side effects)
    - modifiers:
       - TYPE! means not optional
          - ARR:
             - [TYPE!]: TYPE not optional, TYPE_ARR optional
             - [TYPE]!: TYPE optional, TYPE_ARR non optional
             - TYPE_ARR non optional might still have length 0
          - otherwise, resolver can return nothing:
             - including if because of exception|error
       - [TYPE] is array
  ARG:
    - TYPE: including complex
    - "= VAL" is default value

scalar TYPE
  Defines new scalar type:
    - each low-level implementation must have a (e.g.) JavaScript <-> graphQL layer ("scalar coercion")

enum ENUM { 
  ENUM_VAL
  ...
}
  Defines new ENUM type:
    - ENUM_VAL are not surrounded by quote
    - uppercase by convention

interface INTERFACE { ... }
type TYPE implements INTERFACE { ... }
  Inheritance:
    - interface is abstract, i.e. can only be implemented not directly used
    - TYPE must reimplement INTERFACE

union TYPE = TYPE2 | ...
  Generic polymorphism:
    - TYPE is shared contracts between all TYPE2


## QUERY ######################################################################################################################


[METHOD QUERY[($VAR: TYPE [= DEF_VAL],...)]] {
  [ALIAS:] ATTR[(ARG: VAL,...)] { 
    ... (recursive)
  }]
  #COMMENT
  ...
}
  METHOD:
    - query (def): 
       - same semantics as GET in REST
       - executed in parallel
    - mutation: 
       - same semantics as PUT|POST|DELETE|PATCH in REST
       - executed serially
  $VAR:
    - can then be used as const VAL inside query body, including fragments (macro substituted)
  ALIAS|ATTR:
    - by def same, but semantically different:
       - ALIAS is used for return value output, i.e. response shape
          - useful to differentiate to avoid collisions when using twice same ATTR but different arguments
       - ATTR is used to pick resolver, i.e. more like an action name:
          - with METHOD query, conceptually like "getAttr"
          - with METHOD mutation, conceptually like RPC action or specific REST method
  ARG:
    - passed to resolver
  Sub {...}:
    - necessary if TYPE is complex
    - forbidden otherwise
    - same syntax as OBJ

Comparison with REST:
  - query parameters and request body -> ARG
  - response body shape -> QUERY attributes shape

File:
  - contains 0-n operations|fragments


## FRAGMENT ###################################################################################################################


fragment FRAGMENT on TYPE { ... }
  - named fragment
  - can be used as mixin in QUERY using ...FRAGMENT instead of ATTR
     - providing parent is instanceof TYPE
        - if not, just not applied
     - i.e. current RPARENT can have several possible types, so be polymorphic, i.e. either:
        - INTERFACE implementer
        - union TYPE
  - TYPE:
     - cannot include modifiers
     - must be complex (including INTERFACE)
  - can be nested

... [on TYPE] { ... }
  - inline fragment
  - shortcut for ...FRAGMENT, followed by fragment FRAGMENT on TYPE {...}
  - only usage is coupled with polymorphism
  - "on TYPE" is only optional if @DIRECTIVE is used


## DIRECTIVE ##################################################################################################################


... @DIRECTIVE(ARG: VAL,...)... { ... }
  - same as ... { ... } except:
     - possibly change shape of data, implementation-defined
  - possibly used after:
     - METHOD QUERY[(...)]
     - ATTR[(...)]
     - fragment FRAGMENT on TYPE
     - ... [on TYPE]
  - spec define following:
     - @include|skip(if BOOL): skip field if false|true


## INTROSPECTION ##############################################################################################################


Introspection:
  - special attributes that request metadata
  - list:
     - __typename 'TYPE'
     - __schema OBJ:
        - types OBJ_ARR (type information, including scalar and __TYPE):
           - name 'TYPE'
        - queryType OBJ
           - name METHOD
     - __type(name: 'TYPE'):
        - name 'TYPE'
        - description STR
        - kind|ofType 'OBJECT|INTERFACE|NON_NULL|LIST|SCALAR'
           - NON_NULL|LIST are wrapper types, use "ofType" to get subtype


## RETURN VALUE ###############################################################################################################

{
  data: OBJ
}

{
  errors OBJ_ARR
    message STR
    locations OBJ_ARR
      line NUM
      column NUM
}


## VALIDATION #################################################################################################################


Since query has explicit typing, can validate against server definition compile-time


## NON MANDATORY ##############################################################################################################


Single endpoint:
  - usually /graphql
  - over HTTP:
     - GET: query variables:
        - query JSON
        - variables JSON:
           - VAR VAL
        - operationName 'METHOD'
     - POST
  - application/json or application/graphql

No versioning (but I don't agree with that)
