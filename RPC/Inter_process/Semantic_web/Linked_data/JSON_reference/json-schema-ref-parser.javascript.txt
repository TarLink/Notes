
                          
   JSON-SCHEMA-REF-PARSER  
                          



ALTERNATIVES ==>                  #  - json-schema-ref-parser (preferred): can customize parsers, loaders, good at circular ref
                                  #  - whitlockjc json-refs: good features, has options for pre-processing, post-processing,
                                  #    filtering, has CLI tool, good at notifying of errors

VERSION ==>                       #3.1.2

Not only for JSON schema

All function that return a PROMISE can use final callback instead too.
Reference is REF, i.e. [URI][#HASH] where #HASH is absolute JSON pointer
As opposed to spec, can be { $ref STR, ... } in which case ... is merged in (which one has priority???)
Steps:
  - resolution: find reference, local or remote (i.e. fetches)
  - parsing: file parsing, e.g. JSON|YAML to JavaScript OBJ
  - dereferencing: replace $ref by reference

new RefParser->REFPARSER
RefParser.*(...): same as (new RefParser).*(...)

REFPARSER.resolve(OBJ|PATH|URL[, POPTS])->PROMISE(REFS): does resolution
REFPARSER.parse(OBJ|PATH|URL[, POPTS])->PROMISE(OBJ): does parsing
REFPARSER.bundle(OBJ|PATH|URL[, POPTS])->PROMISE(OBJ): does parsing and resolution, then add remote references to local definitions, but does not do dereferencing??? Use OBJ.definitions if defined???
REFPARSER.dereference(OBJ|PATH|URL[, POPTS])->PROMISE(OBJ): does parsing and resolution and deferencing

REFPARSER.schema OBJ: from last REFPARSER.*() after parsing|resolution|dereferencing
REFPARSER.$refs REFS: from last REFPARSER.*() after resolution

REFS.get(REF)->VAL
REFS.set(REF, VAL)
REFS.exists(REF)->BOOL
REFS.values|toJSON(["URI_SCHEME,..."])->{ REF: VAL, ... }
REFS.paths(["URI_SCHEME,..."])->REF_ARR

POPTS.dereference.circular VAL: what to do when dereferencing circular refs among:
  - true (def): create circular references in JavaScript, which works, but won't work when serializing to JSON
  - false: throws ReferenceError
  - "ignore": do not dereference
REFS.circular BOOL: whether there are some circular references
Using REFPARSER.bundle() prevents having any circular references too

PARSER:
  - plugin handling parsing
  - default ones:
      - json: order 100, on *.json, using JSON.parse()
      - yaml: order 200, on *.yaml|yml|json, using YAML.safeLoad() with js-yaml
      - text. order 300, on *.txt|htm|html|md|xml|js|min|map|css|scss|less|svg,  has PARSER.encoding STR (def: "utf8"), using BUFFER.toString()
      - binary: order 400, on *.jpeg|jpg|gif|png|bmp|ico, returning BUFFER as is
POPTS.parser.PARSER PARSER|BOOL: PARSER merges properties of PARSER, i.e. to either specify custom one, or customize default ones
PARSER.parse(FILE)->PROMISE(VAL): main logic
PARSER.order NUM: order of execution between each PARSER
PARSER.canParse VAL: decide whether a given PARSER will be picked. Can be:
  - BOOL
  - REGEXP, against URI
  - ".EXT"[_ARR]
  - FUNC(FILE)->BOOL
If none matches, try every PARSER until one's parse() method succeeds
PARSER.allowEmpty BOOL (def: true): if false and parsed value is undefined|{}|[]|""|emptyBUFFER, rejects parsing PROMISE. Note: default parser can give undefined for yaml|json, "" for text, empty BUFFER for binary.
PARSER.*: any custom property for a given PARSER

RESOLVER:
  - plugin handling resolution
  - default ones:
       - file: order 100, for PATH or file:URI, using FS.readFile(), returns BUFFER
       - http: order 200, for http[s]:, using HTTP[S].get(), can use RESOLVER.headers|timeout|redirects|withCredentials , returns BUFFER
POPTS.resolve.RESOLVER RESOLVER|BOOL
RESOLVER.read|order|canRead|*: similar to PARSER.parse|order|canParse|*
POPTS.resolve.external BOOL (def: true): if false, ignore REF that have a URI part

FILE.url URI
FILE.extension ".EXT"
FILE.data VAL: what was returned by resolver, usually BUFFER but could theoretically be STR
