
                          
   JSON-SCHEMA-REF-PARSER  
                          



ALTERNATIVES ==>                  #  - json-schema-ref-parser (preferred): can customize parsers, loaders, good at circular ref
                                  #  - whitlockjc json-refs: good features, has options for pre-processing, post-processing,
                                  #    filtering, has CLI tool, good at notifying of errors

VERSION ==>                       #3.1.2
                                  #Handles JSON references
                                  #Name suggests "JSON schema" but it's for any JSON

PROMISE ==>                       #All function that return a PROMISE can use final callback instead too.

REF                               #JSON reference [URI][#HASH] where #HASH is absolute JSON pointer
                                  #As opposed to spec, can be { $ref STR, ... } in which case ... is merged in
                                  #(which one has priority???)

STEPS ==>                         #  - resolution:
                                  #     - find reference, local or remote (i.e. fetches)
                                  #     - current|starting document is also added as a local reference
                                  #  - parsing: file parsing, e.g. JSON|YAML to JavaScript OBJ
                                  #  - dereferencing: replace $ref by reference

new RefParser->REFPARSER          #
RefParser.*(...)                  #Same as (new RefParser).*(...)

REFPARSER.resolve
(OBJ|PATH|URL[, POPTS])
->PROMISE(REFS)                   #Does resolution
REFPARSER.parse
(OBJ|PATH|URL[, POPTS])
->PROMISE(OBJ)                    #Does parsing
REFPARSER.dereference
(OBJ|PATH|URL[, POPTS])
->PROMISE(OBJ)                    #Does parsing and resolution and deferencing
REFPARSER.bundle                  #Does parsing and resolution, then add remote references to local definitions,
(OBJ|PATH|URL[, POPTS])           #but does not do dereferencing???
->PROMISE(OBJ)                    #Use OBJ.definitions if defined???
                                  #Note: using REFPARSER.bundle() prevents having any circular references
                                  #But leaves them as local references

REFPARSER.schema OBJ              #From last REFPARSER.*() after parsing|resolution|dereferencing
REFPARSER.$refs REFS              #From last REFPARSER.*() after resolution

REFS.get(REF)->VAL                #
REFS.set(REF, VAL)                #
REFS.exists(REF)->BOOL            #
REFS.values|toJSON
(["URI_SCHEME"[_ARR]])
->{ REF: VAL, ... }               #
REFS.paths(["URI_SCHEME"[_ARR]])
->REF_ARR                         #

POPTS.dereference.circular        #What to do when dereferencing circular refs (with REFPARSER.dereference()) among:
                                  #  - true (def): create circular references in JavaScript, which works,
                                  #    but won't work when serializing to JSON
                                  #  - false: throws ReferenceError
                                  #  - "ignore": do not dereference file that contains circular refs
REFS.circular                     #BOOL: whether there are some circular references

PARSER                            #Plugin handling parsing
                                  #Default ones:
                                  #   - json: order 100, on *.json, using JSON.parse()
                                  #   - yaml: order 200, on *.yaml|yml|json, using YAML.safeLoad() with js-yaml
                                  #   - text. order 300, on *.txt|htm|html|md|xml|js|min|map|css|scss|less|svg,
                                  #     has PARSER.encoding STR (def: "utf8"), using BUFFER.toString()
                                  #   - binary: order 400, on *.jpeg|jpg|gif|png|bmp|ico, returning BUFFER as is
POPTS.parse.PARSER PARSER|BOOL    #PARSER merges properties of PARSER, i.e. to either specify custom one,
                                  #or customize default ones
PARSER.parse(FILE)->PROMISE(VAL)  #Main logic
PARSER.order NUM                  #Order of execution between each PARSER
PARSER.canParse VAL               #Decide whether a given PARSER will be picked. Can be:
                                  #  - BOOL
                                  #  - REGEXP, against URI
                                  #  - ".EXT"[_ARR]
                                  #  - FUNC(FILE)->BOOL
                                  #If none matches, try every PARSER until one's parse() method succeeds
PARSER.allowEmpty BOOL            #If false (def: true) and parsed value is undefined|{}|[]|""|emptyBUFFER,
                                  #rejects parsing PROMISE.
                                  #Note: default parser can give undefined for yaml|json, "" for text, empty BUFFER for binary.
PARSER.*                          #Any custom property for a given PARSER

RESOLVER                          #Plugin handling resolution
                                  #Default ones:
                                  #  - file: order 100, for PATH or file:URI, using FS.readFile(), returns BUFFER
                                  #  - http: order 200, for http[s]:, using HTTP[S].get(),
                                  #    can use RESOLVER.headers|timeout|redirects|withCredentials, returns BUFFER
POPTS.resolve.RSOLVR RESOLVER|BOOL#
RESOLVER.read|order|canRead|*     #Similar to PARSER.parse|order|canParse|*
POPTS.resolve.external BOOL       #If false (def: true), ignore REF that have a URI part

FILE.url URI
FILE.extension ".EXT"
FILE.data VAL                     #What was returned by resolver, usually BUFFER but could theoretically be STR
