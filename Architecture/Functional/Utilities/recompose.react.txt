
               
   RECOMPOSE   
               


VERSION ==>                       #0.12.0
                                  #HOC library, i.e. creating wrappers for React types: FUNC(RTYPE)->RTYPE2
                                  #Can require individual functions (like Underscore/Lodash)

CURRYING ==>                      #Most functions can be curried

HOC                               #Higher order components:
                                  #  - i.e. FUNC(RTYPE)->RTYPE2
                                  #  - works well with RECOMPOSE.compose(...)

RECOMPOSE.compose(...)            #Same as _.compose(...) but with more debug info


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            HELPER             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


RECOMPOSE.isClassComponent(RTYPE)
->BOOL                            #

RECOMPOSE.getDisplayName(RTYPE)
 ->STR                            #Returns RTYPE.displayName|name or 'Component'
RECOMPOSE.wrapDisplayName
(RTYPE, STR)->STR2                #Returns STR + RECOMPOSE.getDisplayName(RTYPE)

RECOMPOSE.toClass())-HOC          #Transform a stateless function into a RTYPE
                                  #Can specify FUNC.displayName|name|propTypes|contextTypes|defaultProps


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             TYPE              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


RECOMPOSE.renderComponent
('TAG'|RTYPE)->HOC                #Make type 'TAG'|RTYPE

RECOMPOSE.componentFromProp('VAR')
 ->RTYPE                          #Make type PROPS.VAR 'TAG'|RTYPE2


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             PROPS             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


RECOMPOSE.renameProp
('VAR', 'VAR2')->HOC
RECOMPOSE.renameProps
({ 'VAR': 'VAR2' ... })->HOC      #Make PROPS.VAR -> PROPS.VAR2

RECOMPOSE.flattenProp('VAR')->HOC #Make PROPS.VAR.VAR2 -> PROPS.VAR2

RECOMPOSE.mapProps
(FUNC(PROPS)->PROPS2)->HOC        #Make PROPS -> PROPS2

RECOMPOSE.mapPropsOnChange        #Same as RECOMPOSE.mapProps() except recomputed on change, i.e.:
('VAR'_ARR, FUNC)->HOC            #  - also pass original PROPS (except PROPS.VAR)
                                  #  - recompute PROPS2 if PROPS.VAR changes (shallow comparison in componentWillReceiveProps)
                                  #So 'VAR'_ARR must be the variables used in FUNC

RECOMPOSE.withAttachedProps
(PROPS[(FUNC()->PROPS2)])->HOC    #Adds PROPS (PROPS2 is the one passed to it, and has higher priority)

RECOMPOSE.withReducer             #Adds:
('VAR', 'VAR2', RFUNC,            #  - PROPS.VAR: initial value is OBJ
OBJ[(PROPS)])->HOC                #  - PROPS.VAR2(ACTION): does PROPS.VAR = RFUNC(PROPS.VAR, ACTION)

RECOMPOSE.withState               #Adds:
('VAR','VAR2',OBJ[(PROPS)])->HOC  #  - PROPS.VAR: initial value is OBJ
                                  #  - PROPS.VAR2(VAL|FUNC(PROPS.VAR)[, FUNC()]): does PROPS.VAR = VAL|FUNC(PROPS.VAR)


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:         RCOMP MEMBERS         :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/

RECOMPOSE.withContext
(OBJ, FUNC()->OBJ)->HOC           #Adds childContextTypes OBJ and getChildContext FUNC

RECOMPOSE.defaultProps(OBJ)->HOC  #Adds defaultProps OBJ

RECOMPOSE.withProps
(FUNC(FUNC()->PROPS2)->PROPS)->HOC#Similar to RECOMPOSE.defaultProps(...)

RECOMPOSE.setStatic
('VAR', VAL)->HOC                 #Adds RTYPE.VAR = VAL
RECOMPOSE.setDisplayName
(VAL)->HOC                        #Adds RTYPE.displayName = VAL
RECOMPOSE.setPropTypes
(VAL)->HOC                        #Adds RTYPE.propTypes = VAL

RECOMPOSE.hoistStatics            #Keep static properties when applying HOC
(HOC)->HOC2                       #except React-specific attributes: contextTypes, defaultProps, displayName, mixins, type, etc.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           LIFECYCLE           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


RECOMPOSE.lifecycle(OBJ)->HOC     #Adds|replaces RCOMP members, i.e. componentWillUpdate(), etc. (except render())
                                  #State changes will be passed as props to lower-order component

RECOMPOSE.doOnReceiveProps        #Fires:
(FUNC(PROPS))->HOC                #  - FUNC(PROPS) called on componentWillMount and componentWillReceiveProps


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:     SHOULDCOMPONENTUPDATE     :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


RECOMPOSE.shouldUpdate
(FUNC(PREV_PROPS,NEXT_PRPS)->BOOL)
->HOC                             #Adds shouldComponentUpdate()->BOOL

RECOMPOSE.pure()->HOC             #Adds shouldComponentUpdate() doing a shallow comparison on PROPS

RECOMPOSE.onlyUpdateForKeys       
('VAR'_ARR)->HOC                  #Adds shouldComponentUpdate() doing a shallow comparison on any PROPS.VAR

RECOMPOSE.onlyUpdateForPropTypes
()->HOC                           #Adds shouldComponentUpdate() doing a shallow comparison on any PROPS.VAR from RTYPE.propTypes


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            RENDER             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


RECOMPOSE.nest(RTYPE...)->RTYPE3  #Will render as:
                                  #  <RTYPE PROPS> 
                                  #     <RTYPE2 PROPS>
                                  #       ...
                                  #         PROPS.children

RECOMPOSE.createSink(FUNC(PROPS))
  ->RTYPE                         #Will render as no HTML but firing FUNC(PROPS) on 'mount' and 'update'

RECOMPOSE.renderNothing()->HOC    #Will render as no HTML

RECOMPOSE.branch                  #Use HOC2 if BOOL true, HOC3 otherwise.
(FUNC(PROPS)->BOOL,HOC2,HOC3)->HOC#Calculated at construction and componentWillReceiveProps
