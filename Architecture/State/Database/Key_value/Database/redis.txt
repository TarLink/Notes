
           
   REDIS   
           


MAIN ==>                      #Architecture:
                              #  - over TCP
                              #  - client-server
                              #  - key/value store, using some structured data types
                              #  - optimized for performance, in-memory
                              #Possible goals:
                              #  - cache
                              #  - realtime
                              #Version: 3.0 beta8

PACKAGES ==>                  #  - redis-server: redis-server, redis-sentinel
                              #  - redis-tools: redis-cli, redis-benchmark, redis-check-dump|aof


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            SERVER             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


DATABASES ==>                 #Redis databases are named with a NUM.
                              #Client can select with select NUM (returns "OK") (def usually 0)

redis-server [CONFFILE]       #Starts a set of databases:
                              #  - called "cluster" for PostgreSQL, but cluster has special meaning in Redis
                              #    (master-master replication)
                              #Should be run under redis SHELL_USER and redis SHELL_GROUP:
                              #  - server runtime directory is $HOME (/var/run/redis/ for redis SHELL_USER)
                              #  - should be owned by redis SHELL_USER and redis SHELL_GROUP
                              #CONFFILE:
                              #  - is redis.conf (def: /etc/redis/redis.conf)
                              #  - can be - for stdin
                              #If CONFVAR daemonize yes (def): 
                              #  - run in background
                              #  - creates a PID file at CONFVAR pidfile (def: /var/run/redis/redis-server.pid)
                              #Should setup /etc/init.d/ script to start redis-server at start time

CONFFILE                      #Values are CONFVAR:
                              #  - VAR VAL
                              #  - can use human readable size
                              #  - include FILE can be used
                              #Can also use:
                              #  - redis-server --CONFVAR VAL
                              #  - config get GLOB_STR: returns [ CONFVAR VAL [...] ]
                              #  - config set CONFVAR VAL: some differences with CONFFILE:
                              #     - cannot use human readable size
                              #     - save UINT UINT2; save UINT3 UINT4 -> save UINT UINT2 UINT3 UINT4
                              #  - config rewrite: 
                              #     - overwrite CONFFILE according to changes made with config set
                              #     - tries to conserve comments, etc. as much as possible


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          CONNECTIONS          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


CONNECTION ==>                #Server connection at CONFVAR:
                              #  - bind (def: 127.0.0.1, can be several): address
                              #  - port (def: 6379)
                              #  - unixsocket: optional
                              #  - unixsocketperm
                              #REDIS_URL: redis://USER:PASSWORD@HOST:PORT/DATABASE_NUM
                              #CONFVAR maxclients:
                              #  - def: ulimit -Sn minus 32
                              #  - by def., tries to do ulimit -n 10032
                              #     - can use /etc/default/redis-server with ULIMIT = n to call ulimit when redis-server is 
                              #       called
                              #  - when reaching limit, close new connections with ERROR
                              #CONFVAR tcp-backlog (def: 511): seems linked to max. number of connections, but not sure.
                              #Commands:
                              #  - client pause UINT:
                              #     - stops all interaction clients-server (except slaves) for UINT ms, then resume them 
                              #       normally
                              #     - returns "OK"
                              #     - used for maintainance:
                              #        - instead of stopping the server alltogether
                              #        - e.g. during failover: waiting for slaves to get all streams (using info replication), 
                              #          then switching everyone to new master
                              #  - client kill ...:
                              #     - ... can be:
                              #        - addr IP:PORT
                              #        - id UINT
                              #        - type "normal|pubsub|slave"
                              #        - skipme yes|no: if yes (def), client calling this command is not killed
                              #     - returns number of clients killed
                              #     - wait for ongoing client command to end
                              #  - client list: returns STR where each line is one client with VAR=VAL ...:
                              #     - id UINT
                              #     - addr IP:PORT
                              #     - fd NUM
                              #     - name STR (def: ""): must use command client setname|getname
                              #     - age UINT: how many sec. connected
                              #     - idle UINT
                              #     - flags STR:
                              #        - "N": no flag
                              #        - "M": master
                              #        - "O": slave in monitor mode
                              #        - "S": slave not in monitor mode
                              #        - "x": transaction ongoing
                              #        - "d": transaction that will fail due to watch ongoing
                              #        - "c|A": transaction to be closed [ASAP]
                              #        - "b|u": [stops to] wait in a blocking operation
                              #     - db UINT
                              #     - [p]sub UINT
                              #     - multi: -1 if not in transaction
                              #     - qbuf[-free] UINT: input buffer size used|allowed
                              #     - omem UINT: output buffer size
                              #     - obl UINT: output buffer length
                              #     - oll UINT: output list length
                              #     - events "r|w": client socket is readable|writable
                              #     - cmd STR: last command played
                              #  - info clients: connected_clients, blocked_clients, client_longest_output_list, 
                              #    client_biggest_input_buf
                              #Output buffers:
                              #  - output from server to client is buffered, but could grow infinitely if gets too much input
                              #     - should only happen for pubsub or slaves, since normal clients wait for answer to reply
                              #  - CONFVAR client-output-buffer-limit CLASS SIZE SIZE2 UINT:
                              #     - closes client connection if:
                              #        - buffer grows of SIZE2/UINT sec. (0 to disable)
                              #        - or buffer grows over SIZE (0 to disable)
                              #     - CLASS is the type of client: normal (def: 0 0 0), pubsub (def: 32MB, 8MB/min), 
                              #       slave (def: 256MB, 64MB/min)
                              #Performance CONFVAR:
                              #  - timeout NUM (in sec., def: 0, i.e. none): closes client connection after idle time
                              #    (approx. time) (not pubsub clients)
                              #  - tcp-keepalive NUM (in sec., def: 0)
                              #Closing commands:
                              #  - quit: single-client stop. Ask server to flushes pending replies, then quit. Returns "OK"
                              #  - shutdown [save|nosave] (fired by SIGTERM): all clients stop:
                              #     - wait for clients to stop
                              #     - sync. save RDB (if used, unless|if save|nosave is used)
                              #     - flush AOF (if used)
                              #     - kill Lua scripts with script kill
                              #     - removes pid file and (if used) Unix socket
                              #     - returns STR if error, e.g. can't save (nothing if success)
                              #If client loses connection, just return ERROR until connection is established again.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          DURABILITY           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


DURABILITY ==>                #Runtime is only in-memory.
                              #But can do persistence on-disk with (can do both):
                              #  - RDB: 
                              #     - point-in-time snapshots/backups
                              #        - when restarts, read state from RDB file
                              #     - how:
                              #        - [bg]save command: [a]sync. save (prefer bgsave) returning "OK"
                              #           - CPU-intensive, can stop the database for up to one second
                              #        - background save requires:
                              #           - /etc/sysctl.conf vm.overcommit_memory = 1
                              #              - then reboot or sysctl vm.overcommit_memory=1
                              #           - so fork doesn't multiply memory by 2 (share parent's memory)
                              #        - CONFVAR save UINT UINT2:
                              #           - checks every UINT seconds if UINT2 keys were changed, then bgsave
                              #           - can be set up several times
                              #           - def: 10000keys/min, 10keys/5min, 1key/15min
                              #        - CONFVAR stop-writes-on-bgsave-error yes (def):
                              #           - returns ERROR on any write after a bgsave error, until a new bgsave succeeds
                              #        - CONFVAR:
                              #           - dbfilename (def: "dump.rdb")
                              #           - dir (def: "/var/lib/redis/"): also for AOF
                              #           - rdbcompression yes (def)
                              #           - rdbchecksum yes (def)
                              #              - can check file with redis-check-dump DUMPFILE
                              #  - AOF ("Append only file"): 
                              #     - logs every write command received before being performed (similar to PostgreSQL WAL)
                              #        - if crash and restart, replay the AOF instead of reading the RDB file
                              #        - slower restart than RDB alone
                              #        - but stronger garentee (do not lose anything if crash)
                              #     - how:
                              #        - CONFVAR appendonly yes
                              #        - CONFVAR appendfilename (def: "appendonly.aof")
                              #        - command bgrewriteaof (returns "OK"): refactor AOF (remove unnecessary commands)
                              #           - automatically done when AOF has grown more than:
                              #              - CONFVAR auto-aof-rewrite-min-size SIZE (def:64mb)
                              #              - and CONFVAR auto-aof-rewrite-percentage NUM (def: 100)
                              #        - CONFVAR appendfsync controls flushing to AOF:
                              #           - no: let OS flush, very fast
                              #           - everysec: flushes every sec., not too slow
                              #           - always: always flushes, very slow
                              #        - CONFVAR no-appendfsync-on-rewrite yes:
                              #           - put appendfsync to "no" if bgsave or bgrewriteaof is being performed, to avoid
                              #             slowing down the database too much.
                              #           - Can last up to 30 secs, so should be avoided
                              #        - if crash while writing AOF:
                              #           - make backup of AOF to OLD_AOF
                              #           - do command line redis-check-aof AOF --fix
                              #           - check diff OLD_AOF NEW_AOF
                              #Should:
                              #  - no RDB nor AOF if no care of durability
                              #  - RDB alone if several hours loss is ok
                              #  - RDB+AOF if only 1 minute to few secs. loss is ok
                              #Info:
                              #  - command lastsave: 
                              #     - returns Unix time UINT3 for last successful save 
                              #     - can be used to check if bgsave succeeded
                              #  - command info persistence:
                              #     - loading: if loading RDB, also:
                              #        - loading_start_time
                              #        - loading_total_bytes
                              #        - loading_loaded_bytes|perc
                              #        - loading_eta_seconds
                              #     - rdb_bgsave_in_progress
                              #     - rdb_changes_since_last_save: number of operations since last save
                              #     - rdb_last|current_bgsave_status|time_sec
                              #     - aof_enabled: if enabled also:
                              #        - aof_base|current_size
                              #        - aof_pending_rewrite
                              #        - aof_[rewrite_]buffer_length
                              #        - aof_pending_bio_fsync
                              #        - aof_delayed_fsync
                              #     - aof_rewrite_in_progress|scheduled
                              #     - aof_last|current_rewrite_time_sec
                              #     - aof_last_[bgre]write_status


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          REPLICATION          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


REPLICATION ==>               #Principles:
                              #  - RDB shipping on first connection, async. log shipping after
                              #     - there is a loss window in the time to ship log
                              #  - goal: 
                              #     - high availability (failover)
                              #     - scalability (read-only slaves)
                              #How:
                              #  - command slaveof HOST PORT:
                              #     - if slaveof no one, turn slave to master:
                              #        - turns down replication to former master, but do not discard it, so can rebecome a 
                              #          slave if former master is back
                              #     - can make a slave to another slave
                              #     - can also use CONFVAR slaveof IP PORT
                              #  - steps:
                              #     - init or when connection lost then regained again:
                              #        - full (sync command):
                              #           - master does bgsave then ships RDB to all slaves that apply it:
                              #              - while waiting for RDB or when connection is lost, they serve old version of RDB 
                              #                if CONFVAR slave-serve-stale-data yes (def) or respond with ERROR if no
                              #              - while applying it, they block queries
                              #        - partial (psync command):
                              #           - only for reconnection, faster (do not reload everything)
                              #           - master accumulates log during connection lost:
                              #              - up to CONFVAR repl-backlog-size SIZE (def: 1MB). 
                              #                If more, force a full sync instead of psync.
                              #              - removes any accumulated log if no more slaves for more than 
                              #                CONFVAR repl-backlog-ttl (def: 3600)
                              #     - then:
                              #        - gets and applies async. log shipping from master
                              #  - Consider connection broken according to:
                              #     - CONFVAR repl-ping-slave-period UINT (def: 10, in secs): pings from slaves to master
                              #     - CONFVAR repl-timeout UINT (def: 60)
                              #  - slaves are conceptually read-only:
                              #     - only master should get write operations, so it's propagated to all slaves
                              #     - can use CONFVAR slave-read-only no (def: yes) to allow slave-specific write operations:
                              #        - like info about master reachability (to coordinate failover strategy)
                              #        - but not usual write operations (would not propagate)
                              #  - CONFVAR on clients:
                              #     - repl-disable-tcp-nodelay (def: no, which should be good)
                              #  - info:
                              #     - command roles returns [ "master|slave|sentinel", OFFSET, [ HOST, PORT, OFFSET2 ]... ]
                              #         - difference OFFSET - OFFSET2 show difference slave-master
                              #         - HOST:PORT are slaves (when master)
                              #     - command info replication: roles, master_host|port, master_link_status, 
                              #       master_last_io_seconds_ago, master_sync_in_progress, connected_slaves,
                              #         - master_sync_left_bytes and master_sync_last_io_seconds_ago: if sync
                              #         - master_link_down_since_seconds: if down
                              #         - slaveNUM: id, ip, address, port, state
                              #     - redis-cli --slave: simulate slave, showing commands received from master


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          AVAILABLITY          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


HIGH AVAILABILITY ==>         #Each redis-server should also launch a sentinel:
                              #  - uses redis-server SENTCONF --sentinel:
                              #     - like CONFFILE, but for sentinels
                              #     - redis-sentinel SENTCONF is a shortcut
                              #  - works like redis-server in terms of protocol, but uses SENTVAR port (def: 26379) 
                              #    All sentinels should use same port.
                              #  - uses SENTVAR dir (def: "/tmp")
                              #A sentinel determines if master looks down:
                              #  - checks SENTVAR sentinel monitor MASTER HOST PORT UINT (def: localhost and 2):
                              #     - at least UINT sentinels needs to think the master look down to start failover
                              #  - is consider down if:
                              #     - down more than SENTVAR sentinel down-after-milliseconds MASTER UINT seconds (def: 30)
                              #  - then:
                              #     - the slave with lower CONFVAR slave-priority UINT (def: 100, 0 to disable) is promoted 
                              #       master
                              #     - other slaves are configured to new master, at most SENTVAR sentinel parallel-sync UINT
                              #       at a time (def: 1)
                              #  - the sentinel in charge:
                              #     - increment the CONFEPOCH, which is the version of the SENTINELFILE (changed on disk too)
                              #     - the other sentinels wait for the sentinel in charge to operate for SENTVAR
                              #       failover-timeout UINT, then try themselves (one at a time)
                              #  - can specify those SENTVAR for several MASTER
                              #  - only need to specify masters (slaves and failovers are auto-discover)
                              #Can simulate crashes with command debug segfault
                              #Can setup notifications:
                              #  - SENTVAR sentinel client-reconfig-script MASTER FILE, will fire 
                              #      FILE MASTER "leader|observer" "failover" OLD_IP NEW_IP OLD_PORT NEW_PORT
                              #    on failovers where:
                              #      - FILE is e.g. Bash
                              #      - leader is whether the current sentinel is in charge of failover
                              #      - IP|PORT are of the master
                              #  - SENTVAR sentinel notification-script MASTER FILE, will fire FILE EVENT_TYPE EVENT_DESC
                              #    on any event (see below)
                              #  - those scripts:
                              #      - must run in 60s
                              #      - will be retried if exit code is 1
                              #CONFVAR on masters for partitions:
                              #  - min-slaves-to-write UINT: master do not allow write commands if <UINT slaves connected
                              #  - min-slaves-max-lag UINT: same for max lag in secs.
                              #  - goal:
                              #     - if partition (slaves lose connection to master, one is promoted) -> two partitions with
                              #       masters. When merge, write info of one master will be lost.
                              #     - can prevent small partitions with less than majority of the system to allow writes
                              #       with those CONFVAR
                              #Commands when connected to a sentinel:
                              #  - ping: returns "PONG"
                              #  - sentinel master MASTER: returns info about MASTER
                              #  - sentinel masters: same as ARR
                              #  - sentinel slaves MASTER: returns list of slaves
                              #  - sentinel get-master-addr-by-name MASTER: returns IP:PORT
                              #  - sentinel reset MASTER_GLOB_STR: restart discovery process
                              #  - sentinel failover MASTER: forces a failover, good if need to reboot master
                              #Commands to update the SENTINELFILE (must be done on all sentinels):
                              #  - sentinel monitor MASTER IP PORT UINT: like sentinel monitor SENTVAR
                              #  - sentinel remove MASTER
                              #  - sentinel set SENTVAR VAL
                              #Pubsub events emitted by sentinels:
                              #  - they all get as message "master|slave" NAME IP PORT [@ MASTER IP PORT]
                              #  - can see events on sentinel log
                              #  - events: +reset-master, +slave, +failover-state-reconf-slaves, +failover-detected, 
                              #    +slave-reconf-sent|inprog|done, -dup-sentinel, +sentinel, +|-sdown, +|-odown, +new-epoch,
                              #    +try-failover, +elected-leader, +failover-state-select-slave, no-good-slave, selected-slave,
                              #    failover-state-send-slaveof-none, failover-end-for-timeout, failover-end, switch-master,
                              #    +|-tilt


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           CLUSTERS            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


PARTITIONS ==>                #Goal is to scale memory and CPU.
                              #Can be:
                              #  - range partioning: according to NUM ranges
                              #  - hash partioning: modulo of hash(KEY)
                              #Choosing the right Redis instance/partition can be done:
                              #  - client-side (Redis client)
                              #  - proxy-assisted (done by a proxy)
                              #  - query-routing: client sends to random redis server instance, which resends to the right 
                              #    instance
                              #Problems:
                              #  - disable operations with several keys (e.g. unions|intersections, or transactions with 
                              #    several keys)
                              #  - make backups, etc. spread accross several files
                              #  - when not implemented correctly, hard to scale (add|remove partitions)

REDIS CLUSTER ==>             #Allow master-master replication (write operations scaled on several masters) using hash 
                              #partioning with query-routing (with help from client-side)
                              #But still in alpha as of 3.0 beta8, should complete later (including info cluster, 
                              #redis-cli -c)


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             LOGS              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


LOGS ==>                      #CONFVAR:
                              #  - loglevel debug|verbose|notice (def)|warning
                              #  - logfile FILE (def: /var/log/redis/redis-server.log) ("" for stdout)
                              #  - syslog-enabled yes|no (def: no)
                              #    Uses /etc/logrotate.d/
                              #     - syslog-ident STR
                              #     - syslog-facility STR


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          MONITORING           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


LATENCY ==>                   #CONFVAR latency-monitor-threshold UINT (def: 0, e.g. disable): 
                              #  - record (in-memory) up to 160 operations with latency >= UINTms
                              #  - use commands:
                              #     - latency latest: [ EVENT_STR, TIMESTAMP, LATENCY, MAX_RECORDED_LATENCY ]
                              #     - latency history EVENT_STR: [ [ TIMESTAMP, LATENCY ]... ]
                              #     - latency reset EVENT_STR...
                              #     - latency graph EVENT_STR: ASCII graph
                              #     - latency doctor: human readable output

INFO ==>                      #Help commands:
                              #  - time: show current time as [ EPOCH_SEC, MICROSECS ]
                              #  - ping: returns "PONG". To check connection or latency.
                              #  - echo STR: same with STR
                              #Command info FIELD:
                              #  - server: redis_version, redis_mode, os, arch_bits, process_id, run_id, tcp_port,
                              #    uptime_in_seconds|days, hz, config_file
                              #  - all: for all FIELD (including some documented somewhere else in this doc)
                              #  - Command resetstat: reset all data collected by info FIELD
                              #Tools:
                              #  - redis-cli --latency[-history] [-i INTERVAL]: show latency at regular intervals
                              #  - redis-cli --intrinsic-latency NUM: NUM is how many seconds test last
                              #  - redis-stat: only monitoring tool I found that do not use command monitor (slow)

DEBUGGING ==>                 #Command monitor: print all commands received by server


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            LIMITS             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


LIMITS ==>                    #  - Databases: CONFVAR databases (def: 16)
                              #  - Set of databases: 2^32 keys (4 billions)
                              #  - Types:
                              #     - OBJ|LIST|SET|ZSET: 2^32 elements
                              #     - STR: 512MB
                              #     - INT: 64 bits signed
                              #     - UINT: 63 bits unsigned
                              #     - FLOAT: DOUBLE truncated to 17 decimals


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          PERFORMANCE          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


MEMORY ==>                    #CONFVAR maxmemory SIZE:
                              #  - goal is either to avoid crashes, or implement a LRU cache
                              #  - def: none on 64 bits, 3GB on 32 bits
                              #  - when over the limit, on write operation, does according to CONFVAR maxmemory-policy:
                              #     - volatile|all-lru (def: volatile-lru): removes last recently used VAR [with ttl]
                              #     - volatile|allkeys-random: removes any VAR [with ttl]
                              #     - volatile-ttl: removes VAR with lowest ttl
                              #     - noeviction: returns an ERROR
                              #  - notes:
                              #     - still return ERROR with other than "noeviction" if there are no suitable key to erase
                              #     - volatile-ttl and *-lru just pick among a random sample of CONFVAR maxmemory-samples
                              #       keys (def: 3)
                              #     - all maxmemory-policy but noeviction allow using Redis as a cache:
                              #        - all-lru is good for LRU cache
                              #        - allkeys-random is good for evenly distributed keyspace
                              #        - volatile-lru|random are good when mixing persistent and volatile keys, but should
                              #          prefer divide into two different Redis instances
                              #        - noeviction should be used if not used as a cache.
                              #  - if there are slaves, should let enough RAM memory for output buffers to slaves
                              #    (see CONFVAR client-output-buffer-limit slave)
                              #How to use less space/memory:
                              #  - use 32 bits CPU (but memory will be limited to 4GB)
                              #  - using BITSTR
                              #  - uses OBJ instead of namespaced STR
                              #Info:
                              #  - command dbsize returns number of keys
                              #  - command info keyspace: dbNUM: keys, expires, avg_ttl
                              #  - command info memory: used_memory[_rss|peak][_human], used_memory_lua,
                              #    mem_fragmentation_ratio
                              #      - if used_memory_rss > used_memory, means memory fragmentation (see also
                              #        mem_fragmentation_ratio)

COMMAND EXECUTION TIME ==>    #Slow commands:
                              #  - CONFVAR slow-log-slower-than UINT (microsecs, def: 10000, 0 for all, -1 for none) 
                              #  - Stored in memory:
                              #     - CONFVAR slowlog-max-len UINT (def: 128)
                              #       Command slowlog len -> UINT
                              #     - command slowlog reset
                              #  - Retrived with slowlog get [UINT] -> [ UINT2, TIMESTAMP, TIME_MICROSECS, COMMAND ]

OTHER PERF INFO ==>           #Command info FIELD:
                              #  - stats: total_connections_received, total_commands_processed, instantaneous_ops_per_sec,
                              #    rejected_connections, expired|evicted_keys, keyspace_hits|misses, pubsub_channels|patterns,
                              #    latest_fork_usec
                              #  - cpu: used_cpu_sys|user[_children]
                              #  - commandstats: cmdstat_COMMAND: calls, usec_per_call

TIPS ==>                      #  - Use pipelining
                              #  - when writing big chunks, should use protocol: write commands in a .txt file, and send it 
                              #    with ncap or (better) with redis-cli --pipe (will parse "inline version" of the protocol)
                              #  - most important factors: latency&bandwith > CPU > Mem speed
                              #  - Unix sockets faster that loopback
                              #  - Single threaded, so must launch 1 redis-server per CPU core (see Redis Cluster)
                              #  - put log files, RDB and AOF on same device
                              #  - don't use monitor in production, but info is fine
                              #  - CONFVAR hz (def: 10): raising will increase CPU usage but lower latency

redis-benchmark [...]         #Perform lot of operations, then report timing.
                              #Test are ping_inline|bulk, set, get, incr, lpush, lpop, sadd, spop, lrange_100|300|500|600,
                              #mset. Can also have custom operations with ..., e.g. redis-benchmark script load ARG
-h HOST
-p PORT
-s SOCKET
-c NUM                        #Number of clients at same time (def: 50)
-n NUM                        #Number of requests per test (def: 10000)
-P NUM                        #Pipeline NUM requests (def: 1, meaning no pipelining)
-d SIZE                       #Data size for get and set
-k 1|0                        #TCP keepalive (def: 1)
-r NUM                        #Uses random keys for get/set/incr, and values for sadd, accross NUM random possibilities.

-t TEST,...                   #Only run specific tests
-q                            #Short output
--csv                         #CSV output
-l                            #Run forever


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           SECURITY            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


SECURITY ==>                  #Clients can do anything on a set of databases, so must be trusted. So there should be an ACL 
                              #layer between end-clients and Redis server. Goal of Redis is performance, not security.
                              #Few CONFVAR:
                              #  - requirepass PASSWORD: 
                              #     - clients gets ERROR "NOAUTH" for all commands until they use auth PASSWORD 
                              #       (return ERROR or "OK")
                              #     - slaves can use CONFVAR masterauth PASSWORD, and sentinels SENTVAR sentinel auth-pass
                              #       MASTER PASSWORD
                              #     - should be very strong PASSWORD, since can bruteforce up to 150000/sec.
                              #  - rename-command COMMAND NEW_COMMAND:
                              #     - change command name (e.g. "config") to a random string, so it is still available for 
                              #       admin but hidden from clients
                              #     - change to "" to make it not available to everyone
                              #     - might cause problem if already existing AOF
                              #By def., does not use SSL because impact perf, needs to do it on top of it or (better) 
                              #communicate using the loopback (same machine).


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           PROTOCOLE           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


PROTOCOLE ==>                 #Is human-readable (client implement it, so should not need to know it) and case-insensitive.
                              #Structure:
                              #  - all lines terminated by \r\n
                              #Types:
                              #  +STR: cannot contain \r or \n
                              #
                              #  -ERROR MESSAGE: cannot contain \r or \n
                              #
                              #  :INT: use as BOOL (0|1) often
                              #
                              #  $LENGTH
                              #  STR: "bulk strings", can contain \r or \n. Good also for big sized data.
                              #
                              #  *LENGTH
                              #  ...: arrays of any type above
                              #
                              #Special:
                              #  - null is either:
                              #     - (preferred) STR with LENGTH -1, i.e. $-1
                              #     - ARR with LENGTH -1, i.e *-1
                              #Clients:
                              #  - sends commands and arguments as STR_ARR ("bulk strings")
                              #  - can also just send command and args as is with newline ("inline version" of the protocol):
                              #    slower but easier (is same as redis-cli)
                              #Can pipeline:
                              #  - client sends several commands, and server will respond with several responses in same order
                              #  - good to minimize network roundtrips

TYPES ==>                     #Input|output types: see protocol
                              #Input types are sent as STR_ARR (see above), but redis-server reinterpret STR according to 
                              #those higher-level types:
                              #  - STR: 
                              #     - STR_LIT are "..." or (escape everything then) '...'
                              #     - According to clients (case of redis-cli):
                              #        - Can contain slash escaped sequences (protocol uses binary)
                              #        - Uses UTF8 (protocol does not care about encoding)
                              #  - BITSTR: actually STR (can BITSTR->STR and STR->BITSTR)
                              #  - INT|FLOAT: actually STR (can INT->FLOAT, but not FLOAT->INT)
                              #  - OBJ: keys and values are STR ("hashes")
                              #  - LIST: STR_ARR
                              #  - SET: STR_ARR with unique values
                              #  - ZSET: STR_ARR with unique values and sorted according to individual NUM scores
                              #  - HYPERLOGLOG: like SET, but specialized for counting number of unique elements:
                              #     - must faster
                              #     - but only 99% approximation
                              #     - and can only add elements and retrieve number of elements
                              #Often keys use namespaces separated with ":"
                              #Usual types:
                              #  - ERROR is usually returned if wrong type.
                              #  - Unless specified otherwise:
                              #     - first argument is always a VAR
                              #     - others LIT if native type, VAR otherwise

TIME COMPLEXITY ==>           #Of commands are written like this:
                              #O(1)
                             n#O(n)
                            1n#O(1) for STR, O(n) for others
                             l#O(log(n))
                             m#O(n*log(n))


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:         TRANSACTIONS          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


multi                         #Make several commands ... atomic. Single commands are always atomic.
...                           #Discard means ... is not performed.
exec|discard                  #Return values:
                              #  - multi and discard returns "OK".
                              #  - ... commands returns "QUEUED"
                              #  - exec returns ... commands results as ARR (if some results are ARR2, returns ARR_ARR2)
                              #Blocking: 
                              #  - ... is only performed once exec is sent.
                              #  - it blocks the whole database (like an atomic operation)
                              #  - If only one operation, does not block more than a normal atomic operation
watch VAR...                  #Make exec fail (returns null) if any VAR... are modified between watch and exec.
                              #Returns "OK"
                              #Goal:
                              #  - to provide garentee VAR... are read-only, without blocking the whole database.
                              #  - means that multi ... exec can be kept smaller
                              #Should watch before multi, and keep multi ... exec as small as possible.
unwatch VAR...                #Returns "OK". Automatically called by exec|discard.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            GENERAL            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


type VAR                      #Returns TYPE "string|list|set|zset|hash" or "none" if does not exist.
object idletime VAR           #Number of seconds (resolution of 10 sec) since VAR has been read|write
                              #(except by object idletime)

rename VAR VAR2               #Like mv VAR VAR2
                              #Returns "OK" or ERROR if VAR not existing or VAR == VAR2
renamenx VAR VAR2             #Same but:
                              #  - do not overwrite if VAR2 exists
                              #  - returns false if VAR2 existed

move VAR UINT                1#Moves VAR to database numero UINT.
                              #Returns false if problem, e.g. key already exist in database UINT, or VAR does not exist.
flush[db|all]                 #Remove all keys from current|all databases

dump VAR                    1n#Returns serialized VAR as STR:
                              #  - is RDB format with a checksum
                              #  - does not contain ttl info
restore VAR UINT STR        1n#Deserialize STR to VAR, with ttl UINT (in ms, 0 for no ttl)
                              #Returns "OK", or ERROR if checksum not validated.
migrate HOST PORT VAR UINT  1n#Moves VAR to another set of databases at HOST:PORT, database number UINT:
UINT2 [copy] [replace]        #  - dump VAR, then restore VAR, then del original VAR
                              #  - UINT2 is idle time timeout (in ms) (not total transfer time timeout)
                              #  - returns "OK" if success or ERROR:
                              #     - if "IOERR", original VAR still exist, but dest VAR may or may not exist
                              #     - any other ERROR: dest VAR do not exist
                              #     - do not overwrite dest VAR
                              #Options:
                              #  - "copy": do not del original VAR
                              #  - "replace": let overwrite dest VAR

keys GLOB_STR                n#Returns keys from current database matching GLOB, as STR_ARR
                              #Very slow, should be used in dev. only (use SET for production)
randomkey                     #Returns random VAR key from current database.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            EXPIRE             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


exists VAR                    #Returns true if VAR exists
del VAR...                  1n#Erases keys, if it exists. Returns number of keys removed
[p]expire VAR UINT            #Fire del VAR in UINT [milli]seconds
                              #Only operations that removes countdown: persist [get]set (not incr, lpush, rename nor hset)
                              #Returns false if VAR does not exist or ttl could not be set.
[p]expireat VAR UINT          #Same but with a Unix timestamp.
[p]ttl VAR                    #Returns VAR expire countdown in [milli]seconds and:
                              #  -1 if no ttl
                              #  -2 if not existing
persist VAR                   #Removes ttl
                              #Returns false if VAR does not exist or have no ttl


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:              STR              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


set STR STR2 [ex|px NUM]      #Like STR = STR2.
[nx|xx]                       #  - ex|px NUM: calls [p]expire STR NUM
                              #  - nx|xx: only if STR [does not] exist
                              #If VAR is from another TYPE, still makes it a STR.
                              #Returns "OK" or, if problem (e.g. with nx|xx), null.
get STR                       #Returns STR value or, if not existing, null.
getset STR STR2               #Like set, but returns old value STR. No ex|px|nx|xx arguments
mset[nx] STR STR2 ...        n#Do several set ...
                              #If nx: only if all STR don't exist
                              #Returns "OK"
mget STR...                  n#Do several get ..., returned as STR_ARR

incrby|decrby INT NUM         #Like INT += NUM or -= NUM
                              #If INT does not exist, set to 0.
                              #Returns new INT value
incr|decr INT                 #Same as incrby|decrby INT 1
incrbyfloat FLOAT FLOAT2      #Same but with FLOAT

strlen STR                    #Return byte size INT (0 when does not exist)
setrange STR OFFSET STR2      #Sets part of STR, i.e. STR[OFFSET] = STR2
                              #  - if OFFSET too big, fills STR with \0
                              #  - works on non-existing STR
                              #Returns new strlen STR
                              #Simple LIST using setrange|getrange|append|strlen (with fixed size element) is faster 
                              #(but less functionality)
getrange STR INT INT2        n#Returns part of STR from INT included to INT2 excluded
                              #INT[2] can be negative (from end)
append STR STR2               #Like STR += STR2
                              #If any not existing -> ""
                              #Returns new length.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            BITSTR             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


getbit BITSTR UINT            #Return bit number UINT.
                              #If out of range, or not existing, returns 0.
setbit BITSTR UINT 1|0        #Sets bit number UINT.
                              #If out of range, or not existing, fills with 0 before.
                              #Returns original bit.
bitpos BITSTR 1|0            n#Returns bit position of first 1|0 bit, from byte INT included to INT2 excluded (def: all).
[INT INT2]                    #Position is always relative to beginning of BITSTR, not INT.
                              #If 1 and there are no 1, returns -1
                              #If 0 and there are no 0:
                              #  - if INT INT2, returns -1
                              #  - otherwise, returns BITSTR bit size + 1
bitcount BITSTR [INT INT2]   n#Returns number of 1 bits in BITSTR, from byte INT included to INT2 excluded (def: all)
                              #INT[2] can be negative (from end)
                              #Returns 0 if not existing
bitop and|or|xor BITSTR      n#Assigns to BITSTR (creates if not existing)
BITSTR2...                    #If not same length or not existing, zero padds.
bitop not BITSTR BITSTR2     n#Returns new BITSTR length


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:              OBJ              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


hset[nx] OBJ VAR STR          #Like OBJ.VAR = STR
                              #Returns false if OBJ.VAR already existed so has [not] been overwritten
hget OBJ VAR                  #
hmget OBJ VAR ...            n#
hmset OBJ VAR STR ...        n#
hdel OBJ VAR...              n#
hexists OBJ VAR               #
hincrby[float] OBJ VAR 
INT|FLOAT                     #Similar than version without h but for OBJ.VAR

hlen OBJ                      #Returns number of keys (0 if OBJ does not exist) (an OBJ with no member does not exist)
hgetall OBJ                  n#Returns all keys and values as STR_ARR: [ KEY1, VALUE1, KEY2, VALUE2 ... ]
hkeys OBJ                    n#Returns all keys as STR_ARR
hvals OBJ                    n#Returns all values as STR_ARR


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             LIST              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


l|rpush[x] LIST STR...        #Insert values.
                              #If LIST does not exist if no x, -> [], if x, do not do anything.
                              #Returns new length.
l|rpop LIST                   #Removes and return value STR (null if empty or not exists)
rpoplpush LIST LIST2          #Does lpush(LIST2, rpop(LIST))
                              #LIST can == LIST2, doing rotation on the LIST.
                              #If LIST does not exist, does not do anything.
                              #Returns element being popped|pushed

llen LIST                     #Returns length (0 if not exists)
lindex LIST INT              n#Returns LIST[INT] (null if not existing or out of range)
                              #INT can be negative (from end)
                              #Slower to access the middle.
lset LIST INT STR            n#Like lindex(LIST, INT) = STR
                              #Returns "OK" or ERROR if out of range.
                              #Slower to access the middle.
linsert LIST before|after    n#Look for first STR in LIST from beginning to end, and insert STR2 before|after
STR STR2                      #Returns new length, or -1 if STR not found.
lrange LIST INT INT2         n#Returns part of LIST as STR_ARR, from INT included to INT2 included.
                              #INT[2] can be negative (from end)
                              #Out of range is just rest to end of LIST.
ltrim LIST INT INT2          n#Like LIST = lrange(...)
lrem LIST INT STR            n#Removes elements == STR:
                              #  - if +INT, INT first elements
                              #  - if -INT, INT last elements
                              #  - if 0, all elements
                              #Returns number of removed elements.
                              #If not existing, do not do anything.

blpop|brpop LIST... UINT      #Do lpop|rpop from the first LIST... that is existing and not empty.
                              #Returns [ LIST_STR, VAL_STR ]
                              #If no LIST... are existing and not empty, blocks until one does, or until timeout UINT seconds
                              #(0 for no timeout) (in which case it returns null). 
                              #If several clients were blocked, the first that asked for it gets it, the other remain blocked.
                              #Used to get notified of LIST changes.
brpoplpush LIST LIST2 UINT    #Like blpop, but for rpoplpush.
                              #As opposed to blpop, if client dies, notification (pushing to LIST2) is still performed, which
                              #makes it more suitable for reliable notification queues.
                              #Returns element being popped|pushed or null if timeout.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:              SET              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


sadd SET STR...              n#Adds to SET if not duplicate.
                              #Returns number of new elements
srem SET STR...              n#Removes to SET if in there.
                              #Returns number of removed elements
scard SET                     #Returns length
smembers SET                 n#Returns all elements as STR_ARR
sismember SET STR             #Returns true if is part of SET

sunion|sinter|sdiff SET...   n#Returns combination as SET2
sunion|sinter|sdiffstore 
SET2 SET...                  n#Same but store result in SET2 instead, and return SET2 length.

srandmember SET [INT]        n#Returns INT random elements from SET as STR_ARR:
                              #  - if positive, can't return duplicates, if negative, can.
                              #  - if no INT, return single one as STR
                              #Returns null or [] if SET has no members.
spop SET                      #Same as srandmember SET, but remove element then.
smove SET SET2 STR            #Moves member STR of SET to SET2.
                              #Returns false if problem, including if STR is not in SET.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             ZSET              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


zadd ZSET SCOR_FLOAT STR ... l#Adds STR to ZSET, with SCORE. FLOAT can be "+|-inf"
                              #SCORE orders from -inf to +inf. If same SCORE, orders according to STR key, byte-wise 
                              #("lexicographical ordering")
                              #If STR already exist in ZSET, update SCORE.
                              #Returns number of new elements.
zincrby ZSET FLOAT STR       l#Adds FLOAT to the SCORE of STR in ZSET.
                              #Returns new SCORE.

zscore ZSET STR               #Returns member SCORE (null if not existing).
z[rev]rank ZSET STR          l#Returns member [reverse] sorted position (null if not existing)

z[rev]range ZSET INT INT2    l#Like srange but for a ZSET, [inverse] sorted
[withscores]                  #If "withscores", returns [ VAL, SCORE ... ] instead of [ VAL... ]
z[rev]rangebyscore ZSET       #Same but using scores, not position.
FLOAT FLOAT2 [withscores]     #FLOAT[2]:
[limit UINT UINT2]            #  - are min|max scores
                              #  - are inclusive, or if "(FLOAT", exclusive
                              #  - can be +|-inf
                              #Can add then an offset UINT (can be 0) then only take UINT2 max elements.
zrangebylex ZSET STR STR2     #Like zrangebyscore, but using lexicographical ordering instead.
[limit UINT UINT2]            #Only works if all elements in ZSET must have same SCORE.
                              #STR[2]:
                              #  - are min|max
                              #  - are inclusive if [STR, exclusive if (STR
                              #  - can be - + (like -inf|+inf)

zcard ZSET                    #Returns number of elements
zcount ZSET FLOAT FLOAT2     l#Returns length of zrangebyscore ... result
zlexcount ZSET STR STR2      l#Returns length of zrangebylex ... result

zrem ZSET STR...             m#Removes element. Returns number of removed elements.
zremrangebyrank ZST INT INT2 l#
zremrangebyscore ZSET 
FLOAT FLOAT2                 l#
zremrangebylex ZSET STR STR2 l#Same but according to range returned by zrange[byscore|bylex] ...

zunionstore|zinterstore      m#Stores in ZSET the union|intersection of ZSET2... (UINT if number of ZSET2...)
ZSET UINT ZSET2...            #Each ZSET2 gets its SCORE multiplied with a FLOAT (def: 1), then take the sum|min|max with 
[weights FLOAT...]            #other ZSET2 (def: sum)
[aggregate sum|min|max]       #Returns number of elements in ZSET.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          HYPERLOGLOG          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


pfadd HYPERLOGLOG STR...      #Add STR element. Returns false if duplicate.
pfcount HYPERLOGLOG...        #Returns number of elements in union of HYPERLOGLOG...
                              #Using several HYPERLOGLOG.. or pfmerge are much slower.
pfmerge HYPERLOGLOG
HYPERLOGLOG2...              n#Store union of HYPERLOGLOG2... in HYPERLOGLOG. Returns "OK"


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          SORT & SCAN          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


sort LIST|SET|ZSET           m#Sort:
[by STR]                      #  - if:
[limit UINT UINT2]            #     - no by STR, by the values
[get STR ...]                 #     - by STR with glob *, replace * with each value, and use this to sort
[asc|desc] [alpha]            #       (e.g. weight_* -> weight_VALUE for each value)
[store LIST|SET|ZSET]         #     - by STR with no glob *, do not sort
                              #  - in numerical ordering or if "alpha" lexicographical ordering.
                              #  - result is:
                              #     - if no get STR, LIST|SET|ZSET, after sorting
                              #     - if get STR with glob *:
                              #        - replace * with each value, and use this as result value instead
                              #        - if several get STR, returns ARR with n times more values
                              #        - can use "#" to mean LIST|SET|ZSET
                              #  - return result or if "store" put in destination.
                              #  - with glob *, can use ->VAR for an OBJ, e.g. weight_*->VAR, if weight_* returns an OBJ
                              #Can add then an offset UINT (can be 0) then only take UINT2 max elements.

scan UINT [match GLOB_STR]    #Iterates over keys of current database, matching GLOB_STR
[count UINT3]                 #Needs to call it several times to return all elements:
                              #  - better performance than long-blocking functions like keys or smembers 
                              #  - but don't provide consistent snapshot (because spread over time):
                              #     - might return duplicates
                              #     - elements that disappear at some point might not appear
                              #  - UINT is the current cursor (start at 0, and returns UINT2 to use for next iteration)
                              #    When iteration if finished, returnes 0 as UINT2
                              #Returns [ UINT2, ARR ], where ARR are the keys of current database.
                              #Number of elements returned:
                              #  - can be hinted by UINT3 (def: 10), but just a hint: might be less, more (especially if small)
                              #    or even 0
hscan OBJ ...                 #
sscan LIST ...                #Same as scan ... but over the elements of an OBJ|LIST|ZSET
zscan ZSET ...                #OBJ returned ARR is [ VAR VAL ... ], ZSET [ VAL SCORE ... ], SET [ VAL ... ]


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            PUBSUB             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


subscribe CHANNEL_STR...     n#Waits for another client to do publish ...
unsubscribe [CHANNEL_STR...] n#Hangs and returns for each event:
publish CHANNEL_STR STR2     n#  - [un]subscribe (for each CHANNEL): [ "[un]subscribe", CHANNEL_STR, UINT ], 
                              #    where UINT is number of subscribed channels
                              #  - message: [ "message", CHANNEL_STR, STR2 ]
psubscribe CHNEL_GLOB_STR... n#Same but:
punsubscribe                  #  - CHANNEL_GLOB_STR can use globbing (good for events namespaces)
[CHANNEL_GLOB_STR...]         #  - events are:
                              #     - [un]subscribe (for each CHANNEL): [ "p[un]subscribe", CHANNEL_GLOB_STR, UINT ], 
                              #     - message: [ "pmessage", CHANNEL_GLOB_STR, CHANNEL_STR, STR2 ]
pubsub channels 
[CHANNEL_GLOB_STR]           n#Returns current channels as STR_ARR
pubsub numsub CHANNEL_STR... n#Returns number of subscription for those channels as [ CHANNEL_STR UINT ... ]
pubsub numpat                 #Returns number of active psubscribe

notify-keyspace-events        #CONFVAR that allow listening for some builtins messages.
                              #Are letters (def: ""):
                              #  - "K": __keyspace@NUM__:VAR events, with message COMMAND at database NUM
                              #  - "E": __keyevent@NUM__:COMMAND events, with message VAR
                              #Then letters:
                              #  - "A": all commands
                              #  - "$": STR commands
                              #  - "l": LIST commands
                              #  - "s": SET commands
                              #  - "h": OBJ commands
                              #  - "z": ZSET commands
                              #  - "x": expired event
                              #  - "e": evicted event
                              #  - "g": other commands (del, rename, etc.)
                              #All COMMAND that modifies KEY (only if modified) generate COMMAND events. Exceptions:
                              #  - del event: anything that erases|overwrites a key
                              #  - hdel event: when erasing OBJ.VAR
                              #  - set event: set, getset, mset
                              #  - hset event: hset, hmset
                              #  - [h]incrby event: [h]incr|decr[by]
                              #  - rename_from|to events: rename
                              #  - r|lpush event: r|lpush[x]
                              #  - [b]rpoplpush -> lpush then rpop events
                              #  - smove -> sadd then srem events
                              #  - expire event: [p]expire
                              #  - expired event: when a key is deleted because of expiration. It is not an end of countdown
                              #    but either:
                              #     - when expired key is being accessed
                              #     - when expired key is being garbage collected
                              #  - evicted event: when key erased because of maxmemory
                              #  - no events: move, restore, migrate


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            CLIENTS            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


redis-cli [...]               #Command line client (connects to a set of databases)
                              #Can send command ... or use CLI
-h HOSTNAME                   #Def: 127.0.0.1
-p PORT                       #Def: 6379
-s UNIXSOCKET                 #Optional

--pipe                        #Read from stdin, and stdout (not stderr) to /dev/null
-x                            #Read last arg from stdin
-r NUM                        #Repeats command, with -i INTERVAL_DOUBLE (def: 0)

-a PASSWORD                   #Do auth PASSWORD
-n NUM                        #Do select NUM (def: 0)
--scan                        #Do a serie of scan. Can use --pattern GLOB

--raw                         #Raw output (def)
--csv                         #CSV output


REDIS                         #Node.js client (0.10.3)
                              #Should also install HIREDIS, to make it faster.
REDIS.createClient            #Returns CLIENT
([PORT[, HOST[, PARAM_OBJ]]]) #Def HOST:PORT is 127.0.0.1:6379. Can use SOCKET_PATH instead of PORT, HOST
                              #PARAM_OBJ:
                              #  - auth_pass PASSWORD: can also use CLIENT.auth(PASSWORD)
                              #  - socket_nodelay BOOL (def: true)
                              #  - socket_keepalive BOOL (def: true)
                              #  - enable_offline_queue BOOL (def: true): 
                              #     - if disconnected, buffer commands until reconnected
                              #     - can check CLIENT.offline_queue.length NUM
                              #  - connect_timeout UINT (def: false) and max_attemps UINT (def: false): 
                              #     - by def., will retry reconnecting forever. 
                              #     - The next try will be multiplied by CLIENT.retry_backoff (def: 1.7), up until 
                              #       retry_max_delay (def: null)
                              #     - Can check current CLIENT.retry_delay NUM
                              #  - family (def: "IPv4")
                              #All commands are async, meaning automatically pipelined (do not wait for answer to keep going)
CLIENT.COMMAND                #ARGS can be ARG_ARR or ARG...
(ARGS[, FUNC(ERROR, VAL)])    #Types:
                              #  - STR -> STR. 
                              #    If PARAM_OBJ.detect_buffers true (def: false), reply with BUFFER if ARGS used BUFFER
                              #  - INT -> INT
                              #  - null -> null
                              #  - LIST|SET|ZSET -> ARR
                              #  - BOOL -> 1|0
                              #Syntax exceptions:
                              #  - COMMAND SUBCOMMAND -> CLIENT.COMMAND(SUBCOMMAND_STR, ...)
                              #  - hgetall|hmset use OBJ
                              #  - pubsub: CLIENT.on(EVENT_STR, FUNC(CHANNEL_STR, VAL)) and CLIENT.publish(...)
                              #  - transaction: 
                              #     - CLIENT.multi() and CLIENT.exec(FUNC(ERROR, ARR))
                              #     - Must use the CLIENT returned by CLIENT.multi(), and finish the chain with exec()
                              #  - CLIENT.on("monitor", FUNC(TIME, ...)): fired after CLIENT.monitor()
                              #Uses command chaining.
CLIENT.send_command
(COMMAND_STR, ARGS, FUNC(...))#Only if CLIENT.COMMAND() is not implemented yet

REDIS.print                   #Redis-specific alternative to console.log.bind( console )

CLIENT.on("ready", FUNC())    #Every CLIENT.* should be inside this.
CLIENT.on("connection",FUNC())#Like ready event but if PARAM_OBJ.no_ready_check false (def), checks if server is loading 
                              #RDB and waits then to emit.
CLIENT.on("error",FUNC(ERROR))#On connection error (otherwise crash Node)
CLIENT.on("end", FUNC())      #When connection ends
CLIENT.on("idle", FUNC())     #When no outstanding client commands waiting for answers
                              #Can also check CLIENT.command_queue.length NUM
CLIENT.on("drain", FUNC())    #Emitted when it is ok to stream commands???

CLIENT.end()                  #Like CLIENT.quit() but forces to quit (avoid).
CLIENT.unref()                #Unref underlying socket, allowing program to quit (automatically done by CLIENT.quit())

CLIENT.connected              #BOOL
CLIENT.server_info            #Result of command info all
