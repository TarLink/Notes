
              
   ALGORITHMS  
              



QUALITIES ==>                     #Qualities of an algorithm:
                                  #  - "optimality": best solution is found
                                  #  - "completeness": all solutions are found
                                  #  - "accuracy": results are close to solutions
                                  #  - "precision": results are close to each other
                                  #  - "complexity"/"efficiency" (see performance doc):
                                  #     - "parallelism" (see its doc)
                                  #     - "locality of reference" (see performance doc)
                                  #  - "persistence" (see state doc)

HEURISTIC ==>                     #Achieving high efficiency by trading off other qualities

GREEDINESS ==>                    #Heuristic using iteration:
                                  #  - each iteration picks candidate ("local optimum") that gets closer to solution
                                  #    ("global optimum")
                                  #  - if no candidate, stops
                                  #"Optimal substructure":
                                  #  - when each iteration
                                  #Often contrasted with recursion as another way to divide an algrithm

Dynamic programming|optimization:
  - "subproblem": input subset
  - breaking down input into smaller ones
  - saMe as "recursion"
  - "overlapping subproblem":
     - when input repeats itself at least partially
     - i.e. subproblem results can be memoized
     - i.e. dynamic programming might be better than greediness

RECURSION ==>                     #Algorithm that calls itself
                                  #Can be:
                                  #  - "divide and conquer":
                                  #     - start with subset of input, merged into bigger input
                                  #     - example: distribution sorts
                                  #  - "decrease and conquer":
                                  #     - start with whole input, divided into subsets
                                  #     - example: binary search
                                  #     - "prune and search": when doing it with constant factor
                                  #Pros:
                                  #  - parallelism
                                  #  - smaller problem
                                  #Cons:
                                  #  - stack size
