
                     
   SEARCH_ALGORITHMS  
                     



SEARCH KEY ==>                    #Arbitrary starting vertex of search

BRUTE FORCE ==>                   #Trying all combinations|permutations
                                  #Also called "exhaustion".
                                  #Time complexity:
                                  #  - average|worst: O(mⁿ)
                                  #  - best: O(1)
                                  #Space complexity: O(1)
                                  #Can sort input:
                                  #  - so than can stop when > the searched value
                                  #  - to put more likely items first

LINEAR|SEQUENTIAL SEARCH ==>      #Brute force when trying to find an item in an array
                                  #Time complexity: O(n)

PRUNING ==>                       #During a search algorithm, skipping a node's descendants when they
                                  #can be guessed (from the parent's value) to be invalid.
                                  #Unless pruning can be done, search algorithms like BFS/DFS are conceptually a linear search.

BREADTH-FIRST SEARCH (BFS) ==>    #Search one level at a time, i.e.:
                                  #  - start at search key
                                  #  - visit each vertex with distance 1, then 2, etc.
                                  #Time complexity: O(order + size)
                                  #Space complexity: O(order)
                                  #Good when:
                                  #  - depth is big
                                  #  - searched value's height is probably high
                                  #Bad when:
                                  #  - space complexity is important
                                  #  - branching factor is big

DEPTH-FIRST SEARCH (DFS) ==>      #Search one path at a time (until cycle or dead-end), i.e.:
                                  #  - start at search key
                                  #  - visit vertex
                                  #  - if:
                                  #     - it has a leftmost non-visited child, repeat with that child
                                  #     - it is not the search key, repeat with parent ("backtrack")
                                  #     - it is the search key, stop
                                  #Also called "backtracking" when applying to more general algorithms
                                  #"Backjumping":
                                  #  - when it can known that a node and its descendants will be invalid because
                                  #    a siblings|cousin is invalid
                                  #Time complexity: O(order + size)
                                  #Space complexity: O(order)
                                  #Good when:
                                  #  - branching factor is big
                                  #  - searched value's height is probably low
                                  #Bad when:
                                  #  - depth is big

DEPTH-LIMITED SEARCH (DLS) ==>    #DFS where we stop when reaching a given depth.
                                  #Compensate some DFS problems but is an incomplete algorithm

ITERATIVE DEEPENING DFS (IDDFS)   #Running DLS iteratively with increasing depth.
 ==>                              #Also called "Iterative deepening search" (IDS)
                                  #Each iteration repeats DLS on nodes already visited:
                                  #  - cons: efficiency
                                  #  - pro: does not need to store nodes to know if already visited
                                  #I.e. has pros of BFS but without space complexity problem.

SEARCH TREE ==>                   #Ordered arborescence where left children < parent < right children.
                                  #Optimized for search algorithms
                                  #Most efficient when tree is balanced

BINARY SEARCH TREE ==>            #Search tree where outdegree = 2
                                  #Optimized for search ("binary search"):
                                  #  - in-order search starting from root
                                  #Time complexity:
                                  #  - search:
                                  #     - average:
                                  #        - if balanced: O(log n)
                                  #        - without proper balancing, height will average sqrt(order), and complexity O(sqrt n)
                                  #     - max: O(n)
                                  #        - i.e. search tree degenerated into a line graph
                                  #  - insert|delete:
                                  #     - like search
                                  #     - first search of it, then perform constant-time insert|delete
