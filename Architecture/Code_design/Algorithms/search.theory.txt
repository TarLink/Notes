
          
   SEARCH  
          



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GENERAL            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SEARCH KEY ==>                    #Arbitrary starting vertex of search

FINGER SEARCH ==>                 #Search where the search key ("finger") is provided.
                                  #Only efficient if search key is likely to be close to searched node.
                                  #Often implemented on linked lists, treaps, etc.

BRUTE FORCE ==>                   #Trying all combinations|permutations
                                  #Also called "exhaustion".
                                  #Time complexity:
                                  #  - average|worst: O(nᵐ)
                                  #  - best: O(1)
                                  #Space complexity: O(1)
                                  #Can sort input:
                                  #  - so than can stop when > the searched value
                                  #  - to put more likely items first

LINEAR|SEQUENTIAL SEARCH ==>      #Brute force when trying to find an item in an array
                                  #Time complexity: O(n)

PRUNING ==>                       #During a search algorithm, skipping a node's descendants when they
                                  #can be guessed (from the parent's value) to be invalid.
                                  #Unless pruning can be done, search algorithms like BFS/DFS are conceptually a linear search.

BREADTH-FIRST SEARCH (BFS) ==>    #Search one level at a time, i.e.:
                                  #  - start at search key
                                  #  - visit each vertex with distance 1, then 2, etc.
                                  #Time complexity: O(order + size)
                                  #Space complexity: O(order)
                                  #Good when:
                                  #  - depth is big
                                  #  - searched value's height is probably high
                                  #Bad when:
                                  #  - space complexity is important
                                  #  - branching factor is big

DEPTH-FIRST SEARCH (DFS) ==>      #Search one path at a time (until cycle or dead-end), i.e.:
                                  #  - start at search key
                                  #  - visit vertex
                                  #  - if:
                                  #     - it has non-visited children, repeat with the leftmost one
                                  #     - it is the search key, stop
                                  #     - otherwise, repeat with parent ("backtrack")
                                  #Also called "backtracking" when applying to more general algorithms
                                  #"Backjumping":
                                  #  - when it can known that a node and its descendants will be invalid because
                                  #    a siblings|cousin is invalid
                                  #Time complexity: O(order + size)
                                  #Space complexity: O(order)
                                  #Good when:
                                  #  - branching factor is big
                                  #  - searched value's height is probably low
                                  #Bad when:
                                  #  - depth is big

DEPTH-LIMITED SEARCH (DLS) ==>    #DFS where we stop when reaching a given depth.
                                  #Compensate some DFS problems but is an incomplete algorithm

ITERATIVE DEEPENING DFS (IDDFS)   #Running DLS iteratively with increasing depth.
 ==>                              #Also called "Iterative deepening search" (IDS)
                                  #Each iteration repeats DLS on nodes already visited:
                                  #  - cons: time complexity
                                  #  - pro: space complexity, i.e. does not need to store nodes to know if already visited
                                  #I.e. has pros of BFS but without space complexity problem.

LEFT-CHILD RIGHT-SIBLING (LCRS)   #Tree obtained from applying the "Knuth transform" on any rooted directed tree.
 TREE ==>                         #Knuth transform:
                                  #  - make each sibling point to next sibling
                                  #  - only keep edge from parent to first child
                                  #Also called "child-sibling representation", "doubly-chained tree", "filial-heir chain"
                                  #Consequences:
                                  #  - pro: result is a binary tree, which is more space efficient than a k-ary tree
                                  #     - i.e. not knowing each vertex's outdegree requires dynamic arrays, which require
                                  #       extra pointers and dope vectors
                                  #  - con: siblings must be accessed in serial access not random access

DATA STRUCTURES ==>               #See doc for data structures, e.g. search tree, hash table, trie.
