
              
   ALGORITHMS  
              



QUALITIES ==>                     #Qualities of an algorithm:
                                  #  - "optimality": best solution is found
                                  #  - "completeness": all solutions are found
                                  #  - "accuracy": results are close to solutions
                                  #  - "precision": results are close to each other
                                  #  - "complexity"/"efficiency"
                                  #     - "parallelism" (see its doc)

HEURISTIC ==>                     #Achieving high efficiency by trading off other qualities
                                  #"Greediness": heuristic using iteration:
                                  #  - each iteration picks candidate ("local optimum") that gets closer to solution
                                  #    ("global optimum")
                                  #  - if no candidate, stops

RECURSION ==>                     #Algorithm that calls itself
                                  #Can be:
                                  #  - "divide and conquer":
                                  #     - start with subset of input, merged into bigger input
                                  #     - example: distribution sorts
                                  #  - "decrease and conquer":
                                  #     - start with whole input, divided into subsets
                                  #     - example: binary search
                                  #     - "prune and search": when doing it with constant factor
                                  #Pros:
                                  #  - parallelism
                                  #  - smaller problem
                                  #Cons:
                                  #  - stack size


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          COMPLEXITY           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


COMPLEXITY ==>                    #Function expressing amount of resource taken by another function.
                                  #Can be:
                                  #  - time complexity: amount of time
                                  #  - space complexity: amount of memory

NOTATION ==>                      #Noted O(...)
                                  #  - n is input size
                                  #     - poly(n): any possible polynome with n as sole variable
                                  #  - k is constant

TYPES ==>                         #  +--------------------+-----------------+---------------+
                                  #  | NAME               | O(...) NOTATION | EXAMPLE       |
                                  #  +--------------------+-----------------+---------------+
                                  #  | constant           | 1               | ARR[NUM]      |
                                  #  | log-logarithmic    | log(log(n))     |               |
                                  #  | logarithmic        | log(n)          | binary search |
                                  #  | polylogarithmic    | (log(n))^k      |               |
                                  #  | fractional power   | n^k (0<k<1)     |               |
                                  #  | square root        | n^0.5           |               |
                                  #  | linear             | n               | max(ARR)      |
                                  #  | linearithmic /     |                 |               |
                                  #  | loglinear          | n.log(n)        | heap sort     |
                                  #  | quadratric         | n²              | bubble sort   |
                                  #  | cubic              | n³              |               |
                                  #  | polynomial         | poly(n)         |               |
                                  #  | exponential        | 2^poly(n)       |               |
                                  #  | double-exponential | 2^(2^(poly(n))  |               |
                                  #  | factorial          | n!              |               |
                                  #  +--------------------+-----------------+---------------+

CASES ==>                         #Can be:
                                  #  - best case
                                  #  - average case: the one usually used
                                  #  - worst case

AMORTIZED COMPLEXITY ==>          #Way of calculating the average case.
                                  #Also called "aggregate analysis"
                                  #Take the average cost over n operations.
                                  #Variants:
                                  #  - "accounting method":
                                  #     - each operation gets a constant amount of credit
                                  #     - each operations uses that credit, depending on its complexity
                                  #     - must ensure current credit always above 0
                                  #  - "potential method":
                                  #     - each operation adds cost related to how much disorder it introduces
                                  #     - e.g. for array geometric expansions, getting closer to upper limit introduces
                                  #       disorder
