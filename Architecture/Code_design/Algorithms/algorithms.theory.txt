
              
   ALGORITHMS  
              



QUALITIES ==>                     #Qualities of an algorithm:
                                  #  - "optimality": best solution is found
                                  #  - "completeness": all solutions are found
                                  #  - "accuracy": results are close to solutions
                                  #  - "precision": results are close to each other
                                  #  - "complexity"/"efficiency" (see performance doc):
                                  #     - "parallelism" (see its doc)
                                  #     - "locality of reference" (see performance doc)
                                  #  - "persistence" (see state doc)

HEURISTIC ==>                     #Achieving high efficiency by trading off other qualities


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          SUBPROBLEMS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SUBPROBLEM ==>                    #Subset of input

OPTIMAL SUBSTRUCTURE ==>          #When each subproblem's solution is the optimal solution

OVERLAPPING SUBPROBLEM ==>        #When some subproblems are the same.
                                  #I.e. memoization can be used

GREEDINESS ==>                    #Way to divide an algorithm into subproblems.
                                  #Each subproblem is iterately computed then merged:
                                  #  - each iteration picks candidate ("local optimum")
                                  #    that gets closer to solution ("global optimum")
                                  #  - if no candidate, stops
                                  #  - each iteration does not keep previous individual results
                                  #Pros:
                                  #  - can be used even with no optimal substructure
                                  #     - but in that case, is heuristic, i.e. does not achieve optimality
                                  #  - sometimes better time complexity
                                  #  - better memory complexity
                                  #Cons:
                                  #  - cannot use overlapping subproblems nor parallelism

RECURSION ==>                     #Way to divide an algorithm into subproblems.
                                  #All subproblems are computed, then are all merged together.
                                  #Also called "dynamic programming|optimization"
                                  #Pros:
                                  #  - can re-use overlapping subproblems
                                  #  - can use parallelism
                                  #Cons:
                                  #  - only possible if optimal substructure
                                  #  - worst memory complexity (e.g. stack size)
                                  #Can be:
                                  #  - "divide and conquer"/"bottom-up":
                                  #     - start with subset of input, merged into bigger input
                                  #     - example: distribution sorts
                                  #  - "decrease and conquer"/"top-down":
                                  #     - start with whole input, divided into subsets
                                  #     - example: binary search
                                  #     - "prune and search": when doing it with constant factor
