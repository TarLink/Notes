
               
   CODE_DESIGN  
               


Algorithms:
  - sorting:
     - comparison-based
     - types:
        - distribution: bucket sort (pigeonhole sort), counting sort, radix sort (LSD, MSD, american flag sort), bead sort
        - insertion: insertion sort, shell sort
        - selection: selection sort
        - exchange: bubble sort, bogosort
        - merge: merge sort
  - shuffling: sort shuffle, knuth shuffle
  - complexity: time vs space, constant, log-logarithmic, logarithmic, polylogarithmic, fractional power, linear, linearithmic,
    quadratic, cubic, polynomial, exponential, double-exponential, factorial
  - data structures:
     - serial: list, stack, queue, linked list
     - tree: binary tree (binary search tree)
     - graph
     - hash table
  - turing machines: instruction(state,input)->(write,move,state), universal (von neumann vs harvard)

Design patterns:
  - creational vs structural vs behavioral
  - software rot: dead code, boat anchor, old dependencies, legacy

Information theory:
  - message, signal, channel, noise, bit
  - channel coding, source coding, crypto, stego
  - entropy, hamming distance, hamming weight, levenshtein distance

Requirements:
  - tradeoffs:
     - efficiency vs efficacity, over engineering
     - UX (user-friendliness vs flexibility) vs quality vs maintainability
  - functional vs non-functional (execution vs evolution, product vs process)
  - non-functional requirements:
     - user-friendliness:
        - usability (ease to use, learnability), a11y (i18n), design, performance
        - manageability:
           - discoverability
           - deployability (integrability, interoperability)
           - administrability (upgradability)
           - supportability
           - interchangeability: lock-in (vendor vs technology), golden hammer
     - flexibility:
        - featureful: feature creep, dead end, monkey patching
        - interactivity: simple vs menu-driven vs event-driven, reactivity
        - evolvability
        - configurability
        - adaptability
        - modifiability
     - quality:
        - stability:
           - aspects:
              - testability
              - security
              - compatibility
              - durability
              - availability
              - reliability
           - robustness principle
           - design by contract
        - vulnerability: recoverability, risk, fault tolerance, correctability (debuggability)
        - monitoring: auditability, reporting
     - maintainability:
        - operability (transferability)
        - extensibility: portability, reusability, modularity, software rot
       - scalability
     - social impact: privacy, sustainability, transparency
     - marketability: certification, cost, legality
  - maintainability concepts:
     - abstraction:
        - downstream vs upstream, abstraction inversion, poltergeist
        - information hiding, dependency inversion
        - 1GL/2GL/3GL/4GL/5GL, interpreter, declarative vs imperative, DSL
        - delegating vs forwarding
        - wrapping:
           - interface: object|class adapter, facade, strategy, bridge
           - behavior: decorator, remote proxy, access proxy, lazy load proxy
           - thin vs thick
        - private class data
        - command pattern: receiver (target, handler, action), command, invoker (command manager)
        - iterator
     - modularity:
        - orthogonality, incoherence
        - modular programming
        - between modules:
           - granularity: monolith, functional decomposition, the blob
           - loose coupling:
              - helpers
              - chain of responsability: container, linked list, dispatcher
              - mediator: broadcast vs target
              - event/hooks:
                 - topic-based vs content-based
                 - pub/sub (message broker)
                 - message-oriented middleware
                 - message queue
        - inside modules:
           - cohesion:
              - coincidental, logical, temporal, procedural, informational, sequential, functional
              - structured programming, spaghetti code
              - kitchen sink
              - primitive obsession
           - simplicity: single resposibility
     - reusability:
        - code reuse vs data reuse
        - open/close principle
        - horizontal vs vertical elements
        - copy-and-paste programming, data clumps
        - reinventing the wheel, stovepipe systems|entreprise
  - definition:
     - INVEST (Independent, Negotiable, Valuable, Estimable, Small, Testable)
     - "what to do" not "how to do"
     - high-level first
  - stages:
     - inception
     - formalization: user story, acceptance test, use case
     - proposals:
        - prototype: sketch/wireframe/mockup/pretotype/prototype, horizontal/vertical, rapid/evolutionary
        - specification

Software methodology:
  - domain-driven design: domain, model, bounded context, viewpoint (3-schema, 4+1 model), ubiquitous language, context map
  - paradigms:
     - waterfall
     - incremental
     - iterative
     - agile:
        - focus on client: value, client involvement (product owner)
        - flexibility to change
        - iterative/incremental: short loops, CI/CD, TDD/BDD
        - social: pair-programming, face-to-face, standups, planning pocker
        - XP, scrum, sprints
     - cowboy coding
  - phases:
     - inception
     - elaboration:
        - analysis, synthesis, evaluation, evolution
        - patterns
        - architecture vs design
     - construction:
        - coding
        - verification:
           - automated vs manual
           - functional vs non-functional
           - dynamic vs static analysis
           - testing: test suite, test case, fixture, data-driven, fake/mock/stubs/spies, traceability matrix, e2e,
             unit/integration/system/acceptance
        - debugging
        - validation from client
     - transition: deployment, maintainance

Types:
  - definition:
     - structural vs duck typing vs nominative
     - type inference vs manifest typing
  - type safety:
     - weakly typed vs strongly typed
     - static vs dynamic type check
     - type punning
     - memory safety
  - resolution:
     - namespaces
     - scope / name binding:
        - early vs late
        - lexical vs dynamic scoping
        - level: global, module, file, function, block, expression
     - dispatch / polymorphism: static vs dynamic
  - null vs empty, null objects
  - object-oriented:
     - relationship:
        - inheritance, coercion, composition, aggregation, association
        - exclusivity, ownership, container
        - composition over inheritance
        - liskov substitution principle
     - initialization:
        - class vs prototype (delegation vs concatenation)
        - factory method, abstract factory, named constructor
        - singleton
  - polymorphism:
     - subtyping
        - multiple inheritance: override vs multicast delegation
        - subclassing vs structural subtyping
           - abstract methods|classes
        - template method
     - typecasting
     - overloading:
        - single vs multiple dispatch
        - visitors
     - generic programming: contracts, templates vs mixins vs traits, predicative, rank-n
  - functions:
     - arity
     - operators
     - first-class functions, lambda calculus
     - high-order functions: composition, currying, binding, reduce, map, filter, list comprehension, zip
