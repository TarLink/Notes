
               
   CODE_DESIGN  
               


Algorithms:
  - sorting:
     - comparison-based
     - types:
        - distribution: bucket sort (pigeonhole sort), counting sort, radix sort (LSD, MSD, american flag sort), bead sort
        - insertion: insertion sort, shell sort
        - selection: selection sort
        - exchange: bubble sort, bogosort
        - merge: merge sort
  - shuffling: sort shuffle, knuth shuffle
  - complexity: time vs space, constant, log-logarithmic, logarithmic, polylogarithmic, fractional power, linear, linearithmic,
    quadratic, cubic, polynomial, exponential, double-exponential, factorial
  - data structures:
     - serial: list, stack, queue, linked list
     - tree: binary tree (binary search tree)
     - graph
     - hash table
  - turing machines: instruction(state,input)->(write,move,state), universal (von neumann vs harvard)

Design patterns:
  - creational vs structural vs behavioral
  - software rot: dead code, boat anchor, old dependencies, legacy

Information theory:
  - message, signal, channel, noise, bit
  - channel coding, source coding, crypto, stego
  - entropy, hamming distance, hamming weight, levenshtein distance

Requirements:
  - abstraction:
     - downstream vs upstream, abstraction inversion, poltergeist
     - information hiding, dependency inversion
     - 1GL/2GL/3GL/4GL/5GL, interpreter, declarative vs imperative, DSL
     - delegating vs forwarding
     - wrapping:
        - interface: object|class adapter, facade, strategy, bridge
        - behavior: decorator, remote proxy, access proxy, lazy load proxy
        - thin vs thick
     - private class data
     - command pattern: receiver (target, handler, action), command, invoker (command manager)
     - iterator
  - extensibility vs modifiability
  - flexibility: feature creep, dead end, monkey patching
  - interactivity: simple vs menu-driven vs event-driven, reactivity
  - interchangeability: lock-in (vendor vs technology), golden hammer
  - maintainability: operability, extensibility (portability, reusability), scalability, refactoring
  - modularity:
     - orthogonality, incoherence
     - modular programming
     - between modules:
        - granularity: monolith, functional decomposition, the blob
        - loose coupling:
           - inheritance/composition/aggregation/association
           - helpers
           - chain of responsability: container, linked list, dispatcher
           - mediator: broadcast vs target
           - event/hooks:
              - topic-based vs content-based
              - pub/sub (message broker)
              - message-oriented middleware
              - message queue
     - inside modules:
        - cohesion:
           - coincidental, logical, temporal, procedural, informational, sequential, functional
           - structured programming, spaghetti code
           - kitchen sink
           - primitive obsession
        - simplicity: single resposibility
  - reusability:
     - code reuse vs data reuse
     - open/close principle
     - horizontal vs vertical elements
     - copy-and-paste programming, data clumps
     - reinventing the wheel, stovepipe systems|entreprise
