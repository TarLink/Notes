
                     
   FLOAT_FIXED_POINT  
                     


DIFFERENCE ==>          #Floating point numbers:
                        #  - more precise
                        #  - simpler to use
                        #  - more common
                        #  - often implemented hardware
                        #Fixed point numbers:
                        #  - are more efficient
                        #  - do not need FPU
                        #  - handle rounding better
                        #  - often implemented software


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        FLOATING POINT         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


IMPLEMENTATION ==>      #Usually done by a FPU (floating-point unit, ou "math coprocesser"),
                        #often found in CPUs.

FLOATING-POINT NUMBERS  #As opposed to fixed-point numbers, it's the comma position that is stored,
  ==>                   #not the number of digits.

STANDARD IEEE 754 ==>   #Usually used.
                        #Can be any radix, but usually 2 (binary).
                        #Three fields, usually contiguous in memory:
                        #  - 1 sign bit (0 +, 1 -)
                        #  - significand (improperly named mantissa)
                        #     - 2 > number >= 1
                        #     - e.g. 1.1101
                        #  - exponent
                        #     - is signed
                        #     - encoded by substracting 1, then flipping first bit
                        #        - e.g. 00000100 -> 10000011
                        #Number = significand + radix ** exponent

PRECISION ==>           #Since exponents have less bits than significands, a floating point number has:
                        #  - a nearly-exact precision for any number that can be represented by significand alone
                        #     - quasi-exact because of radix conversion between decimal to binary
                        #     - e.g. 0.3 does not translate to binary, but 0.25 does
                        #     - max precision loss is 1/(2** significand size)
                        #  - a smaller precision above that
                        #     - but can still represent number up to 2 ** (exponent size - 1) + significand size

DENORMALIZED NUMBERS ==>#Denormalized numbers are numbers with:
                        #  - minimal exponent, i.e. == 0, i.e. it is actually -MIN (e.g. -127 for single-precision)
                        #  - significand != 0
                        #In that case:
                        #  - significand can start with 0.* instead of 1.*
                        #  - this allows adding one bit of precision for very small numbers

ZERO ==>                #Has an exponent and significand == 0
                        #Sign bit allow +0 or -0

INFINI AND NAN ==>      #If exponent is max value, it is:
                        #  - +∞ or -∞ if significand == 0
                        #     - + ∞ == -∞
                        #     - used as limits, i.e. -∞ < all numbers < +∞
                        #  - NaN (NotaNumber) otherwise
                        #     - all numbers != NaN, including itself
                        #     - since several significand are possible, can be used as error code

FORMATS ==>             #Can be:
                        #  - single-precision / float
                        #  - double-precision / double
                        #  - [double] extended precision / long double: non standard

SUMMARY ==>             #  NOM           EXPONENT  SIGNIFICAND   TOTAL     MAX DIGITS      MAX DIGITS
                        #                                        SIZE      WITHOUT
                        #                                                  PRECISION LOSS
                        #  Single-prec   8         23            32        6               38
                        #  Double-prec   11        52            64        15              308
                        #  Extended-prec 15        64            80        19              4932


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          FIXED POINT          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


FIXED-POINT NUMBERS ==> #Fixed point numbers are integers with a scaling scalor, which
                        #is type-determinated.
                        #E.g. with scaling factor 1/1000, 0.012 -> 12
                        #Notation:
                        #  - Q[DIGIT1.]DIGIT2:
                        #     - for a given unit (binary, decimal, etc.)
                        #     - DIGIT1 is number of digits before comma
                        #       Can be guessed from number size - DIGIT2
                        #     - DIGIT2 is number of digits after comma
                        #  - fxDIGIT1.DIGIT2:
                        #     - DIGIT1 is number of digits before comma
                        #     - DIGIT2 is total number of digits
                        #Usually use 2's-complement signedness

