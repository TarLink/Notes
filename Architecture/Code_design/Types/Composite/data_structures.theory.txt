
                   
   DATA_STRUCTURES  
                   



DEFINITION ==>                    #Composite type organized towards performing specific operations/algorithms

SUMMARY ==>                       #Relationship between data items:
                                  #  - serial: linear
                                  #     - order maintained by container:
                                  #        - generic access: list
                                  #        - FILO access: stack
                                  #        - FIFO access: queue
                                  #     - order maintained by items: linked list
                                  #  - parent/child: tree
                                  #     - 1 parent, 2 children: binary tree
                                  #        - optimized for search, can be compared: binary search tree
                                  #  - unrestricted: graph
                                  #  - none:
                                  #     - with keys: associative
                                  #     - without keys: set

OPERATIONS ==>                    #Most common operations on items:
                                  #  - creating/inserting
                                  #  - reading:
                                  #     - by key: accessing
                                  #     - by value: searching
                                  #  - updating
                                  #  - deleting


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          HIGH-LEVEL           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


UNION ==>                         #See types doc

ARRAY ==>                         #Aggregates items ("elements") of the same|similar type
                                  #Keys can be:
                                  #  - numbers/indices ("single-value")
                                  #     - 0-based, 1-based or n-based
                                  #  - strings ("associative")
                                  #Items type can be composite ("container") or not
                                  #Items size ("width|stride|increment|step") can be:
                                  #  - always the same: faster access
                                  #  - or not: more compact
                                  #Position of an item since beginning of array is "offset"
                                  #"Dope vector":
                                  #  - metadata stored alongside
                                  #  - e.g. origin address, items type, length, dimensions, stride
                                  #"Sentinel value":
                                  #  - value at the end to indicate termination
                                  #  - e.g. null-terminated strings or null pointer in a linked list
                                  #Is more a data type than a data structure:
                                  #  - does not prescribe operations or constraints, but representation
                                  #  - e.g. lists, sets and graphs can all be represented as arrays
                                  #  - some use the word "array" to also describe a data structure where items
                                  #    are fetched random-access, as opposed to "list" which is fetched serially
                                  
MATRIX ==>                        #Array that has multiple dimensions|ranks
                                  #Opposite is "vector"
                                  #Can be implemented:
                                  #  - row-major: row > column. better for sequential access
                                  #  - column-major: column > row. Better for array programming
                                  #  - "iliffe vector": array of pointers towards other array

RECORD ==>                        #Aggregates items ("fields"/"members"/"elements"/"column") of different types
                                  #Also called "tuple", "struct[ure]" or "row"
                                  #Items size can be fixed or dynamic.
                                  #Keys:
                                  #  - fields that serve as identifier
                                  #  - "primary key" are unique keys
                                  #According to size, called:
                                  #  - "singleton", "pair", "triplet", "quad", "quint", etc.
                                  #  - "monuple", "couple", "triple", "quadruple", "quintuple", etc.
                                  
RECORD + ARRAY ==>                #Can either:
                                  #  - array of records|structures (AoS)
                                  #     - most used
                                  #     - better when usually accessing and iterating over all fields at a time
                                  #  - record|structures of arrays (SoA) / "interleaving"
                                  #     - better when usually accessing and iterating over one field at a time
                                  #        - including SIMD operations
                                  #        - can save space with:
                                  #           - better low-level byte alignment
                                  #           - indices taking less space than string keys
                                  #     - each array is a "parallel array"
                                  #  - record of AoS:
                                  #     - better when usually accessing and iterating over few fields at a time
                                  #     - sometimes called "data-oriented design", opposing to "object-oriented design"
                                  #       which leads to bad locality of reference and many reference indirections at the
                                  #       low-level


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:    ARRAY MEMORY MANAGEMENT    :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ARRAY MEMORY MANAGEMENT ==>       #Array size can be:
                                  #  - fixed: "table"/"bounded"
                                  #  - dynamic: "collection"/"dynamic array|table"/"array list"
                                  #Array memory can be allocated:
                                  #  - compile-time
                                  #  - runtime: "variable-length"/"dynamically allocated"
                                  #Zero-filling:
                                  #  - filling allocated memory with \0
                                  #  - slower but safer from programming errors and security exploits
                                  
GEOMETRIC EXPANSION ==>           #Possible dynamic array allocation:
                                  #  - increasing capacity on demand, usually using a scaling factor, often:
                                  #     - 2, allowing bitwise/bytewsie operations
                                  #     - 1.5, with less wasted space
                                  #  - most wasted space (O(n)) but simple and limited number of copies
                                  
GAP BUFFER ==>                    #Possible dynamic array allocation:
                                  #  - split array into two parts, and only allow adding|deleting between them
                                  #  - elements can be moved from one part to another
                                  #  - efficient when modification usually happen around the same place, e.g. in a text editor
HASHES ARRAY TREE (HAT) ==>       #Possible dynamic array allocation:
                                  #  - using an iliffe vector ("directory") pointing to arrays ("leaves")
                                  #  - can allocate memory by:
                                  #     - geometric expansion on directory
                                  #     - geometric expansion on all leaves
                                  #     - combinations:
                                  #        - only expanding directory avoid any copy, but makes iteration slower
                                  #        - expanding both but delaying allocating memory for new leaves until needed
                                  #           - waste only O(sqrt(n)) space
                                  #  - can deallocate memory by:
                                  #     - dealllocate leaf when empty
                                  #     - restructure whole array to smaller directory and leaves when smaller size
                                  #        - e.g. when scaling factor 2, when 1/8 full, can half both directory and leaves,
                                  #          so it becomes 1/2 full

SPARSE ARRAY ==>                  #Array that has many empty elements.
                                  #"Sparsity|density" is percentage of [non-]empty elements.
                                  #Can save space using:
                                  #  - "dictionary of keys" (DOK):
                                  #     - associative array with indices as keys
                                  #     - slower on read ordered operations (e.g. iterating) as it is not ordered
                                  #  - "coordinate liste" (COO):
                                  #     - ordered array of (INDEX, VAL) pairs
                                  #     - slower for writes, as it requires ordering
                                  #     - "list of list" (LIL): when using an "iliffe vector"
                                  #  - "compressed sparse row" (CSR) / "compressed row storage" (CRS) / "Yale format":
                                  #     - for matrix only
                                  #     - three arrays, for all non-empty elements:
                                  #        - array A: values of elements
                                  #        - array IA: number of elements per non-empty row. Must append 0.
                                  #        - array JA: column of elements
                                  #     - takes least space (compresses row information), but is slowest on read|write
                                  #     - can concatenate IA and JA ("new format")
                                  #     - called "compressed column storage" (CCS) / "Harwell-Boeing" when using
                                  #       column-major instead of row-major

MATRIX SPACE STORAGE ==>          #Often matrices have the following properties that allow for structures to save space:
                                  #  - band matrix: when all [non-]empty elements form diagonals
                                  #  - symetrix matrix: when one side of diagonal is same as other one


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            LINEAR             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/




                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             LIST              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


LIST ==>                          #Array where items are ordered.
                                  #Also called "sequence"/"linear data structure"
                                  #Operations:
                                  #  - length()->NUM
                                  #  - get(INDEX)->VAL
                                  #  - set(INDEX, VAL)
                                  #  - remove(INDEX)
                                  #  - slice(INDEX, LENGTH)
                                  #  - clear()
                                  #When implemented as a simple array, both operations are random-access with O(1)

STACK/LIFO ==>                    #List with read|write to most-recent item
                                  #Often implemented as a simple array or as a linked list.
                                  #Operations:
                                  #  - push(VAL): O(1)
                                  #  - pop()->VAL: O(1)
                                  #  - peek()->VAL: O(1)

QUEUE/FIFO ==>                    #List with read|write to last-recent item
                                  #Sometimes used for buffers.
                                  #Often implemented as:
                                  #  - a circular buffer when size is bounded
                                  #  - a linked list otherwise
                                  #Operations:
                                  #  - push(VAL)
                                  #  - shift()->VAL
                                  #  - head()->VAL

DOUBLE-ENDED QUEUE ==>            #Combination of a stack and a queue
                                  #Also called "deque[ue]" or "head-tail"

CIRCULAR BUFFER ==>               #Implementation for a queue using a bounded-size array with:
                                  #  - a head|write|end pointer:
                                  #     - where push() adds value
                                  #     - incremented on push()
                                  #  - a tail|read|start pointer:
                                  #     - where shift() removes value
                                  #     - incremented on shift()
                                  #     - when end pointer passes start pointer:
                                  #        - i.e. when data is longer than bounded-size array
                                  #        - can either overwrite data or raise exception
                                  #  - both pointers rotates to start of array when at the end
                                  #Is conceptually like an array forming a circle.
                                  #push(), shift(), head(): O(1)

PRIORITY QUEUE ==>                #List with read|write to highest priority item, where each item is assigned a "priority",
                                  #which can be using any type (as long as it can be compared).
                                  #Operations:
                                  #  - add(VAL, PRIORITY)
                                  #  - pull_highest|lowest()->VAL
                                  #  - peek_highest|lowest()->VAL
                                  #  - set_priority(INDEX, PRIORITY)
                                  #Often implemented as heaps

LINKED LIST ==>                   #Graph where nodes (except tail) always point to 1 other node
                                  #Operations:
                                  #  - length()->NUM: O(n)
                                  #  - get(INDEX)->VAL: O(n)
                                  #  - add(VAL, INDEX): O(n)
                                  #  - remove(INDEX): O(n)
                                  #  - slice(INDEX, LENGTH): O(1)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             GRAPH             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GRAPH THEORY ==>                  #See graph theory documentation

EDGE ==>                          #Is [NODE, NODE2] pair.
                                  #Can be encapsuled in a single EDGE object:
                                  #  - can be used instead of (NODE, NODE2) in operations
                                  #     - e.g. get_edge_value(EDGE)->VAL

GRAPH ==>                         #Operations:
                                  #  - add|remove_node(NODE)
                                  #  - add|remove_edge(NODE, NODE2)
                                  #  - neighbors(NODE|EDGE)->NODE2|EDGE2_ARR
                                  #  - adjacent(NODE|EDGE, NODE2|EDGE2)->BOOL
                                  #  - get_node_value(NODE)->VAL
                                  #  - set_node_value(NODE, VAL)
                                  #  - get_edge_value(NODE, NODE2)->VAL
                                  #  - set_edge_value(NODE, NODE2, VAL)
                                  #Can be implemented by:
                                  #  - an adjacency list using:
                                  #     - a multimap with node as key and neighbors as values
                                  #     - a simple array of neighbors, where nodes are represented as indices
                                  #  - an adjacency matrix
                                  #  - an incidence matrix


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             TREE              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TREE ==>                          #In computer science, usually means arborescence in graph theory.
                                  #Operations:
                                  #  - add(VAL, PARENT_VAL)
                                  #  - traverse|walk(FUNC(VAL))
                                  #High branching factor can increase complexity of some operations
                                  #Often implemented as an array of:
                                  #  - records [VAL, POINTER...]
                                  #  - VAL, with the edges being implicit by the structure
                                  #     - e.g. a balanced binary tree where leftmost parent are ordered first
TODO ==> GO THROUGH WIKIPEDIA ARTICLE OF TREE AGAIN, ESPECIALLY RELATED LINKS

BINARY SEARCH TREE ==>            #Operations:
                                  #  - has(VAL)->BOOL: O(log())
                                  #  - add(VAL): O(log(n))


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          ASSOCIATIVE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ASSOCIATIVE ARRAY ==>             #Unordered array of (KEY, VAL) pairs, with unique keys.
                                  #Also called "map" or "dictionary"
                                  #Operations:
                                  #  - get(KEY)->VAL
                                  #  - set(KEY, VAL)
                                  #  - remove(KEY)
                                  #Complexity depends on implementation, which is often
                                  #either as hash table or as search tree.

INDEX MAP ==>                     #Associative array implemented as a simple array and where KEY is index:
                                  #  - as opposed to a regular array, index is conceptually not used as such,
                                  #    but as a key
                                  #  - e.g. retrieving name of months by using KEY 1-12
                                  #Is the most efficient way of accessing an associative array
                                  #Also called "direct addressing" or "trivial hash function"

BIDIRECTIONAL MAP ==>             #Associative array where values are unique.
                                  #I.e. values can be used as keys as well.
                                  #Also called "hash bag"

MULTIMAP ==>                      #Associate array where values are arrays.
                                  #Can also be thought as associate array where keys are not unique
                                  #Also called "multihash" or "multidict"


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              SET              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


MULTISET ==>                      #Unordered array of values.
                                  #As opposed to a list, there is no order nor indices.
                                  #Also called "bag"
                                  #Operations:
                                  #  - add(VAL)
                                  #  - has(VAL)->BOOL
                                  #  - count(VAL)->NUM
                                  #  - remove(VAL)
                                  #  - clear()
                                  #  - length()->NUM: also called "cardinality" or "capacity"
                                  #  - pop()->VAL, pick()->VAL: pop|get random element
                                  #  - union(SET2)->SET3
                                  #  - intersection(SET2)->SET3
                                  #  - difference(SET2)->SET3
                                  #  - is_subset(SET2)->BOOL
                                  #Often implemented as a tree or an associative array

SET ==>                           #Multiset with unique values.
                                  #Operations: like multiset, except count()
