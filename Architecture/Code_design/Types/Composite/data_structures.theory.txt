
                   
   DATA_STRUCTURES  
                   



DEFINITION ==>                    #Composite type organized towards performing specific operations/algorithms

SUMMARY ==>                       #Relationship between data items:
                                  #  - serial: linear
                                  #     - order maintained by container:
                                  #        - generic access: list
                                  #        - FILO access: stack
                                  #        - FIFO access: queue
                                  #     - order maintained by items: linked list
                                  #  - parent/child: tree
                                  #     - 1 parent, 2 children: binary tree
                                  #        - optimized for search, can be compared: binary search tree
                                  #  - unrestricted: graph
                                  #  - none:
                                  #     - with keys: associative
                                  #     - without keys: set

OPERATIONS ==>                    #Most common operations on items:
                                  #  - creating/inserting
                                  #  - reading:
                                  #     - by key: accessing
                                  #     - by value: searching
                                  #  - updating
                                  #  - deleting


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          HIGH-LEVEL           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


UNION ==>                         #See types doc

ARRAY ==>                         #Aggregates items ("elements") of the same|similar type
                                  #Keys can be:
                                  #  - numbers/indices ("single-value")
                                  #     - 0-based, 1-based or n-based
                                  #  - strings ("associative")
                                  #Items type can be composite ("container") or not
                                  #Items size ("width|stride|increment|step") can be:
                                  #  - always the same: faster access
                                  #  - or not: more compact
                                  #Position of an item since beginning of array is "offset"
                                  #"Dope vector":
                                  #  - metadata stored alongside
                                  #  - e.g. origin address, items type, length, dimensions, stride
                                  #Is more a data type than a data structure:
                                  #  - does not prescribe operations or constraints, but representation
                                  #  - e.g. lists, sets and graphs can all be represented as arrays
                                  #  - some use the word "array" to also describe a data structure where items
                                  #    are fetched random-access, as opposed to "list" which is fetched serially
                                  
MATRIX ==>                        #Array that has multiple dimensions|ranks
                                  #Opposite is "vector"
                                  #Can be implemented:
                                  #  - row-major: row > column. better for sequential access
                                  #  - column-major: column > row. Better for array programming
                                  #  - "iliffe vector": array of pointers towards other array

RECORD ==>                        #Aggregates items ("fields"/"members"/"elements"/"column") of different types
                                  #Also called "tuple", "struct[ure]" or "row"
                                  #Items size can be fixed or dynamic.
                                  #Keys:
                                  #  - fields that serve as identifier
                                  #  - "primary key" are unique keys
                                  #According to size, called:
                                  #  - "singleton", "pair", "triplet", "quad", "quint", etc.
                                  #  - "monuple", "couple", "triple", "quadruple", "quintuple", etc.
                                  
RECORD + ARRAY ==>                #Can either:
                                  #  - array of records|structures (AoS)
                                  #     - most used
                                  #     - better when usually accessing and iterating over all fields at a time
                                  #  - record|structures of arrays (SoA) / "interleaving"
                                  #     - better when usually accessing and iterating over one field at a time
                                  #        - including SIMD operations
                                  #        - can save space with:
                                  #           - better low-level byte alignment
                                  #           - indices taking less space than string keys
                                  #     - each array is a "parallel array"
                                  #  - record of AoS:
                                  #     - better when usually accessing and iterating over few fields at a time
                                  #     - sometimes called "data-oriented design", opposing to "object-oriented design"
                                  #       which leads to bad locality of reference and many reference indirections at the
                                  #       low-level


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:    ARRAY MEMORY MANAGEMENT    :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ARRAY MEMORY MANAGEMENT ==>       #Array size can be:
                                  #  - fixed: "table"/"bounded"
                                  #  - dynamic: "collection"/"dynamic array|table"/"array list"
                                  #Array memory can be allocated:
                                  #  - compile-time
                                  #  - runtime: "variable-length"/"dynamically allocated"
                                  #Zero-filling:
                                  #  - filling allocated memory with \0
                                  #  - slower but safer from programming errors and security exploits
                                  
GEOMETRIC EXPANSION ==>           #Possible dynamic array allocation:
                                  #  - increasing capacity on demand, usually using a scaling factor, often:
                                  #     - 2, allowing bitwise/bytewsie operations
                                  #     - 1.5, with less wasted space
                                  #  - most wasted space (O(n)) but simple and limited number of copies
                                  
GAP BUFFER ==>                    #Possible dynamic array allocation:
                                  #  - split array into two parts, and only allow adding|deleting between them
                                  #  - elements can be moved from one part to another
                                  #  - efficient when modification usually happen around the same place, e.g. in a text editor
HASHES ARRAY TREE (HAT) ==>       #Possible dynamic array allocation:
                                  #  - using an iliffe vector ("directory") pointing to arrays ("leaves")
                                  #  - can allocate memory by:
                                  #     - geometric expansion on directory
                                  #     - geometric expansion on all leaves
                                  #     - combinations:
                                  #        - only expanding directory avoid any copy, but makes iteration slower
                                  #        - expanding both but delaying allocating memory for new leaves until needed
                                  #           - waste only O(sqrt(n)) space
                                  #  - can deallocate memory by:
                                  #     - dealllocate leaf when empty
                                  #     - restructure whole array to smaller directory and leaves when smaller size
                                  #        - e.g. when scaling factor 2, when 1/8 full, can half both directory and leaves,
                                  #          so it becomes 1/2 full

SPARSE ARRAY ==>                  #Array that has many empty elements.
                                  #"Sparsity|density" is percentage of [non-]empty elements.
                                  #Can save space using:
                                  #  - "dictionary of keys" (DOK):
                                  #     - associative array with indices as keys
                                  #     - slower on read ordered operations (e.g. iterating) as it is not ordered
                                  #  - "coordinate liste" (COO):
                                  #     - ordered array of (INDEX, VAL) pairs
                                  #     - slower for writes, as it requires ordering
                                  #     - "list of list" (LIL): when using an "iliffe vector"
                                  #  - "compressed sparse row" (CSR) / "compressed row storage" (CRS) / "Yale format":
                                  #     - for matrix only
                                  #     - three arrays, for all non-empty elements:
                                  #        - array A: values of elements
                                  #        - array IA: number of elements per non-empty row. Must append 0.
                                  #        - array JA: column of elements
                                  #     - takes least space (compresses row information), but is slowest on read|write
                                  #     - can concatenate IA and JA ("new format")
                                  #     - called "compressed column storage" (CCS) / "Harwell-Boeing" when using
                                  #       column-major instead of row-major

MATRIX SPACE STORAGE ==>          #Often matrices have the following properties that allow for structures to save space:
                                  #  - band matrix: when all [non-]empty elements form diagonals
                                  #  - symetrix matrix: when one side of diagonal is same as other one


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            LINEAR             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/




                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             LIST              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


LIST ==>                          #Array where items are ordered.
                                  #Also called "sequence"/"linear data structure"
                                  #Operations:
                                  #  - length()->NUM
                                  #  - get(INDEX)->VAL
                                  #  - set(INDEX, VAL)
                                  #  - remove(INDEX)
                                  #  - slice(INDEX, LENGTH)
                                  #  - clear()
                                  #When implemented as a simple array, both operations are random-access with O(1)

STACK/LIFO ==>                    #List with read|write to most-recent item
                                  #Often implemented as a simple array or as a linked list.
                                  #Operations:
                                  #  - push(VAL): O(1)
                                  #  - pop()->VAL: O(1)
                                  #  - peek()->VAL: O(1)

QUEUE/FIFO ==>                    #List with read|write to last-recent item
                                  #Sometimes used for buffers.
                                  #Often implemented as:
                                  #  - a circular buffer when size is bounded
                                  #  - a linked list otherwise
                                  #Operations:
                                  #  - push(VAL)
                                  #  - shift()->VAL
                                  #  - head()->VAL

DOUBLE-ENDED QUEUE ==>            #Combination of a stack and a queue
                                  #Also called "deque[ue]" or "head-tail"

CIRCULAR BUFFER ==>               #Implementation for a queue using a bounded-size array with:
                                  #  - a head|write|end pointer:
                                  #     - where push() adds value
                                  #     - incremented on push()
                                  #  - a tail|read|start pointer:
                                  #     - where shift() removes value
                                  #     - incremented on shift()
                                  #     - when end pointer passes start pointer:
                                  #        - i.e. when data is longer than bounded-size array
                                  #        - can either overwrite data or raise exception
                                  #  - both pointers rotates to start of array when at the end
                                  #Is conceptually like an array forming a circle.
                                  #push(), shift(), head(): O(1)

PRIORITY QUEUE ==>                #List with read|write to highest priority item, where each item is assigned a "priority",
                                  #which can be using any type (as long as it can be compared).
                                  #Operations:
                                  #  - add(VAL, PRIORITY)
                                  #  - pull_highest|lowest()->VAL
                                  #  - peek_highest|lowest()->VAL
                                  #  - set_priority(INDEX, PRIORITY)
                                  #Often implemented as heaps

LINKED LIST ==>                   #Graph where nodes (except tail) always point to 1 other node
                                  #Operations:
                                  #  - length()->NUM: O(n)
                                  #  - get(INDEX)->VAL: O(n)
                                  #  - add(VAL, INDEX): O(n)
                                  #  - remove(INDEX): O(n)
                                  #  - slice(INDEX, LENGTH): O(1)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             GRAPH             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EDGE ==>                          #Link connecting 2 "nodes"/"vertices"/"points" (unique values) together.
                                  #Also called "arc"/"line"
                                  #"Path":
                                  #  - list of distinct connected edges
                                  #Can be ordered or not:
                                  #  - i.e. there is a start node and an end node
                                  #  - called "arrow" then
                                  #  - "directed path"/"dipath": path where all edges have same direction
                                  #"Loop":
                                  #  - when start node and end node are the same node
                                  #Is [NODE, NODE2] pair.
                                  #Can be encapsuled in a single EDGE object:
                                  #  - can be used instead of (NODE, NODE2) in operations
                                  #     - e.g. get_edge_value(EDGE)->VAL

GRAPH ==>                         #Array of nodes and edges.
                                  #Graph's "order":
                                  #  - number of nodes
                                  #  - can be "finite" or "infinite"
                                  #  - "order-zero" graph:
                                  #     - when order is 0
                                  #     - can be allowed or not
                                  #Graph's "size":
                                  #  - number of edges
                                  #  - "Null"/"edgeless" graph:
                                  #     - when size is 0, i.e. no node is connected
                                  #"Degree/valency":
                                  #  - number of edges of a given node
                                  #  - can be 0, i.e. not be connected to any other nodes.
                                  #"Multiple|parallel edges":
                                  #  - when there can be multiple edges for the same set of nodes
                                  #  - types:
                                  #     - multiple edges and loops: "pseudographs"
                                  #     - multiple edges and no loops: "multigraphs"
                                  #     - single edges and no loops: "simple graph"
                                  #"Directed" vs "undirected" graph:
                                  #  - whether edges are ordered or not
                                  #"Subgraph":
                                  #  - subset of a graph that is itself a graph
                                  #"Labeling":
                                  #  - assigning values to edges ("edge value") or nodes
                                  #  - "weighted graph": when all edges have a numerical value
                                  #  - "coloring":
                                  #     - when adjacent nodes|edges have different labels
                                  #Operations:
                                  #  - add|remove_node(NODE)
                                  #  - add|remove_edge(NODE, NODE2)
                                  #  - neighbors(NODE|EDGE)->NODE2|EDGE2_ARR
                                  #  - adjacent(NODE|EDGE, NODE2|EDGE2)->BOOL
                                  #  - get_node_value(NODE)->VAL
                                  #  - set_node_value(NODE, VAL)
                                  #  - get_edge_value(NODE, NODE2)->VAL
                                  #  - set_edge_value(NODE, NODE2, VAL)
                                  #Can be implemented by an adjacency list, an adjacency matrix or an incidence matrix

HYPEREDGE ==>                     #Link connecting 1-n "nodes"/"vertices"/"points" (unique values) together.
                                  #Is conceptually similar to a mathematical set.
                                  #Since it is a generalization of edges, most concepts of graphs/edges apply:
                                  #  - graph is called "hypergraph"
                                  #"Edge size":
                                  #  - number of nodes per edge
                                  #  - "k-uniform": when all edges have same size
                                  #"clutter"/"sperner family":
                                  #  - when max node degree is 0|1
                                  #  - i.e. no edge is a subset of another edge

PATH GRAPH ==>                    #Graph where nodes form a single sequence, i.e. all nodes (except ends) have degree 2.
                                  #Also called "linear graph"

ADJACENCY LIST ==>                #Representing a graph as a unordered array of [NODE, NODE2|EDGE2_ARR] where
                                  #NODE2|EDGE2_ARR are the neighbors.
                                  #This can be done using:
                                  #  - a multimap with NODE as key and NODE2|EDGE2_ARR as values
                                  #  - a simple array of NODE2|EDGE2_ARR, where nodes are represented as indices

ADJACENCY MATRIX ==>              #Representing a graph as a square matrix:
                                  #  - columns represent end node, rows start node
                                  #     - for undirected graphs:
                                  #        - each node is both end and start
                                  #        - i.e. matrix is symmetric
                                  #  - cells are incremented if there is an edge between those two nodes
                                  #     - for simple graphs: it is either 0 (no edge) or 1 (an edge)
                                  #     - for non-simple graphs:
                                  #        - it can be anything
                                  #        - loops increment by 2


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             TREE              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TREE ==>                          #Graph with transitive (parent-children) relationships, i.e.:
                                  #  - each node ("child") has a single "parent"
                                  #  - there is a single top node ("root"):
                                  #     - no circular reference ("cycle")
                                  #        - i.e. cannot point to an ancestor or to itself
                                  #     - all elements have same root
                                  #        - i.e. all elements are part of the same tree
                                  #     - having no root, i.e. empty graph, might be allowed or not
                                  #Terminology:
                                  #  - two nodes with same parent are "siblings"
                                  #  - "descendants"/"ancestors" are any node part of the parent|child chain
                                  #  - "leaf"/"external node" vs "branch"/"internal node"/"inode": node with [no] children
                                  #  - "subtree": tree inside a tree
                                  #     - "degree": number of subtrees
                                  #  - "edge"/"link": pointer between a child and its parent
                                  #     - "path": sequence of nodes+edges connecting two nodes, including nodes themselves
                                  #     - "level": number of nodes in path to root, i.e. root is 1
                                  #        - "depth": number of edges in path to root, i.e. level - 1
                                  #     - "height" of a node: number of edges in path to furthest child leaf
                                  #        - "height" of a tree: height of the root
                                  #  - "branching factor"/"outdegree": number of children per node
                                  #     - high branching factor can increase complexity of some operations
                                  #  - "forest": several disjoint trees
                                  #     - "linear forest": forest of path graphs
                                  #Operations:
                                  #  - add(VAL, PARENT_VAL)
                                  #  - traverse|walk(FUNC(VAL))
                                  #     - can be done:
                                  #        - parent then children ("pre-order")
                                  #           - one level at a time ("level-order")
                                  #        - children then parent ("post-order")
                                  #        - left child then paren then right child ("in-order") (binary trees only)
                                  #Often implemented as an array of:
                                  #  - records [VAL, POINTER...]
                                  #  - VAL, with the children being previous|next items in array
TODO ==> GO THROUGH WIKIPEDIA ARTICLE OF TREE AGAIN, ESPECIALLY RELATED LINKS

CATERPILLAR TREE ==>              #Tree where

BINARY TREE ==>                   #Tree where each node has two children or none

BINARY SEARCH TREE ==>            #Binary tree where first child < parent < second child
                                  #Operations:
                                  #  - has(VAL)->BOOL: O(log())
                                  #  - add(VAL): O(log(n))


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          ASSOCIATIVE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ASSOCIATIVE ARRAY ==>             #Unordered array of (KEY, VAL) pairs, with unique keys.
                                  #Also called "map" or "dictionary"
                                  #Operations:
                                  #  - get(KEY)->VAL
                                  #  - set(KEY, VAL)
                                  #  - remove(KEY)
                                  #Complexity depends on implementation, which is often
                                  #either as hash table or as search tree.

INDEX MAP ==>                     #Associative array implemented as a simple array and where KEY is index:
                                  #  - as opposed to a regular array, index is conceptually not used as such,
                                  #    but as a key
                                  #  - e.g. retrieving name of months by using KEY 1-12
                                  #Is the most efficient way of accessing an associative array
                                  #Also called "direct addressing" or "trivial hash function"

BIDIRECTIONAL MAP ==>             #Associative array where values are unique.
                                  #I.e. values can be used as keys as well.
                                  #Also called "hash bag"

MULTIMAP ==>                      #Associate array where values are arrays.
                                  #Can also be thought as associate array where keys are not unique
                                  #Also called "multihash" or "multidict"


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              SET              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


MULTISET ==>                      #Unordered array of values.
                                  #As opposed to a list, there is no order nor indices.
                                  #Also called "bag"
                                  #Operations:
                                  #  - add(VAL)
                                  #  - has(VAL)->BOOL
                                  #  - count(VAL)->NUM
                                  #  - remove(VAL)
                                  #  - clear()
                                  #  - length()->NUM: also called "cardinality" or "capacity"
                                  #  - pop()->VAL, pick()->VAL: pop|get random element
                                  #  - union(SET2)->SET3
                                  #  - intersection(SET2)->SET3
                                  #  - difference(SET2)->SET3
                                  #  - is_subset(SET2)->BOOL
                                  #Often implemented as a tree or an associative array

SET ==>                           #Multiset with unique values.
                                  #Operations: like multiset, except count()
