
                   
   DATA_STRUCTURES  
                   



DEFINITION ==>                    #Composite type organized towards performing specific operations/algorithms

SUMMARY ==>                       #Relationship between data items:
                                  #  - serial: linear
                                  #     - order maintained by container:
                                  #        - generic access: list
                                  #        - FILO access: stack
                                  #        - FIFO access: queue
                                  #     - order maintained by items: linked list
                                  #  - parent/child: tree
                                  #     - 1 parent, 2 children: binary tree
                                  #        - optimized for search, can be compared: binary search tree
                                  #  - unrestricted: graph
                                  #  - none:
                                  #     - with keys: associative
                                  #     - without keys: set

OPERATIONS ==>                    #Most common operations on items:
                                  #  - creating/inserting
                                  #  - reading:
                                  #     - by key: accessing
                                  #     - by value: searching
                                  #  - updating
                                  #  - deleting


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          HIGH-LEVEL           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


UNION ==>                         #See types doc

ARRAY ==>                         #Aggregates items of the same|similar type
                                  #Keys can be:
                                  #  - numbers/indices ("single-value")
                                  #     - 0-based, 1-based or n-based
                                  #  - strings ("associative")
                                  #Items type can be composite ("container") or not
                                  #Array size can be:
                                  #  - fixed: "table"/"bounded"
                                  #  - dynamic: "collection"/"dynamic"
                                  #Items size ("width|stride|increment|step") can be:
                                  #  - always the same: faster access
                                  #  - or not: more compact
                                  #Position of an item since beginning of array is "offset"
                                  #Can have:
                                  #  - multiple dimensions|ranks ("matrix")
                                  #     - arranged:
                                  #        - row-major: row > column. better for sequential access
                                  #        - column-major: column > row. Better for array programming
                                  #        - iliffe vector: array of pointers towards other array
                                  #  - or not ("vector")
                                  #Metadata such as origin address, items type, length, dimension, stride
                                  #can be stored alongside in a "dope vector".
                                  #Is more a data type than a data structure:
                                  #  - does not prescribe operations or constraints, but representation
                                  #  - e.g. lists, sets and graphs can all be represented as arrays
                                  #  - some use the word "array" to also describe a data structure where items
                                  #    are fetched random-access, as opposed to "list" which is fetched serially

RECORD ==>                        #Aggregates items ("fields"/"members"/"elements"/"column") of different types
                                  #Also called "tuple", "struct[ure]" or "row"
                                  #Items size can be fixed or dynamic.
                                  #Keys:
                                  #  - fields that serve as identifier
                                  #  - "primary key" are unique keys
                                  #According to size, called:
                                  #  - "singleton", "pair", "triplet", "quad", "quint", etc.
                                  #  - "monuple", "couple", "triple", "quadruple", "quintuple", etc.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            LINEAR             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


BITWISE OPERATIONS ==>            #  - not ~
                                  #  - or |
                                  #  - and &
                                  #  - xor ^
                                  #  - shift:
                                  #     - left vs right
                                  #     - arithmetic|signed|sticky << >> vs logic|unsigned|zero-fill <<< >>>:
                                  #        - left arithmetic and left logic are same, i.e. they preserve sign bit
                                  #        - right arithmetic preserver sign bit, not right logic
                                  #        - arithmetic should be used with signed integers, logic with unsigned
                                  #           - some languages (C/C++/Go) have only << >> and choose according to type
                                  #     - often adds parameter NUM (how many shifts to do)
                                  #     - can be used to:
                                  #        - multiply by 2**NUM
                                  #        - divide by 2**NUM, but rounds towards -Infinity (where the usual is often towards 0)
                                  #  - rotate:
                                  #     - "no carry"/"circular"

BIT ARRAY ==>                     #Array of bits
                                  #Also called bit string|map|vector
                                  #Goal is often to:
                                  #  - be compact space-wise
                                  #  - be efficient, using CPU bitwise opcodes

BIT FIELD ==>                     #Record where fields ("flags") are bit-sized
                                  #Examples: Unix permissions, implementation of IEEE 754 floats, etc.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             LIST              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


LIST ==>                          #Array where items are ordered.
                                  #Also called "sequence"/"linear data structure"
                                  #Operations:
                                  #  - length()->NUM
                                  #  - get(INDEX)->VAL
                                  #  - set(INDEX, VAL)
                                  #  - remove(INDEX)
                                  #  - slice(INDEX, LENGTH)
                                  #  - clear()
                                  #When implemented as a simple array, both operations are random-access with O(1)

STACK/LIFO ==>                    #List with read|write to most-recent item
                                  #Often implemented as a simple array or as a linked list.
                                  #Operations:
                                  #  - push(VAL): O(1)
                                  #  - pop()->VAL: O(1)
                                  #  - peek()->VAL: O(1)

QUEUE/FIFO ==>                    #List with read|write to last-recent item
                                  #Sometimes used for buffers.
                                  #Often implemented as a linked list, a circular buffer or a double-ended queue
                                  #Operations:
                                  #  - push(VAL): O(1)
                                  #  - shift()->VAL: O(1)
                                  #  - head()->VAL: O(1)
                                  #Must keep information about current length to be O(1) instead of O(n)

DOUBLE-ENDED QUEUE ==>            #Combination of a stack and a queue
                                  #Also called "deque[ue]" or "head-tail"

PRIORITY QUEUE ==>                #List with read|write to highest priority item, where each item is assigned a "priority",
                                  #which can be using any type (as long as it can be compared).
                                  #Operations:
                                  #  - add(VAL, PRIORITY)
                                  #  - pull_highest|lowest()->VAL
                                  #  - peek_highest|lowest()->VAL
                                  #  - set_priority(INDEX, PRIORITY)
                                  #Often implemented as heaps

LINKED LIST ==>                   #Graph where nodes (except tail) always point to 1 other node
                                  #Operations:
                                  #  - length()->NUM: O(n)
                                  #  - get(INDEX)->VAL: O(n)
                                  #  - add(VAL, INDEX): O(n)
                                  #  - remove(INDEX): O(n)
                                  #  - slice(INDEX, LENGTH): O(1)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             GRAPH             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GRAPH ==>                         #Array of unique values ("node") that point to 0-n other nodes
                                  #Operations:
                                  #  - add(VAL)
                                  #  - remove(VAL)
                                  #  - find(VAL)
                                  #  - connect(VAL, VAL2)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             TREE              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TREE ==>                          #Graph with transitive (parent-children) relationships, i.e.:
                                  #  - each node ("child") has a single "parent"
                                  #  - there is a single top node ("root"):
                                  #     - no circular reference ("cycle")
                                  #        - i.e. cannot point to an ancestor or to itself
                                  #     - all elements have same root
                                  #        - i.e. all elements are part of the same tree
                                  #     - having no root, i.e. empty graph, might be allowed or not
                                  #Terminology:
                                  #  - two nodes with same parent are "siblings"
                                  #  - "descendants"/"ancestors" are any node part of the parent|child chain
                                  #  - "leaf"/"external node" vs "branch"/"internal node"/"inode": node with [no] children
                                  #  - "subtree": tree inside a tree
                                  #     - "degree": number of subtrees
                                  #  - "edge"/"link": pointer between a child and its parent
                                  #     - "path": sequence of nodes+edges connecting two nodes, including nodes themselves
                                  #     - "level": number of nodes in path to root, i.e. root is 1
                                  #        - "depth": number of edges in path to root, i.e. level - 1
                                  #     - "height" of a node: number of edges in path to furthest child leaf
                                  #        - "height" of a tree: height of the root
                                  #  - "branching factor"/"outdegree": number of children per node
                                  #     - high branching factor can increase complexity of some operations
                                  #  - "forest": several disjoint trees
                                  #Operations:
                                  #  - add(VAL, PARENT_VAL)
                                  #  - traverse|walk(FUNC(VAL))
                                  #     - can be done:
                                  #        - parent then children ("pre-order")
                                  #           - one level at a time ("level-order")
                                  #        - children then parent ("post-order")
                                  #        - left child then paren then right child ("in-order") (binary trees only)
                                  #Often implemented as an array of:
                                  #  - records [VAL, POINTER...]
                                  #  - VAL, with the children being previous|next items in array
TODO ==> GO THROUGH WIKIPEDIA ARTICLE OF TREE AGAIN, ESPECIALLY RELATED LINKS

BINARY TREE ==>                   #Tree where each node has two children or none

BINARY SEARCH TREE ==>            #Binary tree where first child < parent < second child
                                  #Operations:
                                  #  - has(VAL)->BOOL: O(log())
                                  #  - add(VAL): O(log(n))



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          ASSOCIATIVE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ASSOCIATIVE ARRAY ==>             #Unordered array of (KEY, VAL) pairs, with unique keys.
                                  #Also called "map" or "dictionary"
                                  #Operations:
                                  #  - get(KEY)->VAL
                                  #  - set(KEY, VAL)
                                  #  - remove(KEY)
                                  #Complexity depends on implementation, which is often
                                  #either as hash table or as search tree.

INDEX MAP ==>                     #Associative array implemented as a simple array and where KEY is index:
                                  #  - as opposed to a regular array, index is conceptually not used as such,
                                  #    but as a key
                                  #  - e.g. retrieving name of months by using KEY 1-12
                                  #Is the most efficient way of accessing an associative array
                                  #Also called "direct addressing" or "trivial hash function"

BIDIRECTIONAL MAP ==>             #Associative array where values are unique.
                                  #I.e. values can be used as keys as well.
                                  #Also called "hash bag"

MULTIMAP ==>                      #Associate array where values are arrays.
                                  #Can also be thought as associate array where keys are not unique
                                  #Also called "multihash" or "multidict"


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              SET              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


MULTISET ==>                      #Unordered array of values.
                                  #As opposed to a list, there is no order nor indices.
                                  #Also called "bag"
                                  #Operations:
                                  #  - add(VAL)
                                  #  - has(VAL)->BOOL
                                  #  - count(VAL)->NUM
                                  #  - remove(VAL)
                                  #  - clear()
                                  #  - length()->NUM: also called "cardinality" or "capacity"
                                  #  - pop()->VAL, pick()->VAL: pop|get random element
                                  #  - union(SET2)->SET3
                                  #  - intersection(SET2)->SET3
                                  #  - difference(SET2)->SET3
                                  #  - is_subset(SET2)->BOOL
                                  #Often implemented as a tree or an associative array

SET ==>                           #Multiset with unique values.
                                  #Operations: like multiset, except count()
