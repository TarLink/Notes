
                   
   DATA_STRUCTURES  
                   



DEFINITION ==>                    #Composite type organized towards performing specific operations/algorithms

SUMMARY ==>                       #Relationship between data items:
                                  #  - serial: linear
                                  #     - order maintained by container:
                                  #        - generic access: list
                                  #        - FILO access: stack
                                  #        - FIFO access: queue
                                  #     - order maintained by items: linked list
                                  #  - parent/child: tree
                                  #     - 1 parent, 2 children: binary tree
                                  #        - optimized for search, can be compared: binary search tree
                                  #  - unrestricted: graph
                                  #  - none:
                                  #     - with keys: associative
                                  #     - without keys: set

OPERATIONS ==>                    #Most common operations on items:
                                  #  - creating/inserting
                                  #  - reading:
                                  #     - by key: accessing
                                  #     - by value: searching
                                  #  - updating
                                  #  - deleting


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          HIGH-LEVEL           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


UNION ==>                         #See types doc

ARRAY ==>                         #Aggregates items of the same|similar type
                                  #Keys can be:
                                  #  - numbers/indices ("single-value")
                                  #     - 0-based, 1-based or n-based
                                  #  - strings ("associative")
                                  #Items type can be composite ("container") or not
                                  #Array size can be:
                                  #  - fixed: "table"/"bounded"
                                  #  - dynamic: "collection"/"dynamic"
                                  #Items size ("width|stride|increment|step") can be:
                                  #  - always the same: faster access
                                  #  - or not: more compact
                                  #Position of an item since beginning of array is "offset"
                                  #Can have:
                                  #  - multiple dimensions|ranks ("matrix")
                                  #     - arranged:
                                  #        - row-major: row > column. better for sequential access
                                  #        - column-major: column > row. Better for array programming
                                  #        - iliffe vector: array of pointers towards other array
                                  #  - or not ("vector")
                                  #Metadata such as origin address, items type, length, dimension, stride
                                  #can be stored alongside in a "dope vector".
                                  #Is more a data type than a data structure:
                                  #  - does not prescribe operations or constraints, but representation
                                  #  - e.g. lists, sets and graphs can all be represented as arrays
                                  #  - some use the word "array" to also describe a data structure where items
                                  #    are fetched random-access, as opposed to "list" which is fetched serially

RECORD ==>                        #Aggregates items ("fields"/"members"/"elements"/"column") of different types
                                  #Also called "tuple", "struct[ure]" or "row"
                                  #Items size can be fixed or dynamic.
                                  #Keys:
                                  #  - fields that serve as identifier
                                  #  - "primary key" are unique keys
                                  #According to size, called:
                                  #  - "singleton", "pair", "triplet", "quad", "quint", etc.
                                  #  - "monuple", "couple", "triple", "quadruple", "quintuple", etc.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            LINEAR             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


LIST ==>                          #Array where items are ordered.
                                  #Also called "sequence"/"linear data structure"
                                  #Operations:
                                  #  - length()->NUM
                                  #  - get(INDEX)->VAL
                                  #  - set(INDEX, VAL)
                                  #  - remove(INDEX)
                                  #  - slice(INDEX, LENGTH)
                                  #  - clear()
                                  #When implemented as a simple array, both operations are random-access with O(1)

BIT STRING ==>                    #List of bits
                                  #Also called bit array|map|vector
                                  #Goal is often to:
                                  #  - be compact space-wise
                                  #  - be efficient, using CPU bitwise opcodes
                                  #Often use bitwise operations: or, and, xor, not, shifts

STACK/LIFO ==>                    #List with read|write to most-recent item
                                  #Often implemented as a simple array or as a linked list.
                                  #Operations:
                                  #  - push(VAL): O(1)
                                  #  - pop()->VAL: O(1)
                                  #  - peek()->VAL: O(1)

QUEUE/FIFO ==>                    #List with read|write to last-recent item
                                  #Sometimes used for buffers.
                                  #Often implemented as a linked list, a circular buffer or a double-ended queue
                                  #Operations:
                                  #  - push(VAL): O(1)
                                  #  - shift()->VAL: O(1)
                                  #  - head()->VAL: O(1)
                                  #Must keep information about current length to be O(1) instead of O(n)

DOUBLE-ENDED QUEUE ==>            #Combination of a stack and a queue
                                  #Also called "deque[ue]" or "head-tail"

PRIORITY QUEUE ==>                #List with read|write to highest priority item, where each item is assigned a "priority",
                                  #which can be using any type (as long as it can be compared).
                                  #Operations:
                                  #  - add(VAL, PRIORITY)
                                  #  - pull_highest|lowest()->VAL
                                  #  - peek_highest|lowest()->VAL
                                  #  - set_priority(INDEX, PRIORITY)
                                  #Often implemented as heaps

LINKED LIST ==>                   #Graph where nodes (except tail) always point to 1 other node
                                  #Operations:
                                  #  - length()->NUM: O(n)
                                  #  - get(INDEX)->VAL: O(n)
                                  #  - add(VAL, INDEX): O(n)
                                  #  - remove(INDEX): O(n)
                                  #  - slice(INDEX, LENGTH): O(1)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             TREE              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TREE ==>                          #Graph with transitive (parent-children) relationships
                                  #No circular reference, i.e. cannot point to an ancestor or to itself
                                  #Operations:
                                  #  - add(VAL, PARENT_VAL)
                                  #  - traverse(FUNC(VAL))

BINARY TREE ==>                   #Tree where each node has two children or none

BINARY SEARCH TREE ==>            #Binary tree where first child < parent < second child
                                  #Operations:
                                  #  - has(VAL)->BOOL: O(log())
                                  #  - add(VAL): O(log(n))


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             GRAPH             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GRAPH ==>                         #Each node points to 0-n other nodes
                                  #Operations:
                                  #  - add(VAL)
                                  #  - remove(VAL)
                                  #  - find(VAL)
                                  #  - connect(VAL, VAL2)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          ASSOCIATIVE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ASSOCIATIVE ARRAY ==>             #Unordered array of (KEY, VAL) pairs, with unique keys.
                                  #Also called "map" or "dictionary"
                                  #Operations:
                                  #  - get(KEY)->VAL
                                  #  - set(KEY, VAL)
                                  #  - remove(KEY)
                                  #Complexity depends on implementation, which is often
                                  #either as hash table or as search tree.
                                  #"Index mapping"/"direct addressing"/"trivial hash function":
                                  #  - when implemented as a simple array and KEY is index 
                                  #     - as opposed to a regular array, index is conceptually not used as such,
                                  #       but as a key 
                                  #     - e.g. retrieving name of months by using KEY 1-12
                                  #  - is the most efficient way of accessing 

BIDIRECTIONAL MAP ==>             #Associative array where values are unique.
                                  #I.e. values can be used as keys as well.
                                  #Also called "hash bag"

MULTIMAP ==>                      #Associate array where values are arrays.
                                  #Can also be thought as associate array where keys are not unique
                                  #Also called "multihash" or "multidict"


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              SET              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


MULTISET ==>                      #Unordered array of values.
                                  #As opposed to a list, there is no order nor indices.
                                  #Also called "bag"
                                  #Operations:
                                  #  - add(VAL)
                                  #  - has(VAL)->BOOL
                                  #  - count(VAL)->NUM
                                  #  - remove(VAL)
                                  #  - clear()
                                  #  - length()->NUM: also called "cardinality" or "capacity"
                                  #  - pop()->VAL, pick()->VAL: pop|get random element
                                  #  - union(SET2)->SET3
                                  #  - intersection(SET2)->SET3
                                  #  - difference(SET2)->SET3
                                  #  - is_subset(SET2)->BOOL
                                  #Often implemented as a tree or an associative array

SET ==>                           #Multiset with unique values.
                                  #Operations: like multiset, except count()
