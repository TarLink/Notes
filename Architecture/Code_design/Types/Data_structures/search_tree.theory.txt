
               
   SEARCH_TREE  
               



SEARCH TREE ==>                   #Ordered arborescence where left children < parent < right children.
                                  #Optimized for:
                                  #  - search
                                  #  - serial access in sorted order
                                  #Time complexity:
                                  #  - search: O(m/2*logₘ n) where m is outdegree
                                  #  - insert|delete:
                                  #     - like search
                                  #     - first search of it, then perform constant-time insert|delete
                                  #  - tree must be balanced, otherwise:
                                  #     - height will average ᵐ√order, and complexity O(ᵐ√n)
                                  #     - can even be O(n) if search tree degenerates into a line graph
                                  #Values can be stored either on each node or only on leaves

SELF-BALANCING TREE ==>           #Tree that remains balanced after any set of operations
                                  #Also called "height-balancing tree"
                                  #Often on search trees

BINARY SEARCH TREE (BST) ==>      #Search tree where outdegree = 2
                                  #Search is "binary search".
                                  #Time complexity (if balanced): O(log n)

B-TREE ==>                        #Search tree where:
                                  #  - ⌈U/2⌉ <= outdegree <= U ("order")
                                  #  - no lower limit of outdegree for root
                                  #  - node's value is an array or numbers:
                                  #     - acting as separators between each two children
                                  #  - U can be picked to try to make nodes the same size as an I/O block
                                  #Similar to binary search tree:
                                  #  - which can be considered a b-tree of order 2
                                  #The higher the order:
                                  #  - better when nodes are read|write sequentially
                                  #     - i.e. when siblings nodes are usually read|write together
                                  #     - e.g. a file's blocks
                                  #  - instead of O(log₂ n), performs in O(m/2*logₘ n) to find node
                                  #    (which is worst), but then iterating|inserting|deleting siblings is faster
                                  #  - worst time complexity: some space is empty
                                  #  - less frequent balancing needed
                                  #If U is very high, can:
                                  #  - implement keys as a search tree themselves instead of a simple array
                                  #  - use delta encoding compression on keys (better space, worst time)
                                  #Self-balancing:
                                  #  - if node full|empty, can:
                                  #     - transfer ("rotation") or "merge|split" between siblings
                                  #        - must change parent keys as well
                                  #     - merge|split child to|from parent
                                  #  - must be done recursively from node to root
                                  #  - can be done either:
                                  #     - between operations
                                  #     - during operation, as nodes are being visited

B+ TREE ==>                       #B-tree where:
                                  #  - values are stored only on leaves
                                  #  - each leaf contains a pointer to next leaf (i.e. linked list)
                                  #I.e. like B-tree but with better sequential access accross several leaves.

RANDOM SEARCH TREE ==>            #When shuffling nodes before inserting many of them in a search tree.
                                  #Reason:
                                  #  - lower depth in average
                                  #  - e.g. inserting many sorted nodes (without balancing) would otherwise
                                  #    create a graph list as a subtree, increasing depth linearly
                                  #Variants:
                                  #  - do a random pick among all possible trees after insertion of each
                                  #    permutation of the nodes.
                                  #For a binary search tree, in average, depth will be:
                                  #  - mean: 2*log(n)+1
                                  #  - max: 4.3*log(n)

TREAP ==>                         #Tree of [VAL, KEY] pairs:
                                  #  - VALs behave like a search tree, usually binary
                                  #  - KEYs behave like a heap
                                  #  - self-balanced by making it a random search tree (using random KEYs)
                                  #Goal is self-balancing a search tree
                                  #Self-balance:
                                  #  - insertion:
                                  #     - perform binary search tree insertion using VAL
                                  #     - assign a random KEY
                                  #     - perform tree rotations on that node and its parent until KEY satisfies heap property
                                  #  - deletion:
                                  #     - perform tree rotations on that node and its right child until that node has no children
                                  #     - delete that node
                                  #  - split:
                                  #     - insert a node with VAL where split occurs and KEY being highest so that node becomes
                                  #       root
                                  #     - then remove that node, splitting tree
                                  #  - merge:
                                  #     - if max VAL of first tree if less than min VAL of second tree
                                  #     - then insert a node with VAL2 in-between, and KEY being lowest so that rotations
                                  #       performs the merge
                                  #     - then remove that node

