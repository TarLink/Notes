
        
   TRIE  
        


TRIE ==>                          #Search tree where:
                                  #  - keys are arrays
                                  #  - nodes store individual keys' items
                                  #     - i.e. root-to-terminal-node path contains full key
                                  #     - root node has no key item
                                  #Also called "prefix tree"
                                  #Goal:
                                  #  - similar as other search trees but optimized for operations of arrays
                                  #  - only efficient when keys share common prefixes
                                  #Time complexity:
                                  #  - min|average|max O(m) where m is min|average|max array length
                                  #  - but each node step should be fast as it involves a single key item
                                  #     - as opposed e.g. to binary search tree which compares whole array at
                                  #       each step, i.e. complexity is actually O(n*log(n)) on arrays
                                  #Keys are arrays, including:
                                  #  - strings
                                  #  - bits ("bitwise trie")
                                  #Terminal node:
                                  #  - every leaf is a terminal node but internal nodes can be too
                                  #  - can be represented either:
                                  #     - with a flag on the node
                                  #        - sometimes called "white" (terminal) / "black" (non-terminal)
                                  #     - with an empty terminal node child
                                  #Edges from parent to children can be represented in several ways:
                                  #  - dynamic array ("adaptive"):
                                  #     - O(n) lookup time
                                  #  - LCRS tree:
                                  #     - O(n) lookup time but more space efficient
                                  #  - binary search tree:
                                  #     - called (although confusingly) "ternary search tree"
                                  #     - O(log n) lookup time
                                  #     - often represented as a tree with outdegree 3 where:
                                  #        - left and right children are siblings (i.e. the binary search subtree)
                                  #        - middle child is actual child (i.e. the trie supertree)
                                  #  - static array:
                                  #     - with every possible combination, filled with null pointers when no child
                                  #     - O(1) lookup time but O(m) space requirement, where m is number of combinations
                                  #     - "alphabet reduction":
                                  #        - reducing number of combinations, e.g. nibble-wise (16) instead of byte-wise (256)
                                  #        - con: increases tree height
                                  #     - "array mapped trie": when using "array bit mapping" (see its doc)
                                  #        - "concurrent trie"/"ctrie":
                                  #           - using a 32 bits map and a compare-and-swap atomic CPU instruction, so that
                                  #             trie can be thread-safe and lock-free
                                  #Operations:
                                  #  - finding nodes by key prefix

RADIX TREE ==>                    #Trie where nodes can store several key items, as opposed to just one.
                                  #Goal:
                                  #  - more space efficient
                                  #  - more time efficient on reads
                                  #Cons:
                                  #  - less space efficient if high density
                                  #  - less time efficient on writes
                                  #Operations:
                                  #  - insertion: during initial traversal, if there is a partially matching child, split it
                                  #  - deletion: after deletion, merge single-child nodes to their child

DAFSA ==>                         #DAFSA (see state doc) can used to represent tries in a more space efficient way.
                                  #As opposed to normal representation:
                                  #  - simple cycles (but not directed ones) are allowed
                                  #  - i.e. nodes can share multiple parents as long as it does not introduce directed cycles
                                  #  - i.e. space efficient when many common suffixes

BURST TRIE ==>                    #Trie ("access trie") where leaves ("burst") are another data structure ("burst containers").
                                  #Goal:
                                  #  - using time|space efficiency of trie where prefixes are shared
                                  #  - while using time|space efficiency of other data structures where suffixes are unique
                                  #Common burst containers: list, search tree.
                                  #Different strategies on when burst should start:
                                  #  - max size of burst containers
                                  #  - max average number of operations on burst container

