
         
   PHP   
         


VERSION ==>                       #7.1

INTERPRETER ==>                   #Can be:
                                  #  - Zend engine: main one


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:         CONFIGURATION         :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


php.ini                           #CONF file, looked up in:
                                  #  - ENVVAR PHPRC
                                  #  - php -c FILE|DIR
                                  #  - $PWD (unless CLI)
                                  #Can also use:
                                  #  - php -d VAR[=VAL]
                                  #  - extra ini files specified with:
                                  #     - ENVVAR PHP_INI_SCAN_DIR "DIR:..."
                                  #        - for DIR/*.ini
                                  #     - compile-time flag --with-config-file-scan-dir:
                                  #        - overriden by PHP_INI_SCAN_DIR unless specifying empty DIR, e.g. "DIR::DIR2"
                                  #     - can show all the ones parsed with php --ini
                                  #Ini format is usual except:
                                  #  - can use ${VAR} (for CONF.VAR) or ${ENVVAR}
php -n                            #Do not use php.ini


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          BASE SYNTAX          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


<?php ... [?>]                    #Anything outside is left as is.
                                  #... is parsed by PHP, and replaced by its stdout
                                  #If ?> is end of file, do not use it, to avoid unwanted trailing whitespaces
<?= ... ?>                        #Same as <?php echo ... ?>

<?php STRUCTURE ?>                #Same as: 
...                               #  <?php
<?php ENDSTRUCTURE ?>             #  STRUCTURE
                                  #    echo '...';
                                  #  ENDSTRUCTURE
                                  #  ?>
                                  #Use : instead of { } ??? + end statement ???


STATEMENT;                        #Semi-colon terminated
VAL_LIT                           #Constant
EXPR                              #Expression, i.e. anything that returns a value, including but not limited to VAL_LIT
VAL                               #Implied unless *_LIT, VAR or $VAR is specified, e.g. STR means STR expression

// COMMENT
# COMMENT                         #Single-line. Stops at next ?>
/* COMMENT */                     #Multiple-line.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             TYPES             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


TYPE SYSTEM ==>                   #Nominative.
                                  #Weakly typed + type inferred: 
                                  #  - auto-typecasting, including at definition-time
                                  #  - optional "manifest typing" or "strict typing" on function arguments and return values
                                  #Dynamic/runtime type checking
(TYPE) VAL                        #Explicit type casting. TYPE: string|b[inary], bool[ean], int[eger], float|double|real, array, object, unset (null)


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           VARIABLES           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


VAR                               #[[:alnum:]_-]+, can use Unicode chars

$VAR,...                          #Declaration
                                  #Is optional, i.e. undeclared values can be referenced and will have falsy default values, i.e.:
                                  #  - STR: ""
                                  #  - BOOL: false
                                  #  - NUM: 0
                                  #  - ARR: []
$VAR = VAL                        #[Declaration +] Assignment, by value
                                  #Is an EXPR, i.e. returns new value
$VAR                              #Dereferencement

${STR}                            #Can be used like $VAR, but VAR name is STR
$$VAR                             #Same as ${$VAR}
$$$VAR                            #Same as ${${$VAR}}. Can add any number of $ for extra indirections
$$VAR[NUM]                        #Operator priority (from high to low): {} $ []
${$VAR}[NUM]                      #I.e. first two conceptually mean ($$VAR)[NUM], last means $($VAR[NUM])
${$VAR[NUM]}                      #Same thing for $$VAR->KEY


define("VAR", VAL)                #"Constants". Same as global variables except:
                                  #  - read-only
                                  #  - can only resolve to STR|BOOL|NUM|ARR|RES
                                  #  - referenced as VAR, not $VAR
                                  #     - i.e. ${EXPR} or $$VAR cannot be used
                                  #     - if undefined, defaults to "VAR" itself, with a warning message
                                  #  - uppercase by convention
                                  #  - cannot use instanceof
const VAR = VAL,...               #Same but evaluated compile-time not runtime.
                                  #This implies following restrictions:
                                  #  - VAL cannot contain FUNC(), but can contain builtin operators like + -
                                  #  - must be top-level scope, and not in any block


unset(VAR)                        #Removes a variable


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          REFERENCES           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


VALUE VS REFERENCE ==>            #By default:
                                  #  - OBJ always passed|returned|assigned by reference
                                  #  - others (including ARR, scalars) by value
                                  #     - but can do by reference with following syntax


$VAR =& $VAR
$VAR = &$VAR                      #Assignment by reference

function [FUNC]([TYPE] &$VAR,...)
 {...}                            
function [FUNC]([TYPE] &...$ARR)
 {...}                            
function (...) use (&$VAR,...)
 {...}                            #Argument by reference

function &[FUNC](...) {...}       #Return value by reference

foreach 
(ARR|OBJ as [$KEY =>] &$VAL) {...}#Assignment by reference. It is recommended to unset($VAL) after the loop.


(&$VAR)                           #Same as $VAR (i.e. loses reference)

GLOBAL/STATIC VARIABLES ==>       #Assigning a value by reference to global|static $VAR makes it non-global|static.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             SCOPE             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


SCOPE ==>                         #Function-level lexical scope.
                                  #No inheritance from parent function, except optional closure "use" structure.

SUPERGLOBAL ==>                   #PHP-defined global variable
$GLOBALS                          #Global scope, as ARR
                                  #I.e. any global variable will available at both $GLOBALS["VAR"] and $VAR
$GLOBALS["GLOBALS"]               #Same as $GLOBALS (recursion)
global $VAR,...                   #Global variable declaration (no assigning)
                                  #This declaration:
                                  #  - must be present in scopes that use $VAR
                                  #  - does not have to be present in parent|global scope

static $VAR [= VAL],...           #Declaration|assignment with a normal (i.e. function) scope, but:
                                  #  - only done during the first current function call
                                  #  - $VAR value is persisted for the next current function calls


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           FUNCTIONS           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


function [FUNC]                   #Declaration.
([TYPE] $VAR[ = VAL_LIT],...)     #Scope:
[: TYPE2] { ... }                 #  - uses function scope
                                  #  - can be declared after being used, if used in same scope
                                  #  - can be inside a structure or conditional block
                                  #Semicolon optional after }
                                  #Can fire FUNC(...), but not use FUNC as a normal variable
                                  #Cannot redefine already existing functions.
                                  #Case-insensitive name
                                  #Arguments:
                                  #  - VAL_LIT: default value
                                  #  - ...$ARR: 
                                  #     - variadic argument
                                  #     - must be last argument
                                  #     - can use TYPE: refers to each individual argument
function (...) [use ($VAR,...)]   #"Closure". Difference:
 {...}                            #  - is an EXPR, not a statement
                                  #     - i.e. follow normal variable scope|assignment rules
                                  #  - can be used as anonymous function
                                  #  - can be assigned, e.g. $a = function () {}; $a();
                                  #  - semicolon not optional
                                  #"use" $VAR:
                                  #  - inherits parent scope $VAR
                                  #     - lexical scope, evaluated at definition time
return [VAL];                     #Def: null

STRICT TYPING ==>                 #Using TYPE for function arguments or return value, among:
                                  #  - string, bool, int|float, array
                                  #  - CLASS|INTERFACE: including descendants
                                  #  - self: current CLASS|INTERFACE, or descendants
                                  #  - callable
                                  #To allow null as well, add null as default value
                                  #DIRECTIVE strict_types 0|1:
                                  #  - effect:
                                  #     - if 0 (def), only "manifest typing", i.e. tries to typecast
                                  #     - otherwise, also "strong typing", i.e. only allow INT->FLOAT typecast
                                  #  - must be first statement in file
                                  #  - affects all functions calls (not definitions) made in current file
                                  #  - not in CLI
                                  #Enforced runtime, with a TypeError exception

FUNC(VAL,...)                     #Function call
FUNC(...ITERABLE)                 #Same as FUNC(ITERABLE[0],...)
$VAR(...)                         #With $VAR being a FUNC ("closure")


FUNK                              #"Callable|callback", higher-level function.
                                  #Can be:
                                  #  - FUNC, including closure
                                  #  - OBJ with OBJ.__invoke()
                                  #  - variable name STR pointing to one of the above, as:
                                  #     - normal variable: 'VAR'
                                  #     - class variable: [OBJ, '[PARENT::]VAR']
                                  #     - class static variable: 
                                  #        - ['CLASS', '[PARENT::]VAR']
                                  #        - 'CLASS::[PARENT::]VAR'

FUNK(...)
call_user_func(FUNK, ...)         #Fires FUNK(...)
$VAR(...)                         #Same with $VAR containing FUNK


DIRECTIVE tick=NUM                #
register_tick_function(FUNK[,...])#Calls FUNK(...) every NUM statement
unregister_tick_function(FUNK)    #


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          STRUCTURES           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


(EXPR)                            #Same as EXPR, but with higher operator precedence


{
  ...  
}                                 #Same as ...


NO-CURLY BRACE SYNTAX ==>         #Curly braces can be skipped when their content is only a single statement

COLON SYNTAX ==>                  #Can replace:
                                  #  - colon instead of opening brace
                                  #  - endWORD (e.g. endif) instead of last closing brace
                                  #Not for "do while" nor "declare" structures


if (BOOL) { ... } 
elseif (BOOL) { ... } 
else { ... }                      #

while (BOOL) { ... }              #

do { ... } while (BOOL)           #

switch (VAL) {
  case VAL2:... ...; break;       #Uses ==
  default: ...; break;            #Can use case VAL2; instead of case VAL2:
}                                 #continue means same as break in switch loop

for ([EXPR,...]; [EXPR2,...];
 [EXPR3,...]) { ... }             #

foreach 
(ARR|OBJ as [$KEY =>] $VAL) {...} #

LABEL: [{ ... }]                  #
goto LABEL;                       #Must be within same function
                                  #Cannot jump inside a structure block (but can jump out)

break [NUM]                       #For any loop. Not for if structures
continue [NUM]                    #NUM (def: 1) is for nesteed loops


BOOL ? [VAL] : VAL2               #VAL defaults to first part (the one that evaluates to BOOL)

VAL ?? VAL2                       #Same as VAL === null ? VAL2 : VAL
                                  #"null coalescing operator"


declare (DIRECTIVE=VAL_LIT) {...} #Sets compiler DIRECTIVE during that block
                                  #Done compile-time
declare (DIRECTIVE=VAL_LIT);      #Same but for all following statements


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             NULL              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


TYPE CASTING ==>                  #Cast anything to null


null                              #Case-insensitive


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            STRING             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/



TYPE CASTING ==>                  #To STR:
                                  #  - BOOL: false -> "", true -> "1"
                                  #  - INT
                                  #  - FLOAT: 
                                  #     - might use exponent notation
                                  #     - decimal point uses locale
                                  #  - ARR: "Array" (avoid)
                                  #  - OBJ: uses OBJ.__toString()
                                  #  - RES: "Resource id #NUM" (unique string)
                                  #  - NULL: ""


'...'                             #STR
                                  #Escaping:
                                  #  - \ to escape \ '
                                  #  - newlines always escaped
                                  #Can contain any byte, incuding \0, so is used for binary data too.
"..."                             #Like '...', with extra parsing: 
                                  #  - VARR (see below)
                                  #  - backslash-escaping sequences:
                                  #     - among: \n \r \t \v \f \0N[N[N]] \xN[N] \u[N[N[N[N]]]]
                                  #Must escape " $ instead of '
"...$VARR..."                     #Variable expansion. $VARR can be:
                                  #  - $VAR[VAL_LIT]
                                  #  - $VAR->VAR2
"...${VARR}..."                   #Same as $VARR, except it delimitate variable names from surrounding characters
"...{$VARR}..."                   #As opposed to above:
                                  #  - $VAR[VAL] (not VAL_LIT)
                                  #Also $VARR can be:
                                  #  - multidimensional indexing, e.g. VAR[...]->...->...
                                  #  - ${STR} or $VAR->{STR}
<<<["]DELIM["]
...                               
DELIM;                            
<<<'DELIM'                        #"Heredoc" (first), "Newdoc" (second)
...                               #Like "..." or '...' except no need to escape " or '
DELIM;                            #No leading|trailing whitespaces


CHARSET/UNICODE ==>               #String operations are byte-wise, not character-wise, except:
                                  #  - if encoding can be specified as argument
                                  #  - if current locale is used

STR[NUM]                          #NUM can be: 
STR{NUM}                          #  - negative: from end of string
                                  #  - overflow: padds with spaces


STR . STR2                        #Concatenation
STR .= STR2                       #

STR++                             #Increment ASCII value:
++STR                             #  - among allowed ones: a-z, A-Z or 0-9
                                  #  - each character remain in its class, i.e. z rotates to a, Z to A, 9 to 0
                                  #  - last non-allowed characters and anything before are never modified
                                  #STR-- and --STR not available

~STR                       
STR << >> & ^ | STR2      
$VAR <<= >>= &= ^= |= STR         #Bitwise operation, using ASCII binary (as opposed to converting to number)


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            BOOLEAN            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


TYPE CASTING ==>                  #To BOOL:
                                  #  - STR: "" or "0" -> false, else true
                                  #  - NUM: 0 -> false, else true
                                  #  - ARR: length > 0
                                  #  - NULL: false
                                  #  - else: true


true
false                             #BOOL. Case-insensitive

!BOOL
BOOL and BOOL2
BOOL && BOOL2                     
BOOL or BOOL2
BOOL || BOOL2                     #and|or have lower operator precendence than && || or even =
BOOL xor BOOL2                    #Cannot be used to chain statements|expressions

VAL == VAL2
VAL != <> VAL2                    #Type casts
VAL === VAL2
VAL !== VAL2                      #Must be same type (no type cast)
VAL < <= > >= VAL2                #
VAL <=> VAL2                      #Same as VAL < VAL2 ? -1 : VAL > VAL2 ? 1 : 0


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            NUMBERS            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


TYPE CASTING ==>                  #To NUM:
                                  #  - STR:
                                  #     - tries to parse as INT first, then as FLOAT
                                  #     - non-numerical characters at end are ignored
                                  #     - if error, 0
                                  #  - BOOL: false -> 0, true -> 1
                                  #  - FLOAT -> INT:
                                  #     - round towards zero
                                  #     - overflow -> undefined
                                  #     - NAN|INF -> 0
                                  #  - NULL: 0
                                  #  - else: undefined


[-|+]NUM                          #INT (signed integers)
                                  #NUM can be prefixed by 0 (octal), 0x|0X (hex) or 0b (binary)
                                  #Limits:
                                  #  - PHP_INT_SIZE, PHP_INT_MIN|MAX
                                  #  - depends if OS is 32 or 64 bits
                                  #  - if overflow, parsed as FLOAT instead

[-|+]NUM[.NUM2][e|E[-|+]NUM3]     #FLOAT
                                  #Size: OS dependent, but usually double
NAN                               #FLOAT
                                  #NAN != NAN
                                  #Case sensitive
[-|+]INF                          #FLOAT
                                  #Case sensitive


+NUM
-NUM                              #
NUM + - * / % NUM2                #Returns INT|FLOAT, depending on result
NUM ** NUM2                       #Exponation

$VAR++ $VAR-- ++$VAR --$VAR       #
$VAR += -= *= /= %= **= NUM       #

~NUM                              
NUM << >> & ^ | NUM2              
$VAR <<= >>= &= ^= |= NUM         #Bitwise


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             ARRAY             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


TYPE CASTING ==>                  #To ARR:
                                  #  - STR|BOOL|NUM|RES: like [STR|...]
                                  #  - NULL: []
                                  #  - OBJ:
                                  #     - reuse keys|values
                                  #     - special members:
                                  #        - protected OBJ->VAR becomes OBJ->\0*\0VAR
                                  #        - private OBJ->VAR becomes OBJ->\0CLASS\0VAR

COMPARISON ==>                    #Any OBJ > any ARR > any other VAL
                                  #ARR == != <> === !== ARR2:
                                  #  - if same size and same keys, value by value comparison
                                  #  - if different size, length comparison
                                  #  - otherwise, cannot compare


KEY                               #EXPR evaluating to INT|STR. INT prevails.
[[KEY => ]VAL,...]                #ARR
array([KEY => ]VAL,...)           #Is an associative array. As opposed to OBJ, is ordered.
                                  #Trailing comma allowed
                                  #If KEY appears several times, last one prevails
                                  #Default KEY: 
                                  #  - 1 + max KEY_INT (including deleted keys)
                                  #  - or 0
                                  #  - i.e. increments
ARR[KEY]                          #Can be assigned
ARR{KEY}                          #If overflow, NULL + warning message
ARR[KEY][KEY2]...                 #

ARR[KEY] = VAL                    #If ARR does not exist, creates it (avoid)
ARR[] = VAL                       #Appends

list($VARR, ...) = ARR            #Deconstruction, i.e. $VAR = ARR[0]; $VAR2 = ARR[1]; ...
                                  #$VARR is same as in "...{$VARR}..."
                                  #Each $VARR can be ommitted
                                  #Can be nested

unset(ARR[KEY])                   #Removes key + value


ARR + ARR2                        
ARR += ARR2                       #Union, i.e. merge according to keys, with ARR having priority


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            OBJECTS            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


TYPE CASTING ==>                  #To OBJ:
                                  #  - ARR: reuse key|values, except KEY_NUM:
                                  #     - numbers are not proper VAR, i.e.:
                                  #        - OBJ->{"1"} !== OBJ->{1} 
                                  #        - OBJ->{1} and OBJ->1 are illegal
                                  #     - i.e. cannot be directly accessed, but can be iterated over
                                  #  - NULL: {}
                                  #  - other VAL: { scalar: VAL }
                                  #The typecasted object CLASS is "stdClass"


class CLASS [extends CLASS2]
{ 
  [public|private|protected] 
   var|const $VAR = VAL;
  [public|private|protected] 
   [static] function FUNC() {...}
}                                 #Class definition, in current scope
                                  #Inheritance:
                                  #  - child must reuse:
                                  #     - exact same return TYPE (if specified)
                                  #        - int !== float
                                  #        - any CLASS === any other CLASS (parent|child or not)
                                  #     - does not apply to arguments TYPEs

$this                             #Current OBJ

OBJ = new CLASS                   #OBJ declaration

OBJ->VAR                          #Using a member
OBJ->{STR}                        #Same using an EXPR, evaluating to VAR
OBJ->$VAR                         #Same as OBJ->{$VAR}
OBJ::VAR
OBJ::{STR}
OBJ::$VAR                         #Same for static member



VAL instanceof CLASS|INTERFACE    #True if VAL is OBJ whose type is CLASS|INTERFACE (or a descendant)
VAL instanceof STR                #Same with CLASS|INTERFACE name
VAL instanceof VAL2               #Same using VAL2's class|interface


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           RESOURCES           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


TYPE CASTING ==>                  #Not allowed


RES                               #Resource, i.e. file or network connection


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            ERRORS             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


@VAL??? See http://php.net/manual/en/language.operators.errorcontrol.php


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             SHELL             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


`...`                             #Fires ... in current shell
shell_exec("...")->STR            #Return value is:
                                  #  - null if parsing error
                                  #  - otherwise, stdout+stderr
                                  #     - if "" -> null
                                  #`...` works like "..." including for variable expansion


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             HTTP              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


All this chapter: ???

CGI??? Including RFC 3875

$argv                             
$_SERVER["argv"]                  #Global
$argc                             
$_SERVER["argc"]                  #Global
$_ENV                             #Global

$php_errormsg                     #Global

$_SERVER                          #Global ARR. Contains all ENVVAR, plus additional documented here
$_SERVER["DOCUMENT_ROOT "]        #STR
$_SERVER["PATH_TRANSLATED"]       #STR
$_SERVER["PHP_SELF"]              #STR
$_SERVER["REQUEST_TIME[_FLOAT]"]  #INT|FLOAT
$_SERVER["SCRIPT_FILENAME"]       #STR
$_SERVER["SCRIPT_NAME"]           #STR

$_POST                            #Global ARR with request body variables
$_GET                             #Global ARR with request query variables
$_COOKIE                          #Global
$_FILES                           #Global
$_REQUEST                         #Global ARR with request body|query variables
                                  #Variable names:
                                  #  - dots and spaces are converted to _
                                  #  - can be:
                                  #     - VAR[VAR2]: parsed as ARR
                                  #     - VAR[]: appended to ARR
$http_response_header             #Global

$_SESSION                         #Global


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           NAMESPACE           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


__NAMESPACE__                     #Current namespace


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             FILES             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


CONF.include_path                 #Same format as Unix $PATH


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            MODULES            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


include|require[_once] "PATH"     #PATH is relative to (in order):
                                  #  - CONF.include_path
                                  #  - __DIR__
                                  #  - $PWD
                                  #Only difference between include|require is:
                                  #  - if file cannot be found, emits warning|error
                                  #If "_once" and module was already included, does not include it and returns true
                                  #Scope-wise, included files behave like if they were inserted inline, except:
                                  #  - for __*__ variables
                                  #  - stops parsing, i.e. like ?> include "PATH"; <?php
                                  #Returns VAL|false on success|error
return [VAL];                     #Stops execution and pass return value
                                  #Def: 1

__LINE__                          #Line number. 1 if CLI
__FUNCTION__                      #Current function name. "" if top-level
__METHOD__                        #Current method name. "" if none
__CLASS__                         #Current class, when inside a method. "" otherwise
                                  #Prepended by "NAMESPACE|" if there is one
__TRAIT__                         #Current trait. "" if none
                                  #Prepended by "NAMESPACE|" if there is one
__FILE__                          #Current file path. "php shell code" if CLI
__DIR__                           #Current file directory. $PWD if CLI


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            OTHERS             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


echo STR                          #Prints STR to stdout
