
                       
   FUNCTIONAL_THEORY   
                       



ARITY ==>                         #Number of arguments.
                                  #unary, binary, ternary, etc.

OPERATORS ==>                     #Less verbose function name:
                                  #  - more convenient (syntactic sugar)
                                  #  - but harder to communicate precise purpose|contract
                                  #     - e.g. consumers might introduce different purpose|contract by overloading
                                  #Harder to parse, e.g. need to establish implicit operator priority order


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             STATE             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


CLOSURE ==>                       #Function holding state accross executions thanks to lexical scope binding

COROUTINE ==>                     #Function that holds state accross executions, including where it left off:
                                  #  - run until explicit yield 
                                  #  - jump to any function (instead of returning to caller)
                                  #  - when called again, restart at yield point

GENERATOR|SEMICOROUTINE ==>       #Coroutine that only jumps back to caller when yielding, usually returning value
                                  #Usually meant for iterators or streams



IMPERATIVE VS FUNCTIONAL ==>      #Imperative programming emphasizes state manipulation
                                  #  - pros: more flexible
                                  #Functional programming emphasizes referential transparency
                                  #  - pros:
                                  #     - easier to reason with:
                                  #        - for programmers
                                  #        - for static analysis, e.g. easier to test
                                  #     - easier to optimize
                                  #  - usually corrolated with declarative programming

REFERENTIAL TRANSPARENCY ==>      #Also called "purity".
                                  #Function that can be replaced by its return value, i.e.:
                                  #  - does not cause side effects
                                  #  - does not depend on state outside its arguments (i.e. local scope)

IDEMPOTENCY ==>                   #Function that can be called twice without state change, i.e.:
                                  #  - side effect always result in same state (including no side effects)
                                  #  - does not depend on state outside its arguments (i.e. local scope)
                                  #Goal: duplicated calls (e.g. retries) are not a problem, i.e. no need to keep state about previous calls

SIDE EFFECT ==>                   #When state changes after a function has been fired, including:
                                  #  - changing caller state:
                                  #     - arguments passed by reference
                                  #     - global scope
                                  #  - changing closure state
                                  #  - changing control flow, e.g. jumping, including raising exception
                                  #Usually execution time is not considered side effect
                                  #Statement (causes side effects) vs expression (no side effects)
                                  #Alternative to causing side effect (when flexibility is needed, e.g. I/O): returning state|action object to caller



Turing machine:
  - input: array of values ("symbols"):
     - of infinite size, but from a finite set
     - null ("blank"):
        - special symbol
        - originally only nulls
        - only symbol that can appear infinitely
  - current state, from a finite state, including:
     - start state 
     - end states (halt)
        - including any STATE not present in table of instructions
  - table of instructions, i.e. a finite { STATE: {INPUT: [INSTRUCTION, NEW_STATE] ... } ... }
     - INSTRUCTION is:
        - WRITE: "write some value back"
        - MOVE: "move head one index on the left, right or same position"
     - 5-tuple model: WRITE + MOVE, 4-tuple model: either WRITE or MOVE
  - current position ("head"):
     - reads current value as current INPUT
     - performs INSTRUCTION (using table of instructions)
     - changes to NEW_STATE
  - often represented as table of 5-tuples (STATE, INPUT, WRITE_VALUE, MOVE, NEW_STATE)
  - universal Turing machine:
     - turning machine which gets its table of instructions as input
     - e.g. code is data ("stored program computer")
     - architecture where code can be treated as data, and data can be treated as code:
        - Von Neumann architecture: same memory for both
        - Harvard architecture: different memory
  - alternates:
     - "turning equivalent", i.e. not more powerful than normal Turing machine, i.e.:
        - cannot express more but can:
           - have more expressive instructions
           - use less memory
           - use less instructions
        - could be refactored as a normal Turing maching
