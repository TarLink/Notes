
          
   UUID   
          


HEADER ==>              #<boost/uuid/uuid_generators.hpp>
NAMESPACE ==>           #Il s'agit de boost::uuids::

uuid                    #UUID.
                        #Utiliser le constructor ou générer avec l'un des 
                        #fonctors prévus pour.
                        #Est implémenté comme un ensemble de 16 octets 
                        #simplement (sizeof(uuid) == 16) => on peut le 
                        #transférer vers un std::vector pour manipuler les 
                        #octets séparément.
                        #Peut être utilisé avec boost::hash.
                        #Est Serializable avec boost::serialization
                        #(inclure <boost/uuid/uuid_serialize.hpp>)

UUID()                  #Construit un UUID aléatoire et unique, time-based.

UUID == UUID2
UUID != UUID2
UUID < UUID2
UUID > UUID2
UUID <= UUID2
UUID >= UUID2           #Test d'égalités.
UUID.is_nil()           #Renvoie true si UUID est égal à :
                        #   - 00000000-0000-0000-0000-000000000000

uuid::iterator          #Iterateur (*iterator renvoie des UINT8_VAL)

UUID.begin()            #
UUID.end()              #A utiliser avec uuid::iterator

UUID.data               #UUID, sous forme d'UINT8_ADR.

UUID.swap(UUID2)        #
swap(UUID, UUID2)       #Swappe UUID et UUID2

UUID.static_size()      #Renvoie toujours 16.

UUID.size()             #Renvoie toujours 16.
UUID.variant()          #Renvoie la VARIANT_TYPE d'UUID (read-only)
UUID.version()          #Renvoie la VERSION_TYPE d'UUID (read-only)

UUID.variant_type       #Enum représentant la variante de l'algorithme de
UUID.                   #génération des UUID. Valeurs possibles :
UUID.variant_ncs        #
UUID.variant_rfc_4122   #
UUID.variant_microsoft  #(défaut)
UUID.variant_future     #

UUID.version_type       #Enum représentant la version de l'algorithme. Valeurs
                        #possibles :
UUID.version_unknown    #
UUID.version_time_based #(défaut avec le constructor par défaut)
UUID.
version_dce_security    #
UUID.
version_name_based_md5  #
UUID.
version_random_number_  #
based                   
UUID.
version_name_based_sha1 #

basic_random_generator  #Functor, générant des UUID aléatoires, selon 
<RAND_GEN_PA>           #RAND_GEN_PA, random-based.

BASIC_RANDOM_GENERATOR()#Génèration.

random_generator        #Typedef depuis basic_random_generator <boost::mt19937>

string_generator        #Functor, générant des UUID identiques à une STRING, qui
                        #doit être sous la forme :
                        #   - XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX

STRING_GENERATOR(STRING)#Génèration.

name_generator          #Functor, générant des UUIDS aléatoires et uniques, mais
                        #en fonction d'un autre UUID et d'une STRING (ou STR, 
                        #etc.), et renvoie toujours le même UUID avec ces deux
                        #éléments, name-based donc.

NAME_GENERATOR(UUID)    #Construit un NAME_GENERATOR lié à UUID.

NAME_GENERATOR(STR)
NAME_GENERATOR(WSTR)
NAME_GENERATOR(STRING)
NAME_GENERATOR(WSTRING) 
NAME_GENERATOR(ADR,     
SIZE_T_VAL)             #Génération.

nil_generator           #Functor, générant des UUID nuls :
                        #   - 00000000-0000-0000-0000-000000000000

NIL_GENERATOR()         #Génèration.

HEADER ==>              #<boost/uuid/uuid_io.hpp>

ISTREAM >> UUID
OSTREAM << UUID         #UUID est alors considéré comme une STRING.

to_string(UUID)         #Renvoie UUID sous forme de STRING
to_wstring(UUID)        #Renvoie UUID sous forme de WSTRING

                    /=+===============================+=\ 
                   /  :                               :  \  
                   )==:      STANDARD ITU X.667       :==(   
                   \  :_______________________________:  /    
                    \=+===============================+=/

Intérêt :
  - ID sûr (ou très peu probable) de ne pas être généré deux fois de suite
  - Ne nécessite pas de centre pour gérer les ID.
  - consiste en une clef de 128 bits, dont représentation standard est hexadécimal :
    - XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX

Utilisation :
  - COM methodes (GUID)
  - UUID ext2-4

Différentes méthodes :
  - Time-based method :
    - Time : TimeValue{1..3} (60 bits)
      - : nombre de secondes depuis 15 oct. 1582
    - ClockSeq : ClockSeq{1,2} (14 bits)
      - statique, ou change peu, dans le seul but d'éviter duplications en cas de time remis en arrière
    - Node : (48 bits)
      - MAC adress
  - DCE security : 
    - comme time-based mais upper byte de ClockSeq{1,2} est celui d'un domain local (POSIX UID/GID domain)
    - et 4 premiers octets de TimeValue est POSIX UID/GID
  - Name-based : ces trois champs sont le hash d'une string et d'une UUID (MD5 ou SHA1)
  - Random-base : ces trois champs sont remplis aléatoirement
     - has 122 bits of randomness. Probably of generating 2 duplicate after n tries are 1-(e^-(n^2 / 2*(2^122))) :
       - 10^16 tries: one chance over 100000
       - 10^17 tries: one chance over 1000
       - 10^18 tries: one chance over 10
     - with n UUIDs, m tries -> about m^n tries for same chance

UUID : 
  - 16 octets : XXXXXXXX-XXXX-YXXX-XXXX-XXXXXXXXXXXX
    - Y indique Version utilisée
  - fields :
    - XXXXXXXX : TimeLow field (TimeValue3, 32  bits)
    - XXXX : TimeMid field (TimeValue2, 16 bits)
    - XXXX : VersionAndTimeHigh field (16 bits)
      - Version (4 MSB) : 
        - 1 : time-based
        - 2 : DCE-security (embedded POSIX UUID)
        - 3 : name-based + MD5
        - 4 : random-based
        - 5 : name-based + SHA1
      - TimeValue1 (12 bits)
    - XXXX :
      - VariantAndClockSeqHigh (1ère octet) :
        - Variant (2 MSB) :
          - 0 : réservé
          - 2 : variante officielle
          - 3 : variante Microsoft GUID
        - ClockSeq2 (6 bits)
      - puis ClockSeqLow (ClockSeq1, 8 bits)
    - XXXXXXXXXXXX : Node (48 bits)
