
         
   YARGS  
         



ALTERNATIVES ==>                  #  - yargs (preferred): has more features related to config file, help messages (including i18n)
                                  #  - caporal.js: has more features related to logging, colors, auto-typing suggestions.
                                  #    Not maintained
                                  #  - commander: less features
                                  #  - minimist: very few features. not maintained

VERSION ==>                       #8.0.2

CLI_OPTS                          #Mean either '-O[=]OPT_VAL' or '--OPT[=]OPT_VAL'
                                  #Can nest: OPT.OPT2=OPT_VAL will be parsed to OPT: { OPT2: OPT_VAL }
                                  #Top file should probably have #!/usr/bin/env node

CHAINED COMMANDS ==>              #All commands, unless specified otherwise, return YARGS

EXIT CODE ==>                     #0 if success, 1 if failure

YARGS.argv                        #Parsed options as OBJ:
                                  #  - OPT OPT_VAL:
                                  #     - OPT_VAL defaults to true
                                  #  - _ STR_ARR:
                                  #     - anything that is not an OPT or an OPT_VAL
                                  #     - if using COMMANDs, the first element is the COMMAND
                                  #  - $0 STR: main file
                                  #Is actually a getter function, i.e. must be accessed after everything else has been setup.
YARGS(CLI_OPTS[_ARR][,DIR])       #Parse CLI_OPTS so that YARGS.argv can be retrieved
                                  #If not fired, YARGS.argv will automatically use process.argv.slice(2) instead.
                                  #DIR is current directory (def: process.cwd())
YARGS.parse                       #Same as YARGS(...).argv, except:
(...[, OBJ2][, FUNC])->OBJ        #  - if OBJ2, is merged to YARGS.argv
                                  #  - if FUNC, FUNC(ERROR, YARGS.argv, STR) is also fired:
                                  #     - ERROR is exit error if any
                                  #     - STR is what is printed on console

YARGS.option[s]({ OPT: OPTS ... }
YARGS.option[s]('OPT'[, OPTS])    #Adds a possible OPT, or several. OPTS ???

YARGS.reset()                     #Resets YARGS state.
                                  #This is useful e.g. when needs several-staged YARGS, e.g.:
                                  #  - first parse main command
                                  #  - then build a YARGS depending on that command
                                  #Automatically called by YARGS.command()
YARGS.global('OPT'[_ARR][, BOOL]) #Make OPT global (or not if BOOL false), i.e. not affected by YARGS.reset()
                                  #By def, OPTs are global.

YARGS.command                     #Add a COMMAND
('COMMAND'[_ARR], STR[[, OBJ] or  #Can specify an ARR for aliases
[FUNC(YARGS)->YARGS[, FUNC2]]])   #STR is description.
                                  #If STR false instead, will be hidden, i.e. not shown in help|completion.
                                  #Each COMMAND has its own YARGS instance, using YARGS.reset():
                                  #  - using OBJ fires YARGS.option(OBJ)
                                  #  - FUNC is fired with YARGS
                                  #  - FUNC2 is fired with YARGS.argv

YARGS.alias
 ('OPT'[_ARR], 'OPT2'[_ARR])
YARGS.alias
 ({ OPT: 'OPT2'[_ARR] ... })      #Create alternative OPT names.
                                  #On parsing, both OPT and OPT2 will be set.

YARGS.nargs('OPT'[_ARR], NUM)     #Number of arguments after OPT.
                                  #By default:
                                  #  - max 1 argument. I.e. this allows for several arguments per OPT,
                                  #    in which case OPT_VAL will be ARR
                                  #  - can be 0 or 1 arguments. I.e. this validates strict number of arguments
                                  #  - stops at next option. I.e. this allows for arguments that
                                  #    looks like options.
YARGS.requiresArg('OPT'[_ARR])    #OPT must have >= 1 arguments

YARGS.boolean('OPT'[_ARR])        #Make OPT_VAL BOOL.
                                  #Using OPT will set to true, and not using will set to false.
YARGS.string('OPT'[_ARR])         #Make OPT_VAL STR. Defaults to ''.
YARGS.number('OPT'[_ARR])         #Make OPT_VAL NUM.
                                  #Defaults to undefined. NaN if cannot be parsed as NUM.
YARGS.count('OPT'[_ARR])          #Make OPT_VAL NUM, but set to the number of times OPT is specified.
YARGS.array('OPT'[_ARR])          #Make OPT_VAL ARR. Is variadic (unless YARGS.nargs())
                                  #Is compatible with YARGS.boolean|string|number()

YARGS.choices
 ('OPT'[_ARR], OPT_VAL_ARR)
YARGS.choices
 ({ OPT: OPT_VAL_ARR, ... })      #Limit possible OPT_VALs
YARGS.check
 (FUNC(YARGS.argv)->true|STR      #If FUNC() returns|throws STR, prints it and fails.
  [, BOOL])                       #Is global (see YARGS.global()) unless BOOL false.

YARGS.strict([BOOL])              #Enables|disables that unknown arguments are forbidden
                                  #(def: true, but disabled by def)
YARGS.demandOption
 ('OPT'[_ARR][, STR])             #Make OPT required.
YARGS.demandOption                #Not compatible with YARGS.default()
 ({ OPT: true|STR, ... })         #STR is extra error message.
YARGS.demandCommand               #Requires a min|max of COMMANDs. Def NUM: 1
 ([NUM][, NUM2][, STR[, STR2]])   #STR|STR2 are the min|max error messages
YARGS.implies('OPT', 'OPT2')
YARGS.implies({ OPT: 'OPT2' ... })#If OPT is defined, OPT2 must be defined too
YARGS.conflicts(...)              #Inverse

YARGS.skipValidation('OPT'[_ARR]) #Do not run: choices(), check(), requiresArg(), strict(), demandOption(), demandCommand(),
                                  #implies(), conflicts().
                                  #They will still be used for error msessages.
                                  #The following will still be validated: nargs()
                                  #The following do not validate, only influence parsing: boolean(), string(), number(),
                                  #count(), array()
                                  #For some reason, it seems to only work if OPT is a BOOL, and was specified by user.

YARGS.default
 ('OPT'[_ARR], OPT_VAL[()][, STR])#Sets default value
YARGS.default({OPT: OPT_VAL, ...})#STR is default value is displayed in help()
YARGS.config(OBJ)                 #Works like YARGS.default(), except not displayed in help() and higher priority
YARGS.coerce('OPT'[_ARR],
 FUNC(OPT_VAL)->OPT_VAL)          #Modifies OPT_VAL.
YARGS.coerce({ OPT: FUNC, ... })  #Can throw ERROR to notify of validation error.
YARGS.normalize('OPT'[_ARR])      #Like YARGS.coerce(..., PATH.normalize)

YARGS.config                      #Means OPT (def: 'config') will be a path to a config file
 (['OPT'][, STR][, FUNC('PATH')]) #STR is option description
                                  #File content is merged into YARGS.argv
                                  #FUNC() is fired to load the file content, by def require(), i.e. can use *.js|json
YARGS.env()
YARGS.pkgConf()

YARGS.exitProcess()
YARGS.fail()

YARGS.version()

YARGS.wrap()

YARGS.describe()
YARGS.epilog[ue]()
YARGS.example()
YARGS.group()
YARGS.help()
YARGS.showHelp()
YARGS.showHelpOnFail()
YARGS.updateStrings()
YARGS.usage()

YARGS.detectLocale()
YARGS.locale()
YARGS.updateLocale()

YARGS.recommendCommands()         #Provides auto-suggestion of COMMANDs in case of typos

YARGS.completion()
YARGS.getCompletion()
YARGS.showCompletionScript()
