
         
   JWT   
         


GOAL ==>                      #Send JSON information with crypto signature.
                              #Usually info is who issued another info.

JWT: JWS or JWE
		 
JWS is ENVLOP.PAYLOAD.SIGN:
  - Each part are Base64
	- parts:
		 - ENVLOP/JOSE Header OBJ:
		    - typ: "JWT"
				- cty: "JWT", when nested JWT
				- alg: "ALGO", different alsog are called JWA:
				   - HS256|384|512: HMAC-SHA, symetric algo (recipient must have PRIVATE_KEY)
					 - RS256|384|512: RSASSA-PKCS-v1.5 SHA, asym. also (recipient must have PUBLIC_KEY)
					 - ES256|384|512: ECDSA with SHA
					 - PS256|384|512: RSASSA-PSS SHA and MGF1
					 - none
				- x5c: PUBLIC_KEY_CERT
				- x5u: PUBLIC_KEY_CERT_URL
				- x5t: PUBLIC_KEY_CERT_THUMBPRINT
				- kid: PUBLIC_KEY_ID
				- jwk: PUBLIC_KEY
				- jku: PUBLIC_KEY_OBJ
				- cty: PAYLOAD_MIME
	   - PAYLOAD/Claims set OBJ (all optional):
	      - iat NUM: issued time
		    - exp NUM: expiration time
				- nbf NUM: only valid starting from that time
		    - iss ISSUER: entity giving token. Must check right ISSUER
		    - aud AUDIENCE: entity receiving token (optional). If there, must check it.
		    - sub USER_ID
				- jti: JWT ID
	   - SIGN is signature of ENVLOP.PAYLOAD:
		    - SIGN = SHA256(ENVLOP.PAYLOAD, PRIVATEKEY)
        - can check with CRYPTO.createVerify("sha256").update(ENVLOP.PAYLOAD).verify(PUBLICKEY, SIGN, "base64")
				- for Google, PRIVATEKEY is CERT.kid

JWE is ENVLOP.ENCRYPTED_PRIVATE_KEY.JWE_IV.ENCRYPTED_MESSAGE.ENCRYTPED_MESSAGE_TAG:
	- before encryption:
		 - MESSAGE
		 - ENVLOP/JWE protected Header OBJ:
		    - alg: "ALGO1"
				- enc: "ALGO2"
		 - PRIVATE_KEY
		 - JWE_IV
  - final (all base64):
	   - ENVLOP
		 - ENCRYPTED_PRIVATE_KEY: ALGO1(PRIVATE_KEY)
		 - JWE_IV:
	   - ENCRYPTED_MESSAGE:
		    - ALGO2(MESSAGE, PRIVATE_KEY, JWE_IV, ASCII(BASE64(UTF8(ENVELOP))))
		 - ENCRYTPED_MESSAGE_TAG: generated from ALGO2()


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:           LIBRARIES           :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


JJWS													#require("jws"). JWS, but without usual PAYLOAD|ENVLOP members (can be anything).
JJWS.ALGORITHMS								#Don't support algo PS*. X-509 certificates not supported (look at package JWCRYPTO for one 
															#that does)
															#Uses package JWA for the crypto.
JJWS.sign(OBJ)								#Returns JWS.
															#OBJ:
															#  - header ENVLOP: at least alg must be present
															#  - payload PAYLOAD_OBJ
															#  - secret PRIVATE_KEY
JJWS.verify
(JWS, PUBLIC|PRIVATE_KEY)			#Returns BOOL
JJWS.decode(JWS)							#Returns JJWS.sign() OBJ

JJWS.createSign(OBJ)					#Like JJWS.sign() but PAYLOAD|PRIVATE_KEY can be ISTREAM.
															#Returns ISTREAM2, where must listen to event handler done(JWS)
JJWS.createVerify(OBJ)				#Like JJWS.verify() but:
															#  - OBJ.signature: JWS, can be ISTREAM
															#  - OBJ.secret: PUBLIC|PRIVATE_KEY, can be ISTREAM
															#Returns ISTREAM2, where must listen to event handler done(BOOL, OBJ) (JJWS.sign() OBJ)
		 
JSONWEBTOKEN									#JWS, but with usual PAYLOAD|ENVLOP members, and issuer|audience|exp checks:
															#  - ENVLOP has default:
 															#     - type: "JWT" 
															#     - alg: "HS256"
															#  - PAYLOAD has default (unless it is not an OBJ):
															#     - iat: Date.now()
															#Use JJWS
JSONWEBTOKEN.sign							#Returns JWS.
(PAYLOAD, PRIVATEKEY[, OBJ])	#OBJ:
															#  - algorithm (alg)
															#  - expiresInMinutes DOUBLE: sets exp according to Date.now()
															#  - audience (aud)
															#  - subject (sub)
															#  - issuer (iss)
JSONWEBTOKEN.verify(JWS, 			#Checks:
PUBLIC|PRIVATE_KEY[, OBJ]			#  - if OBJ.audience STR, that STR == audience in JWS (ERROR "jwt audience invalid.expected:STR)
, FUNC(ERROR, PAYLOAD))			  #  - if OBJ.issuer STR, same for issuer (ERROR "jwt issuer invalid. expected: STR")
															#  - if PAYLOAD contained exp, that is not expired (ERROR "jwt expired")
															#If problem, other ERROR.
JSONWEBTOKEN.decode(JWS)			#Returns PAYLOAD (doesn't verify)
