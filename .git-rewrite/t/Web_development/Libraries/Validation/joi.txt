
         
   JOI   
         


VERSION ==>                   #4.6.1

JOI.assert(VAL, SCHEMA)				#Throws if not validated by SCHEMA, with error message
JOI.validate(VAL, SCHEMA      #ERROR is null if validated.
[, OBJ2][, FUNC(ERROR, VAL2)])#If no FUNC, returns sync. { error: ERROR, value: VAL2 }
                              #VAL2 is deep copy of VAL.
															#OBJ2: 
															#  - abortEarly BOOL: if true (def), stops on first error, but VAL2 will be incomplete if OBJ.
															#  - convert BOOL: if true (def), VAL2 is cast to SCHEMA type instead of throwing.
                              #    Can also perform some similar transformations, e.g. STR_SCHEMA.lower|uppercase|trim()
															#  - allowUnknown: if false (def), don't validate if VAL is OBJ and has some keys not existing 
															#    in OBJ_SCHEMA
															#  - skipFunctions: same but only for keys being FUNC
															#  - stripUnknown: if true (def: false), if VAL is OBJ, erase OBJ keys not present in OBJ_SCHEMA
															#  - context CONTEXT_OBJ: see below
SCHEMA.validate(VAL[, FUNC])  #Same as JOI.validate(VAL, SCHEMA, FUNC)

JOI.TYPE()										#Returns a SCHEMA, to validate against TYPE(). All methods returns SCHEMA, so chainable.


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:         COMPLEX TYPES         :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


JOI.ref(REF_STR[, OBJ2])			#SCHEMA2 of an OBJ_SCHEMA referring to another SCHEMA3 inside OBJ_SCHEMA:
															#  - STR is relative path among siblings, e.g. "VAR.VAR2"
															#  - If STR starts with "$" (or OBJ2.contextPrefix), look into CONTEXT_OBJ instead of OBJ_SCHEMA

SCHEMA_ARR										#Can be used as SCHEMA, meaning "any of SCHEMA_ARR", but allowing undefined.
JOI.alternatives()            #Same as [], but preferred
SCHEMA_ARR.when(REF_STR, OBJ2)#According to OBJ2.is SCHEMA3 validating REF_STR (against the OBJ to validate), adds to 
                              #SCHEMA_ARR:
															#  - if true, OBJ2.then SCHEMA2
															#  - if false, OBJ2.otherwise SCHEMA2
SCHEMA.when(...)							#Converts JOI into a SCHEMA_ARR, then calls when(...)


																						 /=+===============================+=\ 
																						/  :                               :  \  
							 														  )==:            SCHEMAS            :==(   
																						\  :_______________________________:  /    
																						 \=+===============================+=/


JOI.any()											#Returns SCHEMA (methods can be used by any TYPE_SCHEMA)
SCHEMA.[in]valid(VAL[_ARR]...)#Whitelist/blacklist values:
                              #  - Last defined between whitelist/blacklist has priority
                              #  - If one whitelisted, all others become blacklisted
                              #  - can add several whitelist|blacklist values
                              #  - Can use VAL[_ARR] directly as SCHEMA instead
SCHEMA.allow(VAL[_ARR]...)		#Same as valid(), but if whitelisted, all others don't become blacklisted
SCHEMA.required|forbidden()		#Key must [not] be defined
SCHEMA.options(OBJ2)					#Override default OBJ2 in SCHEMA.validate()
SCHEMA.strict()								#Override OBJ2.convert as false in SCHEMA.validate()
SCHEMA.default(VAL)						#If undefined, replace by VAL in SCHEMA.validate() VAL2
SCHEMA.concat(SCHEMA2)				#Returns a SCHEMA2 that combines both schemas (must be same type)
SCHEMA.description(STR)
SCHEMA.notes(STR_ARR)
SCHEMA.tag(STR[_ARR])					
SCHEMA.meta(OBJ) 								
SCHEMA.example(VAL)							
SCHEMA.unit(STR)							#Meta information (doesn't do anything)

JOI.array()										#
ARR_SCHEMA.in|excludes
(SCHEMA...)										#Each value must sequentially [not] validate against any of them
ARR_SCHEMA.min|max|length(NUM)#Array length validation

JOI.boolean()									#

JOI.binary()									#Validates BUFFER
BIN_SCHEMA.min|max|length(NUM)#BUFFER size validation
BIN_SCHEMA.encoding(STR)			#

JOI.date()										#
DATE_SCHEMA.min|max(DATE)			#

JOI.func()										#

JOI.number()									#
NUM_SCHEMA.min|max(NUM)				#
NUM_SCHEMA.integer()					#

JOI.string()									#By default invalid(''): must allow('') to use ''
STR_SCHEMA.insensitive()			#Make allow|[in]valid() case-insensitive (must be after)
STR_SCHEMA.min|max|lengh
(NUM[, STR2])									#STR length validation (using encoding STR2)
STR_SCHEMA.regex(REGEXP)			#
STR_SCHEMA.alphanum()					#
STR_SCHEMA.token()						#[[:alnum:]_]
STR_SCHEMA.email()						#
STR_SCHEMA.guid()							#
STR_SCHEMA.isoDate()					#
STR_SCHEMA.hostname()					#
STR_SCHEMA.lower|uppercase()	#Can use OBJ2.convert
STR_SCHEMA.trim()							#Can use OBJ2.convert

JOI.object()									#
OBJ_SCHEMA.keys([OBJ])				#Sets up validation for { KEY: SCHEMA2 ... }
															#Special case: if {}, validates that OBJ is empty.
OBJ_SCHEMA.pattern
(REGEXP, SCHEMA2)							#Validates keys matching REGEXP with SCHEMA2, unless they match something in OBJ_SCHEMA.keys()
OBJ_SCHEMA.min|max|length(NUM)#OBJ number of keys validation
OBJSCHEMA.and|or|xor(KEY,KEY2)#Validates KEY and KEY2 presences together.
OBJ_SCHEMA.with[out](KEY,KEY2)#Validates that if KEY, then [not] KEY2
OBJ_SCHEMA.rename(KEY, KEY2		#Before validation (also keep it for VAL2 in SCHEMA.validate()), changes KEY name to KEY2.
[, OBJ2])											#OBJ2 (all def false):
															#  - override BOOL: KEY2 can already exist for the first rename()
															#  - multiple BOOL: KEY2 can exist for the other rename()
															#  - alias BOOL: keep KEY
OBJ_SCHEMA.unknown([BOOL])		#If true (def), allow keys not present in OBJ_SCHEMA.keys() during validation
OBJ_SCHEMA.assert(REF_STR, 
JOI.ref(REF2_STR),            #Asserts member pointed by REF == member pointed by REF2
"equal to REF_STR")						#REF_STR must be at least one level deeper than REF2_STR
