
             
   REGEXPS   
             

                        #Voici un tableau recapitulatif des commandes 
                        #utilisant les regexps simples, etendues ou le globbing.
                        #"limit-class" signifie que \b, \B, \>, \< et \1... sont
                        #impossibles
                        #
                        #GLOBBING   BASIC               ETENDUES                  PERL
                        #
                        #Bash       grep (sans -E)      grep -E                   sed s/// et y/// (sauf \d, \D)
                        #ls         expr                find -regex               grep -P
                        #Les autres find (sans -regex)  sed (échapper wildcards)  agrep
                        #           locate --regexp     awk (tests avec ~,
                        #           ("limit-class" et   built-ins variables,
                        #           pas de ^ pour le    match, sub, gsub)
                        #           début de mot)        (limitations cependant)
                        #                               [[ =~ ]] tests ("limit-
                        #                               class", et rien ne doit 
                        #                               être échappé)
                        #                               run-parts ("limit-
                        #                               class")
                        #                               whatis -r
                        #                               diff -I
                        #                               locate --regex ("limit-
                        #                               class" et pas de ^ pour
                        #                               le début de mot)
                        #                               GDB (rbreak, sea, 
                        #                               reverse-sea, info ty)
                        #                               R ("limit-class")

REGEXP & ECHAPPEMENT ==>#nombreux operateurs doivent etre echappes mais cela
                        #depend de la commande appelee. cela est source de
                        #nombreuses erreurs. la syntaxe qui suit considere que
                        #l'expression reguliere est entouree de "" ou ''
B (BLOC) [BLOC] ==>     #un bloc est un single character (non plusieurs !) ou
                        #plusieurs si ceux-ci sont entoures de () ou []

BLOC*                   #BLOC est present 0 or more times. BLOC doit etre
                        #present, sinon cela signifie null*, qui n'a pas
                        #aucune utilite.
.                       #represente un single character, quel qu'il soit, sauf
                        #newline, mais il doit y en avoir au moins un

^                       #Début d'une ligne
$                       #Fin d'une ligne
\<                      #Debut d'un mot
\>                      #Fin d'un mot
\b                      #\< ou \>
\B                      #Inverse

[ars]                   #designe n'importe quel caractere place entre crochet.
                        #ici a,r ou s. il s'agit d'un seul BLOC
[a-p]                   #designe n'importe quel caractere compris entre les
                        #deux caracteres specifies. ici a, b, c, d, ..., o, p
[a-cjp-z]               #il est possible de combiner les deux
[^ars]                  #designe n'importe quel caractere n'etant pas l'un de
[^a-t]                  #ceux indiques.

[:CLASSE:]              #Utilise une classe POSIX (voir doc). L'ensemble de ces 
                        #classes n'est souvent utilisable qu'entre crochets. 
                        #S'ils sont seuls, il faut donc ecrire : [[:CLASSE:]]
[^[:CLASSE:]]           #equivalent a [^0-9]. meme syntaxe pour les autres

\(BLOCS\)               #Permet de regrouper des BLOCS
\1, \2, etc.            #Fait reference aux premiers, deuxiemes, etc.  BLOCS 
                        #entre parentheses.
                        #Peut etre présent dans la premiere partie d'une 
                        #substitution du genre s/PART1/PART2/ Exemple :
                        #sed "s/\(.\)\+\1/\1/g" élimine les doubles lettres

BLOC\{x\}               #BLOC est present exactement x fois
BLOC\{x,y\}             #BLOC est present de x a y fois.
BLOC\{x,\}              #BLOC est present au moins x fois

REGEXP ETENDUES ==>     #les operateurs suivants ne sont valables qu'avec
                        #quelques commandes externes, avec grep qu'en 
                        #utilisant grep -E et ne sont pas valables avec expr

\{\} -> {}
\(\) -> ()
BLOC?                   #BLOC est present une seule fois ou est absent
BLOC+                  #BLOC est present une fois ou plus
REGEXP1\|REGEXP2        #la premiere regexp est presente et/ou la deuxieme.

TOUT CARACTERE          #Voici la sequence pour specifier "tout caractere dont 
DONT NEWLINE ==>        #newline" : \(.\|\n\)*

PERL REGEXP ==>         #Voici :
                        #En lecture (grep, partie gauche sed, etc.) et écriture :

\w                      #[[:alnum:]_]
\W                      #[^[:alnum:]_]
\s                      #[[:space:]]
\S                      #[^[:space:]]
\d                      #[[:digit:]]
\D                      #[^[:digit:]]

QUANTIFIER*             #QUANTIFIER est * + ? {...}. Manipule la greediness. Si normal, et plusieurs résultats
QUANTIFIER+             #possibles matchant l'expression, prend celle avec le plus de caractères.
                        #Si greedy, prend le max. sans se soucier que l'expression match, et si non-greedy inverse.

\A                      #Début de l'input (par opposition à ^ début d'une ligne)
\Z                      #Inverse

                        #En écriture (partie droite sed, etc.) :

\u                      #La prochaine lettre devient uppercase
\U                      #Toutes les lettres qui suivent (à moins de rencontrer 
                        #un \L ou \E) deviennent uppercase
\l                      #La prochaine lettre devient uppercase
\L                      #Toutes les lettres qui suivent (à moins de rencontrer 
                        #un \U ou \E) deviennent uppercase
\E                      #stoppe une séquence \L ou \U

(?:BLOC)                #Comme (BLOC), mais pas compté pour \1 \2 etc.
BLOC1(?=BLOC2)          #Matche BLOC1 si suivi de BLOC2 (ne compte que BLOC1)
BLOC1(?!BLOC2)          #Matche BLOC1 si non suivi de BLOC2
(?FLAG)                 #Adds a FLAG, to put at the beginning of the regex

ADDITIONAL FLAGS ==>    #
n                       #. never match newline, ^$ are newline-wise, \A \Z are string-wise
                        #Déf is: . match newline, ^$ \A \Z are string-wise
p                       #. never match newline, ^$ \A \Z are string-wise
w                       #. match newline, ^$ are newline-wise, \A \Z are string-wise
x                       #Allow comments: white-space and # and what follows (until newlines) are ignored, unless escaped.
