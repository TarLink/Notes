
                           
   PROGRAMMING PARADIGMS   
                           

Menu-driven vs event-driven design :
  - event-driven : 
    - queue tout event arrivant, et exécute callback function en conséquence
    - en général une main event loop
  - menu-driven :
    - menu et submenus d'actions possibles, avec seulement le submenu final exécutant l'action
    - possibilité de revenir en arrière dans le menu, ou de retour au menu principal/précédent après exécution d'une action
    - queue seulement les events relatifs au menu courant

Imperative vs Declarative :
  - Imperative :
    - statements changeant le state
      - assignations à des variables
      - utilisation de looping statements possible 
      - branchements :
        - conditionnels : if, etc.
        - inconditionnels : jumps, goto, switch, call
    - sous-type :
      - declarative :
        - organisation du projet en subroutines
      - structured vs non-structured :
        - structured :
          - utilisation de boucles for, etc. 
          - modularité (libraries)
          - POO :
            - chaque ensemble de fonction est lié à un ensemble de data (objets)
            - un objet est :
              - un ensemble de data (object state)
              - un ensemble de méthodes (behavior)
              - une identity (existence propre d'une instantiation par rapport à une autre instantiation)
            - class-based vs prototype-based :
              - class-based : le type (structure) des objets est défini compile-time dans des classes
              - prototype-based : le type des objets est défini runtime dans des prototypes, qui sont ensuite clonés pour l'instantiation.
        - non-structured :
          - utilisation de branchements inconditionnels
    - ex : x86, C, BASIC
  - Declarative :
    - pas de statements, ni de side effects, juste un logic flow
    - ne modifie pas le global state, ni n'utilise un global state mutable
    - programme == théorie logique avec des assomptions, et computation == déduction en fonction de cette théorie et d'un input
    - sous-types :
      - functional : accent sur l'absence de side effects
        - purely functional : absence totale de side effects
      - logic : accent sur la représentation logique et mathématique
  - On peut établir des liens entre l'abstraction et modularité tirées des subroutines, de la POO et du functional programming.
